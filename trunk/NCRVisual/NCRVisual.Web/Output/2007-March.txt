From olivier.jolet at skynet.be  Thu Mar  1 00:04:44 2007
From: olivier.jolet at skynet.be (Olivier Jolet)
Date: Thu Mar  1 00:04:52 2007
Subject: [cairo] After 'set_line_width', subsequent stroking isslow
In-Reply-To: <a65ae5c90702281711u758a37b5t3f80de9eef3994c2@mail.gmail.com>
Message-ID: <003601c75bd8$45ed1f60$4f3210ac@Pcoj>

> On 2/23/07, Olivier Jolet <olivier.jolet@skynet.be> wrote:
> > > On Thu, 2007-02-22 at 09:54 -0500, Olivier Jolet wrote:
> > > >
> > > > Here is the application reduced. The important part (the
graphics
> > > > interpreter) is in the hello.c file in the 'cairo_draw'
function.
> > The
> > > > performances are really different with/out the primitive
> > > > cairo_set_line_width (line 175) and using antialiasing or not.
> > >
> > > I can't reproduce your numbers.  Perhaps something wrong with your
X
> > > server?  All the numbers I get with and without set_line_width are
in
> > > the range of 50 to 80 ms.
> > >
> > >
> > > behdad
> >
> > Strange, I've tested on various machines, and each time, the values
I
> > get with set_line_width are much higher.
> 
> Any update on this Olivier? It seems that no one has been able to
> reproduce your problem. Do you still have it?
> 
> Dan

I still have a difference using or not cairo_set_line_width. But I
reduced the variation using amongst other things par values for the
line_width. 


From spitzak at d2.com  Thu Mar  1 01:37:19 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Thu Mar  1 01:37:34 2007
Subject: [cairo] After 'set_line_width', subsequent stroking isslow
In-Reply-To: <003601c75bd8$45ed1f60$4f3210ac@Pcoj>
References: <003601c75bd8$45ed1f60$4f3210ac@Pcoj>
Message-ID: <45E69ECF.3010404@d2.com>

Olivier Jolet wrote:

> I still have a difference using or not cairo_set_line_width. But I
> reduced the variation using amongst other things par values for the
> line_width. 

Is the speed ok if you set_line_width to a constant value of 2? That is 
the default value.

If so, is the speed ok if you set it to even numbers? If x is the value 
you were trying to set, use (int(x)+1)&-2. This should produce values 
that change as you scale your image but will avoid antialiasing.

If it really depends on the existence of the set_line_width call then 
this sounds like a bug in cairo, or your code is calling it a huge 
number of times, such as many more times than it draws a vertex.
From gianmt at gnome.org  Thu Mar  1 02:09:17 2007
From: gianmt at gnome.org (Gian Mario Tagliaretti)
Date: Thu Mar  1 02:09:21 2007
Subject: [cairo] How to move a path
In-Reply-To: <a65ae5c90702281735u31262a2if0538fc6ffda84fe@mail.gmail.com>
References: <1172177213.2694.7.camel@hush>
	<a65ae5c90702281735u31262a2if0538fc6ffda84fe@mail.gmail.com>
Message-ID: <35bf41160703010209t15f54499i85811e06791fafd6@mail.gmail.com>

2007/3/1, Daniel Amelang <daniel.amelang@gmail.com>:

> Hi Fred,
>
> What you're describing (having the user "move" a shape") requires
> statefulness. Cairo (by design) doesn't provide that for you. You'll
> need to look into a canvas library, or roll your own (by maintaining
> data structures with shape information and more). You might want to
> look into GooCanvas to start. Hmm...I don't see a website for it right
> away, but the mailing list is here:

Daniel is right, there is no website, only the page on sourceforge.

http://sourceforge.net/projects/goocanvas

Goocanvas is now at version 0.7.0 but is going towards a 1.0 release
with stable API (Damon said in a month or so), is full of nice
examples including the functionality your are asking for and much
more, the docs cover 100% of the API.

In case you are interested in other programming languages there are
also bindings for python and C++, ruby bindings are under
construction, these are the ones I'm aware of.

cheers
-- 
Gian Mario Tagliaretti
http://www.parafernalia.org/pygtk/
From olivier.jolet at skynet.be  Thu Mar  1 05:19:28 2007
From: olivier.jolet at skynet.be (Olivier Jolet)
Date: Thu Mar  1 05:19:35 2007
Subject: [cairo] blinking graph
Message-ID: <004901c75c04$3d746010$4f3210ac@Pcoj>

Hi all,
 
I have to draw some blinking elements in my picture. The graph is build
with a graphics interpreter. My idea was to use two surfaces, one
surface containing the static fixed graph and the second surface
containing only the blinking elements, then draw alternatively the first
and the both surfaces. So my graphic interpreter has to buid
alternatively the figures to one or the other surface, but I want to
keep the same context for both surfaces. I mean, I want to keep the
context of cairo_t (the line width, the color, the font, etc ...)
drawing in one or the other surface.
What is the better way to do that? And is it a good way to have a graph
with blinking elements?
 
Oli
 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070301/c8a90fad/attachment.html
From brian.ewins at gmail.com  Thu Mar  1 05:33:10 2007
From: brian.ewins at gmail.com (Baz)
Date: Thu Mar  1 05:33:13 2007
Subject: [cairo] Changing test suite to support differing renderings
Message-ID: <2faad3050703010533h6dcb338bsa76a604cba9f668d@mail.gmail.com>

In the past there's been some discussion of redesigning the test suite
to support multiple different renderings better. We have variations
that occur when using different font backends, surfaces, etc. There's
also annoying flaws in the current test system - if you test a single
surface, you can end up with the test marked as a FAIL when all the
actual results were XFAIL, if one of the *untested* surfaces is
supposed to get a PASS.

I posted a small fix to let me put up atsui reference images before:
https://bugs.freedesktop.org/show_bug.cgi?id=9465
but I'd agree with Carl that more bandaids kill kittens. I'd like to
get some progress on this though because we can't get passing tests
for quartz or atsui at the moment (I assume there's problems on win32
as well).

The requirement is actually to determine the expected PASS/FAIL status
and the correct reference check (not necessarily an image comparison,
for pdf/ps/xps/svg...) based on the surface, font backend and the test
name. Possible solutions:

A) introduce a patch with more naming conventions, see above. Means
increasingly complex rules for determining which image we check, most
likely involving some cases where images are duplicated in order to
trick cairo into testing the right file. Does not deal with
fine-grained XFAILs.

B) extend cairo_test_t to include a pointer to a replacement for
cairo_ref_name_for_test_target_format(), and a function to determine
the XFAIL status of a test. Unfortunately this will very quickly
become intrusive; introducing a new surface which fails most tests
will spread these overrides throughout the test suite.

C) introduce explicit test policies, e.g. cairo-quartz-policy.c .
Functions in the test format allow for choosing a reference image,
determining the expected test status (including 'do not test'), etc.
The default expected status would be don't test (making it easy to add
tests without knowing what they'll do on untested surfaces), and the
default test image path would be the same as
cairo_ref_name_for_test_target_format calculates. This separates test
creation from the activity of making a test supported on an unusual
surface.

So, anyone got an opinion or an option D?

-Baz
(prompted by http://bugs.freedesktop.org/show_bug.cgi?id=10141)
From radarsat1 at gmail.com  Thu Mar  1 06:08:29 2007
From: radarsat1 at gmail.com (Stephen Sinclair)
Date: Thu Mar  1 06:15:19 2007
Subject: Update: [cairo] how to interface with an NSWindow (please help!)
In-Reply-To: <A2863730-BAD5-44E6-A6F3-7146A351274D@cincom.com>
References: <5A337AE4-DC2A-4E78-ACEA-C4560672F4F6@cincom.com>
	<7039A64B-9223-467B-B1A1-4F1AA1B26D30@cincom.com>
	<a65ae5c90702281723m5f1f83f9pe156c8228f001e62@mail.gmail.com>
	<A2863730-BAD5-44E6-A6F3-7146A351274D@cincom.com>
Message-ID: <9b3e2dc20703010608r5017b2baybbb3a7eeb95e88e1@mail.gmail.com>

I'm not a Mac expert either, but I had a quick look at the
NSGraphicsContext stuff.
I know that OS X does a lot more buffering and off-screen compositing
stuff than Windows XP.
I noticed, for example, that NSGraphicsContext has a function called
flushGraphics:
"Forces any buffered operations or data to be sent to the receiver's
destination."

Have you tried that?


Steve



> But when I do drawing ops on that surface, nothing happens. :( Am I doing
> this right at all? Or is there a better/different way to do it? Do I need to
> send additional messages to the NSGraphicsContext or to the
> CGGraphicsContext (this is just a struct pointer,right?)?
From behdad at behdad.org  Thu Mar  1 08:13:32 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar  1 08:13:32 2007
Subject: [cairo] Changing test suite to support differing renderings
In-Reply-To: <2faad3050703010533h6dcb338bsa76a604cba9f668d@mail.gmail.com>
References: <2faad3050703010533h6dcb338bsa76a604cba9f668d@mail.gmail.com>
Message-ID: <1172765612.17966.7.camel@behdad>

On Thu, 2007-03-01 at 08:33 -0500, Baz wrote:
> 
> So, anyone got an opinion or an option D?

Thanks for bringing this up.  I have some thing on mind too, but lets
discuss this after getting 1.4.0 out.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From tgriggs at cincom.com  Thu Mar  1 09:12:48 2007
From: tgriggs at cincom.com (Travis Griggs)
Date: Thu Mar  1 09:12:53 2007
Subject: Update: [cairo] how to interface with an NSWindow (please help!)
In-Reply-To: <9b3e2dc20703010608r5017b2baybbb3a7eeb95e88e1@mail.gmail.com>
References: <5A337AE4-DC2A-4E78-ACEA-C4560672F4F6@cincom.com>
	<7039A64B-9223-467B-B1A1-4F1AA1B26D30@cincom.com>
	<a65ae5c90702281723m5f1f83f9pe156c8228f001e62@mail.gmail.com>
	<A2863730-BAD5-44E6-A6F3-7146A351274D@cincom.com>
	<9b3e2dc20703010608r5017b2baybbb3a7eeb95e88e1@mail.gmail.com>
Message-ID: <B9ED263A-9B12-4C20-B61F-E1DE1799F56C@cincom.com>


On Mar 1, 2007, at 6:08, Stephen Sinclair wrote:

> I'm not a Mac expert either, but I had a quick look at the
> NSGraphicsContext stuff.
> I know that OS X does a lot more buffering and off-screen compositing
> stuff than Windows XP.
> I noticed, for example, that NSGraphicsContext has a function called
> flushGraphics:
> "Forces any buffered operations or data to be sent to the receiver's
> destination."
>
> Have you tried that?

I have now. :) Thank you.

So a flushGraphics on the NSGC realizes the changes. Shouldn't Cairo  
being doing this though? At *least* as part of it's own flush()  
function. Though I'd like to not have to litter my drawing sequences  
with well intentioned flushes, since I was shooting for xplatform  
here, and I don't have to do that for Win/Xlib.

For now, this gives me something I can use to do prototyping.

--
Travis Griggs
Objologist
10 2 letter words: "If it is to be, it is up to me"


-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070301/dc7dc6e3/attachment.html
From fcrozat at mandriva.com  Thu Mar  1 10:28:10 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Thu Mar  1 10:23:28 2007
Subject: [cairo] regression in text rendering when not using Render xlib
Message-ID: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>

Hi,

our install guys are often using Xnest to test Mandriva installer in a
chroot and they reported me that glyph rendering has regressed since we
switched to cairo 1.3.x in cooker (see bug
http://qa.mandriva.com/show_bug.cgi?id=28317 ).

I try to duplicate similar problem with a smaller testcase and I was
able to have strange rendering when doing the following :
Xnest :1 & (or Xephyr -extension RENDER :1 ).
DISPLAY=:1 zenity --about 

and check Zenity text : it has some strange colors in it (looks like bad
subpixel hinting, but subpixel hinting isn't enabled in Xnest).

Switching to Xephyr with RENDER enabled hides this problem.

I've attached two screenshots.

Test are done with freetype 2.3.1 (no patch, no bytecode interpreter
enabled) but also with 2.2.1+several CVS patches, DejaVu font 2.15
(already present with 2.12).

If I revert to cairo 1.2.x, problem disappear, with same version of
pango.

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva
-------------- next part --------------
A non-text attachment was scrubbed...
Name: xephyr.png
Type: image/png
Size: 18912 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070301/310bcdc1/xephyr-0001.png
-------------- next part --------------
A non-text attachment was scrubbed...
Name: xephy-norender.png
Type: image/png
Size: 19058 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070301/310bcdc1/xephy-norender-0001.png
From cworth at cworth.org  Thu Mar  1 10:58:51 2007
From: cworth at cworth.org (Carl Worth)
Date: Thu Mar  1 10:59:04 2007
Subject: [cairo] Radii of radial gradients
In-Reply-To: <dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>
References: <646543300702090330w27943b44y6eb05d8212fc33e1@mail.gmail.com>
	<dcbbbb410702090649r18da8110qa4a3bd762db42a6e@mail.gmail.com>
	<87d540vk3s.wl%cworth@cworth.org>
	<dcbbbb410702231204q26601575l2182526caacd5dfe@mail.gmail.com>
	<87649sv9b4.wl%cworth@cworth.org>
	<dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>
Message-ID: <87slcolris.wl%cworth@cworth.org>

On Sat, 24 Feb 2007 12:46:35 -0600, "Michael Urman" wrote:
> wall of the cone is pointing. However with an infinite range of t,
> there's a magic spot by that egde where the entire range t > 1 flips
> from outside the "inner" radius to by all on one side of the inner
> center. Since often all of t > 1 has the same solid color, suddenly a
> section of your infinite background is no longer infinite;

Yes, you've got the problem. And of course, when you derive the proper
mathematics for the radial gradient, the "magic spot" is conveniently
identified by the determinant passing through zero and that
hard-to-define region is exactly where the determinant is negative.

I derived all the math this weekend, and I'll be landing that to cairo
now.

Keith suggested just forcing the determinant to 0 when it is
negative. I've implemented that and was quite pleased by the result it
provides:

http://cairographics.org/~cworth/images/gradient-extreme.png

It's space-filling and without any objectionable color
discontinuities.

In the image above, the gradient is drawn from a small circle to a
large circle. Things also work great if you draw from a large circle
to a small circle, giving a slightly different effect, (very similar
to what PDF defines):

http://cairographics.org/~cworth/images/gradient-extreme2.png

So the big difference between what PDF does and what cairo does here
is that the "infinite" portions that look like a linear gradient here
are "uninked" in PDF. Someone should be able to implement that just
fine by computing the path of the "cone" formed by the two circles and
clipping to it.

Another thing that PDF provides that doesn't have explicit support in
cairo's radial gradients is gradient that extend from only one end or
the other. For that, what I'd like to suggest is simply using
EXTEND_REPEAT, (which affects both ends), and then using a transparent
color stop the end where the extension is undesired.

For that to work, we'll only need one little addition to the current
implementation. Right now, it only uses one real root of the quadratic
equation, even if there is a second one available---it simply chooses
the root that results in a larger value for the gradient's parametric
control, (this gives the "last circle drawn wins" effect that PDF
defines).

To refine this, we'll simply need to check the second root if the
first root results in a non-opaque color value and simply blend the
two colors. This should give an interesting effect when transparency
is used for interior stops, (an effect not expressible in PDF nor
SVG), but should also allow for emulating the PDF single-sided
extended gradients with a transparent stop on one end or the other.

-Carl

PS. You don't even want to know what kind of effects result if you try
drawing some of these cases with cairo 1.0 or 1.2. Let's just say they
are not pretty.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070301/c73e6b21/attachment.pgp
From cworth at cworth.org  Thu Mar  1 11:13:58 2007
From: cworth at cworth.org (Carl Worth)
Date: Thu Mar  1 11:14:08 2007
Subject: [cairo] Radii of radial gradients
In-Reply-To: <87slcolris.wl%cworth@cworth.org>
References: <646543300702090330w27943b44y6eb05d8212fc33e1@mail.gmail.com>
	<dcbbbb410702090649r18da8110qa4a3bd762db42a6e@mail.gmail.com>
	<87d540vk3s.wl%cworth@cworth.org>
	<dcbbbb410702231204q26601575l2182526caacd5dfe@mail.gmail.com>
	<87649sv9b4.wl%cworth@cworth.org>
	<dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>
	<87slcolris.wl%cworth@cworth.org>
Message-ID: <87r6s8lqtl.wl%cworth@cworth.org>

On Thu, 01 Mar 2007 10:58:51 -0800, Carl Worth wrote:
> So the big difference between what PDF does and what cairo does here
> is that the "infinite" portions that look like a linear gradient here
> are "uninked" in PDF.

Oh, in the above I talked about how one could use cairo to draw any
effect that PDF can describe.

But if we define this new behavior for gradients where one circle is
not wholly contained within the other, the other issue we have is to
generate PDF and SVG content that captures this result.

It looks like the new cairo behavior could be done quite easily in PDF
by first drawing a linear gradient and then drawing a radial gradient
on top of that.

SVG, however looks a fair bit trickier, since it is defined as
snapping the fx,fy point to the edge of the circle if the original
fx,fy point lies outside the circle. So maybe this would be one of
those rare situations where cairo-emitted SVG would actually have to
fallback to early rasterization.

Anyway, I don't think anyone's actually clamoring for this
effect. And I'm definitely not going to worry about it now before
1.4. I think I'll just drop a new "radial-extreme" test case in place
just after 1.4.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070301/ae91bd2b/attachment.pgp
From vladimir at pobox.com  Thu Mar  1 11:57:52 2007
From: vladimir at pobox.com (Vladimir Vukicevic)
Date: Thu Mar  1 11:57:57 2007
Subject: Update: [cairo] how to interface with an NSWindow (please help!)
In-Reply-To: <B9ED263A-9B12-4C20-B61F-E1DE1799F56C@cincom.com>
References: <5A337AE4-DC2A-4E78-ACEA-C4560672F4F6@cincom.com>
	<7039A64B-9223-467B-B1A1-4F1AA1B26D30@cincom.com>
	<a65ae5c90702281723m5f1f83f9pe156c8228f001e62@mail.gmail.com>
	<A2863730-BAD5-44E6-A6F3-7146A351274D@cincom.com>
	<9b3e2dc20703010608r5017b2baybbb3a7eeb95e88e1@mail.gmail.com>
	<B9ED263A-9B12-4C20-B61F-E1DE1799F56C@cincom.com>
Message-ID: <45E73040.1090905@pobox.com>

Travis Griggs wrote:
> 
> On Mar 1, 2007, at 6:08, Stephen Sinclair wrote:
> I have now. :) Thank you.
> 
> So a flushGraphics on the NSGC realizes the changes. Shouldn't Cairo 
> being doing this though? At *least* as part of it's own flush() 
> function. Though I'd like to not have to litter my drawing sequences 
> with well intentioned flushes, since I was shooting for xplatform here, 
> and I don't have to do that for Win/Xlib.
> 
> For now, this gives me something I can use to do prototyping.

Sorry, I just now saw this thread.  Cairo has no knowledge of NSGC, etc; 
it only knows about the CGContext.  If you use the CGContext that's 
given to you in a drawRect message, then Quartz will automatically flush 
the rendering afterwards.  If you create the NSGraphicsContext yourself, 
you have to do this manually after you're done rendering.

If you create the context for the window in this way though I don't know 
whether the drawing is actually preserved in the window's backbuffer, 
but I assume that it is, so this should be ok.  You're generally not 
supposed to do the kind of incremental/synchronous drawing that you're 
doing though; the only way to get the behaviour you want is to call that 
flush function as necessary.

     - Vlad
From benjamin at sipsolutions.net  Thu Mar  1 12:46:26 2007
From: benjamin at sipsolutions.net (Benjamin Berg)
Date: Thu Mar  1 12:46:34 2007
Subject: [cairo] memory leak in cairo_stroke
In-Reply-To: <20070219000743.GA18764@infidigm.net>
References: <1171838396.3134.23.camel@localhost>
	<20070219000743.GA18764@infidigm.net>
Message-ID: <1172781986.7192.19.camel@localhost>

On Sun, 2007-18-02 at 19:07 -0500, Jeff Muizelaar wrote: 
> On Sun, Feb 18, 2007 at 11:39:56PM +0100, Benjamin Berg wrote:
> > [...]
> > 
> > It looks like the problem is that _cairo_path_fixed_stroke_rectilinear
> > (cairo-path-stroke.c) only calls _cairo_rectilinear_stroker_fini on
> > success.
> 
> It would be more interesting to know why
> _cairo_path_fixed_interpret or _cairo_rectilinear_stroker_emit_segments
> fails.

OK, more about when the leak happens. The following lines of code leak
(line width is 1.0):

  cairo_move_to (cr, 0.5, 0.5);
  cairo_line_to (cr, 10.5, 0.5);
  cairo_line_to (cr, 0.5, 10.5);
  cairo_stroke (cr);

All the points are pixel aligned. Same for the first line segment, which
is just horizontal, but the second segment does not fit into the pixel
grid.

If one changes the example slightly, so that the first line segment is
not horizontal, then no leak occurs:

  cairo_move_to (cr, 0.5, 0.5);
  cairo_line_to (cr, 10.5, 10.5);
  cairo_line_to (cr, 0.5, 10.5);
  cairo_stroke (cr);


That said, the following patch shuts up valgrind for me. But I have no
idea if this is correct or maybe just hides something else.

diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index 958b95a..8b81373 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -1282,16 +1282,12 @@ _cairo_path_fixed_stroke_rectilinear (cairo_path_fixed_t	*path,
 					  NULL,
 					  _cairo_rectilinear_stroker_close_path,
 					  &rectilinear_stroker);
-    if (status) {
-	_cairo_traps_fini (traps);
-	return status;
-    }
+    if (status)
+        goto BAIL;
 
     status = _cairo_rectilinear_stroker_emit_segments (&rectilinear_stroker);
-    if (status)
-	return status;
 
+BAIL:
     _cairo_rectilinear_stroker_fini (&rectilinear_stroker);
-
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }


From behdad at behdad.org  Thu Mar  1 15:37:20 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar  1 15:37:17 2007
Subject: [cairo] memory leak in cairo_stroke
In-Reply-To: <1172781986.7192.19.camel@localhost>
References: <1171838396.3134.23.camel@localhost>
	<20070219000743.GA18764@infidigm.net>
	<1172781986.7192.19.camel@localhost>
Message-ID: <1172792241.19281.13.camel@behdad>

On Thu, 2007-03-01 at 15:46 -0500, Benjamin Berg wrote:
> 
> That said, the following patch shuts up valgrind for me. But I have no
> idea if this is correct or maybe just hides something else.

Thanks, I extended the test suite to catch that, studied the code, and
fixed it:

  4b1f450f4cf056b4cc28502dcf72eaf54f257c3a

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Thu Mar  1 16:48:25 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar  1 17:02:14 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
Message-ID: <1172796505.19281.20.camel@behdad>

On Thu, 2007-03-01 at 13:28 -0500, Frederic Crozat wrote:
> 
> If I revert to cairo 1.2.x, problem disappear, with same version of
> pango.

Would you mind "git bisect"ing?  Helps a lot, and may be the only way to
pin this down before 1.4.0.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From cworth at cworth.org  Thu Mar  1 17:21:32 2007
From: cworth at cworth.org (Carl Worth)
Date: Thu Mar  1 17:21:43 2007
Subject: [cairo] Radial gradient fixes have landed
Message-ID: <87odncl9sz.wl%cworth@cworth.org>

So I finally pushed out the fixes for the radial gradients that I
worked on at FOSDEM and we've been talking about a bit this week.

As is, everything in the test suite passes except for SVG, (though the
PS/PDF passes are rally boring since we haven't turned on native
gradients there yet---that was blocking on actually getting a test
into the suite, which we at least have now).

For SVG, what's missing is support for remapping gradient stops when
there's an inner radius that is non-zero, particularly for extend
modes of REPEAT and REFLECT. It shouldn't be that much work to do,
(though I did botch my first attempt). Just run the radial-gradient
test case if you want to see what needs to be done.

If anyone wants to look at the math involved in the radial gradient
code, it's here:

http://gitweb.freedesktop.org/?p=cairo;a=blob;h=233b90c77;f=pixman/src/fbcompose.c#l3088

Many thanks to Vincent Torri <vtorri@univ-evry.fr> who helped me come
up with a simple derivation of this stuff, (the algebra I set up on my
own was really over-complicated). Oh, for those that saw a version of
this code that I posted earlier, the algebra has been corrected since
then.

Finally, I did this implementation with almost no concern for
performance. There's still a heck of a lot of work happening for every
pixel here, (many floating-point operations and a sqrt). But I did do
a quick check with cairo-perf-diff and it seems only faster (1.05x -
1.58x) than the only code, (which also had the same sqrt per pixel of
course).

If someone really cares about radial gradient performance, this might
very well be a great place to drop in an all-integer implementation,
(with an integer square root implementation). That should help
embedded systems quite a bit, (though it might slow down things like
x86---let's check and start using our DISABLE_SOME_FLOATING_POINT
define if necessary).

One more bug[*] to go before 1.4 I think...

-Carl

[*] This one here:

Cairo 1.3.14 deadlocks in cairo_scaled_font_glyph_extents or _cairo_ft_unscaled_font_lock_face
https://bugs.freedesktop.org/show_bug.cgi?id=10035

If you can reproduce this, please let us know---many people can't and
we don't yet know what the magic variables might be.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070301/faeaf22e/attachment.pgp
From behdad at behdad.org  Thu Mar  1 18:11:25 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar  1 18:16:37 2007
Subject: 1.4.0 blockers (was Re: [cairo] Radial gradient fixes have landed
In-Reply-To: <87odncl9sz.wl%cworth@cworth.org>
References: <87odncl9sz.wl%cworth@cworth.org>
Message-ID: <1172801485.19281.27.camel@behdad>

On Thu, 2007-03-01 at 20:21 -0500, Carl Worth wrote:
> 
> 
> One more bug[*] to go before 1.4 I think...

Thanks Carl for landing this (and for all your heroic debugging sessions
about the locking bug).

There is another blocker for 1.4.0, that is, the extend-reflect case
seems to hit a bug in some xorg drivers (if fbComposite_8888x8888mmx
that is) that causes an infinite loop.

I'll try to debug and fix it tonight.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From keithp at keithp.com  Thu Mar  1 20:40:40 2007
From: keithp at keithp.com (Keith Packard)
Date: Thu Mar  1 20:41:26 2007
Subject: [cairo] Radii of radial gradients
In-Reply-To: <87slcolris.wl%cworth@cworth.org>
References: <646543300702090330w27943b44y6eb05d8212fc33e1@mail.gmail.com>
	<dcbbbb410702090649r18da8110qa4a3bd762db42a6e@mail.gmail.com>
	<87d540vk3s.wl%cworth@cworth.org>
	<dcbbbb410702231204q26601575l2182526caacd5dfe@mail.gmail.com>
	<87649sv9b4.wl%cworth@cworth.org>
	<dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>
	<87slcolris.wl%cworth@cworth.org>
Message-ID: <1172810440.23133.97.camel@neko.keithp.com>

On Thu, 2007-03-01 at 10:58 -0800, Carl Worth wrote:

> Keith suggested just forcing the determinant to 0 when it is
> negative. I've implemented that and was quite pleased by the result it
> provides:

I think there's another possible interpretation here; if you consider
the gradient as defining a cone, then you could draw the value of the
final color stop where the determinant is less than zero -- this would
present a solid field 'underneath' the cone. I fear the current solution
will produce discontinuities when the final point accidentally steps
just over the radius of the circle.

-- 
keith.packard@intel.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070301/be1b9941/attachment.pgp
From yamagata at skycom.jp  Thu Mar  1 22:58:34 2007
From: yamagata at skycom.jp (yamagata)
Date: Thu Mar  1 23:05:15 2007
Subject: [cairo]about SVG file outputting
Message-ID: <20070302150516.C657.YAMAGATA@skycom.jp>

Hello Cairo Mailing-list,

This is Ryo Yamagata, an engineer.

May I ask you a question?

When outputting any characters by SVG file format using Cairo Library,

Character strings doesn?t display correctly.

Could you please check the following sample code & advice on this?

--System Environment:
  OS:Windows XP
  Development Environment:Visual studio 6
  Cairo library Version:cairo-1.2.6

  SVG Viewer Tool :IE 7 (Adobe SVG Viewer 3.0)
                     or Firefox 2.0.0.1

--Sample Code:

#include <cairo-win32.h>
#include <cairo-svg.h>

void draw(cairo_surface_t *pSurf)
{
    int ires;
    LPWSTR wbuf=L"1234567890";
    LPSTR  putf=NULL;

    //create cairo object
    cairo_t *pCr = cairo_create(pSurf);

    //move
    cairo_move_to (pCr, 10.0, 50.0);

    //font select
    cairo_select_font_face (pCr,"Serif",CAIRO_FONT_SLANT_NORMAL,CAIRO_FONT_WEIGHT_BOLD);

    //font size
    cairo_set_font_size (pCr, 32.0);

    //color
    cairo_set_source_rgba (pCr, 0.0, 0.3, 1.0, 1.0);

    //size check 
    ires = WideCharToMultiByte(
        CP_UTF8,        // UTF8
        0,              // flag
        wbuf,           // in
        -1,             // in size
        NULL,           // out
        0,              // out size
        NULL,NULL
        );
    if (ires == 0)
    {
        delete [] wbuf;
    }

    //// create memory
    putf = new char[ires+1];
    if (putf == NULL)
    {
        delete [] wbuf;
    }
    //// change code
    ires = WideCharToMultiByte(
        CP_UTF8,        // UTF8
        0,              // flag
        wbuf,           // in
        -1,             // in size
        putf,           // out
        ires,           // out size
        NULL,NULL
        );


    if (ires == 0)
    {
        delete [] wbuf;
        delete [] putf;
    }

    cairo_show_text (pCr,putf);                   //text out
    cairo_surface_write_to_png (pSurf, "hw.png"); //png out
    cairo_show_page (pCr);                        //page end
    cairo_destroy(pCr);                           //cairo destroy
}


//----------------Windows Main-----------------------------------
INT WINAPI
WinMain (HINSTANCE hInstance,
         HINSTANCE hPrevInstance,
         PSTR      lpCmdLine,
         INT       iCmdShow)
{

    cairo_surface_t *svg_surface;                         //cairo surface
    cairo_t *svg_cr;                                      //cairo 

    svg_surface =cairo_svg_surface_create("testsvg.svg",1024,1024);//svg create file
    svg_cr = cairo_create (svg_surface);       //cairo create
    draw(svg_surface);                         //draw svg
    cairo_destroy (svg_cr);                    //cairo delete
    cairo_surface_destroy (svg_surface);       //cairo surface delete
    return 0;
}


Thank you in advance for your help.

Best regards,

Ryo Yamagata


From emmanuel.pacaud at lapp.in2p3.fr  Thu Mar  1 23:19:50 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Thu Mar  1 23:19:56 2007
Subject: [cairo]about SVG file outputting
In-Reply-To: <20070302150516.C657.YAMAGATA@skycom.jp>
References: <20070302150516.C657.YAMAGATA@skycom.jp>
Message-ID: <1172819990.5879.2.camel@localhost.localdomain>

Hi,

Le vendredi 02 mars 2007 ? 15:58 +0900, yamagata a ?crit :
> This is Ryo Yamagata, an engineer.
> 
> May I ask you a question?
> 
> When outputting any characters by SVG file format using Cairo Library,
> 
> Character strings doesn?t display correctly.

There was a bug in cairo preventing a correct display of the symbol
elements used for text output. It's fixed in SVN trunk (by adding a
overflow="visible" property to symbol elements).

	Emmanuel.

-- 
Emmanuel PACAUD
Groupe Virgo
LAPP/CNRS
9, chemin de Bellevue - BP 110
74941 Annecy-le-Vieux CEDEX
T?l: (+33)4 50 09 17 89 - Fax: (+33)4 50 27 94 95

From cworth at redhat.com  Fri Mar  2 00:10:12 2007
From: cworth at redhat.com (Carl Worth)
Date: Fri Mar  2 00:10:24 2007
Subject: [cairo] The "deadlock" bug is fixed
In-Reply-To: <1172801485.19281.27.camel@behdad>
References: <87odncl9sz.wl%cworth@cworth.org>
	<1172801485.19281.27.camel@behdad>
Message-ID: <87mz2wkqvv.wl%cworth@cworth.org>

Skipped content of type multipart/mixed-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/d437f37f/attachment-0001.pgp
From yamagata at skycom.jp  Fri Mar  2 00:20:20 2007
From: yamagata at skycom.jp (yamagata)
Date: Fri Mar  2 00:20:24 2007
Subject: [cairo]about SVG file outputting
In-Reply-To: <1172819990.5879.2.camel@localhost.localdomain>
References: <20070302150516.C657.YAMAGATA@skycom.jp>
	<1172819990.5879.2.camel@localhost.localdomain>
Message-ID: <20070302170958.C65B.YAMAGATA@skycom.jp>

Hi Emmanuel,

Thank you very much for your quick response.

> It's fixed in SVN trunk (by adding an overflow="visible" property to symbol elements).

I see. That's good!
I'm not familiar with the location of collecting Cairo information such as patches.
Would you mind to help me again?
Where can I get the updated version of Cairo library or patches from, which has been fixed in SVN trunk?
Sorry for bothering you on this.
Thank you,
- Ryo Yamagata

=========================================================== 
 Ryo Yamagata     Mail: yamagata@skycom.jp 
 SkyCom Corporation      http://www.skycom.jp/ 
 
 Itoupia Kiyosubashi-doori Bldg.1-38-9 Taitou Taitou-ku Tokyo
 110-0016 JAPAN

 TEL: +81-3-5807-6011  FAX: +81-3-5807-6018 
=========================================================== 



> Hi,
> 
> Le vendredi 02 mars 2007 ?  15:58 +0900, yamagata a ??crit :
> > This is Ryo Yamagata, an engineer.
> > 
> > May I ask you a question?
> > 
> > When outputting any characters by SVG file format using Cairo Library,
> > 
> > Character strings doesn?? display correctly.
> 
> There was a bug in cairo preventing a correct display of the symbol
> elements used for text output. It's fixed in SVN trunk (by adding a
> overflow="visible" property to symbol elements).
> 
> 	Emmanuel.
> 
> -- 
> Emmanuel PACAUD
> Groupe Virgo
> LAPP/CNRS
> 9, chemin de Bellevue - BP 110
> 74941 Annecy-le-Vieux CEDEX
> T??l: (+33)4 50 09 17 89 - Fax: (+33)4 50 27 94 95
> 
> 


From fcrozat at mandriva.com  Fri Mar  2 01:06:37 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Fri Mar  2 01:01:50 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1172796505.19281.20.camel@behdad>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
Message-ID: <1172826398.4863.110.camel@trinidad.mandrakesoft.com>

Le jeudi 01 mars 2007 ? 19:48 -0500, Behdad Esfahbod a ?crit :
> On Thu, 2007-03-01 at 13:28 -0500, Frederic Crozat wrote:
> > 
> > If I revert to cairo 1.2.x, problem disappear, with same version of
> > pango.
> 
> Would you mind "git bisect"ing?  Helps a lot, and may be the only way to
> pin this down before 1.4.0.

Good news : it appears to be a gcc optimization issue : I don't get the
error when using standard cflags and not the one we use for our Mandriva
packages.

Anyway, I'll do a bisect to find one which commit caused it and I'll try
to grab our gcc guy to find out how to fix.

More on this later.

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva

From cworth at cworth.org  Fri Mar  2 01:46:45 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 01:47:18 2007
Subject: [cairo] Re: [cairo-commit] 6 commits - doc/public
	src/cairo.c	src/cairo-gstate.c src/cairo.h
	src/cairoint.h	src/cairo-quartz-surface.c
	src/cairo-scaled-font.c	test/font-face-get-type.c TODO
In-Reply-To: <20070228012213.9B4A110089@kemper.freedesktop.org>
References: <20070228012213.9B4A110089@kemper.freedesktop.org>
Message-ID: <87lkigkmey.wl%cworth@cworth.org>

On Tue, 27 Feb 2007 17:22:13 -0800 (PST), Behdad wrote:
> Author: Behdad Esfahbod <behdad@behdad.org>
> Date:   Tue Feb 27 20:09:22 2007 -0500
>
>     Implement cairo_get_scaled_font()

Sneaky, Behdad. You added new public API without sending it to the
cairo list first. Tsk. Tsk.

>  /**
> + * cairo_get_scaled_font:
> + * @cr: a #cairo_t
> + *
> + * Gets the current font face for a #cairo_t.
> + *
> + * Return value: the current font object. Can return %NULL
> + *   on out-of-memory or if the context is already in
> + *   an error state. This object is owned by cairo. To keep
> + *   a reference to it, you must call cairo_font_face_reference().
> + *
> + * Since: 1.4
> + **/

Why is this documented as returning NULL ? Shouldn't it be returning a
non-NULL nil object like everything else in cairo?

> +    if (cr->status)
> +	return (cairo_scaled_font_t *)&_cairo_scaled_font_nil;
> +
> +    cr->status = _cairo_gstate_get_scaled_font (cr->gstate, &scaled_font);
> +    if (cr->status) {
> +	_cairo_set_error (cr, cr->status);
> +	return (cairo_scaled_font_t *)&_cairo_scaled_font_nil;

Oh, phew! It is returning a nil object. Let's just fix that
documentation then.

-Carl

PS. Thanks for cranking out so much good code lately--this 1.4 release
should be dandy!
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/aff8e4fc/attachment.pgp
From cworth at cworth.org  Fri Mar  2 02:00:29 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 02:01:00 2007
Subject: [cairo] [PATCH] Use a closed interval when eliminating
	outliers	from performance measurements
In-Reply-To: <20070228183721.GA30530@infidigm.net>
References: <20070228183721.GA30530@infidigm.net>
Message-ID: <87k5y0kls2.wl%cworth@cworth.org>

On Wed, 28 Feb 2007 13:37:21 -0500, Jeff Muizelaar wrote:
> When choosing the samples that are not outliers we use a half-open interval
> (outlier_min <= x < outlier_max). This causes all of the samples to be
> discarded when the interquartile range is 0 because none of them are less
> than outlier_max. Fix the problem and make the test more consistent by
> using a closed interval (outliner_min <= x <= outlier_max).

Thanks for catching my mistake here.

This is pushed out now.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/49399926/attachment.pgp
From cworth at cworth.org  Fri Mar  2 02:13:18 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 02:13:59 2007
Subject: [cairo] Solid surface cache causing cross-thread unhappiness
In-Reply-To: <8e10abfb0703010053s24f2ca26g2214ef7b1073e617@mail.gmail.com>
References: <8e10abfb0703010053s24f2ca26g2214ef7b1073e617@mail.gmail.com>
Message-ID: <87irdkkl6p.wl%cworth@cworth.org>

On Thu, 1 Mar 2007 08:53:15 +0000, "Damian Dixon" wrote:
> Sorry about the direct email - I need to change my email address with the
> list... (I suspect this will be lost to the list).

No worries, Damian. I'm replying here primarily so that people will be
able to see the message you wrote. And in the meantime, I've also
whitelisted your address so you should be able to post again, (even if
you don't bother subscribing with the new address).

Your techniques below sound useful. Thanks for sharing them.

-Carl

> I have just finished writing a web-map-server, for the company I work for,
> which can have N number of threads using X-lib calls. Not using Cario
> though!
>
> The approach I took was to open a display connection for each thread.
>
> I then allocate the X-lib resources required for each thread via that
> display connection. I don't mix the allocations or attempt to reuse the
> X-lib resources between threads even if the opened display's are to the same
> X-server.
>
> I also cache X-lib resources based on a display connection. Which means I
> avoid any need to lock resources. I suspect you could probably move the
> caches to the cario surface and avoid static cache's with locks.
>
> I have had 15 threads running with a very heavy load quite happily using
> this approach.
>
> One other thing I do is that when checking for compatible surfaces I check
> the display, screen, visual and colourmap. Just checking the Screen is not
> enough IMO if someone has picked a non-default visual and created their own
> colourmap.
>
> Regards
> Damian Dixon

PS. It's amazing how hands will so naturally type "cario" instead of
"cairo". I think it took me many months to work that bug out of my
muscles, (and I still tun into it every once in a while). I'm quite
sure this is a Qwerty artefact, ("car" being left-handed an "io" being
right-handed).
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/b22f487f/attachment.pgp
From emmanuel.pacaud at lapp.in2p3.fr  Fri Mar  2 02:16:18 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Fri Mar  2 02:16:25 2007
Subject: [cairo]about SVG file outputting
In-Reply-To: <20070302170958.C65B.YAMAGATA@skycom.jp>
References: <20070302150516.C657.YAMAGATA@skycom.jp>
	<1172819990.5879.2.camel@localhost.localdomain>
	<20070302170958.C65B.YAMAGATA@skycom.jp>
Message-ID: <1172830578.13276.1.camel@localhost.localdomain>

Le vendredi 02 mars 2007 ? 17:20 +0900, yamagata a ?crit :
> > It's fixed in SVN trunk (by adding an overflow="visible" property to symbol elements).

git master I mean, not SVN trunk.

> I see. That's good!
> I'm not familiar with the location of collecting Cairo information such as patches.
> Would you mind to help me again?
> Where can I get the updated version of Cairo library or patches from, which has been fixed in SVN trunk?
> Sorry for bothering you on this.

You'll find the informations here:

http://cairographics.org/download

	Emmanuel.

-- 
Emmanuel PACAUD
Groupe Virgo
LAPP - Laboratoire d'Annecy-le-Vieux de physique des particules
9, chemin de Bellevue - BP 110
74941 Annecy-le-Vieux CEDEX
France
T?l: (+33)4 50 09 17 89 - Fax: (+33)4 50 27 94 95

From cworth at cworth.org  Fri Mar  2 02:35:11 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 02:36:05 2007
Subject: [cairo]about SVG file outputting
In-Reply-To: <20070302170958.C65B.YAMAGATA@skycom.jp>
References: <20070302150516.C657.YAMAGATA@skycom.jp>
	<1172819990.5879.2.camel@localhost.localdomain>
	<20070302170958.C65B.YAMAGATA@skycom.jp>
Message-ID: <87hct4kk68.wl%cworth@cworth.org>

On Fri, 02 Mar 2007 17:20:20 +0900, yamagata wrote:
> > It's fixed in SVN trunk (by adding an overflow="visible" property to symbol elements).
>
> I see. That's good!
> I'm not familiar with the location of collecting Cairo information such as patches.
> Would you mind to help me again?
> Where can I get the updated version of Cairo library or patches from, which has been fixed in SVN trunk?

Well, Emmanuel misspoke when he said "SVN trunk". He meant, of course,
that the latest version of cairo as checked out with git will have
this fix. That is described for you here:

	http://cairographics.org/download

Also, this fix will be included in a 1.4 release of cairo, for which
you might even be able to hold your breath now, (though, keep the
scuba gear handy...)

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/e37640d5/attachment.pgp
From cworth at cworth.org  Fri Mar  2 02:39:14 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 02:39:36 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1172826398.4863.110.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
Message-ID: <87fy8okjzh.wl%cworth@cworth.org>

On Fri, 02 Mar 2007 10:06:37 +0100, Frederic Crozat wrote:
> Good news : it appears to be a gcc optimization issue : I don't get the
> error when using standard cflags and not the one we use for our Mandriva
> packages.

Fantastic. I was hoping we wouldn't have a last-minute delay to the
1.4 release.

> Anyway, I'll do a bisect to find one which commit caused it and I'll try
> to grab our gcc guy to find out how to fix.
>
> More on this later.

Yes, do keep us posted.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/8f6e60ee/attachment.pgp
From cworth at cworth.org  Fri Mar  2 02:54:50 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 02:55:11 2007
Subject: [cairo] Re: [cairo-commit] 6 commits -
	doc/public	src/cairo.c	src/cairo-gstate.c
	src/cairo.h	src/cairoint.h	src/cairo-quartz-surface.c	src/cairo-scaled-font.c	test/font-face-get-type.c
	TODO
In-Reply-To: <87lkigkmey.wl%cworth@cworth.org>
References: <20070228012213.9B4A110089@kemper.freedesktop.org>
	<87lkigkmey.wl%cworth@cworth.org>
Message-ID: <87ejo7lxtx.wl%cworth@cworth.org>

Skipped content of type multipart/mixed-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/d238d532/attachment-0001.pgp
From fcrozat at mandriva.com  Fri Mar  2 03:24:46 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Fri Mar  2 03:19:55 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1172826398.4863.110.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
Message-ID: <1172834686.4863.129.camel@trinidad.mandrakesoft.com>

Le vendredi 02 mars 2007 ? 10:06 +0100, Frederic Crozat a ?crit :
> Le jeudi 01 mars 2007 ? 19:48 -0500, Behdad Esfahbod a ?crit :
> > On Thu, 2007-03-01 at 13:28 -0500, Frederic Crozat wrote:
> > > 
> > > If I revert to cairo 1.2.x, problem disappear, with same version of
> > > pango.
> > 
> > Would you mind "git bisect"ing?  Helps a lot, and may be the only way to
> > pin this down before 1.4.0.
> 
> Good news : it appears to be a gcc optimization issue : I don't get the
> error when using standard cflags and not the one we use for our Mandriva
> packages.
> 
> Anyway, I'll do a bisect to find one which commit caused it and I'll try
> to grab our gcc guy to find out how to fix.

Culprit is commit 3e002a474b64c83f8768ba8918209eca9d7599a3
Author: Vladimir Vukicevic <vladimir@pobox.com>
Date:   Fri Nov 3 09:47:31 2006 -0800

    [win32] Update pixman MMX code to work with MSVC
    
    Patch from Tor Lillqvist.

When building with "-O2 -fomit-frame-pointer", in 16bpp RGBA, you get
funky mask. Code was probably broken before but it wasn't visible.

With help of our gcc guy (Gwenole Beauchesne), I've fix it "the right
way (c)Gwenole" and it should be optimized nicely with gcc.

However, since I'm not a expert in this area, I would suggest somebody
with more knowledge to check fbmmx.c for other funky conversions between
ullong and __m64 and use to_ullong and to_m64 instead of using M64
blindly.

Another nice thing is it was the first time I use git to commit a patch
(better late than never) and use git rebase to move it to HEAD.

I haven't testing this patch with MSVC (since I don't have Windows
platform around) but I don't think it will cause problem.
-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Fix-aliasing-with-gcc-when-using-fomit-frame-pointer.txt
Type: application/mbox
Size: 2024 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/fff4da8a/0001-Fix-aliasing-with-gcc-when-using-fomit-frame-pointer.bin
From spitzak at d2.com  Fri Mar  2 03:29:29 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Fri Mar  2 03:33:20 2007
Subject: [cairo] Radii of radial gradients
In-Reply-To: <1172810440.23133.97.camel@neko.keithp.com>
References: <646543300702090330w27943b44y6eb05d8212fc33e1@mail.gmail.com>	<dcbbbb410702090649r18da8110qa4a3bd762db42a6e@mail.gmail.com>	<87d540vk3s.wl%cworth@cworth.org>	<dcbbbb410702231204q26601575l2182526caacd5dfe@mail.gmail.com>	<87649sv9b4.wl%cworth@cworth.org>	<dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>	<87slcolris.wl%cworth@cworth.org>
	<1172810440.23133.97.camel@neko.keithp.com>
Message-ID: <45E80A99.2080509@d2.com>

Keith Packard wrote:
> On Thu, 2007-03-01 at 10:58 -0800, Carl Worth wrote:
> 
>> Keith suggested just forcing the determinant to 0 when it is
>> negative. I've implemented that and was quite pleased by the result it
>> provides:
> 
> I think there's another possible interpretation here; if you consider
> the gradient as defining a cone, then you could draw the value of the
> final color stop where the determinant is less than zero -- this would
> present a solid field 'underneath' the cone. I fear the current solution
> will produce discontinuities when the final point accidentally steps
> just over the radius of the circle.

This is what I thought as well, but the solution Carl uses has the 
advantage that it does not look like an antialiased cone edge has to be 
produced. Instead even a perfect image would involve setting a pixel to 
a 1-D segment of the gradient.

Also because all the colors are continuous, it can be clipped with an 
antialiased path to produce the PDF output without any hard-to-fix 
problems where pixels are double-multiplied or otherwise unwanted colors 
leak in.
From spitzak at d2.com  Fri Mar  2 04:13:51 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Fri Mar  2 04:14:24 2007
Subject: [cairo] Radii of radial gradients
In-Reply-To: <87slcolris.wl%cworth@cworth.org>
References: <646543300702090330w27943b44y6eb05d8212fc33e1@mail.gmail.com>	<dcbbbb410702090649r18da8110qa4a3bd762db42a6e@mail.gmail.com>	<87d540vk3s.wl%cworth@cworth.org>	<dcbbbb410702231204q26601575l2182526caacd5dfe@mail.gmail.com>	<87649sv9b4.wl%cworth@cworth.org>	<dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>
	<87slcolris.wl%cworth@cworth.org>
Message-ID: <45E814FF.7080709@d2.com>

Carl Worth wrote:

> Another thing that PDF provides that doesn't have explicit support in
> cairo's radial gradients is gradient that extend from only one end or
> the other. For that, what I'd like to suggest is simply using
> EXTEND_REPEAT, (which affects both ends), and then using a transparent
> color stop the end where the extension is undesired.

Another possiblity is that EXTEND_NONE only removes one end of the 
gradient. The default setup should be such that drawing a normal 
(non-cone) gradient results in the "outside" being black, but the 
"inside" circle still being filled in. I feel that the filled circle is 
more useful than a donut, so it should be the more easily-achieved 
result. Also this clip is topologially the same as what EXTEND_NONE does 
with images and linear gradients.

I'm guessing you have added an argument for whether the front or back of 
the cone is drawn. For the non-cone this could reverse it so that 
EXTEND_NONE means a transparent hole is in the middle but the outside 
extends to infinity.

For your first cone drawing, EXTEND_NONE would clip it with the union of 
the larger circle and a triangle so you get a cone with a sharp point 
even if the smaller circle is non-zero.

For the second cone drawing, EXTEND_NONE would clip it with the same 
"hole" as before, so there is just a transparent circle, you still see 
the infinite linear gradient. This is necessary or there will still be 
the problems with discontinuities as inner circle moves outside the 
outer one. Also for my PDF solution (below) it avoids double multiplying 
of the edge pixels which would leak some back-side pixels where they 
should not be seen.

> For that to work, we'll only need one little addition to the current
> implementation. Right now, it only uses one real root of the quadratic
> equation, even if there is a second one available---it simply chooses
> the root that results in a larger value for the gradient's parametric
> control, (this gives the "last circle drawn wins" effect that PDF
> defines).
> 
> To refine this, we'll simply need to check the second root if the
> first root results in a non-opaque color value and simply blend the
> two colors. This should give an interesting effect when transparency
> is used for interior stops, (an effect not expressible in PDF nor
> SVG), but should also allow for emulating the PDF single-sided
> extended gradients with a transparent stop on one end or the other.

I don't like this solution because it means you cannot use transparent 
parts in the more useful one-sided-cones you are producing now. Anybody 
trying to draw a real transparent cone is probably not going to use 
gradients to achieve this, as it is unlikely that they only want to draw 
3D cones but want to draw other geometry as well.

What could be done instead is that the PDF is produced by merging two 
gradients into a surface and using that as a source. This would only 
have to be done when a cone is being drawn and the inner circle is 
transparent, which is probably rare in real documents.
From quesnel at lil.univ-littoral.fr  Fri Mar  2 03:34:07 2007
From: quesnel at lil.univ-littoral.fr (Gauthier Quesnel)
Date: Fri Mar  2 04:39:18 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
Message-ID: <20070302123407.08a060fa@ecoup>

Le Wed, 28 Feb 2007 17:00:47 -0800,
"Daniel Amelang" <daniel.amelang@gmail.com> a ?crit :

> On 2/27/07, Gauthier Quesnel <quesnel@lil.univ-littoral.fr> wrote:
> > Hi all,
> >
> > I want to build an application which display some layers on a
> > gtk.drawingarea like gimp or inkscape for instance, where each layer
> > have an opacity value. Their is three types of layer:
> >
> > Background (to fill the pixmap with a colour):
> >
> >         cairo.save()
> >         cairo.set_source_rgb(self.__red, self.__green, self.__blue)
> >         cairo.set_operator(cairo.OPERATOR_SOURCE)
> >         cairo.paint()
> >         cairo.set_operator(cairo.OPERATOR_OVER);
> >         cairo.restore()
> >
> > A Grid (to draw a grid on the background layer):
> >
> >         cairo.save()
> >         cairo.set_source_rgb(self.__red, self.__green, self.__blue)
> >         cairo.set_line_width(1)
> >         cellwidth = width / self.column
> >         cellheight = height / self.row
> >         for j in range(self.row):
> >             for i in range(self.column):
> >                 cairo.rectangle(i * cellwidth, j * cellheight,
> > width / self.column, height / self.row)
> >         cairo.stroke()
> >         cairo.restore()
> >
> > And the Matrix layer (a numpy array of float) which can be modified
> > by the user (mouse click):
> >
> >         cellwidth = width / self.table.column
> >         cellheight = height / self.table.row
> >         cairo.save()
> >         for j in range(self.table.row):
> >             for i in range(self.table.column):
> >                 value = self.table.get(i, j)
> >                 cairo.set_source_rgb(self.r * value, self.g * value,
> >                         self.b * value)
> >                 cairo.rectangle(i * cellwidth, j * cellheight,
> >                         cellwidth, cellheight)
> >                 cairo.fill()
> >         cairo.stroke()
> >         cairo.restore()
> >
> >
> > With this technique, renders are very slow with five matrix of
> > 40x40. I have added a gdk.pixmap to make a double buffer (all layers
> > are only redraw on configure event and not expose event).
> >
> > I would liked to attach every cairo_context a gdk.pixmap object in
> > order to compute only the layer modified by the user. But it seems
> > not possible with the gdk.pixmap object.
> >
> > Have-you a solution to optimize this type of application?
> 
> Hello Gauthier,

Hello !

> The gimp-like layers that you're describing are usually implemented as
> cairo surfaces, which can then be composed together as needed. It
> sounds like you could draw the background color and the grid just once
> to an intermediate cairo surface (a cache of sorts) that is painted
> onto the window each time you need to draw it. No need for a gdk
> pixmap here, just a cairo surface. Look into
> cairo_surface_create_similar as the means for creating this
> intermediate surface.

I look for a method or a functionality to save the layers between two
calls of the gtk expose_event. I wanted to attach, to each layer, a
gdk.pixmap but the fusion of gdk.pixmap does not manage
transparency. The cairo_surface seems to be a solution thank you :)

> Now, if for whatever reason you have to redraw your grid each time,
> you could get some speedup by drawing your grid using lines instead of
> drawing each cell as a rectangle. Also, moving the cairo_stroke call
> into the inner-most part of your loop will get you a minor speed up,
> too. It may seem counter-intuitive, but it actually does help.

As users can change the colours or the visibility of each surfaces (ie.
the grid and the background), all of them must be different layers.

For grid, move_to() and line_to() are better, thx :)

> I don't really follow what you're doing with your matrix drawing
> code...it could be possible to get the same effect without so many
> rectangle calls. Do you really expect to draw that many different
> colored rectangles? Maybe so, but I'd need to have a better overall
> picture of what you're doing.

Each matrix layer represent a field of values:

- coast zone, 0 for the sea (transparent) and 1 to the earth (black
rectangle),
- fish concentration, value from 0.0 (transparent) to 1.0 with gradient
of colour,
- etc.

The user can display information by:
- fusion of various layers,
- display or not a layer.

For certain layers, the user can modify information (colours, or add
value directly into a cell).

For instance: http://www.epic.noaa.gov/java/ncBrowse/screen-6_full.gif

> You seem to have an unecessary cairo_stroke at the end of your matrix
> drawing code. Not that it should affect performance at all.

It's fixed, thx :)

> Having said all that, for drawing as simple as yours, I wouldn't
> expect the need for any optimization. Would you care to share your
> code with us? If you give us something that we can run, it makes it
> easier to analyze where the performance problems are.

Yep, my sources are GPL (require pygtk 2.10 and numpy):
http://vle.univ-littoral.fr/gitweb?p=goo.git;a=summary

With Cogito/Git tools:
cg-clone http://vle.univ-littoral.fr/goo.git
git-clone http://vle.univ-littoral.fr/goo.git

> Dan

Gauthier.
From cworth at cworth.org  Fri Mar  2 04:48:53 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 04:49:29 2007
Subject: [cairo] PS/PDF Gradients
In-Reply-To: <45BCABC7.2030203@redneon.com>
References: <45BCABC7.2030203@redneon.com>
Message-ID: <87d53rlsju.wl%cworth@cworth.org>

On Mon, 29 Jan 2007 00:27:27 +1030, Adrian Johnson wrote:
> I have been testing Mikl?s' PDF gradient patch from
> http://lists.freedesktop.org/archives/cairo/2006-August/007648.html

Thanks for keeping this alive, Adrian! 

I know that the inkscape developers, (among others), are very anxious
to see cairo generate PDF files with native gradients rather than
falling back to rasterization---since other than this issue, cairo is
providing very good PDF export capability.

> Looking at the patch the only obvious deficiency I could see is lack of
> support for the different cairo_extend_t options. The patch has the PDF
> /Extend value set to [true true] which is equivalent CAIRO_EXTEND_PAD.
> 
> Testing linear gradients with rgb stops appears to be ok. Changing the
> PDF /Extend value set to [false false] which is equivalent
> CAIRO_EXTEND_NONE also works.

OK, well one thing we definitely need is a test case for linear
gradients with all of the extend modes, (could be much like the recent
radial case I added).

> The results of testing linear gradients with CAIRO_EXTEND_PAD and rgba
> stops are:
>   acroread    - ok but the colors seem to be too dark.
>   evince      - broken, The padded region is opaque when it should have
> some transparency.
>   ghostscript - broken. all opaque colors. no transparency.

All I looked at was the output from poppler which the test suite
uses. I'm also seeing the colors as too dark, but otherwise the
results look quite promising, (again without testing extend modes
yet). Here's the reference image (sorry it's so tiny):

http://cairographics.org/~cworth/images/linear-gradient-ref.png

and here's the rendering of the PDF output:

http://cairographics.org/~cworth/images/linear-gradient-pdf-argb32-out.png

So that just looks like one simple color scaling issue somewhere.

And once we test the extend modes, it would at least be very easy to
only turn on native gradients for known-good extend modes.

> I have not tested radial gradients.

I did now, and it's not too pretty. Here's our reference image:

http://cairographics.org/~cworth/images/radial-gradient-ref.png

and here's the rendering of the PDF output:

http://cairographics.org/~cworth/images/radial-gradient-pdf-argb32-out.png

So it looks like there's still a fair amount of work to be done there.

Anyway, if anyone wants to help out with this, it would be *greatly*
appreciated.

I took this quick look to see if there was anything here in a state
ready to make it into 1.4, but it looks like there's not.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/5b850754/attachment.pgp
From pachi at rvburke.com  Fri Mar  2 04:52:53 2007
From: pachi at rvburke.com (Rafael Villar Burke)
Date: Fri Mar  2 04:53:04 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <20070302123407.08a060fa@ecoup>
References: <20070227201153.02773785@portvle>	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
Message-ID: <45E81E25.60506@rvburke.com>

Gauthier Quesnel wrote:
> Yep, my sources are GPL (require pygtk 2.10 and numpy):
> http://vle.univ-littoral.fr/gitweb?p=goo.git;a=summary
>
> With Cogito/Git tools:
> cg-clone http://vle.univ-littoral.fr/goo.git
> git-clone http://vle.univ-littoral.fr/goo.git
>
>   
I'd like to add your application to the pygtk.org applications list, as 
it can be a good example of using cairo in a pygtk application. Do you 
have a webpage for it so I could link it instead of the git repo?.

Regards,

Rafael Villar Burke (aka pachi)
From quesnel at lil.univ-littoral.fr  Fri Mar  2 08:08:56 2007
From: quesnel at lil.univ-littoral.fr (Gauthier Quesnel)
Date: Fri Mar  2 08:09:17 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <45E81E25.60506@rvburke.com>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup> <45E81E25.60506@rvburke.com>
Message-ID: <20070302170856.1595be9c@ecoup>

Rafael Villar Burke <pachi@rvburke.com> a ?crit :

> Gauthier Quesnel wrote:
> > Yep, my sources are GPL (require pygtk 2.10 and numpy):
> > http://vle.univ-littoral.fr/gitweb?p=goo.git;a=summary
> >
> > With Cogito/Git tools:
> > cg-clone http://vle.univ-littoral.fr/goo.git
> > git-clone http://vle.univ-littoral.fr/goo.git
> >
> >   
> I'd like to add your application to the pygtk.org applications list,
> as it can be a good example of using cairo in a pygtk application. Do
> you have a webpage for it so I could link it instead of the git repo?.

No problem.

A very small webpage which will evolve:
http://vle.univ-littoral.fr/goo/

> Regards,
> Rafael Villar Burke (aka pachi)

Gauthier.
From keithp at keithp.com  Fri Mar  2 08:21:15 2007
From: keithp at keithp.com (Keith Packard)
Date: Fri Mar  2 08:23:29 2007
Subject: [cairo] Radii of radial gradients
In-Reply-To: <45E80A99.2080509@d2.com>
References: <646543300702090330w27943b44y6eb05d8212fc33e1@mail.gmail.com>
	<dcbbbb410702090649r18da8110qa4a3bd762db42a6e@mail.gmail.com>
	<87d540vk3s.wl%cworth@cworth.org>
	<dcbbbb410702231204q26601575l2182526caacd5dfe@mail.gmail.com>
	<87649sv9b4.wl%cworth@cworth.org>
	<dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>
	<87slcolris.wl%cworth@cworth.org>
	<1172810440.23133.97.camel@neko.keithp.com> <45E80A99.2080509@d2.com>
Message-ID: <1172852475.3747.10.camel@neko.keithp.com>

On Fri, 2007-03-02 at 11:29 +0000, Bill Spitzak wrote:

> This is what I thought as well, but the solution Carl uses has the 
> advantage that it does not look like an antialiased cone edge has to be 
> produced. Instead even a perfect image would involve setting a pixel to 
> a 1-D segment of the gradient.

This is a good point; using anything other than a continuous tone will
result in sharp edges unless we do a pile of work. That seems like a
good reason to me.

-- 
keith.packard@intel.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/970dea74/attachment.pgp
From mental at rydia.net  Fri Mar  2 11:36:42 2007
From: mental at rydia.net (MenTaLguY)
Date: Fri Mar  2 11:36:44 2007
Subject: [cairo] PS/PDF Gradients
In-Reply-To: <87d53rlsju.wl%cworth@cworth.org>
References: <87d53rlsju.wl%cworth@cworth.org>
Message-ID: <6632379689babe0ff3014a8378ab75f9@localhost>

On Fri, 02 Mar 2007 04:48:53 -0800, Carl Worth <cworth@cworth.org> wrote:
> I know that the inkscape developers, (among others), are very anxious
> to see cairo generate PDF files with native gradients rather than
> falling back to rasterization---since other than this issue, cairo is
> providing very good PDF export capability.

The biggest issue is still that Cairo rasterizes groups (which, when object opacity is used, means pretty much anything).  Will you have time to look at that with me this weekend?  I tried to attack it during the week, but I got completely lost.

-mental


From cworth at cworth.org  Fri Mar  2 11:45:23 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  2 11:45:36 2007
Subject: [cairo] PS/PDF Gradients
In-Reply-To: <6632379689babe0ff3014a8378ab75f9@localhost>
References: <87d53rlsju.wl%cworth@cworth.org>
	<6632379689babe0ff3014a8378ab75f9@localhost>
Message-ID: <87abyvl99o.wl%cworth@cworth.org>

On Fri, 2 Mar 2007 11:36:42 -0800, MenTaLguY wrote:
> The biggest issue is still that Cairo rasterizes groups (which, when
> object opacity is used, means pretty much anything).

Oh, right. I'd forgotten about that one.

> Will you have time to look at that with me this weekend?  I tried to
> attack it during the week, but I got completely lost.

I'm making 1.4 as we speak, (just typing release notes), and I'll be
doing pretty much nothing of cairo this weekend. But yes, let's work
together on this soon.

I definitely want to make sure we have a 1.4.2 release as soon as
possible, and these are the goals I have for that:

* Fill all XFAIL test cases

* Give inkscape everything it needs for a switch to cairo

	- fix a8-mask XFAIL (patch exists on list---and got good
	- review from inkscape folks)

	- fix long-lines XFAIL (switch from 16.16 to 24.8 for internal
          fixed-point storage)

	- fix rasterization of PDF gradients (starting from Mikl?s
          patch on the list)

	- fix rasterization of PDF groups (make pdf create_similar
          return a meta-surface in a way similar to what the SVG
          backend does

* Turn on X server gradients

* Other cool stuff that people really wanted in 1.4 but just didn't
  quite make it.

-Carl

-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070302/9a6acc5f/attachment.pgp
From fcrozat at mandriva.com  Fri Mar  2 12:01:04 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Fri Mar  2 11:56:15 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1172834686.4863.129.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
Message-ID: <1172865665.4863.131.camel@trinidad.mandrakesoft.com>

Le vendredi 02 mars 2007 ? 12:24 +0100, Frederic Crozat a ?crit :
> Le vendredi 02 mars 2007 ? 10:06 +0100, Frederic Crozat a ?crit :
> > Le jeudi 01 mars 2007 ? 19:48 -0500, Behdad Esfahbod a ?crit :
> > > On Thu, 2007-03-01 at 13:28 -0500, Frederic Crozat wrote:
> > > > 
> > > > If I revert to cairo 1.2.x, problem disappear, with same version of
> > > > pango.
> > > 
> > > Would you mind "git bisect"ing?  Helps a lot, and may be the only way to
> > > pin this down before 1.4.0.
> > 
> > Good news : it appears to be a gcc optimization issue : I don't get the
> > error when using standard cflags and not the one we use for our Mandriva
> > packages.
> > 
> > Anyway, I'll do a bisect to find one which commit caused it and I'll try
> > to grab our gcc guy to find out how to fix.
> 
> Culprit is commit 3e002a474b64c83f8768ba8918209eca9d7599a3
> Author: Vladimir Vukicevic <vladimir@pobox.com>
> Date:   Fri Nov 3 09:47:31 2006 -0800
> 
>     [win32] Update pixman MMX code to work with MSVC
>     
>     Patch from Tor Lillqvist.
> 
> When building with "-O2 -fomit-frame-pointer", in 16bpp RGBA, you get
> funky mask. Code was probably broken before but it wasn't visible.
> 
> With help of our gcc guy (Gwenole Beauchesne), I've fix it "the right
> way (c)Gwenole" and it should be optimized nicely with gcc.
> 
> However, since I'm not a expert in this area, I would suggest somebody
> with more knowledge to check fbmmx.c for other funky conversions between
> ullong and __m64 and use to_ullong and to_m64 instead of using M64
> blindly.
> 
> Another nice thing is it was the first time I use git to commit a patch
> (better late than never) and use git rebase to move it to HEAD.
> 
> I haven't testing this patch with MSVC (since I don't have Windows
> platform around) but I don't think it will cause problem.

Argg, my coworker just told me it wasn't fixing his problem with fonts
being corrupted (see http://qa.mandriva.com/show_bug.cgi?id=28317 ) but
he is running on x86-64 so my fix might be incomplete.

I'll be unable to work on this until Monday. Sorry.

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva

From behdad at behdad.org  Fri Mar  2 09:44:14 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar  2 12:21:33 2007
Subject: [cairo] Re: [cairo-commit] 2 commits - src/cairo-pattern.c
	src/cairo-ps-surface.c
In-Reply-To: <20070302083735.4F76B10089@kemper.freedesktop.org>
References: <20070302083735.4F76B10089@kemper.freedesktop.org>
Message-ID: <1172857454.30731.9.camel@behdad>

On Fri, 2007-03-02 at 03:37 -0500, Carl Worth wrote:
> 
> @@ -1351,7 +1351,12 @@ surface_pattern_supported (const cairo_s
>         return FALSE;
>  */
>  
> -    extend = cairo_pattern_get_extend (&pattern->base);
> +    /* Cast away the const, trusting get_extend not to muck with it.
> +     * And I really wish I had a way to cast away just the const, and
> +     * not potentially coerce this pointer to an incorrect type at
> the
> +     * same time. :-(
> +     */
> +    extend = cairo_pattern_get_extend
> ((cairo_pattern_t*)&pattern->base);
>      switch (extend) { 

The correct fix is IMO to make surface_pattern_supported argument
non-const.  We don't use const for most cairo types because they are
opaque and const does not make much sense in the public API.  It sure
makes sense internally, but these kind of problems appear.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From jslupski at juljas.net  Fri Mar  2 16:47:49 2007
From: jslupski at juljas.net (Jan Slupski)
Date: Fri Mar  2 16:47:53 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <1172700393.31478.1177064837@webmail.messagingengine.com>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>
Message-ID: <Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>

On Wed, 28 Feb 2007, David Turner wrote:

> Hello,
>
> here's the first version of my patches to fix Cairo's usage of FreeType with multiple
> threads. It's rather big, so I'll summarize things here a little:

Hi David,

I tried your patches against the current git cairo (latest commit
fed13e77e1de071ddaaf829aced10b02f6bc8c90).

Is it expected that cairo with these patches runs *much* slower
than without? I'm running simple test case and it seems to be
8+ times slower even in single thread.

Is there anything special I should do (i.e. revert some already
merged patches)?

I'll try to figure out what exactly caused the slowdown, but any hints
are apperciated...

I have used default setup (./autogen.sh; make) and
fontconfig 2.4.2, freetype 2.1.7 & 2.3.1


> - the cairo_ft_ functions do implement the current Cairo behaviour regarding
>  font options (i.e. the FontConfig backend ignores user-provided options for
>  antialiased setting, extracting those from the original FcPattern instead)

It's OT here, but I absolutely agree with you that ignornoring user-provided
options is... strange decision?

Thanks,
Jan


    _  _  _  _  _____________________________________________
    | |_| |\ |  S L U P S K I             jslupski@juljas.net
  |_| | | | \|                             http://juljas.net/
From spitzak at d2.com  Fri Mar  2 17:03:33 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Fri Mar  2 17:03:58 2007
Subject: [cairo] Radii of radial gradients
In-Reply-To: <45E814FF.7080709@d2.com>
References: <646543300702090330w27943b44y6eb05d8212fc33e1@mail.gmail.com>	<dcbbbb410702090649r18da8110qa4a3bd762db42a6e@mail.gmail.com>	<87d540vk3s.wl%cworth@cworth.org>	<dcbbbb410702231204q26601575l2182526caacd5dfe@mail.gmail.com>	<87649sv9b4.wl%cworth@cworth.org>	<dcbbbb410702241046q41fe6b5en3657c53015ff7668@mail.gmail.com>
	<87slcolris.wl%cworth@cworth.org> <45E814FF.7080709@d2.com>
Message-ID: <bf0efdb80cf108cbf714ac1542eb1482@d2.com>

Never mind my discussion of cones below, I was wrong about that.

Here is (I hope) a consistent proposal:

EXTEND_NONE should be very similar (but not exactly) the same as adding 
a transparent color stop at 1. It should actually act like 
EXTEND_REPEAT but clip the gradient with a antia-aliased path. This is 
similar to how EXTEND_NONE should work for images (producing a sharp 
anti-aliased clipping quadralateral of the EXTEND_REPEAT image).

1. If the 0 circle is entirely inside the 1 circle, the clip is the 1 
circle, thus producing a solid circle.

2. If the 0 circle intersects or is outside the 1 circle then your 
calculation should take the *lower* root, and the clip is the union of 
the two circles and the trapazoid formed by the tangent lines and lines 
joining the tangent points. The result will look like a truncated cone 
(if the 0 circle is not a point) that points up out of the paper toward 
you. This must be drawn to be continous with the previous case.

3. If the 0 circle completely encloses the 1 circle then the clipping 
should be the 0 circle and filled with a constant 0 color stop.

To draw the PDF cone using the above:

The above Cairo gradient can be used directly if the extend is set so 
the 0 circle is filled in and/or the 0 circle has zero size. Otherwise:

1. If the 0 circle is entirely inside the 1 circle, clip out the 0 
circle before drawing the gradient, thus producing a "donut".

2. If the 0 circle encloses the 1 circle, make another gradient with 
all the stops reversed and the circles swapped. If the 1 end should be 
opaque you can just use this gradient. If the 1 end should be 
transparent you should clip out the 1 circle and use this gradient.

3. Otherwise two gradients must be composited. First draw the "back" of 
the cone by doing case 2 above (even though the circles intersect). 
Then do case 1 atop that. Use the resulting temporary surface as the 
source.

On Mar 2, 2007, at 12:13 PM, Bill Spitzak wrote:

> For your first cone drawing, EXTEND_NONE would clip it with the union 
> of the larger circle and a triangle so you get a cone with a sharp 
> point even if the smaller circle is non-zero.
>
> For the second cone drawing, EXTEND_NONE would clip it with the same 
> "hole" as before, so there is just a transparent circle, you still see 
> the infinite linear gradient. This is necessary or there will still be 
> the problems with discontinuities as inner circle moves outside the 
> outer one. Also for my PDF solution (below) it avoids double 
> multiplying of the edge pixels which would leak some back-side pixels 
> where they should not be seen.

From david at freetype.org  Fri Mar  2 18:29:19 2007
From: david at freetype.org (David Turner)
Date: Fri Mar  2 18:29:21 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>
Message-ID: <1172888959.26264.1177484563@webmail.messagingengine.com>

Hi Jan,

no, this is not normal at all; I'm running my desktop on this patch and
haven't seen any regression in performance. Are you sure your merge happened
without conflicts ?

the long story is that some of the intermediate commits in the patchset do
produce correct behaviour and very poor performance, but this is normally
fixed in later ones.

In the event your merge didn't work correctly, you could be left in one of
these hideously slow cases. I've just checked the patchset file, and the
changes described there seem ok.

Could you give more details about your test cases ? it may be interesting.

Regards,

- David


On Sat, 3 Mar 2007 01:47:49 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
> On Wed, 28 Feb 2007, David Turner wrote:
> 
> > Hello,
> >
> > here's the first version of my patches to fix Cairo's usage of FreeType with multiple
> > threads. It's rather big, so I'll summarize things here a little:
> 
> Hi David,
> 
> I tried your patches against the current git cairo (latest commit
> fed13e77e1de071ddaaf829aced10b02f6bc8c90).
> 
> Is it expected that cairo with these patches runs *much* slower
> than without? I'm running simple test case and it seems to be
> 8+ times slower even in single thread.
> 
> Is there anything special I should do (i.e. revert some already
> merged patches)?
> 
> I'll try to figure out what exactly caused the slowdown, but any hints
> are apperciated...
> 
> I have used default setup (./autogen.sh; make) and
> fontconfig 2.4.2, freetype 2.1.7 & 2.3.1
> 
> 
> > - the cairo_ft_ functions do implement the current Cairo behaviour regarding
> >  font options (i.e. the FontConfig backend ignores user-provided options for
> >  antialiased setting, extracting those from the original FcPattern instead)
> 
> It's OT here, but I absolutely agree with you that ignornoring
> user-provided
> options is... strange decision?
> 
> Thanks,
> Jan
> 
> 
>     _  _  _  _  _____________________________________________
>     | |_| |\ |  S L U P S K I             jslupski@juljas.net
>   |_| | | | \|                             http://juljas.net/
From jslupski at juljas.net  Fri Mar  2 19:23:33 2007
From: jslupski at juljas.net (Jan Slupski)
Date: Fri Mar  2 19:23:38 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <1172888959.26264.1177484563@webmail.messagingengine.com>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>  
	<Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>
	<1172888959.26264.1177484563@webmail.messagingengine.com>
Message-ID: <Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>

On Sat, 3 Mar 2007, David Turner wrote:

> no, this is not normal at all; I'm running my desktop on this patch and
> haven't seen any regression in performance. Are you sure your merge happened
> without conflicts ?

No, no conflicts. Only few 'fuzz'.

Except makefiles these are:

$ bzcat ../fix-freetype-usage-1.patchset.bz2 | patch -p1
(...)
patching file src/cairo-debug.c
Hunk #1 succeeded at 66 with fuzz 2.
(...)
patching file src/cairoint.h
Hunk #1 succeeded at 623 (offset 4 lines).
Hunk #3 succeeded at 1214 (offset 2 lines).

Should I try any earlier cairo snapshot?

> the long story is that some of the intermediate commits in the patchset do
> produce correct behaviour and very poor performance, but this is normally
> fixed in later ones.
>
> In the event your merge didn't work correctly, you could be left in one of
> these hideously slow cases. I've just checked the patchset file, and the
> changes described there seem ok.
>
> Could you give more details about your test cases ? it may be interesting.

Seems that I am able to reproduce these on my simple cairo threads test case
I used before to hunt previous problems. (attached)

Cairo-git:
real    0m2.551s
user    0m2.530s
sys     0m0.020s

Cairo-git + fix-freetype-usage-1.patchset:
real    0m12.956s
user    0m12.950s
sys     0m0.010s

Command used: time ./threads 1 10000 
(one thread, 10K loops)


Before I used two samples (against some external library that calls
cairo) on two Linux machines. Slowdown with patch applied was:
- between 2x (x86_64 dual) and 6x (i386) - first sample
- between 6x (x86_64 dual) and 60x+ (i386) really! - another sample

I'm sure about these results, but if you find them unbelivable
and cannot reproduce, I'll repeat tests from scratch to make it 200% sure...


Thanks a lot,
Jan



> On Sat, 3 Mar 2007 01:47:49 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
>> On Wed, 28 Feb 2007, David Turner wrote:
>>
>>> Hello,
>>>
>>> here's the first version of my patches to fix Cairo's usage of FreeType with multiple
>>> threads. It's rather big, so I'll summarize things here a little:
>>
>> Hi David,
>>
>> I tried your patches against the current git cairo (latest commit
>> fed13e77e1de071ddaaf829aced10b02f6bc8c90).
>>
>> Is it expected that cairo with these patches runs *much* slower
>> than without? I'm running simple test case and it seems to be
>> 8+ times slower even in single thread.
>>
>> Is there anything special I should do (i.e. revert some already
>> merged patches)?
>>
>> I'll try to figure out what exactly caused the slowdown, but any hints
>> are apperciated...
>>
>> I have used default setup (./autogen.sh; make) and
>> fontconfig 2.4.2, freetype 2.1.7 & 2.3.1

    _  _  _  _  _____________________________________________
    | |_| |\ |  S L U P S K I             jslupski@juljas.net
  |_| | | | \|                             http://juljas.net/
-------------- next part --------------
#include <pthread.h>
#include <cairo.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>


#define MAX_THREAD 2
#define LOOP_COUNT 50

void * Draw(void *p);

int gLoopCount=LOOP_COUNT;

int main(int argc, char **argv) {
	const int nThreads = argc>1?atoi(argv[1]):MAX_THREAD;
	int i;

	pthread_t threads[5000];

	if(argc>2) gLoopCount = atoi(argv[2]);

	//printf("Cairo version: %s\n",cairo_version_string());


	for(i =0; i<nThreads; i++)
	{
		int err = pthread_create(&threads[i],NULL,Draw,(void*)i);
		if(err) printf("error creating thread %d\n",i);
	}

	for(i =0; i<nThreads; i++)
		pthread_join(threads[i], NULL);

	cairo_debug_reset_static_data();

	return 0;
}



void * Draw(void *p)
{ 
  int thread_no = (int)p;
	int loop = 0;

	while (loop<=gLoopCount)
	{
		if(loop%50==0)
			printf("t%03d loop %4d\n",thread_no, loop);

		{
			//char name[200];
			//sprintf(name, "th%03d.img%04d.png", thread_no, loop);

			cairo_surface_t *surface;
			cairo_t *cr;

			char string[] = "Hello";
			cairo_text_extents_t size;
			double fontsize = 100.0;

			surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 400, 300);
			cr = cairo_create (surface);

			cairo_select_font_face (cr, "Serif", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
			cairo_set_font_size (cr, fontsize);
			cairo_text_extents(cr, string, &size);
			cairo_show_text (cr, string);

			//cairo_surface_write_to_png (surface, "rotlabel.png");
			cairo_destroy (cr);
			cairo_surface_destroy (surface);

		}
		loop++;
	}

	return NULL;

}


From david at freetype.org  Fri Mar  2 20:43:52 2007
From: david at freetype.org (David Turner)
Date: Fri Mar  2 20:43:58 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>
	<1172888959.26264.1177484563@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>
Message-ID: <1172897032.4319.1177493595@webmail.messagingengine.com>

I can reproduce the problem with your test, I've just started investigating.
will post later with conclusion and, I hope, a fix

thanks a lot,

- David

On Sat, 3 Mar 2007 04:23:33 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
> On Sat, 3 Mar 2007, David Turner wrote:
> 
> > no, this is not normal at all; I'm running my desktop on this patch and
> > haven't seen any regression in performance. Are you sure your merge happened
> > without conflicts ?
> 
> No, no conflicts. Only few 'fuzz'.
> 
> Except makefiles these are:
> 
> $ bzcat ../fix-freetype-usage-1.patchset.bz2 | patch -p1
> (...)
> patching file src/cairo-debug.c
> Hunk #1 succeeded at 66 with fuzz 2.
> (...)
> patching file src/cairoint.h
> Hunk #1 succeeded at 623 (offset 4 lines).
> Hunk #3 succeeded at 1214 (offset 2 lines).
> 
> Should I try any earlier cairo snapshot?
> 
> > the long story is that some of the intermediate commits in the patchset do
> > produce correct behaviour and very poor performance, but this is normally
> > fixed in later ones.
> >
> > In the event your merge didn't work correctly, you could be left in one of
> > these hideously slow cases. I've just checked the patchset file, and the
> > changes described there seem ok.
> >
> > Could you give more details about your test cases ? it may be interesting.
> 
> Seems that I am able to reproduce these on my simple cairo threads test
> case
> I used before to hunt previous problems. (attached)
> 
> Cairo-git:
> real    0m2.551s
> user    0m2.530s
> sys     0m0.020s
> 
> Cairo-git + fix-freetype-usage-1.patchset:
> real    0m12.956s
> user    0m12.950s
> sys     0m0.010s
> 
> Command used: time ./threads 1 10000 
> (one thread, 10K loops)
> 
> 
> Before I used two samples (against some external library that calls
> cairo) on two Linux machines. Slowdown with patch applied was:
> - between 2x (x86_64 dual) and 6x (i386) - first sample
> - between 6x (x86_64 dual) and 60x+ (i386) really! - another sample
> 
> I'm sure about these results, but if you find them unbelivable
> and cannot reproduce, I'll repeat tests from scratch to make it 200%
> sure...
> 
> 
> Thanks a lot,
> Jan
> 
> 
> 
> > On Sat, 3 Mar 2007 01:47:49 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
> >> On Wed, 28 Feb 2007, David Turner wrote:
> >>
> >>> Hello,
> >>>
> >>> here's the first version of my patches to fix Cairo's usage of FreeType with multiple
> >>> threads. It's rather big, so I'll summarize things here a little:
> >>
> >> Hi David,
> >>
> >> I tried your patches against the current git cairo (latest commit
> >> fed13e77e1de071ddaaf829aced10b02f6bc8c90).
> >>
> >> Is it expected that cairo with these patches runs *much* slower
> >> than without? I'm running simple test case and it seems to be
> >> 8+ times slower even in single thread.
> >>
> >> Is there anything special I should do (i.e. revert some already
> >> merged patches)?
> >>
> >> I'll try to figure out what exactly caused the slowdown, but any hints
> >> are apperciated...
> >>
> >> I have used default setup (./autogen.sh; make) and
> >> fontconfig 2.4.2, freetype 2.1.7 & 2.3.1
> 
>     _  _  _  _  _____________________________________________
>     | |_| |\ |  S L U P S K I             jslupski@juljas.net
>   |_| | | | \|                             http://juljas.net/
From behdad at behdad.org  Fri Mar  2 21:38:00 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar  2 21:38:01 2007
Subject: [cairo] [cairo-announce] cairo snapshot 1.3.16 (1.4.0 release
	candidate) now available
Message-ID: <1172900280.3091.14.camel@behdad>

A new cairo snapshot 1.3.16 is now available from:

        http://cairographics.org/snapshots/cairo-1.3.16.tar.gz

    which can be verified with:

        http://cairographics.org/snapshots/cairo-1.3.16.tar.gz.sha1
        8c80376b18a58727f03fea05ef191acb19903e01  cairo-1.3.16.tar.gz

        http://cairographics.org/snapshots/cairo-1.3.16.tar.gz.sha1.asc
        (signed by Behdad Esfahbod)

  Additionally, a git clone of the source tree:

        git clone git://git.cairographics.org/git/cairo

    will include a signed 1.3.16 tag which points to a commit named:
        b3e1fd8c1cbfc4db88bec4bb52821ed9380dbb4f

    which can be verified with:
        git verify-tag 1.3.16

    and can be checked out with a command such as:
        git checkout -b build 1.3.16


This is the eighth development snapshot in the 1.3 series, and the
release candidate for 1.4.0, that will be released early next week.
It comes just over 3 weeks after the 1.3.14 snapshot.

New API functions
-----------------
A few new public functions have been added to the cairo API since the
1.3.14 snapshot. These include a function to query the current scaled
font:

	cairo_get_scaled_font

New functions to query the reference count of all cairo objects:

	cairo_get_reference_count

	cairo_surface_get_reference_count
	cairo_pattern_get_reference_count

	cairo_font_face_get_reference_count
	cairo_scaled_font_get_reference_count

And new functions to allow the use of user_data with any cairo object,
(previously these were only available on cairo_surface_t and
cairo_font_face_t objects):

	cairo_set_user_data
	cairo_get_user_data

	cairo_pattern_set_user_data
	cairo_pattern_get_user_data

	cairo_scaled_font_set_user_data
	cairo_scaled_font_get_user_data

Usability improvement for PDF/PS/SVG generation
-----------------------------------------------
In previous versions of cairo, generating single-page output with the
cairo-pdf, cairo-ps, or cairo-svg backends required a final call to
cairo_show_page. This was often quite confusing as people would port
functional code from a non-paginated backend and be totally mystified
as to why the output was blank until they learned to add this call.

Now that call to cairo_show_page is optional, (it will be generated
implicitly if the user does not call it). So cairo_show_page is only
needed to explicitly separate multiple pages.

Greatly improved PDF output
---------------------------
We are very happy to be able to announce that cairo-generated PDF
output will now have text that can be selected, cut-and-paste, and
searched with most capable PDF viewer applications. This is something
that was not ever possible with cairo 1.2.

Also, the PDF output now has much more compact encoding of text than
before. Cairo is now much more careful to not embed multiple copies of
the same font at different sizes. It also compresses text and font
streams within the PDF output.

Major bug fixes
---------------
  ? Fixed radial gradients

    The rendering of radial gradients has been greatly improved. In
    the cairo 1.2 series, there was a serious regression affecting
    radial gradients---results would be very incorrect unless one of
    the gradient circles had a radius of 0.0 and a center point within
    the other circle. These bugs have now been fixed.

  ? Fixed dashing

    Several fixes have been made to the implementation of dashed
    stroking. Previously, some dashed, stroked rectangles would
    mis-render and fill half of the rectangle with a large triangular
    shape. This bug has now been fixed.

  ? Fixed transformed images in PDF/PS output

    In previous versions of cairo, painting with an image-based source
    surface pattern to the PDF or PS backends would cause many kinds
    of incorrect results. One of the most common problems was that an
    image would be repeated many times even when the user had
    explicitly requested no repetition with CAIRO_EXTEND_NONE. These
    bugs have now been fixed.

  ? Eliminate errors from CAIRO_EXTEND_REFLECT and CAIRO_EXTEND_PAD

    In the 1.2 version of cairo any use of CAIRO_EXTEND_REFLECT or
    CAIRO_EXTEND_PAD with a surface-based pattern resulted in an
    error, (cairo would stop rendering). This bug has now been
    fixed.

    Now, CAIRO_EXTEND_REFLECT should work properly with surface
    patterns.

    CAIRO_EXTEND_PAD is still not working correctly, but it will now
    simply behave as CAIRO_EXTEND_NONE rather than triggering the
    error.

New rewrite of quartz backend (still experimental)
--------------------------------------------------
Cairo's quartz backend has been entirely rewritten and is now much
more efficient. This backend is still marked as experimental, not
supported, but it is now much closer to becoming an officially
supported backend. (For people that used the experimental nquartz
backend in previous snapshots, that implementation has now been
renamed from "nquartz" to "quartz" and has replaced the old quartz
backend.)

Documentation improvements
--------------------------
We have added documentation for several functions and types that
were previously undocumented, and improved documentation on other
ones.  As of this release, there remain only two undocumented
symbols: cairo_filter_t and cairo_operator_t.

Other bug fixes
---------------
  ? cairo-svg: Fix bug that was preventing text from appearing in many
    viewers

  ? cairo-ft: Return correct metrics when hinting is off

  ? Cairo 1.3.14 deadlocks in cairo_scaled_font_glyph_extents or
    _cairo_ft_unscaled_font_lock_face

    https://bugs.freedesktop.org/show_bug.cgi?id=10035

  ? cairo crashes in cairo_create_similar if nil surface returned by
    other->backend->create_similar

    https://bugs.freedesktop.org/show_bug.cgi?id=9844

  ? evolution crash in _cairo_gstate_backend_to_user()
    https://bugs.freedesktop.org/show_bug.cgi?id=9906

  ? Fix memory leak in rectilinear stroking code

Things not in this release
--------------------------
  ? Solid-surface-pattern cache: This patch had been applied during
    the 1.3.x series, but it was reverted due to some inter-thread
    problems it caused. The patch is interesting since it made a big
    benefit for text rendering performance---so we'll work to bring a
    corrected version of this patch back as soon as possible.



Have fun with a faster, more robust, cairo!

behdad



What is cairo
=============
Cairo is a 2D graphics library with support for multiple output
devices. Currently supported output targets include the X Window
System, win32, and image buffers, as well as PDF, PostScript, and SVG
file output. Experimental backends include OpenGL (through glitz),
Quartz, XCB, BeOS, OS/2, and DirectFB.

Cairo is designed to produce consistent output on all output media
while taking advantage of display hardware acceleration when available
(for example, through the X Render Extension).

The cairo API provides operations similar to the drawing operators of
PostScript and PDF. Operations in cairo including stroking and filling
cubic B?zier splines, transforming and compositing translucent images,
and antialiased text rendering. All drawing operations can be
transformed by any affine transformation (scale, rotation, shear,
etc.).

Cairo has been designed to let you draw anything you want in a modern
2D graphical user interface.  At the same time, the cairo API has been
designed to be as fun and easy to learn as possible. If you're not
having fun while programming with cairo, then we have failed
somewhere---let us know and we'll try to fix it next time around.

Cairo is free software and is available to be redistributed and/or
modified under the terms of either the GNU Lesser General Public
License (LGPL) version 2.1 or the Mozilla Public License (MPL) version
1.1.

Where to get more information about cairo
=========================================
The primary source of information about cairo is:

        http://cairographics.org/

The latest releases of cairo can be found at:

        http://cairographics.org/releases

Snapshots of in-development versions of cairo:

        http://cairographics.org/snapshots

The programming manual for using cairo:

        http://cairographics.org/manual

Mailing lists for contacting cairo users and developers:

        http://cairographics.org/lists

Answers to some frequently asked questions about cairo:

        http://cairographics.org/FAQ


Detailed list of changes since 1.3.14
=====================================

Adrian Johnson:
      TrueType: Add post table and 3,0 cmap encoding
      TrueType: fix bug #9998 - build error with gcc 2.95
      PDF/PS: Don't embed multiple copies of the same font
      Win32: Fix _cairo_win32_scaled_font_map_glyphs_to_unicode return type
      Subsetting: Add check for malloc() error
      PDF: Ensure ToUnicode CMap name is unique

Behdad Esfahbod:
      [configure] Improve win32 detection
      [test/Makefile.am] Document why svg2png and pdf2png use LDADD
      [win32] Make win32-surface compile without win32-font
      [test] Add test case for bug #7965 to the get-path-extents test
      [test] Remove ft-text-vertical-layout-type1 from XFAIL
      [PS] Fix rotated image pattern emission by correcting setting the bbox
      [test] Remove text-rotate test from XFAIL as the bugs are fixed now
      [test] Fix syntax typo in text-rotate
      [Makefile.am] Include boilerplate/ in SUBDIRS
      [FreeType] Truely return unhinted advance width if metrics hinting is off
      [xlib/xcb] Check for same_screen in is_compatible
      [test] Add ref image for extend-reflect
      [cairo-surface] Do not err on CAIRO_EXTEND_PAD and CAIRO_EXTEND_REFLECT
      [PS] Update surface_pattern_supported() from PDF
      Support CAIRO_EXTEND_REFLECT on surface patterns
      [cairo-pattern] Fall back on cairo_surface_create_similar in _cairo_pattern_acquire_surface_for_surface
      [cairo-pattern] Correctly delegate device_transform so tests pass again
      [SVG] Use _cairo_pattern_acquire_surface instead of _cairo_surface_acquire_source_image
      [surface] Copy device_transform_inverse in _cairo_surface_clone_similar
      [test] Increase size of extend-reflect test to see that pattern repeats
      [PS/PDF] Accept CAIRO_EXTEND_REFLECT surface patterns natively
      [test] Update surface-pattern test to include transformations
      [test] Remove non-existing test extend-pad
      [PS] Fix surface patterns with transforms
      [test] Add a new, XFAIL, extend-pad test
      [TODO] Add various TODO items
      [SVG] Rename a local variable for clarity
      [SVG] Fix warnings
      [TODO] More TODO items
      [PS] Add note about possible need for fix.
      [Makefile.am] Remove ChangeLog.cache-* in distclean
      [test] Add tests that show xstep/ystep failures in PS/PDF backends
      [PS/PDF] Fix xstep/ystep values for CAIRO_EXTEND_NONE
      [test] Add ref images for new tests
      [cairo.h] Reorder function prototypes a bit for clarity
      [cairo.c] Reorder some function implementations for clarity
      [quartz] Remove comment syntax that is recognized by gtkdoc from regular comments
      Implement cairo_get_scaled_font()
      Slim-hidden cairo_scale()
      [doc] Add new APIs to cairo-sections.txt
      [paginated] Automatically issue a final cairo_show_page()
      [paginated] Also do an automatic show page if nothing ever drawn
      [boilerplate/test-paginated] Issue a show_page before writing buffer
      Revert the solid-pattern cache
      [TODO] Add/remove items
      [RELEASING] Add notifying desktop-devel-list
      [paginated] Also increase page number in copy_page
      [TODO] Add cairo_surface_copy_page()
      [xlib] Drop XrmFinalize() stuff.  That didn't ever exist in any public X server
      [test] Plug a leak in the test suite
      [test] Add leak-revealing path to rectilinear-stroke
      Fix leak in rectilinear stroking code
      [test] Add more valgrind suppressions
      [boilerplate] Add correct dependency on libcairo.la
      [test] Move .la dependencies around
      [PS/PDF] Mark CAIRO_EXTEND_PAD for surface patterns as natively supported
      [test] Support passing extra valgrind flags
      [NEWS] Fix typos
      [doc] Update list of header files to ignore
      [doc] Some documentation love
      Beautify cairo.h
      [doc] Docuemnt all symbols but cairo_filter_t and cairo_operator_t
      [doc] Update templates
      [NEWS] Add note about documentation improvements
      [test] Update list of refrerence images
      [ChangeLog.mk] Adapt to latest git-describe output format
      [Makefile.am] Check for ChangeLog sanity in release-publish
      [test] Include romedalen.png in dist, oops
      [RELEASING] Add note about ChangeLog sanity
      [configure.in] Increase version to 1.3.16 in preparation for release

Brian Ewins:
      [ATSUI] implement load_truetype_table

Carl Worth:
      Bump cairo version to 1.3.15 after making the 1.3.14 snapshot
      Add radial-gradient test case
      Rename radial gradient inner/outer to c1/c2
      Fix implementation of radial gradients for inner radius != 0
      Fix gradient walker to not reset needlessly
      SVG: Support CAIRO_EXTEND_NONE for radial gradients.
      Merge branch 'radial-gradient-fixes' into cairo
      Implement CAIRO_MUTEX_INIT with memcpy instead of pthread_mutex_init
      Cast away a const to quiet a compiler warning.
      Cast -1 values to unsigned to quiet the compiler.
      Update documentation for cairo_get_scaled_font and cairo_get_font_face
      Don't crash if backend->create_similar returns a nil surface
      Fix yet another backend (quartz) for the gradient renaming
      Add test of cairo_get_* after INVALID_RESTORE to nil-surface
      Fix INVALID_RESTORE case to avoid crashes
      Fix leak in pdiff lpyramid
      Add a couple of missing test cases to .gitignore
      Add even more XrmGetFileDatabase leaks to the valgrind suppressions file
      Augment cairo_test_init with cairo_test_fini to avoid leak
      Fix leak in pattern-getters test (missing cairo_pattern_destroy)
      More tightening of test cleanup to avoid valgrind complaints.
      Fix leak of an output stream in cairo_type1_font_destroy
      Add notes for 1.3.16

Emmanuel Pacaud:
      Set overflow to visible for symbols.

Jeff Muizelaar:
      Add two new test cases to degenerate-path test
      Add a new dashing test
      Add a comment about the point choice when capping degenerate paths
      Rename has_sub_path to has_initial_sub_path
      Fix several issues with dashed stroking code, particularly 'leaky-dash'
      Rename tmp to step_length because that is what it actually is.
      Use a closed interval when eliminating outliers from performance measurements

Jeff Smith:
      Change type of cairo_stroker_t's dash_on from int to cairo_bool_t
      Modify how _cairo_stroker_add_caps handles zero-length sub-paths
      Minor changes to shorten the stroking code
      Add or reword several comments in the stroking code
      Clean up some inconsistent spacing in the stroking code

Jinghua Luo:
      glitz: fix build error.

Jorn Baayen:
      [cairo-pattern] Cache surface for solid patterns

Vladimir Vukicevic:
      [quartz] Rename nquartz to quartz
      [quartz] rename NQUARTZ -> QUARTZ in defines
      [quartz] rename test override images from nquartz to quartz
      [quartz] Rename public function parameter from surf -> surface
      [quartz] Remove (disabled) support for rendering via AGL/CGGL
      [core] Add user_data and reference count getters to all objects
      [core] put back REF_COUNT_INVALID to be -1, fix finish
      [quartz] Bug 3939 - Fix Quartz backend endianness problem

_______________________________________________
cairo-announce mailing list
cairo-announce@cairographics.org
http://cairographics.org/cgi-bin/mailman/listinfo/cairo-announce
From daniel.amelang at gmail.com  Fri Mar  2 22:58:48 2007
From: daniel.amelang at gmail.com (Daniel Amelang)
Date: Fri Mar  2 22:58:57 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <20070302123407.08a060fa@ecoup>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
Message-ID: <a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>

On 3/2/07, Gauthier Quesnel <quesnel@lil.univ-littoral.fr> wrote:
> Le Wed, 28 Feb 2007 17:00:47 -0800,
> "Daniel Amelang" <daniel.amelang@gmail.com> a ?crit :
> > Having said all that, for drawing as simple as yours, I wouldn't
> > expect the need for any optimization. Would you care to share your
> > code with us? If you give us something that we can run, it makes it
> > easier to analyze where the performance problems are.
>
> Yep, my sources are GPL (require pygtk 2.10 and numpy):
> http://vle.univ-littoral.fr/gitweb?p=goo.git;a=summary

Thank you for making it so easy to help you :) This also really help
us get a feel for how cairo performs "in the wild".

First of all, when I ran your app, I didn't notice anything
particularly slow about it. Window resizing, hiding/showing layers and
changing opacity all completed in well under a second. What operation
were you doing that felt slow?

Regardless, I went ahead and profiled the app anyway just to get an
idea of what's going on (using `valgrind --tool=callgrind`) by forcing
a bunch of redraws and resizing. So, about 30% of the time is spend in
cairo_fill downwards. 19% of that is spent in
_cairo_bentley_ottmann_tessellate_polygon, which in your case is just
chomping away on those rectangles.

So, I think I remember Carl mentioning some idea he had for speeding
up rectangle rendering. Carl, do you see that helping here? These
rectangles are all integer coordinates and sizes, BTW. This should
match our existing "rectangles" perf case pretty closely.

Besides that, it is interesting to note that cairo spends about 10% of
the overall time in malloc and free combined. Also, 6% of the overall
time is spend in cairo_rectangle calls and downwards.

In the meantime, Gauthier, you can avoid a lot of this overhead by
doing that surface cache idea that I mentioned earlier. Of course,
if/when your data changes, or if/when you resize the drawing area,
you'll have to redraw the surfaces.

Hope that helps!

Dan
From bzbarsky at MIT.EDU  Fri Mar  2 23:06:43 2007
From: bzbarsky at MIT.EDU (Boris Zbarsky)
Date: Fri Mar  2 23:27:23 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
References: <20070227201153.02773785@portvle>	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
Message-ID: <45E91E83.8050608@mit.edu>

Daniel Amelang wrote:
> Besides that, it is interesting to note that cairo spends about 10% of
> the overall time in malloc and free combined.

I've noticed the same thing with Gecko profiles, often with the number being as 
high as 15-25%.

Are you generally interested in data of this sort?  If there's something I can 
do to help improve cairo performance, I'd love to help.

-Boris
From behdad at behdad.org  Sat Mar  3 08:12:05 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Sat Mar  3 08:12:01 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <45E91E83.8050608@mit.edu>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu>
Message-ID: <1172938325.3091.19.camel@behdad>

On Sat, 2007-03-03 at 02:06 -0500, Boris Zbarsky wrote:
> Daniel Amelang wrote:
> > Besides that, it is interesting to note that cairo spends about 10% of
> > the overall time in malloc and free combined.
> 
> I've noticed the same thing with Gecko profiles, often with the number being as 
> high as 15-25%.
> 
> Are you generally interested in data of this sort?  If there's something I can 
> do to help improve cairo performance, I'd love to help.

Definitely.  Pass 'em on.  Specifically, I'm really interested in a call
graph to malloc.  There's a lot we can do to drop those.

> -Boris

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From david at freetype.org  Sat Mar  3 10:22:34 2007
From: david at freetype.org (David Turner)
Date: Sat Mar  3 10:22:37 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>
	<1172888959.26264.1177484563@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>
Message-ID: <1172946154.614.1177548387@webmail.messagingengine.com>

Hi again,

I found the bug, it only affects the implementation of the toy font interface,
which is why I couldn't see it with my desktop (which uses Pango instead).

Simple profiling shows that all the slowdown comes from calling FontConfig
matching algorithm in each iteration, while the original code cached the
result correctly.

Basically, cairo_freetype_scaled_font_create_toy doesn't reference the parent
toy font_face, but instead a new freetype font face that is created from the
corresponding FontConfig pattern. As a consequence, the toy font face is
destroyed when the function exits.

This shouldn't happen; I'll provide a new patchset shortly that fixes this
issue.

Thanks a lot

- David


On Sat, 3 Mar 2007 04:23:33 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
> On Sat, 3 Mar 2007, David Turner wrote:
> 
> > no, this is not normal at all; I'm running my desktop on this patch and
> > haven't seen any regression in performance. Are you sure your merge happened
> > without conflicts ?
> 
> No, no conflicts. Only few 'fuzz'.
> 
> Except makefiles these are:
> 
> $ bzcat ../fix-freetype-usage-1.patchset.bz2 | patch -p1
> (...)
> patching file src/cairo-debug.c
> Hunk #1 succeeded at 66 with fuzz 2.
> (...)
> patching file src/cairoint.h
> Hunk #1 succeeded at 623 (offset 4 lines).
> Hunk #3 succeeded at 1214 (offset 2 lines).
> 
> Should I try any earlier cairo snapshot?
> 
> > the long story is that some of the intermediate commits in the patchset do
> > produce correct behaviour and very poor performance, but this is normally
> > fixed in later ones.
> >
> > In the event your merge didn't work correctly, you could be left in one of
> > these hideously slow cases. I've just checked the patchset file, and the
> > changes described there seem ok.
> >
> > Could you give more details about your test cases ? it may be interesting.
> 
> Seems that I am able to reproduce these on my simple cairo threads test
> case
> I used before to hunt previous problems. (attached)
> 
> Cairo-git:
> real    0m2.551s
> user    0m2.530s
> sys     0m0.020s
> 
> Cairo-git + fix-freetype-usage-1.patchset:
> real    0m12.956s
> user    0m12.950s
> sys     0m0.010s
> 
> Command used: time ./threads 1 10000 
> (one thread, 10K loops)
> 
> 
> Before I used two samples (against some external library that calls
> cairo) on two Linux machines. Slowdown with patch applied was:
> - between 2x (x86_64 dual) and 6x (i386) - first sample
> - between 6x (x86_64 dual) and 60x+ (i386) really! - another sample
> 
> I'm sure about these results, but if you find them unbelivable
> and cannot reproduce, I'll repeat tests from scratch to make it 200%
> sure...
> 
> 
> Thanks a lot,
> Jan
> 
> 
> 
> > On Sat, 3 Mar 2007 01:47:49 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
> >> On Wed, 28 Feb 2007, David Turner wrote:
> >>
> >>> Hello,
> >>>
> >>> here's the first version of my patches to fix Cairo's usage of FreeType with multiple
> >>> threads. It's rather big, so I'll summarize things here a little:
> >>
> >> Hi David,
> >>
> >> I tried your patches against the current git cairo (latest commit
> >> fed13e77e1de071ddaaf829aced10b02f6bc8c90).
> >>
> >> Is it expected that cairo with these patches runs *much* slower
> >> than without? I'm running simple test case and it seems to be
> >> 8+ times slower even in single thread.
> >>
> >> Is there anything special I should do (i.e. revert some already
> >> merged patches)?
> >>
> >> I'll try to figure out what exactly caused the slowdown, but any hints
> >> are apperciated...
> >>
> >> I have used default setup (./autogen.sh; make) and
> >> fontconfig 2.4.2, freetype 2.1.7 & 2.3.1
> 
>     _  _  _  _  _____________________________________________
>     | |_| |\ |  S L U P S K I             jslupski@juljas.net
>   |_| | | | \|                             http://juljas.net/
From daniel.amelang at gmail.com  Sat Mar  3 10:30:40 2007
From: daniel.amelang at gmail.com (Daniel Amelang)
Date: Sat Mar  3 10:30:46 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1172938325.3091.19.camel@behdad>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
Message-ID: <a65ae5c90703031030n2be84b1q464432efed98992f@mail.gmail.com>

On 3/3/07, Behdad Esfahbod <behdad@behdad.org> wrote:
> On Sat, 2007-03-03 at 02:06 -0500, Boris Zbarsky wrote:
> > Daniel Amelang wrote:
> > > Besides that, it is interesting to note that cairo spends about 10% of
> > > the overall time in malloc and free combined.
> >
> > I've noticed the same thing with Gecko profiles, often with the number being as
> > high as 15-25%.
> >
> > Are you generally interested in data of this sort?  If there's something I can
> > do to help improve cairo performance, I'd love to help.
>
> Definitely.  Pass 'em on.  Specifically, I'm really interested in a call
> graph to malloc.  There's a lot we can do to drop those.

Your wish is my command, Behdad. See the attached graph and tell me
if this is the type of thing you're looking for. I cropped away the
Python-related calls, which means that the numbers won't add up as
you'd expect, but you should get the idea.

Dan
-------------- next part --------------
A non-text attachment was scrubbed...
Name: goo_malloc_call_graph-cropped.png
Type: image/png
Size: 59679 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070303/1c3679f1/goo_malloc_call_graph-cropped-0001.png
From behdad at behdad.org  Sat Mar  3 13:13:20 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Sat Mar  3 13:13:18 2007
Subject: [cairo] Recommendations for 1.4.0
Message-ID: <1172956400.25990.31.camel@behdad>

Hi,

While updating docs for the 1.3.16 release yesterday I gathered the
following that I suggest we fix before 1.4.0:

  - cairo_text_path() currently does not set the current point.  It will
be implicitly set to the last point that an outline drew.  I recommend
making it set the current point explicitly like cairo_show_text() does.
That gives users the same convenience that cairo_show_text() does, that
is, that you can chain multiple calls to it and get text progress
naturally.  And document this.

  - Since _reference() and _destroy() functions just return on NULL,
make _get_reference_count() return 0 on NULL.

  - Cosmetic: Rename cairo-font.c to cairo-font-face.c.

  - Personal: In _cairo_path_append_to_context(), replace "!=" checks
with "<".  That is, to allow more cairo_path_data_t elements in the path
than needed.  I have requested this before:

http://lists.freedesktop.org/archives/cairo/2005-August/004673.html

I actually needed this in my cairotwisted pangocairo example:

http://svn.gnome.org/viewcvs/pango/trunk/examples/cairotwisted.c?view=markup

  - Make some of the test images smaller.  The 1.3.16 tarball is bigger
than 4MB, while 1.2.0 was just 2.6MB and 1.0 only 1.4MB.  The main
culprits seem to be extend-reflect and random-intersections reference
images.  Maybe even replace romedalen.png with something smaller.

  - Fix mutex initialization in win32, os2, and beos backends.  They are
out of synch with the actually mutexes declared, and that causes link
errors if not using pthread on win32.  I'm wondering if we should go for
the backup plan:

http://lists.freedesktop.org/archives/cairo/2007-February/009679.html


That's about it.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From hans at breuer.org  Sat Mar  3 13:46:47 2007
From: hans at breuer.org (Hans Breuer)
Date: Sat Mar  3 13:46:58 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <1172956400.25990.31.camel@behdad>
References: <1172956400.25990.31.camel@behdad>
Message-ID: <45E9ECC7.6070505@breuer.org>

On 03.03.2007 22:13, Behdad Esfahbod wrote:
> Hi,
> 
> While updating docs for the 1.3.16 release yesterday I gathered the
> following that I suggest we fix before 1.4.0:
> 
[...]
>   - Fix mutex initialization in win32, os2, and beos backends.  They are
> out of synch with the actually mutexes declared, and that causes link
> errors if not using pthread on win32.  I'm wondering if we should go for
> the backup plan:
> 
> http://lists.freedesktop.org/archives/cairo/2007-February/009679.html
> 
For win32 you can just apply the following patch.

Regards,
	Hans

-------- Hans "at" Breuer "dot" Org -----------
Tell me what you need, and I'll tell you how to
get along without it.                -- Dilbert
-------------- next part --------------
--- cairo-win32-surface.c.org	Sat Mar 03 05:14:56 2007
+++ cairo-win32-surface.c	Sat Mar 03 22:36:57 2007
@@ -1898,6 +1898,7 @@
 CRITICAL_SECTION cairo_toy_font_face_hash_table_mutex;
 CRITICAL_SECTION cairo_scaled_font_map_mutex;
 CRITICAL_SECTION cairo_ft_unscaled_font_map_mutex;
+CRITICAL_SECTION cairo_font_face_mutex;
 
 static int _cairo_win32_initialized = 0;
 
@@ -1910,6 +1911,7 @@
     InitializeCriticalSection (&cairo_toy_font_face_hash_table_mutex);
     InitializeCriticalSection (&cairo_scaled_font_map_mutex);
     InitializeCriticalSection (&cairo_ft_unscaled_font_map_mutex);
+    InitializeCriticalSection (&cairo_font_face_mutex);
 
     _cairo_win32_initialized = 1;
 }
@@ -1929,6 +1931,7 @@
     DeleteCriticalSection (&cairo_toy_font_face_hash_table_mutex);
     DeleteCriticalSection (&cairo_scaled_font_map_mutex);
     DeleteCriticalSection (&cairo_ft_unscaled_font_map_mutex);
+    DeleteCriticalSection (&cairo_font_face_mutex);
     break;
   }
   return TRUE;
From cairo-2007a at ryandesign.com  Sat Mar  3 17:15:33 2007
From: cairo-2007a at ryandesign.com (Ryan Schmidt)
Date: Sat Mar  3 17:15:51 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
Message-ID: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>

Hello.

Seeing how cairo 1.3.16 is a release candidate for 1.4.0, and it  
includes new quartz code, and I had problems building with quartz and  
atsui support before, I figured I'd try it again with 1.3.16 to see  
what happens, but unfortunately I seem to be having problems again.  
I'm running Mac OS X 10.4.8 on a PowerBook G4.


If I just --enable-atsui it complains that I haven't compiled with  
quartz support:

gcc -DHAVE_CONFIG_H -I. -I. -I.. -I. -I../pixman/src -I/usr/local/ 
graphviz-2.13/include/freetype2 -I/usr/local/graphviz-2.13/include -I/ 
usr/local/graphviz-2.13/include -I/usr/local/graphviz-2.13/include/ 
libpng12 -I/usr/X11R6/include -Wall -Wextra -Wsign-compare -Werror- 
implicit-function-declaration -Wpointer-arith -Wwrite-strings - 
Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations - 
Wnested-externs -Wpacked -Wswitch-enum -Wmissing-format-attribute - 
Wstrict-aliasing=2 -Winit-self -Wdeclaration-after-statement -Wold- 
style-definition -Wno-missing-field-initializers -Wno-unused- 
parameter -fno-strict-aliasing -I/usr/local/graphviz-2.13/include -I/ 
usr/X11R6/include -I/usr/local/graphviz-2.13/include -I/usr/X11R6/ 
include -MT cairo-atsui-font.lo -MD -MP -MF .deps/cairo-atsui- 
font.Tpo -c cairo-atsui-font.c  -fno-common -DPIC -o .libs/cairo- 
atsui-font.o
In file included from cairo-quartz-private.h:42,
                  from cairo-atsui-font.c:42:
./cairo-quartz.h:63:3: error: #error Cairo was not compiled with  
support for the quartz backend
cairo-atsui-font.c: In function 'CreateSizedCopyOfStyle':
cairo-atsui-font.c:213: warning: ISO C90 forbids mixed declarations  
and code
cairo-atsui-font.c: In function '_cairo_atsui_font_old_show_glyphs':
cairo-atsui-font.c:932: warning: unused variable 'surface'
make[3]: *** [cairo-atsui-font.lo] Error 1
make[2]: *** [all] Error 2
make[1]: *** [all-recursive] Error 1
make: *** [all] Error 2


If I just --enable-quartz it fails with undefined atsui symbols:

gcc -dynamiclib  -o .libs/libcairo.2.11.0.dylib  .libs/cairo.o .libs/ 
cairo-arc.o .libs/cairo-array.o .libs/cairo-base85-stream.o .libs/ 
cairo-bentley-ottmann.o .libs/cairo-cache.o .libs/cairo-clip.o .libs/ 
cairo-color.o .libs/cairo-debug.o .libs/cairo-deflate-stream.o .libs/ 
cairo-fixed.o .libs/cairo-font.o .libs/cairo-font-options.o .libs/ 
cairo-freelist.o .libs/cairo-gstate.o .libs/cairo-hash.o .libs/cairo- 
hull.o .libs/cairo-image-surface.o .libs/cairo-lzw.o .libs/cairo- 
matrix.o .libs/cairo-operator.o .libs/cairo-path.o .libs/cairo-path- 
bounds.o .libs/cairo-path-fill.o .libs/cairo-path-fixed.o .libs/cairo- 
path-stroke.o .libs/cairo-pen.o .libs/cairo-polygon.o .libs/cairo- 
rectangle.o .libs/cairo-region.o .libs/cairo-scaled-font.o .libs/ 
cairo-skiplist.o .libs/cairo-slope.o .libs/cairo-spline.o .libs/cairo- 
stroke-style.o .libs/cairo-surface.o .libs/cairo-surface- 
fallback.o .libs/cairo-traps.o .libs/cairo-pattern.o .libs/cairo- 
unicode.o .libs/cairo-output-stream.o .libs/cairo-wideint.o .libs/ 
cairo-meta-surface.o .libs/cairo-paginated-surface.o .libs/cairo- 
analysis-surface.o .libs/cairo-ft-font.o .libs/cairo-ps- 
surface.o .libs/cairo-pdf-surface.o .libs/cairo-png.o .libs/cairo-svg- 
surface.o .libs/cairo-cff-subset.o .libs/cairo-truetype- 
subset.o .libs/cairo-type1-fallback.o .libs/cairo-scaled-font- 
subsets.o .libs/cairo-type1-subset.o .libs/cairo-xlib-surface.o .libs/ 
cairo-xlib-screen.o .libs/cairo-quartz-surface.o  .libs/libcairo.lax/ 
libpixman.a/fbcompose.o .libs/libcairo.lax/libpixman.a/fbedge.o .libs/ 
libcairo.lax/libpixman.a/fbpict.o .libs/libcairo.lax/libpixman.a/ 
fbtrap.o .libs/libcairo.lax/libpixman.a/icblt.o .libs/libcairo.lax/ 
libpixman.a/icbltone.o .libs/libcairo.lax/libpixman.a/iccolor.o .libs/ 
libcairo.lax/libpixman.a/icformat.o .libs/libcairo.lax/libpixman.a/ 
icimage.o .libs/libcairo.lax/libpixman.a/icpixels.o .libs/ 
libcairo.lax/libpixman.a/icrect.o .libs/libcairo.lax/libpixman.a/ 
icstipple.o .libs/libcairo.lax/libpixman.a/ictransform.o .libs/ 
libcairo.lax/libpixman.a/ictrap.o .libs/libcairo.lax/libpixman.a/ 
ictri.o .libs/libcairo.lax/libpixman.a/icutil.o .libs/libcairo.lax/ 
libpixman.a/pixregion.o .libs/libcairo.lax/libpixman.a/renderedge.o    
-L/usr/local/graphviz-2.13/lib -L/usr/X11R6/lib /usr/local/ 
graphviz-2.13/lib/libfreetype.dylib /usr/local/graphviz-2.13/lib/ 
libz.dylib -lz /usr/local/graphviz-2.13/lib/libfontconfig.dylib /usr/ 
local/graphviz-2.13/lib/libexpat.dylib /usr/local/graphviz-2.13/lib/ 
libpng12.dylib -lXrender -lSM -lICE -lX11  -Wl,-framework - 
Wl,CoreServices -Wl,-framework -Wl,ApplicationServices -Wl,-framework  
-Wl,Carbon -install_name  /usr/local/graphviz-2.13/lib/libcairo. 
2.dylib -Wl,-compatibility_version -Wl,14 -Wl,-current_version -Wl,14.0
ld: Undefined symbols:
__cairo_atsui_scaled_font_get_atsu_font_id
__cairo_scaled_font_is_atsui
/usr/bin/libtool: internal link edit command failed
make[3]: *** [libcairo.la] Error 1
make[2]: *** [all] Error 2
make[1]: *** [all-recursive] Error 1
make: *** [all] Error 2


So it seems that --enable-quartz and --enable-atsui must always  
appear together, so why isn't there just a single switch (like -- 
enable-quartz-atsui -- similar to how some programs (like graphviz)  
have just --with-pangocairo, since pango and cairo work so closely  
together), or why doesn't configure at least complain loudly if I use  
one but not the other? Currently, configure seems to succeed, and  
then make takes a long time compiling stuff before it finally fails  
with some weird message, which just wastes my time.


Lastly, if I both --enable-quartz and --enable-atsui it fails with an  
error about conflicting types for 'Picture':

gcc -DHAVE_CONFIG_H -I. -I. -I.. -D_GNU_SOURCE -I. -I../pixman/src - 
I../src -I../src -I/usr/local/graphviz-2.13/include/freetype2 -I/usr/ 
local/graphviz-2.13/include -I/usr/local/graphviz-2.13/include -I/usr/ 
local/graphviz-2.13/include/libpng12 -I/usr/X11R6/include -Wall - 
Wextra -Wsign-compare -Werror-implicit-function-declaration -Wpointer- 
arith -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes - 
Wmissing-declarations -Wnested-externs -Wpacked -Wswitch-enum - 
Wmissing-format-attribute -Wstrict-aliasing=2 -Winit-self - 
Wdeclaration-after-statement -Wold-style-definition -Wno-missing- 
field-initializers -Wno-unused-parameter -fno-strict-aliasing -I/usr/ 
local/graphviz-2.13/include -I/usr/X11R6/include -I/usr/local/ 
graphviz-2.13/include -I/usr/X11R6/include -MT cairo-boilerplate.lo - 
MD -MP -MF .deps/cairo-boilerplate.Tpo -c cairo-boilerplate.c  -fno- 
common -DPIC -o .libs/cairo-boilerplate.o
In file included from /usr/X11R6/include/X11/extensions/Xrender.h:29,
                  from ../src/cairo-xlib-xrender.h:44,
                  from cairo-boilerplate.c:864:
/usr/X11R6/include/X11/extensions/render.h:31: error: conflicting  
types for 'Picture'
/System/Library/Frameworks/ApplicationServices.framework/Frameworks/ 
QD.framework/Headers/Quickdraw.h:309: error: previous declaration of  
'Picture' was here
In file included from /usr/X11R6/include/X11/Xlib.h:59,
                  from /usr/X11R6/include/X11/Xutil.h:55,
                  from /usr/X11R6/include/X11/extensions/Xrender.h:33,
                  from ../src/cairo-xlib-xrender.h:44,
                  from cairo-boilerplate.c:864:
/usr/X11R6/include/X11/X.h:108: error: conflicting types for 'Cursor'
/System/Library/Frameworks/ApplicationServices.framework/Frameworks/ 
QD.framework/Headers/Quickdraw.h:278: error: previous declaration of  
'Cursor' was here
make[2]: *** [cairo-boilerplate.lo] Error 1
make[1]: *** [all-recursive] Error 1
make: *** [all] Error 2


I realize these are experimental / unsupported backends, but I was  
hoping to at least be able to compile them.


From brian.ewins at gmail.com  Sat Mar  3 18:16:05 2007
From: brian.ewins at gmail.com (Baz)
Date: Sat Mar  3 18:16:09 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
Message-ID: <2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>

On 04/03/07, Ryan Schmidt <cairo-2007a@ryandesign.com> wrote:
> So it seems that --enable-quartz and --enable-atsui must always
> appear together, so why isn't there just a single switch (like --
> enable-quartz-atsui -- similar to how some programs (like graphviz)
> have just --with-pangocairo, since pango and cairo work so closely
> together), or why doesn't configure at least complain loudly if I use
> one but not the other? Currently, configure seems to succeed, and
> then make takes a long time compiling stuff before it finally fails
> with some weird message, which just wastes my time.

Good point. In the past the separation worked, I believe you could get
ft fonts rendering on quartz via glyph surfaces, atsui depended on
quartz, and nquartz depended on both. Renaming has made quartz and
atsui co-dependent.

I'd be happy enough with just reducing it to '--enable-quartz'. This does it:
diff --git a/configure.in b/configure.in
index f2657db..087e4c9 100644
--- a/configure.in
+++ b/configure.in
@@ -568,9 +568,9 @@ dnl
===========================================================================
 dnl This check should default to 'auto' once we have code to actually
 dnl check for the atsui font backend.

-CAIRO_BACKEND_ENABLE(atsui, ATSUI font, atsui, ATSUI_FONT, no, [
-  dnl There is no pkgconfig for atsui; lets do a header check
-  AC_CHECK_HEADER(Carbon/Carbon.h, , [use_atsui="no (Carbon not found)"])
+CAIRO_BACKEND_ENABLE(atsui, ATSUI font, atsui, ATSUI_FONT, auto, [
+  dnl Quartz requires and is required by atsui.
+  use_atsui=$use_quartz
 ])

 dnl ===========================================================================

(--enable-atsui on its own will now report that --enable-quartz is
required). Anyone object to this one? It seems uncontroversial, it
works the same as the --enable-win32-font flag.

> Lastly, if I both --enable-quartz and --enable-atsui it fails with an
> error about conflicting types for 'Picture':

I disabled xlib, xcb in my build to get rid of that. Currently I build with
'--enable-quartz --enable-atsui --disable-xlib --disable-ft
--disable-ps --disable-xcb'

IIRC disable ft isn't necessary (enabling atsui will disable it) and
ps was disabled because I have the wrong version of ghostscript and
was getting the test failures that result (I've gone to the trouble of
having the right version of gs in the past, but its just not there
right now)

For this one, should automake fail to enable quartz if xlib is
enabled? Or should --enable-quartz disable xlib?

Cheers,
Baz
From vladimir at pobox.com  Sat Mar  3 18:32:29 2007
From: vladimir at pobox.com (Vladimir Vukicevic)
Date: Sat Mar  3 18:32:25 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
Message-ID: <45EA2FBD.4080303@pobox.com>

Baz wrote:
> I disabled xlib, xcb in my build to get rid of that. Currently I build with
> '--enable-quartz --enable-atsui --disable-xlib --disable-ft
> --disable-ps --disable-xcb'
> 
> IIRC disable ft isn't necessary (enabling atsui will disable it) and
> ps was disabled because I have the wrong version of ghostscript and
> was getting the test failures that result (I've gone to the trouble of
> having the right version of gs in the past, but its just not there
> right now)
> 
> For this one, should automake fail to enable quartz if xlib is
> enabled? Or should --enable-quartz disable xlib?

Probably; I don't really know how to resolve the Picture conflict 
otherwise, and I'm not sure if there is any value in doing so -- a Cairo 
that supports xlib (perfectly valid on the Mac) will probably be used by 
a totally different class of apps than one that supports Quartz. 
However, the problem only comes up in cairo-boilerplate.c, which is one 
of the very few places (if not the only one?) where all the different 
backends touch.

Maybe the solution is to just split out cairo-boilerplate into multiple 
translation units, so that we don't run into this?  Building a Cairo on 
OSX that supports both xlib and quartz should be possible (though as I 
said before I don't think it's a high value thing).

    - Vlad
From brian.ewins at gmail.com  Sat Mar  3 19:08:34 2007
From: brian.ewins at gmail.com (Baz)
Date: Sat Mar  3 19:08:38 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <45EA2FBD.4080303@pobox.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
Message-ID: <2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>

On 04/03/07, Vladimir Vukicevic <vladimir@pobox.com> wrote:
> > For this one, should automake fail to enable quartz if xlib is
> > enabled? Or should --enable-quartz disable xlib?
>
> Probably; I don't really know how to resolve the Picture conflict
> otherwise, and I'm not sure if there is any value in doing so -- a Cairo
> that supports xlib (perfectly valid on the Mac) will probably be used by
> a totally different class of apps than one that supports Quartz.

Ok, I've just pushed the change to warn about xlib, since splitting
the boilerplate seemed to need more thought, ad the warning is useful
for now. So Ryan, the flags you need are:

--enable-quartz --disable-xlib

and autogen should be a little more helpful about telling you this.

Cheers,
Baz
From jeff at infidigm.net  Sat Mar  3 21:50:20 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Sat Mar  3 21:48:59 2007
Subject: [cairo] Compositing benchmarks
Message-ID: <20070304055020.GA9660@infidigm.net>

In my investigation into 'fixing' libpixman cairo's software compositing
code, I built a benchmarking suite for different software and hardware
compositing libraries.

In theory, it supports the following backend:
- cairo
- pixman (directly)
- cairo-glitz
- cairo-xlib
- glitz
- liboil
- evas_core (compositing routines from enlightenment)
- intel performance primitives

The x and glitz backends might be a little suspect, as I wasn't
completely sure what I was doing.

Here are some results:
The benchmark is compositing solid square images of exponentially
increasing size 100 times in a row. The color of the images are src color
(0xa4045090), dest color (0xe0e01000) (some backends optimize for alpha
of 255 or 0). The benchmarks were performed on a Intel(R) Xeon(TM) CPU
2.80GHz.

The most interesting:
argb32 OVER argb32
(./test -b oil,pixman,cairo,ipp,evas_core -o OVER --no-mask -s 33 -f ARGB32)
 - http://people.freedesktop.org/~jrmuizel/composite-bench/over-comparison-linear.png
 - liboil is the clear winner here. It looks like liboil is memory bound
   because there is a sharp drop off where the image's would no longer
   fit in cache. Even when we are out of cache liboil is about 4x faster
   than cairo. However, the liboil backend that was measured took
   advantage of the fact that it could treat the images as a single
   contiguous row in memory.

 - http://people.freedesktop.org/~jrmuizel/composite-bench/over-no-oil-cheat-comparison.png
 - This shows the same data as above, except the 'cheat' in liboil has
   been disabled. It looks pretty much how one would expect. The
   zig-zags are likely due to cache-size/image-size interactions.

argb32 ADD argb32
(./test -b oil,pixman,cairo,ipp,evas_core -o ADD --no-mask -s 33 -f ARGB32)
 - http://people.freedesktop.org/~jrmuizel/composite-bench/add-comparison-linear.png
 - liboil doesn't do nearly as well here. pixman matches it pretty
   closely. ipp takes a small lead as the image sizes get large.
   

I have put up a preview version of the source code at:
http://people.freedesktop.org/~jrmuizel/composite-bench/composite-bench-preview.tar.bz2
It isn't very clean, or usable so don't expect much.

In addition, there is a mostly self contained x86 binary at:
http://people.freedesktop.org/~jrmuizel/composite-bench/comp-bench.tar.bz2
This should make it easier for people wanting to try it out on different
machines. Note, this binary does not link to the ipp libraries because
of distribution issues.

Currently, the results are stored in a sqlite database and all of the
graphing/report generation is done using python and matlab (the binary
tarball does not contain the report generation source) I realize this is
less than ideal and I'll look into making it easier for people to
generate graphs without matlab. For now, it might be easiest if people
just made their results db (results/data.store) available, and I can
produce graphs on Monday.

-Jeff
From daveryeo at telus.net  Sat Mar  3 22:45:34 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Sat Mar  3 22:45:09 2007
Subject: [cairo] Recommendations for 1.4.0
Message-ID: <20070304064449.D1MH4GS7PQ@priv-edtnaa05.telusplanet.net>

On Sat, 03 Mar 2007 16:13:20 -0500, Behdad Esfahbod wrote:

>  - Fix mutex initialization in win32, os2, and beos backends.  They are
>out of synch with the actually mutexes declared, and that causes link
>errors if not using pthread on win32.  I'm wondering if we should go for
>the backup plan:
>
>http://lists.freedesktop.org/archives/cairo/2007-February/009679.html

Ok, I tried compiling and doing a make check on 1.3.16. First problem
is that in test/makefile.am we  need this patch

--- Makefile.am.bak     Fri Mar  2 21:04:02 2007
+++ Makefile.am Sat Mar  3 22:24:54 2007
@@ -465,7 +465,7 @@
 LDADD += -lpthread
 endif

-SUPPORT_PROGS += imagediff png-flatten
+SUPPORT_PROGS += imagediff$(EXEEXT) png-flatten$(EXEEXT)

 if CAIRO_CAN_TEST_PDF_SURFACE
 SUPPORT_PROGS += pdf2png

please apply. Actually looking at above pdf2png should also have
$(EXEEXT) added.

Anyways make check then ends with this
f:/usr/bin/sh.exe ../libtool --tag=CC --mode=link gcc.exe  -g -O2   -o
imagediff.exe  imagediff.o libcairotest.la -lpthread -lm
gcc.exe    -g    -O2    -o    imagediff.exe    imagediff.o       
./.libs/cairotest.a    -L/usr/local/lib   
/usr/src/cairo-1.3.16/src/.libs/cairo.a   
/usr/local/lib/libfontconfig_dll.a    /usr/local/lib/libfreetype_dll.a 
  /usr/local/lib/expat.a    /usr/local/lib/libpng12_dll.a    -lz   
-lpthread    -lm       -L/usr/local/lib -L/usr/local/lib
cairo-font.c:96
(/usr/src/cairo-1.3.16/src/.libs/cairo.a(cairo-font.o)): Undefined
symbol _cairo_font_face_mutex referenced from text segment
cairo-font.c:104
(/usr/src/cairo-1.3.16/src/.libs/cairo.a(cairo-font.o)): Undefined
symbol _cairo_font_face_mutex referenced from text segment
...
cairo-font.c:0 (/usr/src/cairo-1.3.16/src/.libs/cairo.a(cairo-font.o)):
More undefined symbol _cairo_font_face_mutex refs follow
make[3]: *** [imagediff.exe] Error 1

which I take is the mutex problem referred above
Dave
ps also something needs to be done about pthread on OS/2, I usually
edit config.h to comment out
#define HAVE_PTHREAD_H 1
in config.h
A better fix would be along the lines of win32 where you can have or
not have pthreads. Or perhaps a configure option.
pps also here configure has to be called with --enable-os2
--disable-xlib, not a big deal but xlib needs an older libc (EMX) and
is not compatible with the newer libc (klibc).

From cworth at cworth.org  Sat Mar  3 22:52:19 2007
From: cworth at cworth.org (Carl Worth)
Date: Sat Mar  3 22:59:11 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <45E9ECC7.6070505@breuer.org>
References: <1172956400.25990.31.camel@behdad>
	<45E9ECC7.6070505@breuer.org>
Message-ID: <874pp1lcv0.wl%cworth@cworth.org>

On Sat, 03 Mar 2007 22:46:47 +0100, Hans Breuer wrote:
> > http://lists.freedesktop.org/archives/cairo/2007-February/009679.html
> >
> For win32 you can just apply the following patch.

Thanks. I've done that now, (and sorry we missed this patch which had
been offered between 1.3.14 and 1.3.16---yes, we're that lame).

If any kind soul wants to help us avoid exposing our inadequacies as
often, please refer to the URL above and implement Behdad's good
proposal.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070303/2f967ae1/attachment.pgp
From mathias.hasselmann at gmx.de  Sun Mar  4 01:18:43 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Sun Mar  4 01:18:54 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
Message-ID: <1172999923.17604.3.camel@dali>

I am trying to implement Behad's suggestions, but I consider calling
CAIRO_MUTEX_INITIALIZE everywhere as overkill, considering that

a) DllMain exists
b) gcc supports marking functions as runtime initializers/finalizers
(something long with __ini__ and __fini__ sections/attributes - dunno
exactly: have to read gcc's manual again).

Ciao,
Mathias

From lu_zero at gentoo.org  Sun Mar  4 01:18:09 2007
From: lu_zero at gentoo.org (Luca Barbato)
Date: Sun Mar  4 01:23:40 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <1172956400.25990.31.camel@behdad>
References: <1172956400.25990.31.camel@behdad>
Message-ID: <45EA8ED1.7010302@gentoo.org>

Behdad Esfahbod wrote:
> Hi,
> 
> While updating docs for the 1.3.16 release yesterday I gathered the
> following that I suggest we fix before 1.4.0:
> 

Could be possible adding my VMX/Altivec bits?

lu

-- 

Luca Barbato

Gentoo/linux Gentoo/PPC
http://dev.gentoo.org/~lu_zero

From mathias.hasselmann at gmx.de  Sun Mar  4 03:13:41 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Sun Mar  4 03:13:51 2007
Subject: [cairo] Building pdiff fails for builddir != srcdir
Message-ID: <1173006821.17604.5.camel@dali>

Building pdiff fails for builddir != srcdir. Fix is trivial:

diff --git a/test/pdiff/Makefile.am b/test/pdiff/Makefile.am
index 0a53ce0..89856b8 100644
--- a/test/pdiff/Makefile.am
+++ b/test/pdiff/Makefile.am
@@ -12,5 +12,5 @@ perceptualdiff_SOURCES =      \
        args.h                  \
        perceptualdiff.c
 
-INCLUDES = -I$(top_srcdir)/src $(CAIRO_CFLAGS)
+INCLUDES = -I$(top_srcdir)/src -I$(top_builddir)/src $(CAIRO_CFLAGS)
 LDADD = libpdiff.la $(top_builddir)/src/libcairo.la


From tml at iki.fi  Sun Mar  4 03:15:12 2007
From: tml at iki.fi (Tor Lillqvist)
Date: Sun Mar  4 03:15:18 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <1172999923.17604.3.camel@dali>
References: <1172999923.17604.3.camel@dali>
Message-ID: <17898.43584.471000.26325@gargle.gargle.HOWL>

Mathias Hasselmann writes:
 > a) DllMain exists

As the docs say, "There are serious limits on what you can do in a DLL
entry point. To provide more complex initialization, create an
initialization routine for the DLL." But just calling (a function that
calls) InitializeCriticalSection() is no problem at all.

But what about people who build a static cairo library, and perhaps
link that into a DLL which already has its own DllMain()...?

 > b) gcc supports marking functions as runtime initializers/finalizers
 > (something long with __ini__ and __fini__ sections/attributes - dunno
 > exactly: have to read gcc's manual again).

cairo can be built with MSVC as well as gcc on Win32. And are you sure
those aren't ELF features, not gcc (or GNU linker) features?

--tml
From mathias.hasselmann at gmx.de  Sun Mar  4 06:44:34 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Sun Mar  4 06:44:51 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <17898.43584.471000.26325@gargle.gargle.HOWL>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
Message-ID: <1173019474.17604.17.camel@dali>

Ok, so here there is a first patch. Followed the path of
CAIRO_MUTEX_INITIALIZE() in every potential entry point. Only
difference: CAIRO_MUTEX_INITIALIZE() also invokes code on pthread
platforms as I wanted to keep handling of CAIRO_MUTEX_DECLARE simple. 
If that minimal performance penalty is not acceptable, I can change
that.

Compile-tested the changes with following feature sets:

- Ubuntu 6.10:

#define CAIRO_HAS_SVG_SURFACE 1
#define CAIRO_HAS_PDF_SURFACE 1
#define CAIRO_HAS_PS_SURFACE 1
#define CAIRO_HAS_FT_FONT 1
#define CAIRO_HAS_DIRECTFB_SURFACE 1
#define CAIRO_HAS_GLITZ_SURFACE 1
#define CAIRO_HAS_PNG_FUNCTIONS 1
#define CAIRO_HAS_XLIB_XRENDER_SURFACE 1
#define CAIRO_HAS_XLIB_SURFACE 1

- Windows (cross-compiled using mingw32):

#define CAIRO_HAS_SVG_SURFACE 1
#define CAIRO_HAS_PDF_SURFACE 1
#define CAIRO_HAS_PS_SURFACE 1
#define CAIRO_HAS_FT_FONT 1
#define CAIRO_HAS_PNG_FUNCTIONS 1
#define CAIRO_HAS_WIN32_FONT 1
#define CAIRO_HAS_WIN32_SURFACE 1

- OSX 10.3

#define CAIRO_HAS_ATSUI_FONT 1
#define CAIRO_HAS_SVG_SURFACE 1
#define CAIRO_HAS_PDF_SURFACE 1
#define CAIRO_HAS_PS_SURFACE 1
#define CAIRO_HAS_FT_FONT 1
#define CAIRO_HAS_PNG_FUNCTIONS 1
#define CAIRO_HAS_QUARTZ_SURFACE 1


Not tested: XCB, OS/2, BeOS
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cairo-mutex-private.diff
Type: text/x-patch
Size: 42305 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070304/b0858062/cairo-mutex-private-0001.bin
From david at freetype.org  Sun Mar  4 12:07:21 2007
From: david at freetype.org (David Turner)
Date: Sun Mar  4 12:07:29 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <1172946154.614.1177548387@webmail.messagingengine.com>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>
	<1172888959.26264.1177484563@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>
	<1172946154.614.1177548387@webmail.messagingengine.com>
Message-ID: <1173038841.28494.1177656165@webmail.messagingengine.com>

Hello,

here's a second version of my patchset that fixes the bug described early
(incorrect behaviour of the FreeType-backed implementation of the toy font
interface). It needed a few tricky internal changes, but all sems good know.

  http://david.freetype.org/cairo/fix-freetype-usage-2.patchset

note that it was generated against a recent clone of the Cairo git repository,
you should *not* apply the first patchset before this one.

All test cases pass, except the ones that already failed with the original
sources.

As usual, all comments are welcomed :-)

- David



On Sat, 03 Mar 2007 19:22:34 +0100, "David Turner" <david@freetype.org> said:
> Hi again,
> 
> I found the bug, it only affects the implementation of the toy font
> interface,
> which is why I couldn't see it with my desktop (which uses Pango
> instead).
> 
> Simple profiling shows that all the slowdown comes from calling
> FontConfig
> matching algorithm in each iteration, while the original code cached the
> result correctly.
> 
> Basically, cairo_freetype_scaled_font_create_toy doesn't reference the
> parent
> toy font_face, but instead a new freetype font face that is created from
> the
> corresponding FontConfig pattern. As a consequence, the toy font face is
> destroyed when the function exits.
> 
> This shouldn't happen; I'll provide a new patchset shortly that fixes
> this
> issue.
> 
> Thanks a lot
> 
> - David
> 
> 
> On Sat, 3 Mar 2007 04:23:33 +0100 (CET), "Jan Slupski"
> <jslupski@juljas.net> said:
> > On Sat, 3 Mar 2007, David Turner wrote:
> > 
> > > no, this is not normal at all; I'm running my desktop on this patch and
> > > haven't seen any regression in performance. Are you sure your merge happened
> > > without conflicts ?
> > 
> > No, no conflicts. Only few 'fuzz'.
> > 
> > Except makefiles these are:
> > 
> > $ bzcat ../fix-freetype-usage-1.patchset.bz2 | patch -p1
> > (...)
> > patching file src/cairo-debug.c
> > Hunk #1 succeeded at 66 with fuzz 2.
> > (...)
> > patching file src/cairoint.h
> > Hunk #1 succeeded at 623 (offset 4 lines).
> > Hunk #3 succeeded at 1214 (offset 2 lines).
> > 
> > Should I try any earlier cairo snapshot?
> > 
> > > the long story is that some of the intermediate commits in the patchset do
> > > produce correct behaviour and very poor performance, but this is normally
> > > fixed in later ones.
> > >
> > > In the event your merge didn't work correctly, you could be left in one of
> > > these hideously slow cases. I've just checked the patchset file, and the
> > > changes described there seem ok.
> > >
> > > Could you give more details about your test cases ? it may be interesting.
> > 
> > Seems that I am able to reproduce these on my simple cairo threads test
> > case
> > I used before to hunt previous problems. (attached)
> > 
> > Cairo-git:
> > real    0m2.551s
> > user    0m2.530s
> > sys     0m0.020s
> > 
> > Cairo-git + fix-freetype-usage-1.patchset:
> > real    0m12.956s
> > user    0m12.950s
> > sys     0m0.010s
> > 
> > Command used: time ./threads 1 10000 
> > (one thread, 10K loops)
> > 
> > 
> > Before I used two samples (against some external library that calls
> > cairo) on two Linux machines. Slowdown with patch applied was:
> > - between 2x (x86_64 dual) and 6x (i386) - first sample
> > - between 6x (x86_64 dual) and 60x+ (i386) really! - another sample
> > 
> > I'm sure about these results, but if you find them unbelivable
> > and cannot reproduce, I'll repeat tests from scratch to make it 200%
> > sure...
> > 
> > 
> > Thanks a lot,
> > Jan
> > 
> > 
> > 
> > > On Sat, 3 Mar 2007 01:47:49 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
> > >> On Wed, 28 Feb 2007, David Turner wrote:
> > >>
> > >>> Hello,
> > >>>
> > >>> here's the first version of my patches to fix Cairo's usage of FreeType with multiple
> > >>> threads. It's rather big, so I'll summarize things here a little:
> > >>
> > >> Hi David,
> > >>
> > >> I tried your patches against the current git cairo (latest commit
> > >> fed13e77e1de071ddaaf829aced10b02f6bc8c90).
> > >>
> > >> Is it expected that cairo with these patches runs *much* slower
> > >> than without? I'm running simple test case and it seems to be
> > >> 8+ times slower even in single thread.
> > >>
> > >> Is there anything special I should do (i.e. revert some already
> > >> merged patches)?
> > >>
> > >> I'll try to figure out what exactly caused the slowdown, but any hints
> > >> are apperciated...
> > >>
> > >> I have used default setup (./autogen.sh; make) and
> > >> fontconfig 2.4.2, freetype 2.1.7 & 2.3.1
> > 
> >     _  _  _  _  _____________________________________________
> >     | |_| |\ |  S L U P S K I             jslupski@juljas.net
> >   |_| | | | \|                             http://juljas.net/
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
From behdad at behdad.org  Sun Mar  4 13:32:06 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Sun Mar  4 13:32:04 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <1173019474.17604.17.camel@dali>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
	<1173019474.17604.17.camel@dali>
Message-ID: <1173043926.9109.10.camel@behdad>

On Sun, 2007-03-04 at 09:44 -0500, Mathias Hasselmann wrote:
> Ok, so here there is a first patch. Followed the path of
> CAIRO_MUTEX_INITIALIZE() in every potential entry point. Only
> difference: CAIRO_MUTEX_INITIALIZE() also invokes code on pthread
> platforms as I wanted to keep handling of CAIRO_MUTEX_DECLARE simple. 
> If that minimal performance penalty is not acceptable, I can change
> that. 

Thanks Matthias.  I didn't completely read your patch, but at a glance
it looked it.  Just:

  - Why does it touch cairo-boilerplate.c?  Please break changes into
minimal patches.  That helps debugging later.

  - Yesterday I had an idea: instead of touching all backends, we can
call CAIRO_MUTEX_INITIALIZE() in these:

	_cairo_font_face_init
	_cairo_surface_init
	_cairo_pattern_init

This should be enough.

And I didn't get why you had to make it call anything on pthread.  If
there's no need, lets make it a nop.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Sun Mar  4 13:36:50 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Sun Mar  4 13:36:49 2007
Subject: [cairo] Building pdiff fails for builddir != srcdir
In-Reply-To: <1173006821.17604.5.camel@dali>
References: <1173006821.17604.5.camel@dali>
Message-ID: <1173044210.9109.12.camel@behdad>

On Sun, 2007-03-04 at 06:13 -0500, Mathias Hasselmann wrote:
> 
> Building pdiff fails for builddir != srcdir. Fix is trivial:
> 
> diff --git a/test/pdiff/Makefile.am b/test/pdiff/Makefile.am
> index 0a53ce0..89856b8 100644
> --- a/test/pdiff/Makefile.am
> +++ b/test/pdiff/Makefile.am
> @@ -12,5 +12,5 @@ perceptualdiff_SOURCES =      \
>         args.h                  \
>         perceptualdiff.c
>  
> -INCLUDES = -I$(top_srcdir)/src $(CAIRO_CFLAGS)
> +INCLUDES = -I$(top_srcdir)/src -I$(top_builddir)/src $(CAIRO_CFLAGS)
>  LDADD = libpdiff.la $(top_builddir)/src/libcairo.la

Ok, this is a bit "make" dependent, but makes sense.  I'll commit.


-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From daveryeo at telus.net  Sun Mar  4 14:34:30 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Sun Mar  4 14:33:57 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
Message-ID: <20070304223344.69XK2JL9VS@priv-edtnaa05.telusplanet.net>

On Sun, 04 Mar 2007 15:44:34 +0100, Mathias Hasselmann wrote:

>Ok, so here there is a first patch. Followed the path of
>CAIRO_MUTEX_INITIALIZE() in every potential entry point. Only
>difference: CAIRO_MUTEX_INITIALIZE() also invokes code on pthread
>platforms as I wanted to keep handling of CAIRO_MUTEX_DECLARE simple. 
>If that minimal performance penalty is not acceptable, I can change
>that.
>
>Compile-tested the changes with following feature sets:
>
>
>Not tested: XCB, OS/2, BeOS
>

Quickly tested on OS/2 with
#define CAIRO_HAS_SVG_SURFACE 1
#define CAIRO_HAS_PDF_SURFACE 1
#define CAIRO_HAS_PS_SURFACE 1
#define CAIRO_HAS_FT_FONT 1
#define CAIRO_HAS_PNG_FUNCTIONS 1
#define CAIRO_HAS_OS2_SURFACE 1

and got these errors
 gcc.exe -Zdll .libs/cairoDi.dll.def   .libs/cairo.o .libs/cairo-arc.o .libs/cairo-array.o .libs/cairo-base85-stream.o .libs/cairo-bentley-ottmann.o .libs/cairo-cache.o .libs/cairo-clip.o .libs/cairo-color.o .libs/cairo-debug.o .libs/cairo-deflate-stream.o .libs/cairo-fixed.o .libs/cairo-font.o .libs/cairo-font-options.o .libs/cairo-freelist.o .libs/cairo-gstate.o .libs/cairo-hash.o .libs/cairo-hull.o .libs/cairo-image-surface.o .libs/cairo-lzw.o .libs/cairo-matrix.o .libs/cairo-mutex.o .libs/cairo-operator.o .libs/cairo-path.o .libs/cairo-path-bounds.o .libs/cairo-path-fill.o .libs/cairo-path-fixed.o .libs/cairo-path-stroke.o .libs/cairo-pen.o .libs/cairo-polygon.o .libs/cairo-rectangle.o .libs/cairo-region.o .libs/cairo-scaled-font.o .libs/cairo-skiplist.o .libs/cairo-slope.o .libs/cairo-spline.o .libs/cairo-stroke-style.o .libs/cairo-surface.o .libs/cairo-surface-fallback.o .libs/cairo-traps.o .libs/cairo-pattern.o .libs/cairo-unicode.o .libs/cairo-output-stream.o .libs/cairo-wideint.o .libs/cairo-meta-su
rface.o .libs/cairo-paginated-surface.o .libs/cairo-analysis-surface.o .libs/cairo-ft-font.o .libs/cairo-ps-surface.o .libs/cairo-pdf-surface.o .libs/cairo-png.o .libs/cairo-svg-surface.o .libs/cairo-cff-subset.o .libs/cairo-truetype-subset.o .libs/cairo-type1-fallback.o .libs/cairo-scaled-font-subsets.o .libs/cairo-type1-subset.o .libs/cairo-os2-surface.o .libs/libcairo.lax/libpixman_s.a/fbcompose.o  .libs/libcairo.lax/libpixman_s.a/fbedge.o  .libs/libcairo.lax/libpixman_s.a/fbpict.o  .libs/libcairo.lax/libpixman_s.a/fbtrap.o  .libs/libcairo.lax/libpixman_s.a/icblt.o  .
libs/libcairo.lax/libpixman_s.a/icbltone.o  .libs/libcairo.lax/libpixman_s.a/iccolor.o  .libs/libcairo.lax/libpixman_s.a/icformat.o  .libs/libcairo.lax/libpixman_s.a/icimage.o  .libs/libcairo.lax/libpixman_s.a/icpixels.o  .libs/libcairo.lax/libpixman_s.a/icrect.o  .libs/libcairo.lax/libpixman_s.a/icstipple.o  .libs/libcairo.lax/libpixman_s.a/ictransform.o  .libs/libcairo.lax/libpixman_s.a/ictrap.o  .libs/libcairo.lax/libpixman_s.a/ictri.o  .libs/libcairo.lax/libpixman_s.a/icutil.o  .libs/libcairo.lax/libpixman_s.a/pixregion.o  .libs/libcairo.lax/libpixman_s.a/renderedge.o    -L/usr/local/lib /usr/local/lib/libfreetype_dll.a /usr/local/lib/libfontconfig_dll.a /usr/local/lib/libpng12_dll.a -lz    -o .libs/cairoDi.dll
I:/usr/i386-pc-os2-emx/bin/ld.exe: symbol `_cairo_scaled_font_map_mutex' defined more than once in .libs/cairo-os2-surface.o
make[2]: *** [libcairo.la] Error 1

 gcc.exe -Zdll .libs/cairoDi.dll.def   .libs/cairo.o .libs/cairo-arc.o .libs/cairo-array.o .libs/cairo-base85-stream.o .libs/cairo-bentley-ottmann.o .libs/cairo-cache.o .libs/cairo-clip.o .libs/cairo-color.o .libs/cairo-debug.o .libs/cairo-deflate-stream.o .libs/cairo-fixed.o .libs/cairo-font.o .libs/cairo-font-options.o .libs/cairo-freelist.o .libs/cairo-gstate.o .libs/cairo-hash.o .libs/cairo-hull.o .libs/cairo-image-surface.o .libs/cairo-lzw.o .libs/cairo-matrix.o .libs/cairo-mutex.o .libs/cairo-operator.o .libs/cairo-path.o .libs/cairo-path-bounds.o .libs/cairo-path-fill.o .libs/cairo-path-fixed.o .libs/cairo-path-stroke.o .libs/cairo-pen.o .libs/cairo-polygon.o .libs/cairo-rectangle.o .libs/cairo-region.o .libs/cairo-scaled-font.o .libs/cairo-skiplist.o .libs/cairo-slope.o .libs/cairo-spline.o .libs/cairo-stroke-style.o .libs/cairo-surface.o .libs/cairo-surface-fallback.o .libs/cairo-traps.o .libs/cairo-pattern.o .libs/cairo-unicode.o .libs/cairo-output-stream.o .libs/cairo-wideint.o .libs/cairo-meta-su
rface.o .libs/cairo-paginated-surface.o .libs/cairo-analysis-surface.o .libs/cairo-ft-font.o .libs/cairo-ps-surface.o .libs/cairo-pdf-surface.o .libs/cairo-png.o .libs/cairo-svg-surface.o .libs/cairo-cff-subset.o .libs/cairo-truetype-subset.o .libs/cairo-type1-fallback.o .libs/cairo-scaled-font-subsets.o .libs/cairo-type1-subset.o .libs/cairo-os2-surface.o .libs/libcairo.lax/libpixman_s.a/fbcompose.o  .libs/libcairo.lax/libpixman_s.a/fbedge.o  .libs/libcairo.lax/libpixman_s.a/fbpict.o  .libs/libcairo.lax/libpixman_s.a/fbtrap.o  .libs/libcairo.lax/libpixman_s.a/icblt.o  .
libs/libcairo.lax/libpixman_s.a/icbltone.o  .libs/libcairo.lax/libpixman_s.a/iccolor.o  .libs/libcairo.lax/libpixman_s.a/icformat.o  .libs/libcairo.lax/libpixman_s.a/icimage.o  .libs/libcairo.lax/libpixman_s.a/icpixels.o  .libs/libcairo.lax/libpixman_s.a/icrect.o  .libs/libcairo.lax/libpixman_s.a/icstipple.o  .libs/libcairo.lax/libpixman_s.a/ictransform.o  .libs/libcairo.lax/libpixman_s.a/ictrap.o  .libs/libcairo.lax/libpixman_s.a/ictri.o  .libs/libcairo.lax/libpixman_s.a/icutil.o  .libs/libcairo.lax/libpixman_s.a/pixregion.o  .libs/libcairo.lax/libpixman_s.a/renderedge.o    -L/usr/local/lib /usr/local/lib/libfreetype_dll.a /usr/local/lib/libfontconfig_dll.a /usr/local/lib/libpng12_dll.a -lz    -o .libs/cairoDi.dll
I:/usr/i386-pc-os2-emx/bin/ld.exe: symbol `_cairo_ft_unscaled_font_map_mutex' defined more than once in .libs/cairo-os2-surface.o
make[2]: *** [libcairo.la] Error 1

I got the compile to finish by removing these from cairo-os2-surface.c (see attached diff).
Not sure if this is good way to do this or not
Dave

-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/octet-stream
Size: 704 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070304/671f9ee7/attachment.obj
From jslupski at juljas.net  Sun Mar  4 19:56:05 2007
From: jslupski at juljas.net (Jan Slupski)
Date: Sun Mar  4 19:56:09 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <1173038841.28494.1177656165@webmail.messagingengine.com>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>  
	<Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>  
	<1172888959.26264.1177484563@webmail.messagingengine.com>  
	<Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>  
	<1172946154.614.1177548387@webmail.messagingengine.com>
	<1173038841.28494.1177656165@webmail.messagingengine.com>
Message-ID: <Pine.BSO.4.62.0703050420550.23048@tydraniu.sfires.net>

On Sun, 4 Mar 2007, David Turner wrote:

> Hello,
>
> here's a second version of my patchset that fixes the bug described early
> (incorrect behaviour of the FreeType-backed implementation of the toy font
> interface). It needed a few tricky internal changes, but all sems good know.
>
>  http://david.freetype.org/cairo/fix-freetype-usage-2.patchset
>
> note that it was generated against a recent clone of the Cairo git repository,
> you should *not* apply the first patchset before this one.
>
> All test cases pass, except the ones that already failed with the original
> sources.
>
> As usual, all comments are welcomed :-)


Hi David,

Thanks a lot for a patch. It helped a lot.
I can report that 1.3.16 with this patch is often quicker that 1.2.6.

Unfortunately I just hit another problem.
It seems that at certain conditions I hit endless loop
in _cairo_mru_list_remove_select function.

This happens when 'node' that is 'first' element is removed.


I've added some debug code (_cairo_mru_list_remove_select.c)

Here is sample output (when LOOP_WORKAROUND unset) - endless.log
When I switch LOOP_WORKAROUND on I have correct results - workaround.log

Let me know if there is anything else I can provide you with

Jan


    _  _  _  _  _____________________________________________
    | |_| |\ |  S L U P S K I             jslupski@juljas.net
  |_| | | | \|                             http://juljas.net/
-------------- next part --------------
/* destroy all free nodes corresponding a to given selection */
static void
_cairo_mru_list_remove_select (cairo_mru_list_t        *list,
                               cairo_mru_equal_func_t   equal_func,
                               void                    *equal_key)
{
    cairo_mru_t  *first, *node;

    first = list->free_nodes;
    printf("first %p\n", first);
    if (first != NULL) {
	node = first;
	do
	{
	    cairo_mru_t  *node_next = node->next;

	    printf("node: %p next: %p (first is %p)\n", node, node_next, first);

	    if ( (*equal_func) (node, (cairo_mru_t*)equal_key) ) {
		printf("remove %p\n", node);
		_cairo_mru_remove (&list->free_nodes, node);
		list->num_nodes--;
		_cairo_mru_list_free_node (list, node);
		if(getenv("LOOP_WORKAROUND") && node == first ) {
		    printf("Oops removed first!\n");
		    if(list->free_nodes) {
			first = list->free_nodes->prev;
			printf("New first %p\n", first);
		    }
		    else
			break;
		}
	    }
	    node = node_next;
	}
	while (node != first);
    }
}

-------------- next part --------------
first 0x6e0f60
node: 0x6e0f60 next: 0x681500 (first is 0x6e0f60)
node: 0x681500 next: 0x698200 (first is 0x6e0f60)
node: 0x698200 next: 0x691250 (first is 0x6e0f60)
node: 0x691250 next: 0x684a70 (first is 0x6e0f60)
node: 0x684a70 next: 0x6e0f60 (first is 0x6e0f60)
remove 0x684a70
first 0x667600
node: 0x667600 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x6e57b0 (first is 0x667600)
node: 0x6e57b0 next: 0x6e0f60 (first is 0x667600)
node: 0x6e0f60 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x698200 (first is 0x667600)
node: 0x698200 next: 0x691250 (first is 0x667600)
remove 0x698200
node: 0x691250 next: 0x667600 (first is 0x667600)
first 0x667600
node: 0x667600 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x6e57b0 (first is 0x667600)
node: 0x6e57b0 next: 0x6e0f60 (first is 0x667600)
node: 0x6e0f60 next: 0x681500 (first is 0x667600)
remove 0x6e0f60
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x667600 (first is 0x667600)
first 0x667600
node: 0x667600 next: 0x6e6290 (first is 0x667600)
remove 0x667600
node: 0x6e6290 next: 0x6e57b0 (first is 0x667600)
node: 0x6e57b0 next: 0x681500 (first is 0x667600)
remove 0x6e57b0
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x691250 (first is 0x667600)
(...)
-------------- next part --------------
first 0x6e0f60
node: 0x6e0f60 next: 0x681500 (first is 0x6e0f60)
node: 0x681500 next: 0x698200 (first is 0x6e0f60)
node: 0x698200 next: 0x691250 (first is 0x6e0f60)
node: 0x691250 next: 0x684a70 (first is 0x6e0f60)
node: 0x684a70 next: 0x6e0f60 (first is 0x6e0f60)
remove 0x684a70
first 0x667600
node: 0x667600 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x6e57b0 (first is 0x667600)
node: 0x6e57b0 next: 0x6e0f60 (first is 0x667600)
node: 0x6e0f60 next: 0x681500 (first is 0x667600)
node: 0x681500 next: 0x698200 (first is 0x667600)
node: 0x698200 next: 0x691250 (first is 0x667600)
remove 0x698200
node: 0x691250 next: 0x667600 (first is 0x667600)
first 0x667600
node: 0x667600 next: 0x6e6290 (first is 0x667600)
node: 0x6e6290 next: 0x6e57b0 (first is 0x667600)
node: 0x6e57b0 next: 0x6e0f60 (first is 0x667600)
node: 0x6e0f60 next: 0x681500 (first is 0x667600)
remove 0x6e0f60
node: 0x681500 next: 0x691250 (first is 0x667600)
node: 0x691250 next: 0x667600 (first is 0x667600)
first 0x667600
node: 0x667600 next: 0x6e6290 (first is 0x667600)
remove 0x667600
Oops removed first!
New first 0x691250
node: 0x6e6290 next: 0x6e57b0 (first is 0x691250)
node: 0x6e57b0 next: 0x681500 (first is 0x691250)
remove 0x6e57b0
node: 0x681500 next: 0x691250 (first is 0x691250)
first (nil)
first (nil)
first (nil)
first (nil)
From jose_ogp at juno.com  Sun Mar  4 21:39:37 2007
From: jose_ogp at juno.com (jose_ogp@juno.com)
Date: Sun Mar  4 21:47:13 2007
Subject: [cairo] Compositing benchmarks
Message-ID: <20070304.214030.757.1009333@webmail37.nyc.untd.com>


> In my investigation into 'fixing' libpixman cairo's software
> compositing code, I built a benchmarking suite for different
> software and hardware compositing libraries.
> 
> In theory, it supports the following backend:
> - cairo
> - pixman (directly)
> - cairo-glitz
> - cairo-xlib
> - glitz
> - liboil
> - evas_core (compositing routines from enlightenment)
> - intel performance primitives
> 
> ....
> ....

	Interesting. I can tell you that evas' blending routines
use an approximation to the 'ideal' blending equation, which cairo
chooses to follows more exactly.. hence likely the speed difference
between these two. If liboil has something closer to cairo's, then
that would be a great improvement indeed. If not, well, cairo already
has a choice of filtering 'quality', so perhaps it could offer a
choice of compositing 'quality' - especially if the speed gains are
large and the 'quality loss' is small.

	It's curious to see how different sets of criteria lead to
various choices in design and implementation.
	In evas for example, one wants to balance sometimes competing
needs such as speed, low memory use, and good visual quality. This
last is important, though somewhat vague.
	I once did a very unscientific test where I had several
people look at the result of blending several images using various
approximations to an ideal definition of 'over' blending. I asked
them to tell me if they could see any differences.. No one could.

	Surely this is a foolish way to develop visual criteria,
but it was interesting enough that I've performed a few other
similar tests on such "typical viewers".
	Recently, I had several scaling algorithms I wanted to test,
including cairo's (among others), and again asked if they could see
any difference.
	This time, however, there was a rather different reaction
from my test subjects. As I varied the x,y scaling factors below
1/2,1/2 and further, all of the methods that did not sample the
src image in full - and this includes cairo - were eventually
reported as giving results that were: "not clear", "blurry",
"uneven", "missing things", and other similar such remarks.

	It's curious to me that cairo puts so much emphasis on
the 'accuracy' of compositing calculations - variations of which
people are unable to discern - and yet seems to put much less
emphasis on the 'accuracy' of scaling results - variations of
which people note as giving considerable differences.
	Obviously there's a reason for this seeming disparity
-- possibly it's the desire to have a single unified method for
dealing with transforms... But I would say that this is an area
that could use more looking into.

   jose.


From mathias.hasselmann at gmx.de  Sun Mar  4 22:14:31 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Sun Mar  4 22:14:43 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <20070304223344.69XK2JL9VS@priv-edtnaa05.telusplanet.net>
References: <20070304223344.69XK2JL9VS@priv-edtnaa05.telusplanet.net>
Message-ID: <1173075271.5590.1.camel@dali>

Am Sonntag, den 04.03.2007, 14:34 -0800 schrieb Dave Yeo:
> I got the compile to finish by removing these from cairo-os2-surface.c (see attached diff).
> Not sure if this is good way to do this or not

Getting rid of those separate declarations exactly was the purpose of
the patch.

Ciao,
Mathias

From mathias.hasselmann at gmx.de  Sun Mar  4 22:22:43 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Sun Mar  4 22:22:54 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <1173043926.9109.10.camel@behdad>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
	<1173019474.17604.17.camel@dali>  <1173043926.9109.10.camel@behdad>
Message-ID: <1173075763.5590.8.camel@dali>

Am Sonntag, den 04.03.2007, 16:32 -0500 schrieb Behdad Esfahbod:
> On Sun, 2007-03-04 at 09:44 -0500, Mathias Hasselmann wrote:
> > Ok, so here there is a first patch. Followed the path of
> > CAIRO_MUTEX_INITIALIZE() in every potential entry point. Only
> > difference: CAIRO_MUTEX_INITIALIZE() also invokes code on pthread
> > platforms as I wanted to keep handling of CAIRO_MUTEX_DECLARE simple. 
> > If that minimal performance penalty is not acceptable, I can change
> > that. 
>
>   - Why does it touch cairo-boilerplate.c?  Please break changes into
> minimal patches.  That helps debugging later.

As they change I was going to made had the potential of creating many
new warnings I've decided to compile with -Werror before starting. Some
of the changes are the result of that step. Should have sent two
separate patches. Will split it.

>   - Yesterday I had an idea: instead of touching all backends, we can
> call CAIRO_MUTEX_INITIALIZE() in these:
> 
> 	_cairo_font_face_init
> 	_cairo_surface_init
> 	_cairo_pattern_init
> 
> This should be enough.

Yup. Had a similiar impression, but don't know the code well enough to
do that. Creative usage of grep, sort -u and diff helped me to spot all
places you've mentioned initially.

> And I didn't get why you had to make it call anything on pthread.  If
> there's no need, lets make it a nop.

This avoids some pre-processor magic in cairo-mutex-private.h, as I am
not a fan of excessive pre-processor magic. But still I know what to do,
so I can create an alternate patchset.

Ciao,
Mathias

From cairo-2007a at ryandesign.com  Sun Mar  4 22:27:26 2007
From: cairo-2007a at ryandesign.com (Ryan Schmidt)
Date: Sun Mar  4 22:28:58 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
Message-ID: <DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>

On Mar 3, 2007, at 21:08, Baz wrote:

> On 04/03/07, Vladimir Vukicevic wrote:
>
>> > For this one, should automake fail to enable quartz if xlib is
>> > enabled? Or should --enable-quartz disable xlib?
>>
>> Probably; I don't really know how to resolve the Picture conflict
>> otherwise, and I'm not sure if there is any value in doing so -- a  
>> Cairo
>> that supports xlib (perfectly valid on the Mac) will probably be  
>> used by
>> a totally different class of apps than one that supports Quartz.
>
> Ok, I've just pushed the change to warn about xlib, since splitting
> the boilerplate seemed to need more thought, ad the warning is useful
> for now. So Ryan, the flags you need are:
>
> --enable-quartz --disable-xlib

Thanks, that works. That's what I was going to try next, just hadn't  
gotten around to it.

> and autogen should be a little more helpful about telling you this.

Wonderful.


FYI, the only cairo-using app I'm interested in is Graphviz. They use  
the cairo xlib/freetype backends currently, but the way the text  
comes out in the graphs is decidedly yuckier than what I'm used to  
seeing from native Mac OS X apps. So I'd like for Graphviz to be able  
to use the quartz/atsui backends instead if they're available. I'm  
not sure how we get there, since I can't really call myself a C  
programmer and the Graphviz programmers don't spend so much time with  
Macs, but compiling a quartz/atzui cairo was the first step. Thanks  
for your help getting me that far.


From david at freetype.org  Sun Mar  4 22:59:39 2007
From: david at freetype.org (David Turner)
Date: Sun Mar  4 22:59:43 2007
Subject: [cairo] fixing Cairo's FreeType multi-threaded usage
In-Reply-To: <Pine.BSO.4.62.0703050420550.23048@tydraniu.sfires.net>
References: <1172700393.31478.1177064837@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030116070.32443@tydraniu.sfires.net>
	<1172888959.26264.1177484563@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703030401530.8518@tydraniu.sfires.net>
	<1172946154.614.1177548387@webmail.messagingengine.com>
	<1173038841.28494.1177656165@webmail.messagingengine.com>
	<Pine.BSO.4.62.0703050420550.23048@tydraniu.sfires.net>
Message-ID: <1173077979.26261.1177720611@webmail.messagingengine.com>

Hi Jan,

the removal loop is broken, thanks for spotting this; I must say I'm
surprised I've never encountered that on my desktop that runs it.

here's a diff that fixes the issue. And I also regenerated a patchset:

http://david.freetype.org/cairo/fix-freetype-usage-3.patchset

thanks,

- David



On Mon, 5 Mar 2007 04:56:05 +0100 (CET), "Jan Slupski" <jslupski@juljas.net> said:
> On Sun, 4 Mar 2007, David Turner wrote:
> 
> > Hello,
> >
> > here's a second version of my patchset that fixes the bug described early
> > (incorrect behaviour of the FreeType-backed implementation of the toy font
> > interface). It needed a few tricky internal changes, but all sems good know.
> >
> >  http://david.freetype.org/cairo/fix-freetype-usage-2.patchset
> >
> > note that it was generated against a recent clone of the Cairo git repository,
> > you should *not* apply the first patchset before this one.
> >
> > All test cases pass, except the ones that already failed with the original
> > sources.
> >
> > As usual, all comments are welcomed :-)
> 
> 
> Hi David,
> 
> Thanks a lot for a patch. It helped a lot.
> I can report that 1.3.16 with this patch is often quicker that 1.2.6.
> 
> Unfortunately I just hit another problem.
> It seems that at certain conditions I hit endless loop
> in _cairo_mru_list_remove_select function.
> 
> This happens when 'node' that is 'first' element is removed.
> 
> 
> I've added some debug code (_cairo_mru_list_remove_select.c)
> 
> Here is sample output (when LOOP_WORKAROUND unset) - endless.log
> When I switch LOOP_WORKAROUND on I have correct results - workaround.log
> 
> Let me know if there is anything else I can provide you with
> 
> Jan
> 
> 
>     _  _  _  _  _____________________________________________
>     | |_| |\ |  S L U P S K I             jslupski@juljas.net
>   |_| | | | \|                             http://juljas.net/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: fix-freetype-usage-3.diff
Type: application/octet-stream
Size: 1103 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/b708ca3e/fix-freetype-usage-3.obj
From mathias.hasselmann at gmx.de  Mon Mar  5 01:42:09 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Mon Mar  5 01:42:23 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <1173075763.5590.8.camel@dali>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
	<1173019474.17604.17.camel@dali>  <1173043926.9109.10.camel@behdad>
	<1173075763.5590.8.camel@dali>
Message-ID: <1173087730.20769.7.camel@dali>

Now I've split the patch into two portions and also updated
cairo-os2-surface.c.

Had some trouble figuring out boring copyright stuff for the new files:
Do I have to include Redhat? Do I have to include University of Southern
California? Should I add myself for those trivial changes initially
designed by Behdad? Maybe cairographics.org should point to some
copyright policy page. Maybe it makes sense to just assign all the
boring copyright stuff to the cairo graphics project?

Ciao,
Mathias

-------------- next part --------------
A non-text attachment was scrubbed...
Name: cairo-mutex-private.diff
Type: text/x-patch
Size: 24638 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/97f29d73/cairo-mutex-private-0001.bin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cairo-warnings.diff
Type: text/x-patch
Size: 12350 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/97f29d73/cairo-warnings-0001.bin
From tgriggs at cincom.com  Mon Mar  5 05:24:43 2007
From: tgriggs at cincom.com (Travis Griggs)
Date: Mon Mar  5 05:24:51 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
Message-ID: <B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>

On Mar 5, 2007, at 1:27, Ryan Schmidt wrote:

> On Mar 3, 2007, at 21:08, Baz wrote:
>
>> On 04/03/07, Vladimir Vukicevic wrote:
>>
>>> > For this one, should automake fail to enable quartz if xlib is
>>> > enabled? Or should --enable-quartz disable xlib?
>>>
>>> Probably; I don't really know how to resolve the Picture conflict
>>> otherwise, and I'm not sure if there is any value in doing so --  
>>> a Cairo
>>> that supports xlib (perfectly valid on the Mac) will probably be  
>>> used by
>>> a totally different class of apps than one that supports Quartz.
>>
>> Ok, I've just pushed the change to warn about xlib, since splitting
>> the boilerplate seemed to need more thought, ad the warning is useful
>> for now. So Ryan, the flags you need are:
>>
>> --enable-quartz --disable-xlib
>
> Thanks, that works. That's what I was going to try next, just  
> hadn't gotten around to it.
>
>> and autogen should be a little more helpful about telling you this.
>
> Wonderful.
>
>
> FYI, the only cairo-using app I'm interested in is Graphviz. They  
> use the cairo xlib/freetype backends currently, but the way the  
> text comes out in the graphs is decidedly yuckier than what I'm  
> used to seeing from native Mac OS X apps. So I'd like for Graphviz  
> to be able to use the quartz/atsui backends instead if they're  
> available. I'm not sure how we get there, since I can't really call  
> myself a C programmer and the Graphviz programmers don't spend so  
> much time with Macs, but compiling a quartz/atzui cairo was the  
> first step. Thanks for your help getting me that far.

I'd like some clarification pretty please. I'm using 1.2.6 right now  
on PPC OSX. I actually use both interfaces. I have some stuff that  
uses xlib interfaces, and other which goes straight through the  
quartz interface. When I get around to upgrading to 1.4, am I still  
going to be able to do this?

--
Travis Griggs
Objologist
"Dying men never wish they'd spent more time at the office"


-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070305/50e4b439/attachment.html
From fcrozat at mandriva.com  Mon Mar  5 05:53:37 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Mon Mar  5 05:48:19 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1172865665.4863.131.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
Message-ID: <1173102817.24503.7.camel@trinidad.mandrakesoft.com>

Le vendredi 02 mars 2007 ? 21:01 +0100, Frederic Crozat a ?crit :
> Le vendredi 02 mars 2007 ? 12:24 +0100, Frederic Crozat a ?crit :
> > Le vendredi 02 mars 2007 ? 10:06 +0100, Frederic Crozat a ?crit :
> > > Le jeudi 01 mars 2007 ? 19:48 -0500, Behdad Esfahbod a ?crit :
> > > > On Thu, 2007-03-01 at 13:28 -0500, Frederic Crozat wrote:
> > > > > 
> > > > > If I revert to cairo 1.2.x, problem disappear, with same version of
> > > > > pango.
> > > > 
> > > > Would you mind "git bisect"ing?  Helps a lot, and may be the only way to
> > > > pin this down before 1.4.0.
> > > 
> > > Good news : it appears to be a gcc optimization issue : I don't get the
> > > error when using standard cflags and not the one we use for our Mandriva
> > > packages.
> > > 
> > > Anyway, I'll do a bisect to find one which commit caused it and I'll try
> > > to grab our gcc guy to find out how to fix.
> > 
> > Culprit is commit 3e002a474b64c83f8768ba8918209eca9d7599a3
> > Author: Vladimir Vukicevic <vladimir@pobox.com>
> > Date:   Fri Nov 3 09:47:31 2006 -0800
> > 
> >     [win32] Update pixman MMX code to work with MSVC
> >     
> >     Patch from Tor Lillqvist.
> > 
> > When building with "-O2 -fomit-frame-pointer", in 16bpp RGBA, you get
> > funky mask. Code was probably broken before but it wasn't visible.
> > 
> > With help of our gcc guy (Gwenole Beauchesne), I've fix it "the right
> > way (c)Gwenole" and it should be optimized nicely with gcc.
> > 
> > However, since I'm not a expert in this area, I would suggest somebody
> > with more knowledge to check fbmmx.c for other funky conversions between
> > ullong and __m64 and use to_ullong and to_m64 instead of using M64
> > blindly.
> > 
> > Another nice thing is it was the first time I use git to commit a patch
> > (better late than never) and use git rebase to move it to HEAD.
> > 
> > I haven't testing this patch with MSVC (since I don't have Windows
> > platform around) but I don't think it will cause problem.
> 
> Argg, my coworker just told me it wasn't fixing his problem with fonts
> being corrupted (see http://qa.mandriva.com/show_bug.cgi?id=28317 ) but
> he is running on x86-64 so my fix might be incomplete.

And it was incomplete.

Here is an additional fix for x86-64.

You need to apply first fix and second one in sequence (I've undo some
of the change I did in my first patch, which aren't really needed).

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0002-Fix-aliasing-on-64-bits-platform-too.txt
Type: application/mbox
Size: 1469 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/4559eeb8/0002-Fix-aliasing-on-64-bits-platform-too.bin
From brian.ewins at gmail.com  Mon Mar  5 05:58:27 2007
From: brian.ewins at gmail.com (Baz)
Date: Mon Mar  5 05:58:31 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
	<B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>
Message-ID: <2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>

On 05/03/07, Travis Griggs <tgriggs@cincom.com> wrote:
> I'd like some clarification pretty please. I'm using 1.2.6 right now on PPC
> OSX. I actually use both interfaces. I have some stuff that uses xlib
> interfaces, and other which goes straight through the quartz interface. When
> I get around to upgrading to 1.4, am I still going to be able to do this?

Short answer is no, unless you build yourself 2 libraries (or are you
using both in the same program?). Long answer is we should be able to
do this but it needs a bit more work to fix it up. My change was just
intended to better document the build options, quartz + xlib havent
been buildable together since at least 1.3.14.

I've not looked into splitting up cairo-boilerplate as Vlad described
earlier in the thread; but changing something that's used all over
cairo seemed like a Bad Idea with 1.4 imminent. Unless someone more
familiar with that jumps in and does it right away, its not going to
be in 1.4.

Cheers,
Baz
From behdad at behdad.org  Mon Mar  5 07:12:10 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 07:12:21 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
Message-ID: <1173107531.13318.9.camel@behdad>

On Sat, 2007-03-03 at 22:08 -0500, Baz wrote:
> 
> Ok, I've just pushed the change to warn about xlib, since splitting
> the boilerplate seemed to need more thought, ad the warning is useful
> for now. So Ryan, the flags you need are:
> 
> --enable-quartz --disable-xlib
> 
> and autogen should be a little more helpful about telling you this.

Humm, actually I want to revert that.  No backends in cairo should ever
be exclusive.  In fact for 1.4.2, I want to make sure that no font
backend is tied to any particular surface, and any font backend can be
used with any surface.


> Cheers,
> Baz 
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar  5 07:55:35 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 07:55:35 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
	<B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>
	<2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>
Message-ID: <1173110135.13318.14.camel@behdad>

On Mon, 2007-03-05 at 08:58 -0500, Baz wrote:
> On 05/03/07, Travis Griggs <tgriggs@cincom.com> wrote:
> > I'd like some clarification pretty please. I'm using 1.2.6 right now on PPC
> > OSX. I actually use both interfaces. I have some stuff that uses xlib
> > interfaces, and other which goes straight through the quartz interface. When
> > I get around to upgrading to 1.4, am I still going to be able to do this?
> 
> Short answer is no, unless you build yourself 2 libraries (or are you
> using both in the same program?). Long answer is we should be able to
> do this but it needs a bit more work to fix it up. My change was just
> intended to better document the build options, quartz + xlib havent
> been buildable together since at least 1.3.14.


I'm going to fix this.

> I've not looked into splitting up cairo-boilerplate as Vlad described
> earlier in the thread; but changing something that's used all over
> cairo seemed like a Bad Idea with 1.4 imminent. Unless someone more
> familiar with that jumps in and does it right away, its not going to
> be in 1.4.

cairo-boilerplate is only used for test and performance suites.  At any
cost, that should not limit our library.  And it will not in 1.4.0.

> Cheers,
> Baz

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From richard at imendio.com  Mon Mar  5 08:15:55 2007
From: richard at imendio.com (Richard Hult)
Date: Mon Mar  5 08:47:53 2007
Subject: [cairo] CGContextFlush in the new quartz backend
Message-ID: <45EC423B.9010603@imendio.com>

Hi,

I have looked into a bit why GTK+ on OSX is much slower with the new 
quartz backend than it was with the old one.

The reason seems to be the call to flush the graphics context whenever a 
surface is finished. This basically means "synchronously push my changes 
to the screen", which doesn't work well together with how GTK+ uses 
cairo. A typical GTK+ app can easily create and destroy 20 surfaces when 
exposed, like when first created or when moving the mouse across it, and 
this means a flush is called 20 times as well, creating a lot of flicker 
and you can actually see each widget being drawn to the screen one at a 
time.

To me, it would make more sense to leave that part (flushing the 
context) to the user of the surface, in this case GTK+ and not have the 
cairo surface do it automatically. Would this cause problems for other 
users?

/Richard

-- 
Imendio AB, http://www.imendio.com/
From cworth at cworth.org  Mon Mar  5 08:49:22 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar  5 08:51:21 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
	<B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>
	<2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>
Message-ID: <871wk3ljot.wl%cworth@cworth.org>

On Mon, 5 Mar 2007 13:58:27 +0000, Baz wrote:
> On 05/03/07, Travis Griggs <tgriggs@cincom.com> wrote:
> > I'd like some clarification pretty please. I'm using 1.2.6 right now on PPC
> > OSX. I actually use both interfaces. I have some stuff that uses xlib
> > interfaces, and other which goes straight through the quartz interface. When
> > I get around to upgrading to 1.4, am I still going to be able to do this?
>
> Short answer is no, unless you build yourself 2 libraries (or are you
> using both in the same program?).

Short answer is absolutely yes.

I won't release cairo 1.4 until this is fixed.

There's no reason cairo shouldn't allow you to build it with any
combination of the available backends.

> do this but it needs a bit more work to fix it up. My change was just
> intended to better document the build options, quartz + xlib havent
> been buildable together since at least 1.3.14.

It's really totally buildable. The only problem comes up in
boilerplate, which is part of cairo's test infrastructure and not part
of the library itself.

> I've not looked into splitting up cairo-boilerplate as Vlad described
> earlier in the thread; but changing something that's used all over
> cairo seemed like a Bad Idea with 1.4 imminent. Unless someone more
> familiar with that jumps in and does it right away, its not going to
> be in 1.4.

It's not used all over cairo---in fact, it's not used in cairo at all,
(just in the test and perf suites built on top of cairo). And the
change needed here is just to take two functions that currently exist
in one .c file and put them into two .c files. Nothing really
invasive.

So, yes, this will be happening before 1.4.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/8b33910b/attachment.pgp
From cworth at cworth.org  Mon Mar  5 08:55:16 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar  5 08:55:50 2007
Subject: [cairo] Compositing benchmarks
In-Reply-To: <20070304.214030.757.1009333@webmail37.nyc.untd.com>
References: <20070304.214030.757.1009333@webmail37.nyc.untd.com>
Message-ID: <87zm6rk4uj.wl%cworth@cworth.org>

On Mon, 5 Mar 2007 05:39:37 GMT, "jose_ogp@juno.com" wrote:
> 	It's curious to me that cairo puts so much emphasis on
> the 'accuracy' of compositing calculations - variations of which
> people are unable to discern - and yet seems to put much less
> emphasis on the 'accuracy' of scaling results - variations of
> which people note as giving considerable differences.

Cairo's downscaling implementation is an embarrassment.

You're correct to note that its quality is decidedly inferior to
almost all other results obtainable with cairo.

> 	Obviously there's a reason for this seeming disparity
> -- possibly it's the desire to have a single unified method for
> dealing with transforms... But I would say that this is an area
> that could use more looking into.

I think the reason is simply that we haven't gotten around to fixing
it yet. I'd love to see someone implement a software "mipmap"-like
approach for image scaling. It would eliminate one of the few
visual-quality warts still left in cairo.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/56f58cbf/attachment.pgp
From jeff at infidigm.net  Mon Mar  5 09:03:13 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Mon Mar  5 09:01:50 2007
Subject: [cairo] Compositing benchmarks
In-Reply-To: <20070304.214030.757.1009333@webmail37.nyc.untd.com>
References: <20070304.214030.757.1009333@webmail37.nyc.untd.com>
Message-ID: <20070305170313.GA18253@infidigm.net>

On Mon, Mar 05, 2007 at 05:39:37AM +0000, jose_ogp@juno.com wrote:
> 
> > In my investigation into 'fixing' libpixman cairo's software
> > compositing code, I built a benchmarking suite for different
> > software and hardware compositing libraries.
> > 
> > In theory, it supports the following backend:
> > - cairo
> > - pixman (directly)
> > - cairo-glitz
> > - cairo-xlib
> > - glitz
> > - liboil
> > - evas_core (compositing routines from enlightenment)
> > - intel performance primitives
> > 
> > ....
> > ....
> 
> 	Interesting. I can tell you that evas' blending routines
> use an approximation to the 'ideal' blending equation, which cairo
> chooses to follows more exactly.. hence likely the speed difference
> between these two. If liboil has something closer to cairo's, then
> that would be a great improvement indeed. If not, well, cairo already
> has a choice of filtering 'quality', so perhaps it could offer a
> choice of compositing 'quality' - especially if the speed gains are
> large and the 'quality loss' is small.

I had a look at the routine (_op_blend_p_dp_mmx) in evas and it looks it
is doing: a*b/256. Is this correct? The routine used in liboil
(composite_over_argb_sse2_3) appears to be using the exact and
traditional blin95 formula: (a*b+128)*(257/65536), however, I could be
misreading the code. Cairo also uses the blin95 formula.

> 
> 	It's curious to see how different sets of criteria lead to
> various choices in design and implementation.
> 	In evas for example, one wants to balance sometimes competing
> needs such as speed, low memory use, and good visual quality. This
> last is important, though somewhat vague.
> 	I once did a very unscientific test where I had several
> people look at the result of blending several images using various
> approximations to an ideal definition of 'over' blending. I asked
> them to tell me if they could see any differences.. No one could.

That doesn't surprise me. The formula used by evas is off by at most 2
which would be pretty difficult to percieve.  I guess the biggest
problem with that formula would be accumulated error, especially because
that formula always aproximates under the true value. Still, the idea of
controlable compositing quality is an interesting one, provided the
performance benefits are large enough to justify it.

> 
> 	Surely this is a foolish way to develop visual criteria,
> but it was interesting enough that I've performed a few other
> similar tests on such "typical viewers".
> 	Recently, I had several scaling algorithms I wanted to test,
> including cairo's (among others), and again asked if they could see
> any difference.
> 	This time, however, there was a rather different reaction
> from my test subjects. As I varied the x,y scaling factors below
> 1/2,1/2 and further, all of the methods that did not sample the
> src image in full - and this includes cairo - were eventually
> reported as giving results that were: "not clear", "blurry",
> "uneven", "missing things", and other similar such remarks.
> 
> 	It's curious to me that cairo puts so much emphasis on
> the 'accuracy' of compositing calculations - variations of which
> people are unable to discern - and yet seems to put much less
> emphasis on the 'accuracy' of scaling results - variations of
> which people note as giving considerable differences.
> 	Obviously there's a reason for this seeming disparity
> -- possibly it's the desire to have a single unified method for
> dealing with transforms... But I would say that this is an area
> that could use more looking into.

The scaling code that cairo currently uses is known to be bad and is not
really representive of the goals of cairo. It needs replacing, but no
one has actually done the work yet. I'd be very interested in knowing
more about the different scaling algorithms that you tested and what
your conclusions were.

-Jeff
From cworth at cworth.org  Mon Mar  5 09:03:23 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar  5 09:03:42 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <1173087730.20769.7.camel@dali>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
	<1173019474.17604.17.camel@dali> <1173043926.9109.10.camel@behdad>
	<1173075763.5590.8.camel@dali> <1173087730.20769.7.camel@dali>
Message-ID: <87y7mbk4h0.wl%cworth@cworth.org>

On Mon, 05 Mar 2007 10:42:09 +0100, Mathias Hasselmann wrote:
> Had some trouble figuring out boring copyright stuff for the new files:
> Do I have to include Redhat? Do I have to include University of Southern
> California?

No. The cairo project does not require any copyright assignment. You
see Red Hat and University of Southern California a lot in the code
only because those are the places where I (and others) worked while
implementing much of cairo, so they have much of the copyright
interest.

> Should I add myself for those trivial changes initially
> designed by Behdad?

Please designate the proper copyright holder for all changes you make,
(whether yourself or your employer as appropriate given arrangements
between yourself and your employer).

> Maybe cairographics.org should point to some
> copyright policy page.

Feel free to draft something up, (note: all of cairographics.org is a
wiki---so everyone is free to help improve it).

> Maybe it makes sense to just assign all the
> boring copyright stuff to the cairo graphics project?

Absolutely not. There is no legal entity that is "the cairo graphics
library project" so a copyright attribution as follows:

> + * Copyright ? 2007 the cairo graphics library project

doesn't make any sense. With no such entity, there's nobody designated
as holding copyright interest here.

Please fix this and resubmit,

Thanks,

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/8f51c4aa/attachment.pgp
From otaylor at redhat.com  Mon Mar  5 09:17:13 2007
From: otaylor at redhat.com (Owen Taylor)
Date: Mon Mar  5 09:17:28 2007
Subject: [cairo] CGContextFlush in the new quartz backend
In-Reply-To: <45EC423B.9010603@imendio.com>
References: <45EC423B.9010603@imendio.com>
Message-ID: <1173115033.2565.26.camel@localhost.localdomain>

On Mon, 2007-03-05 at 17:15 +0100, Richard Hult wrote:
> Hi,
> 
> I have looked into a bit why GTK+ on OSX is much slower with the new 
> quartz backend than it was with the old one.
> 
> The reason seems to be the call to flush the graphics context whenever a 
> surface is finished. This basically means "synchronously push my changes 
> to the screen", which doesn't work well together with how GTK+ uses 
> cairo. A typical GTK+ app can easily create and destroy 20 surfaces when 
> exposed, like when first created or when moving the mouse across it, and 
> this means a flush is called 20 times as well, creating a lot of flicker 
> and you can actually see each widget being drawn to the screen one at a 
> time.
> 
> To me, it would make more sense to leave that part (flushing the 
> context) to the user of the surface, in this case GTK+ and not have the 
> cairo surface do it automatically. Would this cause problems for other 
> users?

I can't answer to what it would do to other users, but the flush there
is certainly against the philosophy of what the other backends do.
Drawing with cairo is supposed to act very much like using drawing
commands in the native API.

 * When drawing in windows, you call BeginPaint/EndPaint around
   your calls into Cairo.

 * In X, if you want to flush buffered drawing commands you have to 
   call XFlush() yourself.

And so forth. What cairo_surface_flush() does is flush out buffered
state that is *internal* to cairo; it thus synchronizes the native
drawing state to the cairo drawing state for the surface.

					- Owen

From behdad at behdad.org  Mon Mar  5 09:20:32 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 09:23:36 2007
Subject: Which thread lib to use on Win32 and other systems (was Re:
	[cairo] Recommendations for 1.4.0
In-Reply-To: <45E9ECC7.6070505@breuer.org>
References: <1172956400.25990.31.camel@behdad> <45E9ECC7.6070505@breuer.org>
Message-ID: <1173115232.14796.11.camel@behdad>

On Sat, 2007-03-03 at 22:46 +0100, Hans Breuer wrote:
> 
> For win32 you can just apply the following patch.

Thanks Hans.  A question for you, tml, and other backend maintainers:
which thread library should we prefer: pthread or native threads?
This concerns Win32, and OS/2 at least.

I think the current "prefer pthread" is Ok if we provide a
--without-pthread option.  Comments?

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar  5 09:21:42 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 09:23:41 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <45EA8ED1.7010302@gentoo.org>
References: <1172956400.25990.31.camel@behdad> <45EA8ED1.7010302@gentoo.org>
Message-ID: <1173115302.14796.13.camel@behdad>

On Sun, 2007-03-04 at 04:18 -0500, Luca Barbato wrote:
> Behdad Esfahbod wrote:
> > Hi,
> > 
> > While updating docs for the 1.3.16 release yesterday I gathered the
> > following that I suggest we fix before 1.4.0:
> > 
> 
> Could be possible adding my VMX/Altivec bits?

Not really.  We are frozen.  Please bring that up soon after the
release, so we can test and incorporate them early in the cycle.

> lu
> 
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From cworth at cworth.org  Mon Mar  5 09:38:08 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar  5 09:38:34 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <1172956400.25990.31.camel@behdad>
References: <1172956400.25990.31.camel@behdad>
Message-ID: <87wt1vk2v3.wl%cworth@cworth.org>

On Sat, 03 Mar 2007 16:13:20 -0500, Behdad Esfahbod wrote:
> While updating docs for the 1.3.16 release yesterday I gathered the
> following that I suggest we fix before 1.4.0:

Thanks for the many documentation fixes.

>   - cairo_text_path() currently does not set the current point.  It will
> be implicitly set to the last point that an outline drew.  I recommend
> making it set the current point explicitly like cairo_show_text()
> does.

Yes, that should be done.

>   - Since _reference() and _destroy() functions just return on NULL,
> make _get_reference_count() return 0 on NULL.

Yes, that sounds good.

>   - Cosmetic: Rename cairo-font.c to cairo-font-face.c.

No, let's do this after 1.4, (I smell chances to break our currently
un-synced Makefiles for various platforms).

>   - Personal: In _cairo_path_append_to_context(), replace "!=" checks
> with "<".  That is, to allow more cairo_path_data_t elements in the path
> than needed.  I have requested this before:

Sure, easy enough.

>   - Make some of the test images smaller.  The 1.3.16 tarball is bigger
> than 4MB, while 1.2.0 was just 2.6MB and 1.0 only 1.4MB.  The main
> culprits seem to be extend-reflect and random-intersections reference
> images.  Maybe even replace romedalen.png with something smaller.

Ouch, that growth is pretty bad.

>   - Fix mutex initialization in win32, os2, and beos backends.  They are
> out of synch with the actually mutexes declared, and that causes link
> errors if not using pthread on win32.  I'm wondering if we should go for
> the backup plan:

I'm glad to see the new plan coming together now. But I'm hesitant to
do anything to major right now.

A problem that we have is that we don't have a lot of people doing
regular build-testing on non-Linux platforms between snapshots. So I
don't want to risk breaking the build again between 1.3.16 and 1.4.0.

We got reports of what was broken on win32 and we fixed that. I don't
think we've gotten any reports from os2 and beos, so we can just make
our best attempt, (without a compiler to verify).

The changes I accepted above look safe enough to implement and test on
one platform without a big risk of breaking other platforms.

I'll do what I can on these, (or Behdad, you can work on any you'd
like to as well).

Meanwhile, what I'll do today is roll up the various 1.3.x release
notes into a set of release notes giving an overview of what's changed
from 1.2 to 1.4 . I'll also do some cairo-perf testing from 1.2 to 1.4
so we can include a nice chart. I can easily do that on my x86 laptop,
but I don't think I'll have time to do any arm-based performance
runs. Anyone else want to take a whack at that now? Or maybe we'll
just have to let that appear after the release.

Anyway, things look good for 1.4 to happen today.

Thanks to everyone for the tremendous efforts over the last several
months.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/0d22e66b/attachment-0001.pgp
From tml at iki.fi  Mon Mar  5 10:30:59 2007
From: tml at iki.fi (Tor Lillqvist)
Date: Mon Mar  5 10:30:52 2007
Subject: Which thread lib to use on Win32 and other systems (was Re:
	[cairo] Recommendations for 1.4.0
In-Reply-To: <1173115232.14796.11.camel@behdad>
References: <1172956400.25990.31.camel@behdad> <45E9ECC7.6070505@breuer.org>
	<1173115232.14796.11.camel@behdad>
Message-ID: <17900.25059.34000.112613@gargle.gargle.HOWL>

Behdad Esfahbod writes:
 > which thread library should we prefer: pthread or native threads?

You mean just on Win32, or in general? Depends on how "foreign"
pthreads is on the platform in question. On most modern Unixes,
pthread comes with the OS, and is pretty close to native threads,
isn't it? The pthread API is used by much (most?) GNOMEish or KDEish
software already anyway on such platforms, yes?

But on Win32 pthreads-win32 is a 3rd-party DLL. No reason to drag in a
pthreads dependency there just for something as simple as in-process
mutexes.

 > I think the current "prefer pthread" is Ok if we provide a
 > --without-pthread option. Comments?

Sounds OK.

--tml
From behdad at behdad.org  Mon Mar  5 10:37:42 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 10:37:40 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <20070304064449.D1MH4GS7PQ@priv-edtnaa05.telusplanet.net>
References: <20070304064449.D1MH4GS7PQ@priv-edtnaa05.telusplanet.net>
Message-ID: <1173119862.18079.20.camel@behdad>

On Sat, 2007-03-03 at 22:45 -0800, Dave Yeo wrote:
> On Sat, 03 Mar 2007 16:13:20 -0500, Behdad Esfahbod wrote:
> 
> >  - Fix mutex initialization in win32, os2, and beos backends.  They are
> >out of synch with the actually mutexes declared, and that causes link
> >errors if not using pthread on win32.  I'm wondering if we should go for
> >the backup plan:
> >
> >http://lists.freedesktop.org/archives/cairo/2007-February/009679.html
> 
> Ok, I tried compiling and doing a make check on 1.3.16. First problem
> is that in test/makefile.am we  need this patch
> 
> --- Makefile.am.bak     Fri Mar  2 21:04:02 2007
> +++ Makefile.am Sat Mar  3 22:24:54 2007
> @@ -465,7 +465,7 @@
>  LDADD += -lpthread
>  endif
> 
> -SUPPORT_PROGS += imagediff png-flatten
> +SUPPORT_PROGS += imagediff$(EXEEXT) png-flatten$(EXEEXT)
> 
>  if CAIRO_CAN_TEST_PDF_SURFACE
>  SUPPORT_PROGS += pdf2png
> 
> please apply. Actually looking at above pdf2png should also have
> $(EXEEXT) added.

Fixed.  Thanks.


> Anyways make check then ends with this
> f:/usr/bin/sh.exe ../libtool --tag=CC --mode=link gcc.exe  -g -O2   -o
> imagediff.exe  imagediff.o libcairotest.la -lpthread -lm
> gcc.exe    -g    -O2    -o    imagediff.exe    imagediff.o       
> ./.libs/cairotest.a    -L/usr/local/lib   
> /usr/src/cairo-1.3.16/src/.libs/cairo.a   
> /usr/local/lib/libfontconfig_dll.a    /usr/local/lib/libfreetype_dll.a 
>   /usr/local/lib/expat.a    /usr/local/lib/libpng12_dll.a    -lz   
> -lpthread    -lm       -L/usr/local/lib -L/usr/local/lib
> cairo-font.c:96
> (/usr/src/cairo-1.3.16/src/.libs/cairo.a(cairo-font.o)): Undefined
> symbol _cairo_font_face_mutex referenced from text segment
> cairo-font.c:104
> (/usr/src/cairo-1.3.16/src/.libs/cairo.a(cairo-font.o)): Undefined
> symbol _cairo_font_face_mutex referenced from text segment
> ...
> cairo-font.c:0 (/usr/src/cairo-1.3.16/src/.libs/cairo.a(cairo-font.o)):
> More undefined symbol _cairo_font_face_mutex refs follow
> make[3]: *** [imagediff.exe] Error 1
> 
> which I take is the mutex problem referred above
> Dave
> ps also something needs to be done about pthread on OS/2, I usually
> edit config.h to comment out
> #define HAVE_PTHREAD_H 1
> in config.h
> A better fix would be along the lines of win32 where you can have or
> not have pthreads. Or perhaps a configure option.
> pps also here configure has to be called with --enable-os2
> --disable-xlib, not a big deal but xlib needs an older libc (EMX) and
> is not compatible with the newer libc (klibc).

I'm planning on adding a --without-pthread for those cases.


-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar  5 11:20:01 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 11:20:03 2007
Subject: [cairo] Re: [cairo-commit] 6 commits - doc/public
	src/cairo.c	src/cairo-gstate.c src/cairo.h
	src/cairoint.h	src/cairo-quartz-surface.c
	src/cairo-scaled-font.c	test/font-face-get-type.c TODO
In-Reply-To: <87lkigkmey.wl%cworth@cworth.org>
References: <20070228012213.9B4A110089@kemper.freedesktop.org>
	<87lkigkmey.wl%cworth@cworth.org>
Message-ID: <1173122401.18079.40.camel@behdad>

On Fri, 2007-03-02 at 04:46 -0500, Carl Worth wrote:
> On Tue, 27 Feb 2007 17:22:13 -0800 (PST), Behdad wrote:
> > Author: Behdad Esfahbod <behdad@behdad.org>
> > Date:   Tue Feb 27 20:09:22 2007 -0500
> >
> >     Implement cairo_get_scaled_font()
> 
> Sneaky, Behdad. You added new public API without sending it to the
> cairo list first. Tsk. Tsk. 

Well, I wrote a proposal to the list:

  http://lists.freedesktop.org/archives/cairo/2007-January/009374.html


had it in my TODO for 1.4, saw it in your TODO for 1.4 (in your tree!),
and I thought well, I may as well push the trivial implementation...
Sorry about that.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar  5 11:28:58 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 11:28:57 2007
Subject: [cairo] Solid surface cache causing cross-thread unhappiness
In-Reply-To: <87irdkkl6p.wl%cworth@cworth.org>
References: <8e10abfb0703010053s24f2ca26g2214ef7b1073e617@mail.gmail.com>
	<87irdkkl6p.wl%cworth@cworth.org>
Message-ID: <1173122938.18079.44.camel@behdad>

On Fri, 2007-03-02 at 05:13 -0500, Carl Worth wrote:
> I suspect you could probably move the
> > caches to the cario surface and avoid static cache's with locks.

This is a very neat idea in fact.  Just caching last solid source per
surface probably fixes the performance issue at hand.  I thought about
that first, but it clutters the current code base.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar  5 11:33:17 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 11:33:15 2007
Subject: [cairo] scale with text
In-Reply-To: <1172264028.3100.3.camel@localhost.localdomain>
References: <1171718525.5636.8.camel@underworth>
	<87odnsybvn.wl%cworth@cworth.org> <1171736441.5636.16.camel@underworth>
	<87mz3cy4z1.wl%cworth@cworth.org> <1171742627.5636.30.camel@underworth>
	<87hctkxx3p.wl%cworth@cworth.org> <1172226862.18202.6.camel@underworth>
	<1172254461.10382.10.camel@underworth>
	<1172264028.3100.3.camel@localhost.localdomain>
Message-ID: <1173123197.18079.46.camel@behdad>

On Fri, 2007-02-23 at 15:53 -0500, Damon Chaplin wrote:
> 
> Are you using Pango? If you are, you need to set the font options on
> the pango context rather than the cairo context (this one took me ages
> to figure out):

Ah, good point.  Unfortunately a bit hard to fix at this point...

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From mathias.hasselmann at gmx.de  Mon Mar  5 11:33:26 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Mon Mar  5 11:33:42 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <87y7mbk4h0.wl%cworth@cworth.org>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
	<1173019474.17604.17.camel@dali> <1173043926.9109.10.camel@behdad>
	<1173075763.5590.8.camel@dali> <1173087730.20769.7.camel@dali>
	<87y7mbk4h0.wl%cworth@cworth.org>
Message-ID: <1173123206.10240.5.camel@dali>

Next attempt. Copyright stuff cleaned up in third patch.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 01-remove-problems-causing--werror-to-fail.patch
Type: text/x-patch
Size: 12347 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/420df89b/01-remove-problems-causing--werror-to-fail-0001.bin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 02-initialize-mutexes-at-central-location-.patch
Type: text/x-patch
Size: 24635 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/420df89b/02-initialize-mutexes-at-central-location--0001.bin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 03-copyright-cleanups-and-mutex-finalization-on-os2.patch
Type: text/x-patch
Size: 4260 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/420df89b/03-copyright-cleanups-and-mutex-finalization-on-os2-0001.bin
From Marty.Sherrill at celera.com  Mon Mar  5 11:52:09 2007
From: Marty.Sherrill at celera.com (Marty Sherrill)
Date: Mon Mar  5 11:56:23 2007
Subject: [cairo] How to crop image surface?
Message-ID: <OFDBD150B6.19472531-ON85257295.006CB487-85257295.006D2555@applera.com>

Hello all,

I'm looking for help understanding how to crop an image (or otherwise set 
its dimensions) in memory just after it's drawn.  I'm drawing images that 
need to be different sizes according to their content, and it's not 
practical to figure out the dimensions before doing the actual drawing.

I have the idea in mind to draw on a larger-than-necessary surface, track 
the extents of my drawing, and then crop off the extra space.

Is that a good approach?  If so, could I get some advice as to how the 
cropping step can be accomplished?

Best regards,

 - Marty
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070305/b52b6586/attachment.htm
From behdad at behdad.org  Mon Mar  5 12:01:36 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 12:01:34 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <1173123206.10240.5.camel@dali>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
	<1173019474.17604.17.camel@dali> <1173043926.9109.10.camel@behdad>
	<1173075763.5590.8.camel@dali> <1173087730.20769.7.camel@dali>
	<87y7mbk4h0.wl%cworth@cworth.org>  <1173123206.10240.5.camel@dali>
Message-ID: <1173124897.18079.64.camel@behdad>

On Mon, 2007-03-05 at 20:33 +0100, Mathias Hasselmann wrote:
> Next attempt. Copyright stuff cleaned up in third patch.

Quick note:

  - all non-public headers should end in "-private.h".  This is relied
on in the documentation generation stuff.  We talked about moving to a
scheme that all non-public headers don't start with "cairo-", but that's
not been done so far.

  - Please rename all mutexes to be in the shape "_cairo_*_mutex", since
they are not static anymore.  We can go a bit further and make the
CAIRO_MUTEX_* macros do the namespacing for us, but we typically avoid
name mangling in cairo. 

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From cworth at cworth.org  Mon Mar  5 12:12:21 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar  5 12:12:38 2007
Subject: [cairo] Re: [cairo-commit] 6 commits -
	doc/public	src/cairo.c	src/cairo-gstate.c
	src/cairo.h	src/cairoint.h	src/cairo-quartz-surface.c	src/cairo-scaled-font.c	test/font-face-get-type.c
	TODO
In-Reply-To: <1173122401.18079.40.camel@behdad>
References: <20070228012213.9B4A110089@kemper.freedesktop.org>
	<87lkigkmey.wl%cworth@cworth.org>
	<1173122401.18079.40.camel@behdad>
Message-ID: <87wt1vbgbe.wl%cworth@cworth.org>

On Mon, 05 Mar 2007 14:20:01 -0500, Behdad Esfahbod wrote:
> On Fri, 2007-03-02 at 04:46 -0500, Carl Worth wrote:
> Well, I wrote a proposal to the list:
>
>   http://lists.freedesktop.org/archives/cairo/2007-January/009374.html

Ah, my mistake then. Sorry for my short memory.

It was really the funny NULL semantics I was worried about, but then I
realized that was never part of the proposal and just a cut-and-paste
bug of some stale documentation.

All looks good now I think.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/623ea04e/attachment.pgp
From daveryeo at telus.net  Mon Mar  5 11:15:30 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Mon Mar  5 12:27:39 2007
Subject: Which thread lib to use on Win32 and other systems (was Re:
	[cairo] Recommendations for 1.4.0
Message-ID: <20070305191447.2BA0JD2XQ9@priv-edmwaa06.telusplanet.net>

On Mon, 5 Mar 2007 20:30:59 +0200, Tor Lillqvist wrote:

>Behdad Esfahbod writes:
> > which thread library should we prefer: pthread or native threads?
>
>You mean just on Win32, or in general? Depends on how "foreign"
>pthreads is on the platform in question. On most modern Unixes,
>pthread comes with the OS, and is pretty close to native threads,
>isn't it? The pthread API is used by much (most?) GNOMEish or KDEish
>software already anyway on such platforms, yes?
>
>But on Win32 pthreads-win32 is a 3rd-party DLL. No reason to drag in a
>pthreads dependency there just for something as simple as in-process
>mutexes.
>
> > I think the current "prefer pthread" is Ok if we provide a
> > --without-pthread option. Comments?
>
>Sounds OK.
>
>--tml

I would have to agree with the above as on OS/2 pthreads is also a
third party lib and IIRC is not 100%. Also in general native threads
should be more efficient
Still nice to have choice
Dave

From daveryeo at telus.net  Mon Mar  5 11:11:03 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Mon Mar  5 12:27:52 2007
Subject: [cairo] Recommendations for 1.4.0
Message-ID: <20070305191019.37TSUM8M93@priv-edmwaa05.telusplanet.net>

On Mon, 05 Mar 2007 09:38:08 -0800, Carl Worth wrote:

>We got reports of what was broken on win32 and we fixed that. I don't
>think we've gotten any reports from os2 and beos, so we can just make
>our best attempt, (without a compiler to verify).

Currently an OS/2 build ends here
 gcc.exe -Zdll .libs/cairoDi.dll.def   .libs/cairo.o .libs/cairo-arc.o .libs/cairo-array.o .libs/cairo-base85-stream.o .libs/cairo-bentley-ottmann.o .libs/cairo-cache.o .libs/cairo-clip.o .libs/cairo-color.o .libs/cairo-debug.o .libs/cairo-deflate-stream.o .libs/cairo-fixed.o .libs/cairo-font.o .libs/cairo-font-options.o .libs/cairo-freelist.o .libs/cairo-gstate.o .libs/cairo-hash.o .libs/cairo-hull.o .libs/cairo-image-surface.o .libs/cairo-lzw.o .libs/cairo-matrix.o .libs/cairo-operator.o .libs/cairo-path.o .libs/cairo-path-bounds.o .libs/cairo-path-fill.o .libs/cairo-path-fixed.o .libs/cairo-path-stroke.o .libs/cairo-pen.o .libs/cairo-polygon.o .libs/cairo-rectangle.o .libs/cairo-region.o .libs/cairo-scaled-font.o .libs/cairo-skiplist.o .libs/cairo-slope.o .libs/cairo-spline.o .libs/cairo-stroke-style.o .libs/cairo-surface.o .libs/cairo-surface-fallback.o .libs/cairo-traps.o .libs/cairo-pattern.o .libs/cairo-unicode.o .libs/cairo-output-stream.o .libs/cairo-wideint.o .libs/cairo-meta-surface.o .libs/cairo-
paginated-surface.o .libs/cairo-analysis-surface.o .libs/cairo-ft-font.o .libs/cairo-ps-surface.o .libs/cairo-pdf-surface.o .libs/cairo-png.o .libs/cairo-svg-surface.o .libs/cairo-cff-subset.o .libs/cairo-truetype-subset.o .libs/cairo-type1-fallback.o .libs/cairo-scaled-font-subsets.o .libs/cairo-type1-subset.o .libs/cairo-os2-surface.o .libs/libcairo.lax/libpixman_s.a/fbcompose.o  .libs/libcairo.lax/libpixman_s.a/fbedge.o  .libs/libcairo.lax/libpixman_s.a/fbpict.o  .libs/libcairo.lax/libpixman_s.a/fbtrap.o  .libs/libcairo.lax/libpixman_s.a/icblt.o  .libs/libcairo.lax/li
bpixman_s.a/icbltone.o  .libs/libcairo.lax/libpixman_s.a/iccolor.o  .libs/libcairo.lax/libpixman_s.a/icformat.o  .libs/libcairo.lax/libpixman_s.a/icimage.o  .libs/libcairo.lax/libpixman_s.a/icpixels.o  .libs/libcairo.lax/libpixman_s.a/icrect.o  .libs/libcairo.lax/libpixman_s.a/icstipple.o  .libs/libcairo.lax/libpixman_s.a/ictransform.o  .libs/libcairo.lax/libpixman_s.a/ictrap.o  .libs/libcairo.lax/libpixman_s.a/ictri.o  .libs/libcairo.lax/libpixman_s.a/icutil.o  .libs/libcairo.lax/libpixman_s.a/pixregion.o  .libs/libcairo.lax/libpixman_s.a/renderedge.o    -L/usr/local/lib /usr/local/lib/libfreetype_dll.a /usr/local/lib/libfontconfig_dll.a /usr/local/lib/libpng12_dll.a -lz    -o .libs/cairoDi.dll
cairo-font.c:96 (.libs/cairo-font.o): Undefined symbol _cairo_font_face_mutex referenced from text segment
...
cairo-font.c:0 (.libs/cairo-font.o): More undefined symbol _cairo_font_face_mutex refs follow
make[3]: *** [libcairo.la] Error 1

The attached patch seems to do the right thing, at least allowing the build to finish.
Also here is a patch against test/makefile.am allowing make check to get much further.
More work needs to be done on this as make check still fails when building a8-mask (should be a8-mask.exe) so this patch perhaps could go in after the release of 1.4.0
Dave

-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/octet-stream
Size: 2249 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/dd38ae35/attachment.obj
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/octet-stream
Size: 951 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/dd38ae35/attachment-0001.obj
From hans at breuer.org  Mon Mar  5 12:39:48 2007
From: hans at breuer.org (Hans Breuer)
Date: Mon Mar  5 12:39:56 2007
Subject: Which thread lib to use on Win32 and other systems (was
	Re:	[cairo] Recommendations for 1.4.0
In-Reply-To: <1173115232.14796.11.camel@behdad>
References: <1172956400.25990.31.camel@behdad> <45E9ECC7.6070505@breuer.org>
	<1173115232.14796.11.camel@behdad>
Message-ID: <45EC8014.6090608@breuer.org>

On 05.03.2007 18:20, Behdad Esfahbod wrote:
> On Sat, 2007-03-03 at 22:46 +0100, Hans Breuer wrote:
>> For win32 you can just apply the following patch.
> 
> Thanks Hans.  A question for you, tml, and other backend maintainers:
> which thread library should we prefer: pthread or native threads?
> This concerns Win32, and OS/2 at least.
> 
Haven't looked into pthreads lately (it is rumoured that it improved a lot
over the years), I'm  still prefering the native threads API. Adding just
another dependecy just to do some locking looks excessive to me.

> I think the current "prefer pthread" is Ok if we provide a
> --without-pthread option.  Comments?
> 
My msvc build of cairo does not use configure so there is no --without-*
switch either. But if native threads remain supported I don't care much
about the default ...

Regards,
	Hans

-------- Hans "at" Breuer "dot" Org -----------
Tell me what you need, and I'll tell you how to
get along without it.                -- Dilbert
From tor at cs.brown.edu  Mon Mar  5 12:20:21 2007
From: tor at cs.brown.edu (T Rowley)
Date: Mon Mar  5 12:42:33 2007
Subject: [cairo] Image surface pixel twiddling API
Message-ID: <45EC7B85.7040600@cs.brown.edu>

In implementing SVG filters in mozilla, we have the need to access and 
modify individual pixels of an image.  Our existing code relied on a 
particular byte layout, which broke when tested on a big-endian cpu for 
reasons that were obvious after taking a close read of cairo.h.

We would like an API to obtain the particular channel of a pixel.  In 
our experiments we tried two different types of API.  The first was a 
set of macros that returned a particular channel from pixel word [1], 
the second were channel offset macros that could be used to index into a 
byte pointer.  For our use, the first approach of word accessors made 
for somewhat messier source code and generated code that was slightly 
slower for x86 though faster on PPC [3].  For that reason we're more in 
favor of the channel offsets, but would like to hear feedback from 
others about what seems best.

[1] https://bugzilla.mozilla.org/attachment.cgi?id=254325

[2] https://bugzilla.mozilla.org/attachment.cgi?id=256528

[3] https://bugzilla.mozilla.org/show_bug.cgi?id=369528#c9
From hans at breuer.org  Mon Mar  5 12:51:40 2007
From: hans at breuer.org (Hans Breuer)
Date: Mon Mar  5 12:51:49 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <87wt1vk2v3.wl%cworth@cworth.org>
References: <1172956400.25990.31.camel@behdad>
	<87wt1vk2v3.wl%cworth@cworth.org>
Message-ID: <45EC82DC.1090808@breuer.org>

On 05.03.2007 18:38, Carl Worth wrote:
> On Sat, 03 Mar 2007 16:13:20 -0500, Behdad Esfahbod wrote:
[...]
>>   - Fix mutex initialization in win32, os2, and beos backends.  They are
>> out of synch with the actually mutexes declared, and that causes link
>> errors if not using pthread on win32.  I'm wondering if we should go for
>> the backup plan:
> 
> I'm glad to see the new plan coming together now. But I'm hesitant to
> do anything to major right now.
> 
> A problem that we have is that we don't have a lot of people doing
> regular build-testing on non-Linux platforms between snapshots. So I
> don't want to risk breaking the build again between 1.3.16 and 1.4.0.
> 
One way to improve this (at least for me) would be a more accessible
version control system. Even if the svn server would be at sourceforge
though I would prefer svn.gnome.org ;)

Any experience with git-svn:
http://www.kernel.org/pub/software/scm/git/docs/git-svn.html

Thanks,
	Hans

-------- Hans "at" Breuer "dot" Org -----------
Tell me what you need, and I'll tell you how to
get along without it.                -- Dilbert
From emmanuel.pacaud at lapp.in2p3.fr  Mon Mar  5 12:52:24 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Mon Mar  5 12:52:30 2007
Subject: [cairo] SVG radial gradient fix
Message-ID: <1173127944.26632.8.camel@hobbes>

Hi,

It looks like the patch below fixes the radial gradient test for SVG
surface. The output is not exactly the same as the reference one, but it
should be good enough. I've attached the resulting svg file and what
librsvg renders (batik rendering looks the same).

Comments ?

	Emmanuel.

diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index 2b2b2fe..f1cd4bc 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -1190,11 +1190,29 @@ emit_surface_pattern (cairo_svg_surface_t	*surface,
 static void
 emit_pattern_stops (cairo_output_stream_t *output,
 		    cairo_gradient_pattern_t const *pattern,
-		    double start_offset)
+		    double start_offset,
+		    cairo_extend_t extend)
 {
     double offset;
-    unsigned int i;
-
+    unsigned int i, stop_index;
+
+    if (start_offset > 0.0 
+	&& (extend == CAIRO_EXTEND_REPEAT 
+	    || extend == CAIRO_EXTEND_REFLECT))
+	for (i = 0; i < pattern->n_stops; i++) {
+	    offset = start_offset *
+		_cairo_fixed_to_double (pattern->stops[i].x);
+	    stop_index = (extend == CAIRO_EXTEND_REPEAT) ? i : pattern->n_stops - i - 1; 
+	    _cairo_output_stream_printf (output,
+					 "<stop offset=\"%f\" style=\""
+					 "stop-color: rgb(%f%%,%f%%,%f%%); "
+					 "stop-opacity: %f;\"/>\n",
+					 offset,
+					 pattern->stops[stop_index].color.red   / 655.35,
+					 pattern->stops[stop_index].color.green / 655.35,
+					 pattern->stops[stop_index].color.blue  / 655.35,
+					 pattern->stops[stop_index].color.alpha / 65535.0);
+	}
     for (i = 0; i < pattern->n_stops; i++) {
 	offset = start_offset + (1 - start_offset ) *
 	    _cairo_fixed_to_double (pattern->stops[i].x);
@@ -1222,9 +1240,7 @@ emit_pattern_extend (cairo_output_stream_t *output,
 	    _cairo_output_stream_printf (output, "spreadMethod=\"reflect\" ");
 	    break;
 	case CAIRO_EXTEND_NONE:
-	    break;
 	case CAIRO_EXTEND_PAD:
-	    /* FIXME not implemented */
 	    break;
     }
 }
@@ -1256,7 +1272,7 @@ emit_linear_pattern (cairo_svg_surface_t    *surface,
     cairo_matrix_invert (&p2u);
     emit_transform (document->xml_node_defs, "gradientTransform", ">\n", &p2u);
 
-    emit_pattern_stops (document->xml_node_defs ,&pattern->base, 0.0);
+    emit_pattern_stops (document->xml_node_defs ,&pattern->base, 0.0, CAIRO_EXTEND_NONE);
 
     _cairo_output_stream_printf (document->xml_node_defs,
 				 "</linearGradient>\n");
@@ -1290,13 +1306,8 @@ emit_radial_pattern (cairo_svg_surface_t    *surface,
     /* SVG doesn't have a start radius, so computing now SVG focal coordinates
      * and emulating start radius by translating color stops.
      * FIXME: Handle radius1 <= radius0 */
-    if (pattern->base.base.extend == CAIRO_EXTEND_NONE) {
-	fx = x0;
-	fy = y0;
-    } else {
-	fx = (r1 * x0 - r0 * x1) / (r1 - r0);
-	fy = (r1 * y0 - r0 * y1) / (r1 - r0);
-    }
+    fx = (r1 * x0 - r0 * x1) / (r1 - r0);
+    fy = (r1 * y0 - r0 * y1) / (r1 - r0);
 
     _cairo_output_stream_printf (document->xml_node_defs,
 				 "<radialGradient id=\"radial%d\" "
@@ -1327,7 +1338,7 @@ emit_radial_pattern (cairo_svg_surface_t    *surface,
 					 "stop-opacity: 0;\"/>\n",
 					 r0 / r1);
     }
-    emit_pattern_stops (document->xml_node_defs, &pattern->base, r0 / r1);
+    emit_pattern_stops (document->xml_node_defs, &pattern->base, r0 / r1, pattern->base.base.extend);
     if (pattern->base.base.extend == CAIRO_EXTEND_NONE)
 	_cairo_output_stream_printf (document->xml_node_defs,
 				     "<stop offset=\"1.0\" style=\""
-------------- next part --------------
A non-text attachment was scrubbed...
Name: radial-gradient-svg-argb32-out.jpg
Type: image/jpeg
Size: 46693 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/db49f2cf/radial-gradient-svg-argb32-out-0001.jpg
-------------- next part --------------
A non-text attachment was scrubbed...
Name: radial-gradient-svg-argb32-out.svg.zip
Type: application/zip
Size: 1567 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/db49f2cf/radial-gradient-svg-argb32-out.svg-0001.zip
From behdad at behdad.org  Mon Mar  5 13:01:40 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 13:01:38 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <20070305191019.37TSUM8M93@priv-edmwaa05.telusplanet.net>
References: <20070305191019.37TSUM8M93@priv-edmwaa05.telusplanet.net>
Message-ID: <1173128500.18079.71.camel@behdad>

On Mon, 2007-03-05 at 11:11 -0800, Dave Yeo wrote:
> On Mon, 05 Mar 2007 09:38:08 -0800, Carl Worth wrote:
> 
> >We got reports of what was broken on win32 and we fixed that. I don't
> >think we've gotten any reports from os2 and beos, so we can just make
> >our best attempt, (without a compiler to verify).
> 
> Currently an OS/2 build ends here
>  gcc.exe -Zdll .libs/cairoDi.dll.def   .libs/cairo.o .libs/cairo-arc.o .libs/cairo-array.o .libs/cairo-base85-stream.o .libs/cairo-bentley-ottmann.o .libs/cairo-cache.o .libs/cairo-clip.o .libs/cairo-color.o .libs/cairo-debug.o .libs/cairo-deflate-stream.o .libs/cairo-fixed.o .libs/cairo-font.o .libs/cairo-font-options.o .libs/cairo-freelist.o .libs/cairo-gstate.o .libs/cairo-hash.o .libs/cairo-hull.o .libs/cairo-image-surface.o .libs/cairo-lzw.o .libs/cairo-matrix.o .libs/cairo-operator.o .libs/cairo-path.o .libs/cairo-path-bounds.o .libs/cairo-path-fill.o .libs/cairo-path-fixed.o .libs/cairo-path-stroke.o .libs/cairo-pen.o .libs/cairo-polygon.o .libs/cairo-rectangle.o .libs/cairo-region.o .libs/cairo-scaled-font.o .libs/cairo-skiplist.o .libs/cairo-slope.o .libs/cairo-spline.o .libs/cairo-stroke-style.o .libs/cairo-surface.o .libs/cairo-surface-fallback.o .libs/cairo-traps.o .libs/cairo-pattern.o .libs/cairo-unicode.o .libs/cairo-output-stream.o .libs/cairo-wideint.o .libs/cairo-meta-surface.o .libs/cairo-
> paginated-surface.o .libs/cairo-analysis-surface.o .libs/cairo-ft-font.o .libs/cairo-ps-surface.o .libs/cairo-pdf-surface.o .libs/cairo-png.o .libs/cairo-svg-surface.o .libs/cairo-cff-subset.o .libs/cairo-truetype-subset.o .libs/cairo-type1-fallback.o .libs/cairo-scaled-font-subsets.o .libs/cairo-type1-subset.o .libs/cairo-os2-surface.o .libs/libcairo.lax/libpixman_s.a/fbcompose.o  .libs/libcairo.lax/libpixman_s.a/fbedge.o  .libs/libcairo.lax/libpixman_s.a/fbpict.o  .libs/libcairo.lax/libpixman_s.a/fbtrap.o  .libs/libcairo.lax/libpixman_s.a/icblt.o  .libs/libcairo.lax/li
> bpixman_s.a/icbltone.o  .libs/libcairo.lax/libpixman_s.a/iccolor.o  .libs/libcairo.lax/libpixman_s.a/icformat.o  .libs/libcairo.lax/libpixman_s.a/icimage.o  .libs/libcairo.lax/libpixman_s.a/icpixels.o  .libs/libcairo.lax/libpixman_s.a/icrect.o  .libs/libcairo.lax/libpixman_s.a/icstipple.o  .libs/libcairo.lax/libpixman_s.a/ictransform.o  .libs/libcairo.lax/libpixman_s.a/ictrap.o  .libs/libcairo.lax/libpixman_s.a/ictri.o  .libs/libcairo.lax/libpixman_s.a/icutil.o  .libs/libcairo.lax/libpixman_s.a/pixregion.o  .libs/libcairo.lax/libpixman_s.a/renderedge.o    -L/usr/local/lib /usr/local/lib/libfreetype_dll.a /usr/local/lib/libfontconfig_dll.a /usr/local/lib/libpng12_dll.a -lz    -o .libs/cairoDi.dll
> cairo-font.c:96 (.libs/cairo-font.o): Undefined symbol _cairo_font_face_mutex referenced from text segment
> ...
> cairo-font.c:0 (.libs/cairo-font.o): More undefined symbol _cairo_font_face_mutex refs follow
> make[3]: *** [libcairo.la] Error 1
> 
> The attached patch seems to do the right thing, at least allowing the build to finish.
> Also here is a patch against test/makefile.am allowing make check to get much further.
> More work needs to be done on this as make check still fails when building a8-mask (should be a8-mask.exe) so this patch perhaps could go in after the release of 1.4.0
> Dave

These should all be fixed in the set of commits I just pushed.  Please
test and let us know.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar  5 13:05:40 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 13:05:37 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173102817.24503.7.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
Message-ID: <1173128740.18079.75.camel@behdad>

On Mon, 2007-03-05 at 08:53 -0500, Frederic Crozat wrote:
> 
> You need to apply first fix and second one in sequence (I've undo some
> of the change I did in my first patch, which aren't really needed). 

In that case, would you mind giving us a final combined patch, without
any formatting changes please?

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From brian.ewins at gmail.com  Mon Mar  5 14:00:40 2007
From: brian.ewins at gmail.com (Baz)
Date: Mon Mar  5 14:00:44 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <1173107531.13318.9.camel@behdad>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<1173107531.13318.9.camel@behdad>
Message-ID: <2faad3050703051400j746ec21dy389ed0e2bdcdca43@mail.gmail.com>

On 05/03/07, Behdad Esfahbod <behdad@behdad.org> wrote:
> Humm, actually I want to revert that.  No backends in cairo should ever
> be exclusive.  In fact for 1.4.2, I want to make sure that no font
> backend is tied to any particular surface, and any font backend can be
> used with any surface.

Ok, mea culpa. If any-with-any is wanted, how about the patch below
(for 1.4.2). It makes quartz and atsui independent again. Doesn't fix
the quartz-xlib issue in cairo-backend.

This produces nice results with quartz+ft, the known rotation/scaling
errors in quartz+atsui, and works with image+atsui (no quartz). It may
even work with xlib+atsui once the other issues are sorted. Previously
I've tried using atsui glyph surfaces in firefox, and I got no text on
controls though, so there might be problems I havent seen with
quartz+ft. The only other issue is that I don't think old_show_glyphs
in atsui is used any more, it could just be removed (in a separate
patch).

-Baz

PS I won't be so quick off the mark pushing this one, sorry :)

diff --git a/configure.in b/configure.in
index 8608f10..b023c4c 100644
--- a/configure.in
+++ b/configure.in
@@ -269,13 +269,9 @@ CAIRO_BACKEND_ENABLE(xcb, XCB, xcb, XCB_SURFACE, no, [
 dnl ===========================================================================

 CAIRO_BACKEND_ENABLE(quartz, Quartz, quartz, QUARTZ_SURFACE, no, [
-  if test "x$use_xlib" = "xyes"; then
-    use_quartz="no (requires --disable-xlib)";
-  else
-    dnl There is no pkgconfig for quartz; lets do a header check
-    AC_CHECK_HEADER(Carbon/Carbon.h, , [use_quartz="no (Carbon
headers not found)"])
-    quartz_LIBS="-Xlinker -framework -Xlinker Carbon"
-  fi
+  dnl There is no pkgconfig for quartz; lets do a header check
+  AC_CHECK_HEADER(Carbon/Carbon.h, , [use_quartz="no (Carbon headers
not found)"])
+  quartz_LIBS="-Xlinker -framework -Xlinker Carbon"
 ])

 dnl ===========================================================================
@@ -572,9 +568,10 @@ dnl
===========================================================================
 dnl This check should default to 'auto' once we have code to actually
 dnl check for the atsui font backend.

-CAIRO_BACKEND_ENABLE(atsui, ATSUI font, atsui, ATSUI_FONT, auto, [
-  dnl Quartz requires and is required by atsui.
-  use_atsui=$use_quartz
+CAIRO_BACKEND_ENABLE(atsui, ATSUI font, atsui, ATSUI_FONT, no, [
+  dnl There is no pkgconfig for atsui; lets do a header check
+  AC_CHECK_HEADER(Carbon/Carbon.h, , [use_atsui="no (Carbon headers
not found)"])
+  atsui_LIBS="-Xlinker -framework -Xlinker Carbon"
 ])

 dnl ===========================================================================
diff --git a/src/cairo-atsui-font.c b/src/cairo-atsui-font.c
index fff7a22..1eb95b7 100644
--- a/src/cairo-atsui-font.c
+++ b/src/cairo-atsui-font.c
@@ -908,6 +908,7 @@ _cairo_atsui_font_text_to_glyphs (void
 *abstract_font,
     return CAIRO_STATUS_SUCCESS;
 }

+#if CAIRO_HAS_QUARTZ_SURFACE
 static cairo_int_status_t
 _cairo_atsui_font_old_show_glyphs (void                       *abstract_font,
                                   cairo_operator_t     op,
@@ -1024,6 +1025,7 @@ _cairo_atsui_font_old_show_glyphs (void
        *abstract_font,

     return CAIRO_STATUS_SUCCESS;
 }
+#endif /* CAIRO_HAS_QUARTZ_SURFACE */

 cairo_bool_t
 _cairo_scaled_font_is_atsui (cairo_scaled_font_t *sfont)
@@ -1078,7 +1080,11 @@ const cairo_scaled_font_backend_t
cairo_atsui_scaled_font_backend = {
     _cairo_atsui_font_scaled_glyph_init,
     _cairo_atsui_font_text_to_glyphs,
     NULL, /* ucs4_to_index */
+#if CAIRO_HAS_QUARTZ_SURFACE
     _cairo_atsui_font_old_show_glyphs,
+#else
+    NULL,
+#endif /* CAIRO_HAS_QUARTZ_SURFACE */
     _cairo_atsui_load_truetype_table,
     NULL, /* map_glyphs_to_unicode */
 };
diff --git a/src/cairo-quartz-private.h b/src/cairo-quartz-private.h
index 1000e73..d3c9c6b 100644
--- a/src/cairo-quartz-private.h
+++ b/src/cairo-quartz-private.h
@@ -39,6 +39,8 @@
 #define CAIRO_QUARTZ_PRIVATE_H

 #include <cairoint.h>
+
+#ifdef CAIRO_HAS_QUARTZ_SURFACE
 #include <cairo-quartz.h>

 typedef struct cairo_nquartz_surface {
@@ -59,7 +61,9 @@ typedef struct cairo_nquartz_surface {
     CGShadingRef sourceShading;
     CGPatternRef sourcePattern;
 } cairo_nquartz_surface_t, cairo_quartz_surface_t;
+#endif /* CAIRO_HAS_QUARTZ_SURFACE */

+#if CAIRO_HAS_ATSUI_FONT
 cairo_bool_t
 _cairo_scaled_font_is_atsui (cairo_scaled_font_t *sfont);

@@ -68,5 +72,6 @@ _cairo_atsui_scaled_font_get_atsu_style
(cairo_scaled_font_t *sfont);

 ATSUFontID
 _cairo_atsui_scaled_font_get_atsu_font_id (cairo_scaled_font_t *sfont);
+#endif /* CAIRO_HAS_ATSUI_FONT */

 #endif /* CAIRO_QUARTZ_PRIVATE_H */
diff --git a/src/cairo-quartz-surface.c b/src/cairo-quartz-surface.c
index 86b39f9..d601aae 100644
--- a/src/cairo-quartz-surface.c
+++ b/src/cairo-quartz-surface.c
@@ -1239,6 +1239,7 @@ _cairo_nquartz_surface_stroke (void *abstract_surface,
     return rv;
 }

+#if CAIRO_HAS_ATSUI_FONT
 static cairo_int_status_t
 _cairo_nquartz_surface_show_glyphs (void *abstract_surface,
                                    cairo_operator_t op,
@@ -1351,6 +1352,7 @@ _cairo_nquartz_surface_show_glyphs (void
*abstract_surface,

     return rv;
 }
+#endif /* CAIRO_HAS_ATSUI_FONT */

 static cairo_int_status_t
 _cairo_nquartz_surface_mask (void *abstract_surface,
@@ -1455,7 +1457,11 @@ static const struct _cairo_surface_backend
cairo_nquartz_surface_backend = {
     _cairo_nquartz_surface_mask,
     _cairo_nquartz_surface_stroke,
     _cairo_nquartz_surface_fill,
+#if CAIRO_HAS_ATSUI_FONT
     _cairo_nquartz_surface_show_glyphs,
+#else
+    NULL, /* surface_show_glyphs */
+#endif /* CAIRO_HAS_ATSUI_FONT */

     NULL, /* snapshot */
 };
From behdad at behdad.org  Mon Mar  5 14:43:27 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 14:43:33 2007
Subject: [cairo] cairo 1.3.16 with quartz and atsui
In-Reply-To: <2faad3050703051400j746ec21dy389ed0e2bdcdca43@mail.gmail.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<1173107531.13318.9.camel@behdad>
	<2faad3050703051400j746ec21dy389ed0e2bdcdca43@mail.gmail.com>
Message-ID: <1173134607.18079.82.camel@behdad>

On Mon, 2007-03-05 at 22:00 +0000, Baz wrote:
> 
> Ok, mea culpa. If any-with-any is wanted, how about the patch below
> (for 1.4.2). It makes quartz and atsui independent again. Doesn't fix
> the quartz-xlib issue in cairo-backend.
> 
> This produces nice results with quartz+ft, the known rotation/scaling
> errors in quartz+atsui, and works with image+atsui (no quartz). It may
> even work with xlib+atsui once the other issues are sorted. Previously
> I've tried using atsui glyph surfaces in firefox, and I got no text on
> controls though, so there might be problems I havent seen with
> quartz+ft. The only other issue is that I don't think old_show_glyphs
> in atsui is used any more, it could just be removed (in a separate
> patch).

Thanks.  Looks really good.  I'd suggest you remove
_cairo_scaled_font_is_atsui() and directly use:

  if (cairo_scaled_font_get_type (scaled_font) != CAIRO_FONT_TYPE_ATSUI)
	return CAIRO_INT_STATUS_UNSUPPORTED;

That's what win32-surface.c does for example.

After that, I'm fine with you pushing this.

> -Baz 
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar  5 14:47:52 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 14:47:49 2007
Subject: [cairo] Decoupling win32-surface and win32-font
Message-ID: <1173134872.18079.88.camel@behdad>

So, similar to the recent discussion about quartz and atsui, I want to
see it possible to use win32-font with non-win32 backends and vice
versa.  The case of win32-surface without win32-font should already
work.  win32-font needs some fixes to not assume win32-surfaces though.
Should be easy to fix for 1.4.2.

What may not be easy to fix later however is the fact that there is no
cairo-win32-font.h and those functions are put in cairo-win32.h.  For
the least, I want to suggest that we wrap them with #if
CAIRO_HAS_WIN32_FONT correctly.  Or better, add a new header,
cairo-win32-font.h, and have cairo-win32.h include it for backward
compatibility.

Thoughts?

(in the same line, we still need to fix xlib compilation without ft and
render, but I'm only concerned about public API right now.)

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From daveryeo at telus.net  Mon Mar  5 15:14:11 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Mon Mar  5 15:13:33 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
Message-ID: <20070305231324.6CXJCLKETT@priv-edtnaa05.telusplanet.net>

On Mon, 05 Mar 2007 20:33:26 +0100, Mathias Hasselmann wrote:

>Next attempt. Copyright stuff cleaned up in third patch.
>

Sorry for not noticing sooner but in eg cairo-mutex-private.h you have
+#elif defined __OS2__
This should really be
+#elif defined CAIRO_HAS_OS2_SURFACE
as the __OS2__ could break an xlib build on OS/2, especially if using
pthreads.
Dave

From cworth at cworth.org  Mon Mar  5 16:06:34 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar  5 16:07:22 2007
Subject: [cairo] SVG radial gradient fix
In-Reply-To: <1173127944.26632.8.camel@hobbes>
References: <1173127944.26632.8.camel@hobbes>
Message-ID: <87vehfb5h1.wl%cworth@cworth.org>

On Mon, 05 Mar 2007 21:52:24 +0100, Emmanuel Pacaud wrote:
> It looks like the patch below fixes the radial gradient test for SVG
> surface. The output is not exactly the same as the reference one, but it
> should be good enough. I've attached the resulting svg file and what
> librsvg renders (batik rendering looks the same).

Thanks very much for this fix! I've just pushed it out now, so it
will be great to have this in place for cairo 1.4.

As is, I think that EXTEND_NONE, EXTEND_PAD, and EXTEND_REPEAT are
handled perfectly fine. However, I think the handling of
CAIRO_EXTEND_REFLECT is still slightly off and could be improved.

But regardless, it's definitely much, much better than it was before.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/cf897c3a/attachment-0001.pgp
From behdad at behdad.org  Mon Mar  5 16:34:11 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 16:34:08 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <87wt1vk2v3.wl%cworth@cworth.org>
References: <1172956400.25990.31.camel@behdad>
	<87wt1vk2v3.wl%cworth@cworth.org>
Message-ID: <1173141251.6906.8.camel@behdad>

On Mon, 2007-03-05 at 09:38 -0800, Carl Worth wrote:
> 
> Anyway, things look good for 1.4 to happen today.

Just to keep the list updated, I committed all the items that Carl
accepted, and Carl, Brian, and Emmanuel have fixed some other bits.  At
this time, there are not other changes scheduled and we should be
starting the release process.  Yay!

> Thanks to everyone for the tremendous efforts over the last several
> months.

+1.

> -Carl 
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From jeff at infidigm.net  Mon Mar  5 17:08:01 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Mon Mar  5 17:06:35 2007
Subject: [cairo] Image surface pixel twiddling API
In-Reply-To: <45EC7B85.7040600@cs.brown.edu>
References: <45EC7B85.7040600@cs.brown.edu>
Message-ID: <20070306010800.GA21850@infidigm.net>

On Mon, Mar 05, 2007 at 02:20:21PM -0600, T Rowley wrote:
> In implementing SVG filters in mozilla, we have the need to access and 
> modify individual pixels of an image.  Our existing code relied on a 
> particular byte layout, which broke when tested on a big-endian cpu for 
> reasons that were obvious after taking a close read of cairo.h.
> 
> We would like an API to obtain the particular channel of a pixel.  In 
> our experiments we tried two different types of API.  The first was a 
> set of macros that returned a particular channel from pixel word [1], 
> the second were channel offset macros that could be used to index into a 
> byte pointer.  For our use, the first approach of word accessors made 
> for somewhat messier source code and generated code that was slightly 
> slower for x86 though faster on PPC [3].

This is probably because x86 is better at byte addressing/operations.  If
it's faster on PPC it will probably be faster on ARM which I imagine is a
platform Mozilla will care about more in the future.

> For that reason we're more in favor of the channel offsets, but would
> like to hear feedback from others about what seems best.

Personally, I think the word accessors are a 'cleaner' API. However, the
offsets might be easier to use when writing byte oriented code. They might
also be useful if the inkscape people want to convert their pixel munging
routines to the same format as cairo's.

Well looking into this, I noticed that mozilla's macros for 255 division
do not do any rounding, which is sort of wrong. e.g (1 * 254) is 0 with
mozilla's code and should be 1.

To fix this at no extra cost:

#define FAST_DIVIDE_BY_255(target,v)               \
  PR_BEGIN_MACRO                                   \
    unsigned tmp_ = v;                             \
    target = ((tmp_ << 8) + tmp_ + 255) >> 16;     \
  PR_END_MACRO

should become:

#define FAST_DIVIDE_BY_255(target,v)               \
  PR_BEGIN_MACRO                                   \
    unsigned tmp_ = v + 128;                       \
    target = ((tmp_ >> 8) + tmp_) >> 8;            \
  PR_END_MACRO

and

#define GFX_DIVIDE_BY_255(v)  \
     (((((unsigned)(v)) << 8) + ((unsigned)(v)) + 255) >> 16

becomes:

#define GFX_DIVIDE_BY_255(v)  \
     ((((unsigned)(v) + 128) >> 8) + ((unsigned)(v) + 128)) >> 8

In this case the compiler's common subexpression elimination should take
care of combining the two '+ 128' so that it is only performed once.

If anyone is interested, the derivation of the correct formula is in a
paper by Jim Blinn called "Three wrongs make a right".

-Jeff
From daveryeo at telus.net  Mon Mar  5 17:18:03 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Mon Mar  5 17:17:21 2007
Subject: [cairo] Recommendations for 1.4.0
Message-ID: <20070306011716.B1LPUN8M1E@priv-edmwaa05.telusplanet.net>

On Mon, 05 Mar 2007 16:01:40 -0500, Behdad Esfahbod wrote:

>On Mon, 2007-03-05 at 11:11 -0800, Dave Yeo wrote:
>> On Mon, 05 Mar 2007 09:38:08 -0800, Carl Worth wrote:
>> 
>> >We got reports of what was broken on win32 and we fixed that. I don't
>> >think we've gotten any reports from os2 and beos, so we can just make
>> >our best attempt, (without a compiler to verify).
>> 
>> Currently an OS/2 build ends here
...
>
>These should all be fixed in the set of commits I just pushed.  Please
>test and let us know.
>
>-- 
>behdad
>http://behdad.org/

Ok, much better now. Make check still fails when building a8-mask, so
still needing more $(EXEEXT) somewhere. Unluckily test/Makefile.am
seems to be getting more cryptic.
Dave

From behdad at behdad.org  Mon Mar  5 18:01:00 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar  5 18:00:57 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <20070306011716.B1LPUN8M1E@priv-edmwaa05.telusplanet.net>
References: <20070306011716.B1LPUN8M1E@priv-edmwaa05.telusplanet.net>
Message-ID: <1173146460.6906.27.camel@behdad>

On Mon, 2007-03-05 at 17:18 -0800, Dave Yeo wrote:
> 
> Ok, much better now. Make check still fails when building a8-mask, so
> still needing more $(EXEEXT) somewhere. Unluckily test/Makefile.am
> seems to be getting more cryptic.
> Dave 

Can you paste the error message?

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From daveryeo at telus.net  Mon Mar  5 20:19:16 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Mon Mar  5 20:18:49 2007
Subject: [cairo] Recommendations for 1.4.0
Message-ID: <20070306041828.8A8AR6DGL3@priv-edmwaa06.telusplanet.net>

On Mon, 05 Mar 2007 21:01:00 -0500, Behdad Esfahbod wrote:

>On Mon, 2007-03-05 at 17:18 -0800, Dave Yeo wrote:
>> 
>> Ok, much better now. Make check still fails when building a8-mask, so
>> still needing more $(EXEEXT) somewhere. Unluckily test/Makefile.am
>> seems to be getting more cryptic.
>> Dave 
>
>Can you paste the error message?
>
>--

Sure, though I think it is the GCC line that is in error

gcc.exe -g -O2 -o .libs/png-flatten.exe png-flatten.o 
./.libs/libcairotest_s.a -L/usr/local/lib
/usr/src/cairo-git/src/.libs/libcairo_dll.a
/usr/local/lib/libfontconfig_dll.a /usr/local/lib/libfreetype_dll.a
/usr/local/lib/expat.a /usr/local/lib/libpng12_dll.a -lz -lpthread
creating png-flatten.exe
gcc.exe -g -O2    a8-mask.c imagediff.exe png-flatten.exe   -o a8-mask
In file included from a8-mask.c:26:
cairo-test.h:30:31: cairo-boilerplate.h: No such file or directory
cairo-test.h:53:2: #error Cannot find definitions for fixed-width
integral types (uint8_t, uint32_t, \etc.)
In file included from I:/usr/include/machine/_types.h:1,
                 from I:/usr/include/sys/_types.h:42,
                 from I:/usr/include/math.h:25,
                 from cairo-test.h:60,
                 from a8-mask.c:26:
I:/usr/include/386/_types.h:51: error: syntax error before "typedef"
In file included from a8-mask.c:26:
cairo-test.h:69: error: parse error before '*' token
cairo-test.h:121: error: parse error before "CAIRO_PRINTF_FORMAT"
cairo-test.h:121: warning: data definition has no type or storage class
cairo-test.h:127: error: parse error before '*' token
cairo-test.h:128: warning: data definition has no type or storage class
cairo-test.h:130: error: parse error before '*' token
cairo-test.h:131: warning: data definition has no type or storage class
cairo-test.h:134: error: parse error before
"cairo_test_paint_checkered"
cairo-test.h:134: error: parse error before '*' token
cairo-test.h:134: warning: data definition has no type or storage class
a8-mask.c:28: error: syntax error before "static"
a8-mask.c:50: error: parse error before '*' token
a8-mask.c: In function `draw':
a8-mask.c:52: error: `cairo_surface_t' undeclared (first use in this
function)
a8-mask.c:52: error: (Each undeclared identifier is reported only once
a8-mask.c:52: error: for each function it appears in.)
a8-mask.c:52: error: `surface' undeclared (first use in this function)
a8-mask.c:53: error: `cairo_pattern_t' undeclared (first use in this
function)
a8-mask.c:53: error: `pattern' undeclared (first use in this function)
a8-mask.c:55: error: `cr' undeclared (first use in this function)
a8-mask.c:58: error: `CAIRO_FORMAT_A8' undeclared (first use in this
function)
make[3]: *** [a8-mask] Error 1
make[3]: Leaving directory `I:/usr/src/cairo-git/test'

Had a similar error since maybe 1.0.4 which clears up if building
a8-mask.exe instead of a8-mask etc and most recently very similar
results while compiling imagediff, fixed by adding $(EXEEXT). Make just
does not add includes and libs unless building an executable.
I also note that pthreads is still being linked in.
Dave 

From ken.carlino at gmail.com  Mon Mar  5 21:04:54 2007
From: ken.carlino at gmail.com (ken carlino)
Date: Mon Mar  5 21:11:40 2007
Subject: [cairo] Trying to compile cairo 1.0.2 in Fedora 5
Message-ID: <b9e408290703052104h4d666e11k51973d59d87c4650@mail.gmail.com>

Hi,
For our legacy project, I need to get cairo 1.0.2 compile under Fedora 5.

I get the following error, can you please tell me what should I do to
get cairo 1.0.2 to compile?

Thank you.

make  all-recursive
make[1]: Entering directory `/home/xma/src/cairo-1.0.2'
Making all in pixman
make[2]: Entering directory `/home/xma/src/cairo-1.0.2/pixman'
Making all in src
make[3]: Entering directory `/home/xma/src/cairo-1.0.2/pixman/src'
if /bin/sh ../../libtool --tag=CC --mode=compile gcc -DHAVE_CONFIG_H
-I. -I. -I../.. -I../.. -I.     -g -O2 -MT fbpict.lo -MD -MP -MF
".deps/fbpict.Tpo" -c -o fbpict.lo fbpict.c; \
then mv -f ".deps/fbpict.Tpo" ".deps/fbpict.Plo"; else rm -f
".deps/fbpict.Tpo"; exit 1; fi
 gcc -DHAVE_CONFIG_H -I. -I. -I../.. -I../.. -I. -g -O2 -MT fbpict.lo
-MD -MP -MF .deps/fbpict.Tpo -c fbpict.c  -fPIC -DPIC -o
.libs/fbpict.o
/tmp/ccpOMvec.s: Assembler messages:
/tmp/ccpOMvec.s:8518: Error: symbol `_cairo_pixman_composite' is
already definedmake[3]: *** [fbpict.lo] Error 1
make[3]: Leaving directory `/home/xma/src/cairo-1.0.2/pixman/src'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/xma/src/cairo-1.0.2/pixman'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/home/xma/src/cairo-1.0.2'
make: *** [all] Error 2
From daniel.amelang at gmail.com  Mon Mar  5 21:15:30 2007
From: daniel.amelang at gmail.com (Daniel Amelang)
Date: Mon Mar  5 21:15:34 2007
Subject: [cairo] Trying to compile cairo 1.0.2 in Fedora 5
In-Reply-To: <b9e408290703052104h4d666e11k51973d59d87c4650@mail.gmail.com>
References: <b9e408290703052104h4d666e11k51973d59d87c4650@mail.gmail.com>
Message-ID: <a65ae5c90703052115m304e7e9ax4e1a1bb3fead0849@mail.gmail.com>

On 3/5/07, ken carlino <ken.carlino@gmail.com> wrote:
> Hi,
> For our legacy project, I need to get cairo 1.0.2 compile under Fedora 5.
>
> I get the following error, can you please tell me what should I do to
> get cairo 1.0.2 to compile?

Sounds like this:

https://bugs.freedesktop.org/show_bug.cgi?id=5136

Does the patch found there solve your problem?

Dan
From emmanuel.pacaud at lapp.in2p3.fr  Mon Mar  5 21:59:33 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Mon Mar  5 21:59:39 2007
Subject: [cairo] SVG radial gradient fix
In-Reply-To: <87vehfb5h1.wl%cworth@cworth.org>
References: <1173127944.26632.8.camel@hobbes> <87vehfb5h1.wl%cworth@cworth.org>
Message-ID: <1173160773.7820.2.camel@hobbes>

On lun, 2007-03-05 at 16:06 -0800, Carl Worth wrote:
> On Mon, 05 Mar 2007 21:52:24 +0100, Emmanuel Pacaud wrote:
> > It looks like the patch below fixes the radial gradient test for SVG
> > surface. The output is not exactly the same as the reference one, but it
> > should be good enough. I've attached the resulting svg file and what
> > librsvg renders (batik rendering looks the same).
> 
> Thanks very much for this fix! I've just pushed it out now, so it
> will be great to have this in place for cairo 1.4.

> As is, I think that EXTEND_NONE, EXTEND_PAD, and EXTEND_REPEAT are
> handled perfectly fine. However, I think the handling of
> CAIRO_EXTEND_REFLECT is still slightly off and could be improved.
> 
> But regardless, it's definitely much, much better than it was before.

I'm sorry, but it's a dumb patch that only fixes the radial test (where
r1/r0 is approximatively an integer). Expect a real patch in a couple of
hours.

	Emmanuel. 

> -Carl
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo

From cworth at cworth.org  Mon Mar  5 22:30:40 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar  5 22:30:53 2007
Subject: [cairo] SVG radial gradient fix
In-Reply-To: <1173160773.7820.2.camel@hobbes>
References: <1173127944.26632.8.camel@hobbes> <87vehfb5h1.wl%cworth@cworth.org>
	<1173160773.7820.2.camel@hobbes>
Message-ID: <87tzwyc29b.wl%cworth@cworth.org>

On Tue, 06 Mar 2007 06:59:33 +0100, Emmanuel Pacaud wrote:
> I'm sorry, but it's a dumb patch that only fixes the radial test (where
> r1/r0 is approximatively an integer). Expect a real patch in a couple of
> hours.

Oh, and by the way, this piece of code also needs some attention to
avoid divide-by-zero errors.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070305/897af7f8/attachment-0001.pgp
From mathias.hasselmann at gmx.de  Mon Mar  5 22:11:32 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Mon Mar  5 23:07:05 2007
Subject: [cairo] Image surface pixel twiddling API
In-Reply-To: <20070306010800.GA21850@infidigm.net>
References: <45EC7B85.7040600@cs.brown.edu>
	<20070306010800.GA21850@infidigm.net>
Message-ID: <1173161492.1524.6.camel@dali>

Am Montag, den 05.03.2007, 20:08 -0500 schrieb Jeff Muizelaar:
> > We would like an API to obtain the particular channel of a pixel.  In 
> > our experiments we tried two different types of API.  The first was a 
> > set of macros that returned a particular channel from pixel word [1], 
> > the second were channel offset macros that could be used to index into a 
> > byte pointer.  For our use, the first approach of word accessors made 
> > for somewhat messier source code and generated code that was slightly 
> > slower for x86 though faster on PPC [3].
> 
> This is probably because x86 is better at byte addressing/operations.  If
> it's faster on PPC it will probably be faster on ARM which I imagine is a
> platform Mozilla will care about more in the future.

IMHO even such a minor platform like x86 ;-) should not get any
performance penalty in favour for exotic platforms like PowerPC or less
exotic platforms like ARM. Would it be possible to combine both
approaches using #ifdef mess?

Ciao,
Mathias

From fcrozat at mandriva.com  Tue Mar  6 00:47:01 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Tue Mar  6 00:41:35 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173128740.18079.75.camel@behdad>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
Message-ID: <1173170822.24503.63.camel@trinidad.mandrakesoft.com>

Le lundi 05 mars 2007 ? 16:05 -0500, Behdad Esfahbod a ?crit :
> On Mon, 2007-03-05 at 08:53 -0500, Frederic Crozat wrote:
> > 
> > You need to apply first fix and second one in sequence (I've undo some
> > of the change I did in my first patch, which aren't really needed). 
> 
> In that case, would you mind giving us a final combined patch, without
> any formatting changes please?

I wanted git to give me a combined patch with changelog but I'm still a
newbie for that ;)

Anyway, new patch attached.

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cairo-1.3.14-fixaliasing.patch
Type: text/x-patch
Size: 1688 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070306/8c4b17cd/cairo-1.3.14-fixaliasing.bin
From cworth at cworth.org  Tue Mar  6 01:48:38 2007
From: cworth at cworth.org (Carl Worth)
Date: Tue Mar  6 01:56:24 2007
Subject: [cairo] [cairo-announce] cairo release 1.4.0 now available
Message-ID: <87odn6bt3d.wl%cworth@cworth.org>

Skipped content of type multipart/signed-------------- next part --------------
_______________________________________________
cairo-announce mailing list
cairo-announce@cairographics.org
http://cairographics.org/cgi-bin/mailman/listinfo/cairo-announce
From spitzak at d2.com  Tue Mar  6 03:40:52 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Tue Mar  6 03:41:06 2007
Subject: [cairo] Compositing benchmarks
In-Reply-To: <20070305170313.GA18253@infidigm.net>
References: <20070304.214030.757.1009333@webmail37.nyc.untd.com>
	<20070305170313.GA18253@infidigm.net>
Message-ID: <45ED5344.4020801@d2.com>

Jeff Muizelaar wrote:

> I had a look at the routine (_op_blend_p_dp_mmx) in evas and it looks it
> is doing: a*b/256. Is this correct? The routine used in liboil
> (composite_over_argb_sse2_3) appears to be using the exact and
> traditional blin95 formula: (a*b+128)*(257/65536), however, I could be
> misreading the code. Cairo also uses the blin95 formula.

int((a*b+255)/256) produces much more accurate values and is probably 
fast enough. It also produces the same answer for all cases where a and 
b are 0, 128, and 255.
From spitzak at d2.com  Tue Mar  6 04:40:58 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Tue Mar  6 04:41:14 2007
Subject: [cairo] Compositing benchmarks
In-Reply-To: <87zm6rk4uj.wl%cworth@cworth.org>
References: <20070304.214030.757.1009333@webmail37.nyc.untd.com>
	<87zm6rk4uj.wl%cworth@cworth.org>
Message-ID: <45ED615A.9030807@d2.com>

Carl Worth wrote:

> I think the reason is simply that we haven't gotten around to fixing
> it yet. I'd love to see someone implement a software "mipmap"-like
> approach for image scaling. It would eliminate one of the few
> visual-quality warts still left in cairo.

A mipmap is only useful if the image is going to be drawn many times. 
This perhaps could be done if the source surface could store it for 
reuse, but this would have to be a special mipmap-surface type and 
(similar to that jpeg->pdf stuff) would require the destination surface 
to recognize and use the mipmap source directly.

The more immediate and useful solution for Cairo is to do filtered 
sampling of more than 4 pixels of the source image. I believe that for 
Cairo, a pixel-aligned box filter is quite sufficient, and has the 
advantage of blending smoothly with how cairo enlarges images. The 
following will do it, there is just a small matter of optimizing it :-)

All variables are floating point.

Take the center of the destination pixel X,Y (this would be two numbers 
ending in .5).

Back-project X,Y to get x,y source coordinate.

Back-project X+1,Y and subtract x,y to get dux,duy.
Back-project X,Y+1 and subtract x,y to get dvx,dvy.
(above two steps can be simplified a lot if perspective is not done)

// Produce the pixel-aligned rectangle of approximately equal size:
A = fabs(dux*dvy-duy*dvx);
W = dux*dux+dvx*dvx;
H = duy*duy+dvy*dvy;
if (W>H) {
   W = sqrt(W);
   H = A/W;
} else if (H > 0) {
   H = sqrt(H);
   W = A/H;
}
// Box filter must be at least 1 in size.
if (W < 1) W = 1;
if (H < 1) H = 1;

Now consider the rectangle of size W,H centered on x,y. Multiply every 
pixel that intersects this rectangle by the area of the intersection, 
add all these together, and divide by W*H. This is the resulting sample.

optimizations:

The most useful optimization is to detect W==1 and H==1 as early as 
possible in the above and do the current cairo sampling, which is 
equivalent.

Less important, though it seems obvious, is to do a 2-pass algorithim, 
as the weight for each pixel is the horizontal weight times the vertical 
weight.

In each direction there are only 2 pixels with fractional weights 
(sometimes these "fractions" are 0 and 1) and floor(W-1) pixels that are 
multiplied by 1.

The next step down in quality is to round W and H to the nearest 
integers, making the division an integer and making the above two 
fractions always add to 1.

Further reductions in quality would be to round the edges of the 
rectangle to integers for any direction where the size is greater than 
1. This makes each pass be two cases: either average n pixels or do the 
current cairo weighted sum of 2 pixels.

Another reduction in quality is to set W==H==sqrt(A). I suspect OS/X 
quartz may be doing this.

Going the other way, the best way to improve quality is to sample a 
axis-aligned "parallelogram" by doing integer offsets to the nearest 
value. I would not try anything fancier (such as trying to figure out 
the intersection with an arbitrary parallelogram) as this is overkill, 
it is better to use better sampling filters (ie apply different weights 
to the pixels depending on how far they are from x,y).

From kou at cozmixng.org  Tue Mar  6 04:59:36 2007
From: kou at cozmixng.org (Kouhei Sutou)
Date: Tue Mar  6 05:18:29 2007
Subject: [cairo] [rcairo] 1.4.0
Message-ID: <20070306.215936.213028378.kou@cozmixng.org>

Hi,

I released rcairo 1.4.0 that supports cairo 1.4.0:

  http://cairographics.org/releases/rcairo-1.4.0.tar.gz

  http://cairographics.org/releases/rcairo-1.4.0.tar.gz.md5
  efb370e819e5ce354d42a01f58e39688  rcairo-1.4.0.tar.gz

  http://cairographics.org/releases/rcairo-1.4.0.tar.gz.sha1
  35f39618e492c3efffcbc326e5622c37baedc58c  rcairo-1.4.0.tar.gz


Regards,
--
kou
From mozilla at weilbacher.org  Tue Mar  6 05:39:20 2007
From: mozilla at weilbacher.org (Peter Weilbacher (Mozilla))
Date: Tue Mar  6 05:46:04 2007
Subject: [cairo] Recommendations for 1.4.0
In-Reply-To: <20070306041828.8A8AR6DGL3@priv-edmwaa06.telusplanet.net>
References: <20070306041828.8A8AR6DGL3@priv-edmwaa06.telusplanet.net>
Message-ID: <45ED6F08.6040904@gaston.Weilbacher.org>

Dave Yeo wrote:

> Sure, though I think it is the GCC line that is in error
> 
> gcc.exe -g -O2 -o .libs/png-flatten.exe png-flatten.o 
> ./.libs/libcairotest_s.a -L/usr/local/lib
> /usr/src/cairo-git/src/.libs/libcairo_dll.a
> /usr/local/lib/libfontconfig_dll.a /usr/local/lib/libfreetype_dll.a
> /usr/local/lib/expat.a /usr/local/lib/libpng12_dll.a -lz -lpthread
> creating png-flatten.exe
> gcc.exe -g -O2    a8-mask.c imagediff.exe png-flatten.exe   -o a8-mask
> In file included from a8-mask.c:26:
> cairo-test.h:30:31: cairo-boilerplate.h: No such file or directory
> cairo-test.h:53:2: #error Cannot find definitions for fixed-width
> integral types (uint8_t, uint32_t, \etc.)
[...]
> Had a similar error since maybe 1.0.4 which clears up if building
> a8-mask.exe instead of a8-mask etc and most recently very similar
> results while compiling imagediff, fixed by adding $(EXEEXT). Make just
> does not add includes and libs unless building an executable.
> I also note that pthreads is still being linked in.

Hi Dave et al.,

many thanks for checking the OS/2 side of things before the release.
I was away and out of email contact for the last two weeks and still
trying to work out what I missed when I just noticed the 1.4.0
annoucement in my Inbox...
So many thanks for everybody helping out with the OS/2 stuff! :-)

Now, do I understand correctly, that the 1.4.0 release package does
build on OS/2 out of the box and that it's just the tests that fail?
I remember that for the tests I posted a patch here some months ago
that added $(EXEEXT) to all the tests listed in the TESTS variable
in tests/Makefile.am, similar to what Dave is suggesting above. At
the time it was rejected because there was some overhaul planned for
the tests makefile anyway. But it seems that it didn't happen yet?

Cheers,
   Peter.
From SZhang at qnx.com  Tue Mar  6 06:20:33 2007
From: SZhang at qnx.com (Shouqing Zhang)
Date: Tue Mar  6 06:26:52 2007
Subject: [cairo] [cairo-announce] cairo release 1.4.0 now available
Message-ID: <3518719F06577C4F85DA618E3C37AB9108DB5075@nimbus.ott.qnx.com>

Hi Carl, 

I am looking at the possibility of porting Cairo Graphics. According to the
messages posted on CairoGraphics.com, I could create and post patches to
this mailing list for submitting the changes. Do you have any more detailed
info (procedures) regarding posting and maintaining the patch?

Thanks in advance. 

Shawn Zhang
Software Developer
QNX Software Systems
(613) 591-0931 X2353
szhang@qnx.com
 
Stay up-to-date on all the QNX news!  Register here to receive our
newsletter.

-----Original Message-----
From: cairo-bounces@cairographics.org
[mailto:cairo-bounces@cairographics.org] On Behalf Of Carl Worth
Sent: March 6, 2007 4:49 AM
To: cairo-announce@cairographics.org
Cc: gnome-announce-list@gnome.org
Subject: [cairo] [cairo-announce] cairo release 1.4.0 now available

_______________________________________________
cairo-announce mailing list
cairo-announce@cairographics.org
http://cairographics.org/cgi-bin/mailman/listinfo/cairo-announce
From behdad at behdad.org  Tue Mar  6 07:28:45 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Tue Mar  6 07:28:46 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173170822.24503.63.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
Message-ID: <1173194925.11414.3.camel@behdad>

On Tue, 2007-03-06 at 03:47 -0500, Frederic Crozat wrote:
> Le lundi 05 mars 2007 ? 16:05 -0500, Behdad Esfahbod a ?crit :
> > On Mon, 2007-03-05 at 08:53 -0500, Frederic Crozat wrote:
> > > 
> > > You need to apply first fix and second one in sequence (I've undo some
> > > of the change I did in my first patch, which aren't really needed). 
> > 
> > In that case, would you mind giving us a final combined patch, without
> > any formatting changes please?
> 
> I wanted git to give me a combined patch with changelog but I'm still a
> newbie for that ;)
> 
> Anyway, new patch attached.

Thanks.  BTW, cairo's configure tries to use -fno-strict-aliasing.  Did
you force it off or something to hit this bug?

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From fcrozat at mandriva.com  Tue Mar  6 08:04:50 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Tue Mar  6 07:59:32 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173194925.11414.3.camel@behdad>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
	<1173194925.11414.3.camel@behdad>
Message-ID: <1173197090.24503.83.camel@trinidad.mandrakesoft.com>

Le mardi 06 mars 2007 ? 10:28 -0500, Behdad Esfahbod a ?crit :
> On Tue, 2007-03-06 at 03:47 -0500, Frederic Crozat wrote:
> > Le lundi 05 mars 2007 ? 16:05 -0500, Behdad Esfahbod a ?crit :
> > > On Mon, 2007-03-05 at 08:53 -0500, Frederic Crozat wrote:
> > > > 
> > > > You need to apply first fix and second one in sequence (I've undo some
> > > > of the change I did in my first patch, which aren't really needed). 
> > > 
> > > In that case, would you mind giving us a final combined patch, without
> > > any formatting changes please?
> > 
> > I wanted git to give me a combined patch with changelog but I'm still a
> > newbie for that ;)
> > 
> > Anyway, new patch attached.
> 
> Thanks.  BTW, cairo's configure tries to use -fno-strict-aliasing.  Did
> you force it off or something to hit this bug?

Our default packages CFLAGS are :
on x86 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
-fomit-frame-pointer -march=i586 -mtune=generic
-fasynchronous-unwind-tables

and on x86-64 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions

and they overwrite default CFLAGS in an autoconf/automake setup.

Which is why we were the only one to see this problem.

So, I think we can say -fno-strict-aliasing can be removed from cairo
with my patch :)

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva

From tor at cs.brown.edu  Tue Mar  6 08:51:06 2007
From: tor at cs.brown.edu (T Rowley)
Date: Tue Mar  6 08:51:40 2007
Subject: [cairo] Image surface pixel twiddling API
In-Reply-To: <20070306010800.GA21850@infidigm.net>
References: <45EC7B85.7040600@cs.brown.edu>
	<20070306010800.GA21850@infidigm.net>
Message-ID: <45ED9BFA.7000301@cs.brown.edu>

On 3/5/07 7:08 PM, Jeff Muizelaar wrote:
> On Mon, Mar 05, 2007 at 02:20:21PM -0600, T Rowley wrote:
>> We would like an API to obtain the particular channel of a pixel.  In 
>> our experiments we tried two different types of API.  The first was a 
>> set of macros that returned a particular channel from pixel word [1], 
>> the second were channel offset macros that could be used to index into a 
>> byte pointer.  For our use, the first approach of word accessors made 
>> for somewhat messier source code and generated code that was slightly 
>> slower for x86 though faster on PPC [3].
> 
> This is probably because x86 is better at byte addressing/operations.  If
> it's faster on PPC it will probably be faster on ARM which I imagine is a
> platform Mozilla will care about more in the future.

Yes, I'd expect that any architecture with a RISC lineage would probably 
  have a slight performance benefit with the word oriented code. 
However since x86 is what the vast majority of Mozilla/Firefox users run 
on, we tend to favor solutions that benefit that architecture as long as 
it doesn't overly hurt performance elsewhere.

> Personally, I think the word accessors are a 'cleaner' API. However, the
> offsets might be easier to use when writing byte oriented code. They might
> also be useful if the inkscape people want to convert their pixel munging
> routines to the same format as cairo's.

There's always the option of having both techniques provided, and 
letting the developer use whichever is most appropriate for their code.

> Well looking into this, I noticed that mozilla's macros for 255 division
> do not do any rounding, which is sort of wrong. e.g (1 * 254) is 0 with
> mozilla's code and should be 1.

Interesting, thanks.

-tor
From daveryeo at telus.net  Tue Mar  6 08:54:22 2007
From: daveryeo at telus.net (Dave Yeo)
Date: Tue Mar  6 08:54:06 2007
Subject: [cairo] Recommendations for 1.4.0
Message-ID: <20070306165333.0BB7LPUHEW@priv-edtnaa06.telusplanet.net>

On Tue, 06 Mar 2007 14:39:20 +0100, Peter Weilbacher (Mozilla) wrote:

>Now, do I understand correctly, that the 1.4.0 release package does
>build on OS/2 out of the box and that it's just the tests that fail?
>I remember that for the tests I posted a patch here some months ago
>that added $(EXEEXT) to all the tests listed in the TESTS variable
>in tests/Makefile.am, similar to what Dave is suggesting above. At
>the time it was rejected because there was some overhaul planned for
>the tests makefile anyway. But it seems that it didn't happen yet?

It should build fine, at least a git-pull just before release did. Make
check still fails and should work fine with the correct $(EXEEXT)
added. tests/Makefile.am has been reworked and I haven't had time to do
that much experimenting.
Dave

From cworth at cworth.org  Tue Mar  6 10:05:28 2007
From: cworth at cworth.org (Carl Worth)
Date: Tue Mar  6 10:06:13 2007
Subject: [cairo] Procedures for contributing patches.
In-Reply-To: <3518719F06577C4F85DA618E3C37AB9108DB5075@nimbus.ott.qnx.com>
References: <3518719F06577C4F85DA618E3C37AB9108DB5075@nimbus.ott.qnx.com>
Message-ID: <87k5xub63b.wl%cworth@cworth.org>

On Tue, 6 Mar 2007 09:20:33 -0500 , Shouqing Zhang wrote:
> Hi Carl,

Hi Shouqing,

> I am looking at the possibility of porting Cairo Graphics. According to the
> messages posted on CairoGraphics.com, I could create and post patches to
> this mailing list for submitting the changes.

Yes, this is the correct list to send patches to.

>                                               Do you have any more detailed
> info (procedures) regarding posting and maintaining the patch?

There's not much to it really. If you're planning on doing long-term
maintenance of code within cairo, (as opposed to some one-time
fixing), then you'll really want to get familiar with git and use it
to put together your patches. That way we'll have the option to create
an account for you to push commits out to cairo's central repository
directly.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070306/29dbd4a6/attachment.pgp
From lupinsky at gmail.com  Tue Mar  6 11:21:38 2007
From: lupinsky at gmail.com (Idan Lupinsky)
Date: Tue Mar  6 11:21:51 2007
Subject: [cairo] Mediaphile Project Using Cairo
Message-ID: <d8b559e60703061121g53643201o6bc4dceb21e4255a@mail.gmail.com>

Hi,

I wanted to share with you that I'm working on an open-source music player
and I'm utilizing cairo graphics.

I'm attaching a couple of screenshots from my work-in-progress; any comments
are welcome.

A screenshot of an amazon.com feature that renders info retrieved using
amazon web services to display info about a specific album (very initial
work):
http://mediaphile.sourceforge.net/screenshots/screenshot-amazon.png

A screenshot of a basic "live search" feature in the 'flat' tracks view:
http://mediaphile.sourceforge.net/screenshots/screenshot-search-tracks.png

Thanks for a wonderful graphics library,
Idan Lupinsky
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070306/c4609a19/attachment.html
From emmanuel.pacaud at lapp.in2p3.fr  Tue Mar  6 12:04:09 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Tue Mar  6 12:04:27 2007
Subject: [cairo] SVG radial gradient fix
In-Reply-To: <1173160773.7820.2.camel@hobbes>
References: <1173127944.26632.8.camel@hobbes>
	<87vehfb5h1.wl%cworth@cworth.org>  <1173160773.7820.2.camel@hobbes>
Message-ID: <1173211450.7820.8.camel@hobbes>

On mar, 2007-03-06 at 06:59 +0100, Emmanuel Pacaud wrote:
> On lun, 2007-03-05 at 16:06 -0800, Carl Worth wrote:
> > On Mon, 05 Mar 2007 21:52:24 +0100, Emmanuel Pacaud wrote:
> > > It looks like the patch below fixes the radial gradient test for SVG
> > > surface. The output is not exactly the same as the reference one, but it
> > > should be good enough. I've attached the resulting svg file and what
> > > librsvg renders (batik rendering looks the same).
> > 
> > Thanks very much for this fix! I've just pushed it out now, so it
> > will be great to have this in place for cairo 1.4.
> 
> > As is, I think that EXTEND_NONE, EXTEND_PAD, and EXTEND_REPEAT are
> > handled perfectly fine. However, I think the handling of
> > CAIRO_EXTEND_REFLECT is still slightly off and could be improved.
> > 
> > But regardless, it's definitely much, much better than it was before.
> 
> I'm sorry, but it's a dumb patch that only fixes the radial test (where
> r1/r0 is approximatively an integer). Expect a real patch in a couple of
> hours.

A couple of couple of couple hours later, here's the announced patch. It
should also prevent a crash when r0 == r1 and make radial gradients work
when r0 > r1.

	Emmanuel.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cairo-radial-gradient-03.patch
Type: text/x-patch
Size: 14342 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070306/927b0f36/cairo-radial-gradient-03.bin
From Marty.Sherrill at celera.com  Tue Mar  6 12:28:30 2007
From: Marty.Sherrill at celera.com (Marty Sherrill)
Date: Tue Mar  6 12:28:39 2007
Subject: [cairo] Pretty-please, help with cropping
Message-ID: <OF07078424.09EE4627-ON85257296.006BBCBF-85257296.00707934@applera.com>

I think I posted my question right in the heat of your big release 
yesterday, so I hope you'll forgive me for re-posting it today.

Would one of you experts be willing to give me just a quick hint at how to 
size (or resize) an image surface *after* I've drawn the content, in order 
to output a .PNG that is right-sized for the drawing?  I've spent hours 
fumbling with clipping functions without success. . .

I'm currently drawing everything once *just* to find the extents, then 
throwing it away and drawing everything all over again on the correct size 
surface!  Please save me from this humiliation!

Congratulations on Cairo version 1.4.0.  It's really a super package.

 - Marty

p.s. I'm using rcairo on Red Hat, if that matters.

----- Forwarded by Marty Sherrill/CRA/PEC on 03/06/2007 02:57 PM -----

Marty Sherrill/CRA/PEC wrote on 03/05/2007 02:52:09 PM:

> Hello all,
> 
> I'm looking for help understanding how to crop an image (or 
> otherwise set its dimensions) in memory just after it's drawn.  I'm 
> drawing images that need to be different sizes according to their 
> content, and it's not practical to figure out the dimensions before 
> doing the actual drawing.
> 
> I have the idea in mind to draw on a larger-than-necessary surface, 
> track the extents of my drawing, and then crop off the extra space.
> 
> Is that a good approach?  If so, could I get some advice as to how 
> the cropping step can be accomplished?
> 
> Best regards,
> 
>  - Marty
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070306/cd971e76/attachment.html
From bzbarsky at MIT.EDU  Tue Mar  6 12:43:31 2007
From: bzbarsky at MIT.EDU (Boris Zbarsky)
Date: Tue Mar  6 12:43:57 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1172938325.3091.19.camel@behdad>
References: <20070227201153.02773785@portvle>	
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>	
	<20070302123407.08a060fa@ecoup>	
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>	
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
Message-ID: <45EDD273.6030305@mit.edu>

Behdad Esfahbod wrote:
>> Are you generally interested in data of this sort?  If there's something I can 
>> do to help improve cairo performance, I'd love to help.
> 
> Definitely.  Pass 'em on.  Specifically, I'm really interested in a call
> graph to malloc.  There's a lot we can do to drop those.

I'll try to get together a more exhaustive list, but in the meantime 
https://bugzilla.mozilla.org/show_bug.cgi?id=368018 is a decent example 
(16% of total pageload time is under malloc/free, most of it called from 
cairo).  Most of the other profiles I've seen look much like this, so it 
may be worth addressing this one and then reprofiling.

I don't have a good way to generate pictorial call graphs, but as far as 
cairo calls to malloc in that testcase go (note that some of the 
callstacks might have stack frames skipped due to the profiler being 
used...):

malloc
   cairo_path_arg_buf_create
     cairo_path_fixed_add
       cairo_path_fixed_move_to
         cairo_move_to
           cairo_rectangle
         cairo_path_fixed_close_path
           cairo_close_path
             cairo_rectangle
       cairo_path_fixed_line_to
         cairo_path_fixed_rel_line_to
           cairo_rectangle

   realloc
     cairo_polygon_add_edge
       cairo_polygon_line_to
         cairo_filler_line_to
           cairo_path_fixed_interpret
             cairo_path_fixed_fill_to_traps
               cairo_surface_fallback_fill
     cairo_traps_grow_by
       cairo_traps_add_trap
         cairo_traps_add_trap_from_points
           cairo_bentley_ottmann_tessellate_polygon
           cairo_bo_edge_end_trap
             cairo_bentley_ottmann_tessellate_polygon

   cairo_bentley_ottmann_tessellate_polygon
     cairo_path_fixed_fill_to_traps
       cairo_surface_fallback_fill

   cairo_pattern_create_solid
     cairo_pattern_create_rgba
       cairo_set_source_rgba

   skip_list_insert
     cairo_bentley_ottmann_tessellate_polygon

   cairo_path_op_buf_create
     cairo_path_fixed_add
       cairo_path_fixed_move_to
         cairo_move_to
           cairo_rectangle
         cairo_path_fixed_close_path
           cairo_close_path
             cairo_rectangle
       cairo_path_fixed_line_to
         cairo_path_fixed_rel_line_to
           cairo_rectangle

   cairo_surface_fill_region
     clip_and_composite_trapezoids
       cairo_surface_fallback_fill

   cairo_freelist_alloc
     cairo_bentley_ottmann_tessellate_polygon

   pixman_region_create_simple
     pixman_region_create
       cairo_traps_extract_region
       clip_and_composite_trapezoids
         cairo_surface_fallback_fill
     cairo_traps_extract_region
       clip_and_composite_trapezoids
         cairo_surface_fallback_fill

   cairo_pattern_create_rgba
     cairo_set_source_rgba

In all cases, callers are listed in order from most common to least common.

-Boris
From cworth at cworth.org  Tue Mar  6 13:07:02 2007
From: cworth at cworth.org (Carl Worth)
Date: Tue Mar  6 13:08:07 2007
Subject: [cairo] Pretty-please, help with cropping
In-Reply-To: <OF07078424.09EE4627-ON85257296.006BBCBF-85257296.00707934@applera.com>
References: <OF07078424.09EE4627-ON85257296.006BBCBF-85257296.00707934@applera.com>
Message-ID: <87ejo2axop.wl%cworth@cworth.org>

On Tue, 6 Mar 2007 15:28:30 -0500, Marty Sherrill wrote:
> I think I posted my question right in the heat of your big release
> yesterday, so I hope you'll forgive me for re-posting it today.

Yeah, sorry about that. The reposting is not a problem at all.

> Would one of you experts be willing to give me just a quick hint at how to
> size (or resize) an image surface *after* I've drawn the content, in order
> to output a .PNG that is right-sized for the drawing?  I've spent hours
> fumbling with clipping functions without success. . .

So, if I understand your question correctly, you've now got
big_surface that's big but has useful content only within a rectangle
(x,y,width,height), and you've got small_surface that's just the right
size (width,height).

So, copying the sub-piece of big_surface of interest would be as
simple as this:

	cairo_t *cr = cairo_create (small_surface);
	cairo_set_source_surface (cr, big_surface, -x, -y);
	cairo_rectangle (cr, 0, 0, width, height);
	cairo_fill (cr);

The interesting thing to note here, (and what will hopefully be an
"Ah-ha!" moment for some readers), is that cairo does not have any
drawing operation that is "paint an image". Instead, cairo has a much
more general notion where you can use an image, (or other more general
patterns, such as gradients), as the source pattern. And with that,
you can draw any shape you want, and the appropriate pieces of the
source surface will appear within that shape.

Does that make sense? Give the above sequence a try and let us know
how it goes.

> Congratulations on Cairo version 1.4.0.  It's really a super package.

Thanks! I hope you have lots of fun with it.

> p.s. I'm using rcairo on Red Hat, if that matters.

I'm not up on ruby syntax, but hopefully it is extremely
straightforward for you to translate the above from C to ruby.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070306/92fee980/attachment-0001.pgp
From Marty.Sherrill at celera.com  Tue Mar  6 13:56:59 2007
From: Marty.Sherrill at celera.com (Marty Sherrill)
Date: Tue Mar  6 13:57:09 2007
Subject: [cairo] Pretty-please, help with cropping
In-Reply-To: <87ejo2axop.wl%cworth@cworth.org>
Message-ID: <OF686AAF57.05027262-ON85257296.0077324D-85257296.00789311@applera.com>

Perfect!  An instant ~2x performance boost, and my dignity restored!  :-)

Thank you so much Carl for this information,

 - Marty

Carl Worth <cworth@cworth.org> wrote on 03/06/2007 04:07:02 PM:
> 
> So, copying the sub-piece of big_surface of interest would be as
> simple as this:
> 
>    cairo_t *cr = cairo_create (small_surface);
>    cairo_set_source_surface (cr, big_surface, -x, -y);
>    cairo_rectangle (cr, 0, 0, width, height);
>    cairo_fill (cr);
> 
> The interesting thing to note here, (and what will hopefully be an
> "Ah-ha!" moment for some readers), is that cairo does not have any
> drawing operation that is "paint an image". Instead, cairo has a much
> more general notion where you can use an image, (or other more general
> patterns, such as gradients), as the source pattern. And with that,
> you can draw any shape you want, and the appropriate pieces of the
> source surface will appear within that shape.
> 
> Does that make sense? Give the above sequence a try and let us know
> how it goes.
> 
> > Congratulations on Cairo version 1.4.0.  It's really a super package.
> 
> Thanks! I hope you have lots of fun with it.
> 
> > p.s. I'm using rcairo on Red Hat, if that matters.
> 
> I'm not up on ruby syntax, but hopefully it is extremely
> straightforward for you to translate the above from C to ruby.
> 
> -Carl
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070306/2527cd14/attachment.html
From behdad at behdad.org  Tue Mar  6 14:16:32 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Tue Mar  6 14:16:31 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <45EDD273.6030305@mit.edu>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
	<45EDD273.6030305@mit.edu>
Message-ID: <1173219393.11414.34.camel@behdad>

On Tue, 2007-03-06 at 14:43 -0600, Boris Zbarsky wrote:
> Behdad Esfahbod wrote:
> >> Are you generally interested in data of this sort?  If there's something I can 
> >> do to help improve cairo performance, I'd love to help.
> > 
> > Definitely.  Pass 'em on.  Specifically, I'm really interested in a call
> > graph to malloc.  There's a lot we can do to drop those.
> 
> I'll try to get together a more exhaustive list, but in the meantime 
> https://bugzilla.mozilla.org/show_bug.cgi?id=368018 is a decent example 
> (16% of total pageload time is under malloc/free, most of it called from 
> cairo).  Most of the other profiles I've seen look much like this, so it 
> may be worth addressing this one and then reprofiling.
>
> I don't have a good way to generate pictorial call graphs, but as far as 
> cairo calls to malloc in that testcase go (note that some of the 
> callstacks might have stack frames skipped due to the profiler being 
> used...):

Thanks.  The list really helps.  Fortunately all look very easy to
optimize as I expected.  I just need a test case that gives
malloc/realloc numbers so I can measure my progress.

One way would be to write a small .so that overrides malloc/realloc, and
run perf suite against it.  If we were using glib, such stats were
free...  Anyway, anyone taking this?

Per-item plans follow.

> malloc
>    
>      cairo_path_fixed_add
>        cairo_path_fixed_move_to
>          cairo_move_to
>            cairo_rectangle
>          cairo_path_fixed_close_path
>            cairo_close_path
>              cairo_rectangle
>        cairo_path_fixed_line_to
>          cairo_path_fixed_rel_line_to
>            cairo_rectangle

Explanation: currently _cairo_path_fixed has pointers to two lists: one
for operations, another for points.  Each list is a linked list of
chunks each holding 64 items.  This means, any path (even with a single
move-to) will cause at least three malloc()s.  One for the path struct,
two for the list nodes.

Easy-fix: make _cairo_path_fixed keep a node of those two lists, instead
of pointers.

More work can be done still: for example, the current approach of const
number of items per chunk has a constant malloc() overhead (two mallocs
per 64 operations).  One can make the size of chunks grow exponentially
to reduce the overall overhead.


>    realloc
>      cairo_polygon_add_edge
>        cairo_polygon_line_to
>          cairo_filler_line_to
>            cairo_path_fixed_interpret
>              cairo_path_fixed_fill_to_traps
>                cairo_surface_fallback_fill
>      cairo_traps_grow_by
>        cairo_traps_add_trap
>          cairo_traps_add_trap_from_points
>            cairo_bentley_ottmann_tessellate_polygon
>            cairo_bo_edge_end_trap
>              cairo_bentley_ottmann_tessellate_polygon

Both realloc an array to fit more items, but oops!  they just enlarge it
enough to fit the items at hand (I may be wrong, but I don't think I
am.)  That means, at some point, they will realloc on any operation!

Easy-fix: exponentially enlarge them.


>    cairo_bentley_ottmann_tessellate_polygon
>      cairo_path_fixed_fill_to_traps
>        cairo_surface_fallback_fill

Allocates an array at the beginning of function and frees at the end.

Easy-fix: use an stack buffer of size CAIRO_STACK_BUFFER_SIZE bytes and
use it when data fits.


>    cairo_pattern_create_solid
>      cairo_pattern_create_rgba
>        cairo_set_source_rgba

Does a malloc() every time you cairo_set_source_rgba?().

Medium-fix: instead of solid-surface cache, cache solid patterns, like
we do for scaled-fonts.

Solid-surface caching still should be done the hard way because of the
xlib threading problems we recently found.  In fact the code for
solid-surface caching may be adapted for solid-pattern caching without
any problems.  It doesn't even have to check for backend compatibility.


>    skip_list_insert
>      cairo_bentley_ottmann_tessellate_polygon

This one's harder.  It already uses a free-list.  One possible solution
may be 1) allocate in chunks, 2) be more relaxed about using available
chunks that are slightly larger than needed.


>    cairo_path_op_buf_create
>      cairo_path_fixed_add
>        cairo_path_fixed_move_to
>          cairo_move_to
>            cairo_rectangle
>          cairo_path_fixed_close_path
>            cairo_close_path
>              cairo_rectangle
>        cairo_path_fixed_line_to
>          cairo_path_fixed_rel_line_to
>            cairo_rectangle

Covered with cairo_path_fixed_add() already.


>    cairo_surface_fill_region
>      clip_and_composite_trapezoids
>        cairo_surface_fallback_fill

Easy-fix: Use a stack buffer.


>    cairo_freelist_alloc
>      cairo_bentley_ottmann_tessellate_polygon

Another freelist implementation, oops!  Again, make it allocate in
chunks.  That's not a problem at all, since the memory is very
shortlived.


>    pixman_region_create_simple
>      pixman_region_create
>        cairo_traps_extract_region
>        clip_and_composite_trapezoids
>          cairo_surface_fallback_fill
>      cairo_traps_extract_region
>        clip_and_composite_trapezoids
>          cairo_surface_fallback_fill

Is allocating small structures using malloc().  Most uses can do with a
local one on stack.

Easy-fix: Change pixman to expose pixman_region_initialize() and
allocate region on stack when possible.


>    cairo_pattern_create_rgba
>      cairo_set_source_rgba

Inlined version of _cairo_pattern_create_solid() covered above.


> In all cases, callers are listed in order from most common to least common.
> 
> -Boris

If people want to beat me and submit patches for these, I'M ALL FOR IT.
But we first need a quantitative test case.

Cheers,
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From bzbarsky at MIT.EDU  Tue Mar  6 14:28:11 2007
From: bzbarsky at MIT.EDU (Boris Zbarsky)
Date: Tue Mar  6 14:41:08 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1173219393.11414.34.camel@behdad>
References: <20070227201153.02773785@portvle>	
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>	
	<20070302123407.08a060fa@ecoup>	
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>	
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>	
	<45EDD273.6030305@mit.edu> <1173219393.11414.34.camel@behdad>
Message-ID: <45EDEAFB.6070602@mit.edu>

Behdad Esfahbod wrote:
> Thanks.  The list really helps.  Fortunately all look very easy to
> optimize as I expected.  I just need a test case that gives
> malloc/realloc numbers so I can measure my progress.

For what it's worth, I'm happy to patch-and-reprofile if that would 
help.  That doesn't scale in general, and separating out the cairo parts 
from the other-Gecko-stuff parts in the profile is a little annoying, so 
it's still good to have tests, of course.

-Boris
From cworth at cworth.org  Tue Mar  6 15:53:18 2007
From: cworth at cworth.org (Carl Worth)
Date: Tue Mar  6 15:53:30 2007
Subject: [cairo] SVG radial gradient fix
In-Reply-To: <1173211450.7820.8.camel@hobbes>
References: <1173127944.26632.8.camel@hobbes> <87vehfb5h1.wl%cworth@cworth.org>
	<1173160773.7820.2.camel@hobbes> <1173211450.7820.8.camel@hobbes>
Message-ID: <87d53mapzl.wl%cworth@cworth.org>

On Tue, 06 Mar 2007 21:04:09 +0100, Emmanuel Pacaud wrote:
> A couple of couple of couple hours later, here's the announced patch. It
> should also prevent a crash when r0 == r1 and make radial gradients work
> when r0 > r1.

Fabulous work, thanks!

I've pushed this out now, (as part of 1.4.1). Too bad it didn't make
it into 1.4.0, but I guess this will just give us one more reason not
to delay 1.4.2 unnecessarily.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070306/413539f0/attachment.pgp
From jose_ogp at juno.com  Tue Mar  6 17:55:04 2007
From: jose_ogp at juno.com (jose_ogp@juno.com)
Date: Tue Mar  6 17:56:30 2007
Subject: [cairo] Compositing benchmarks
Message-ID: <20070306.175603.9225.1252888@webmail36.nyc.untd.com>


> > 	Interesting. I can tell you that evas' blending routines
> > use an approximation to the 'ideal' blending equation, which cairo
> > chooses to follows more exactly.. hence likely the speed difference
> > between these two. If liboil has something closer to cairo's, then
> > that would be a great improvement indeed...
> 
> I had a look at the routine (_op_blend_p_dp_mmx) in evas and it
> looks it is doing: a*b/256. Is this correct? The routine used in

	For a,b in [0,255] the multiplications are like ((a+1)*b)/256
and sometimes like ((a*b)+255)/256, depending on different funcs and
their purpose.

> > 
> > 	It's curious to me that cairo puts so much emphasis on
> > the 'accuracy' of compositing calculations - variations of which
> > people are unable to discern - and yet seems to put much less
> > emphasis on the 'accuracy' of scaling results - variations of
> > which people note as giving considerable differences.
> > 	Obviously there's a reason for this seeming disparity
> > -- possibly it's the desire to have a single unified method for
> > dealing with transforms... But I would say that this is an area
> > that could use more looking into.

> The scaling code that cairo currently uses is known to be bad
> and is not really representive of the goals of cairo. It needs
> replacing, but no one has actually done the work yet. I'd be very
> interested in knowing more about the different scaling algorithms
> that you tested and what your conclusions were.
> 
> -Jeff

	Only a handful of them.. including evas' current code,
bilinear interpolation, and even a stab at using 'mipmapping'.
	I had certain requirements at hand that I needed to
satisfy, and all failed in some respect. In the end I had to write
a version to meet my needs.. But it too is unsatisfactory in many
respects, even within its limits.

	No, this is something that needs some serious thought.
Surely someone somewhere in the comp gfx community has gone
over this in detail before?

   jose.


From jose_ogp at juno.com  Tue Mar  6 17:56:47 2007
From: jose_ogp at juno.com (jose_ogp@juno.com)
Date: Tue Mar  6 17:58:30 2007
Subject: [cairo] Compositing benchmarks
Message-ID: <20070306.175706.9225.1252897@webmail36.nyc.untd.com>


> > Obviously there's a reason for this seeming disparity
> > -- possibly it's the desire to have a single unified method for
> > dealing with transforms... But I would say that this is an area
> > that could use more looking into.
> 
> I think the reason is simply that we haven't gotten around to
> fixing it yet. I'd love to see someone implement a software
> "mipmap"-like approach for image scaling. It would eliminate one
> of the few visual-quality warts still left in cairo.
> 
> -Carl

	Mipmapping approaches seem to have some 'issues'...
In order to obtaing something close to full sampling (and thus 'good'
results), one needs more than just (1/2,1/2) factors.. which means
a somewhat more complex 'mipmapping' approach. But perhaps one could
make this work satisfactory.

	Again, it's odd that such an important aspect of comp gfx
hasn't been covered in great detail before, with some (maybe many)
satisfactory solution to 'high quality' image transforms being well
known in the field.

   jose.


From jose_ogp at juno.com  Tue Mar  6 18:08:43 2007
From: jose_ogp at juno.com (jose_ogp@juno.com)
Date: Tue Mar  6 18:11:26 2007
Subject: [cairo] Compositing benchmarks
Message-ID: <20070306.180921.9225.1252954@webmail36.nyc.untd.com>


	Bill Spitzak wrote:

> The more immediate and useful solution for Cairo is to do filtered
> sampling of more than 4 pixels of the source image. I believe that
> for Cairo, a pixel-aligned box filter is quite sufficient, and has
> the advantage of blending smoothly with how cairo enlarges images.
> The following will do it, there is just a small matter of optimizing
> it  :-)
> 
> ....
> ....

	Seems like a reasonable start. :)
	It might take some work, but if you could write out an actual
working sample implementation, I'm sure optimizations could be made
to follow.

   jose.


From spitzak at d2.com  Wed Mar  7 03:33:32 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Wed Mar  7 03:33:47 2007
Subject: [cairo] Box filtering code
In-Reply-To: <20070306.180921.9225.1252954@webmail36.nyc.untd.com>
References: <20070306.180921.9225.1252954@webmail36.nyc.untd.com>
Message-ID: <45EEA30C.6040603@d2.com>

jose_ogp@juno.com wrote:
> 	Bill Spitzak wrote:
> 
>> The more immediate and useful solution for Cairo is to do filtered
>> sampling of more than 4 pixels of the source image. I believe that
>> for Cairo, a pixel-aligned box filter is quite sufficient, and has
>> the advantage of blending smoothly with how cairo enlarges images.
>> The following will do it, there is just a small matter of optimizing
>> it  :-)
>>
>> ....
>> ....
> 
> 	Seems like a reasonable start. :)
> 	It might take some work, but if you could write out an actual
> working sample implementation, I'm sure optimizations could be made
> to follow.

Well this is not a working implementation but I hope it will get things 
started and it was not a waste of time to type this all in. I have no 
idea where this goes into Cairo, or if it has to go into the XRender or 
pixman code.

This is entirely written from scratch without any cut & paste to avoid 
any possible IP problems. I release it entirely into the public domain.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: sample.C
Type: text/x-c++src
Size: 8191 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070307/63d8a762/sample.c++
From ickle at chris-wilson.co.uk  Wed Mar  7 06:05:36 2007
From: ickle at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar  7 06:20:34 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1173219393.11414.34.camel@behdad>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
	<45EDD273.6030305@mit.edu> <1173219393.11414.34.camel@behdad>
Message-ID: <20070307140536.GA24942@inspired.chris-wilson.co.uk>

Following Behdad's call to arms, I added valgrind/callgrind targets to
perf/Makefile.am similar to test/Makefile.am.

This immediately showed that there were a couple of per-test leaks...

* crosses fingers and hopes he has submitted the patches in the approved
manner.
--
Chris Wilson
-------------- next part --------------
>From c7c068129c22048e9f068db47637446b1d995379 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 7 Mar 2007 12:19:44 +0000
Subject: [PATCH] Add valgrind/callgrind targets to Makefile.
---
 perf/Makefile.am |   20 ++++++++++++++++++++
 1 files changed, 20 insertions(+), 0 deletions(-)

diff --git a/perf/Makefile.am b/perf/Makefile.am
index a50ce8a..cef6431 100644
--- a/perf/Makefile.am
+++ b/perf/Makefile.am
@@ -60,5 +60,25 @@ LDADD = $(top_builddir)/boilerplate/libc
 perf: cairo-perf FORCE
 	./cairo-perf
 
+EXTRA_VG_FLAGS = $(CAIRO_EXTRA_VALGRIND_FLAGS)
+VG_MEMCHECK_FLAGS = \
+	--tool=memcheck \
+	--suppressions=$(top_srcdir)/test/.valgrind-suppressions \
+	--leak-check=yes --show-reachable=yes
+VG_CALLGRIND_FLAGS = \
+	--tool=callgrind
+CLEANFILES = \
+	valgrind-log
+
+perf-valgrind: cairo-perf FORCE
+	$(top_srcdir)/libtool --mode=execute \
+		valgrind $(VG_MEMCHECK_FLAGS) $(EXTRA_VG_FLAGS) \
+		./cairo-perf 2>&1 | tee valgrind-log
+perf-callgrind: cairo-perf FORCE
+	$(top_srcdir)/libtool --mode=execute \
+		valgrind $(VG_CALLGRIND_FLAGS) $(EXTRA_VG_FLAGS) \
+		./cairo-perf
+
 FORCE:
 
+.PHONY: perf perf-valgrind perf-callgrind FORCE
-- 
1.4.1

-------------- next part --------------
>From ddebb6a7d6b4205d554dadf740f3d596eff431e7 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 7 Mar 2007 13:31:54 +0000
Subject: [PATCH] Fix up the trivial leaks found by valgrind.
---
 perf/cairo-perf.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/perf/cairo-perf.c b/perf/cairo-perf.c
index ae83690..49f4b59 100644
--- a/perf/cairo-perf.c
+++ b/perf/cairo-perf.c
@@ -185,6 +185,7 @@ cairo_perf_run (cairo_perf_t		*perf,
     }
 
     perf->test_number++;
+    free (times);
 }
 
 static void
@@ -307,6 +308,9 @@ main (int argc, char *argv[])
 
 		cairo_destroy (perf.cr);
 		cairo_surface_destroy (surface);
+
+		if (target->cleanup)
+		    target->cleanup (target->closure);
 	    }
 	}
     }
-- 
1.4.1

From lu_zero at gentoo.org  Wed Mar  7 05:56:35 2007
From: lu_zero at gentoo.org (Luca Barbato)
Date: Wed Mar  7 06:56:10 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <45D6DFF1.4080505@gentoo.org>
References: <45D6DFF1.4080505@gentoo.org>
Message-ID: <45EEC493.9030701@gentoo.org>

Luca Barbato wrote:
> I completed the fbcompose part the regtest are consistent, hopefully
> I'll start adding the pict ops later in the next week.
> 

Patch ping, anybody could test&commit/report back ?

lu

From lupinsky at gmail.com  Wed Mar  7 07:19:49 2007
From: lupinsky at gmail.com (Idan Lupinsky)
Date: Wed Mar  7 07:26:42 2007
Subject: [cairo] Mediaphile project using Cairo
Message-ID: <d8b559e60703070719s7cc7001aib8b17e9651e2227@mail.gmail.com>

Hi,

I wanted to share with you that I'm working on an open-source music player
and I'm utilizing cairo graphics.

I'm attaching a couple of screenshots from my work-in-progress; any comments
are welcome.

A screenshot of an amazon.com feature that renders info retrieved using
amazon web services to display info about a specific album (very initial
work):
http://mediaphile.sourceforge.net/screenshots/screenshot-amazon.png

A screenshot of a basic "live search" feature in the 'flat' tracks view:
http://mediaphile.sourceforge.net/screenshots/screenshot-search-tracks.png

Thanks for a wonderful graphics library,
Idan Lupinsky
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070307/1738ab98/attachment.html
From brian.ewins at gmail.com  Wed Mar  7 07:32:08 2007
From: brian.ewins at gmail.com (Baz)
Date: Wed Mar  7 07:32:12 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <45EEC493.9030701@gentoo.org>
References: <45D6DFF1.4080505@gentoo.org> <45EEC493.9030701@gentoo.org>
Message-ID: <2faad3050703070732n1dc0225o10a45811597caf6b@mail.gmail.com>

On 07/03/07, Luca Barbato <lu_zero@gentoo.org> wrote:
> Luca Barbato wrote:
> > I completed the fbcompose part the regtest are consistent, hopefully
> > I'll start adding the pict ops later in the next week.
> >
>
> Patch ping, anybody could test&commit/report back ?
>

Yes, I'll do this unless anyone else gets in first - it'll be tomorrow
though, big footy match tonight. I'll be testing on OSX 10.4/ppc.
Anyone with 10.3.9 ppc, or some PPC Linux, jump in too.

Cheers,
Baz
From brian.ewins at gmail.com  Wed Mar  7 07:55:01 2007
From: brian.ewins at gmail.com (Baz)
Date: Wed Mar  7 07:55:09 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <2faad3050703070732n1dc0225o10a45811597caf6b@mail.gmail.com>
References: <45D6DFF1.4080505@gentoo.org> <45EEC493.9030701@gentoo.org>
	<2faad3050703070732n1dc0225o10a45811597caf6b@mail.gmail.com>
Message-ID: <2faad3050703070755y3f82c8acy78e2871340d08abe@mail.gmail.com>

On 07/03/07, Baz <brian.ewins@gmail.com> wrote:
> On 07/03/07, Luca Barbato <lu_zero@gentoo.org> wrote:
> > Luca Barbato wrote:
> > > I completed the fbcompose part the regtest are consistent, hopefully
> > > I'll start adding the pict ops later in the next week.
> > >
> >
> > Patch ping, anybody could test&commit/report back ?
> >
>
> Yes, I'll do this unless anyone else gets in first - it'll be tomorrow
> though, big footy match tonight. I'll be testing on OSX 10.4/ppc.
> Anyone with 10.3.9 ppc, or some PPC Linux, jump in too.

Actually, if I can dig out the disks, I'll set that box up as
gentoo/10.3.9 dual boot. I only use  the laptop for testing these
days. Reading the patch:

+#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 &&
__GNUC_MINOR__ < 4))
+#error "Need GCC >= 3.4 for sane altivec support"
+#endif

This jumps out at me because Mozilla use gcc 3.3 for Mac PPC builds,
but only because they want to support releases earlier than 10.3.9. So
this is going to mean no altivec in firefox on older macs. What goes
wrong with 3.3?

Also, anyone else trying this out - cairo 1.4 has been crashing
Xquartz fairly regularly in the extend-reflect test, in
fbCompositeSrc_8888x8888. Behdad's seen similar (but rarer) crashes in
fbCompositeSrc_8888x8888mmx in the same test, so a crash there in
fbCompositeSrc_8888x8888vmx may not be a problem with the patch. Code
seems to work reliably when EXTEND_REFLECT is changed to EXTEND_REPEAT
in that test.

Cheers,
Baz
From brian.ewins at gmail.com  Wed Mar  7 08:03:44 2007
From: brian.ewins at gmail.com (Baz)
Date: Wed Mar  7 08:03:52 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <2faad3050703070755y3f82c8acy78e2871340d08abe@mail.gmail.com>
References: <45D6DFF1.4080505@gentoo.org> <45EEC493.9030701@gentoo.org>
	<2faad3050703070732n1dc0225o10a45811597caf6b@mail.gmail.com>
	<2faad3050703070755y3f82c8acy78e2871340d08abe@mail.gmail.com>
Message-ID: <2faad3050703070803o16954988p3e5610da49157e82@mail.gmail.com>

On 07/03/07, Baz <brian.ewins@gmail.com> wrote:
> +#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 &&
> __GNUC_MINOR__ < 4))
> +#error "Need GCC >= 3.4 for sane altivec support"
> +#endif
>
> This jumps out at me because Mozilla use gcc 3.3 for Mac PPC builds,
> but only because they want to support releases earlier than 10.3.9. So
> this is going to mean no altivec in firefox on older macs. What goes
> wrong with 3.3?

Actually, can someone from moz clarify this? The MDC instructions say
gcc=3.3 but the reasons for that only apply to gecko < 1.9. Build
hosts for 1.9 need to be 10.3.9+ anyway, so gcc 4 should be ok now?
From lu_zero at gentoo.org  Wed Mar  7 08:09:29 2007
From: lu_zero at gentoo.org (Luca Barbato)
Date: Wed Mar  7 08:09:01 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <2faad3050703070755y3f82c8acy78e2871340d08abe@mail.gmail.com>
References: <45D6DFF1.4080505@gentoo.org> <45EEC493.9030701@gentoo.org>	
	<2faad3050703070732n1dc0225o10a45811597caf6b@mail.gmail.com>
	<2faad3050703070755y3f82c8acy78e2871340d08abe@mail.gmail.com>
Message-ID: <45EEE3B9.1060703@gentoo.org>

Baz wrote:
> On 07/03/07, Baz <brian.ewins@gmail.com> wrote:

> 
> Actually, if I can dig out the disks, I'll set that box up as
> gentoo/10.3.9 dual boot. I only use  the laptop for testing these
> days. Reading the patch:
> 
> +#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 &&
> __GNUC_MINOR__ < 4))
> +#error "Need GCC >= 3.4 for sane altivec support"
> +#endif
> 
> This jumps out at me because Mozilla use gcc 3.3 for Mac PPC builds,
> but only because they want to support releases earlier than 10.3.9. So
> this is going to mean no altivec in firefox on older macs. What goes
> wrong with 3.3?

it has some glitches that could require some workarounds I could add but
I'd rather avoid...

> 
> Also, anyone else trying this out - cairo 1.4 has been crashing
> Xquartz fairly regularly in the extend-reflect test, in
> fbCompositeSrc_8888x8888. Behdad's seen similar (but rarer) crashes in
> fbCompositeSrc_8888x8888mmx in the same test, so a crash there in
> fbCompositeSrc_8888x8888vmx may not be a problem with the patch. Code
> seems to work reliably when EXTEND_REFLECT is changed to EXTEND_REPEAT
> in that test.

disabling mmx/vmx shows the same issue?

Could you please send some benchmark results?

lu
From brian.ewins at gmail.com  Wed Mar  7 08:26:26 2007
From: brian.ewins at gmail.com (Baz)
Date: Wed Mar  7 08:26:32 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <45EEE3B9.1060703@gentoo.org>
References: <45D6DFF1.4080505@gentoo.org> <45EEC493.9030701@gentoo.org>
	<2faad3050703070732n1dc0225o10a45811597caf6b@mail.gmail.com>
	<2faad3050703070755y3f82c8acy78e2871340d08abe@mail.gmail.com>
	<45EEE3B9.1060703@gentoo.org>
Message-ID: <2faad3050703070826y736e8a9cw42918c889febde0d@mail.gmail.com>

On 07/03/07, Luca Barbato <lu_zero@gentoo.org> wrote:
> > This jumps out at me because Mozilla use gcc 3.3 for Mac PPC builds,
> > but only because they want to support releases earlier than 10.3.9. So
> > this is going to mean no altivec in firefox on older macs. What goes
> > wrong with 3.3?
>
> it has some glitches that could require some workarounds I could add but
> I'd rather avoid...

Ok. No problem.

> >
> > Also, anyone else trying this out - cairo 1.4 has been crashing
> > Xquartz fairly regularly in the extend-reflect test, in
> > fbCompositeSrc_8888x8888. Behdad's seen similar (but rarer) crashes in
> > fbCompositeSrc_8888x8888mmx in the same test, so a crash there in
> > fbCompositeSrc_8888x8888vmx may not be a problem with the patch. Code
> > seems to work reliably when EXTEND_REFLECT is changed to EXTEND_REPEAT
> > in that test.
>
> disabling mmx/vmx shows the same issue?

It did for me :) . But its not 100% reproducable anywhere; I had it
happening to me for an hour or so on the night of the release, then it
went away again. And it only hits extend-reflect, which is also weird.

> Could you please send some benchmark results?
>
> lu

Yep, will do.
From jeff at infidigm.net  Wed Mar  7 08:42:43 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Wed Mar  7 08:41:16 2007
Subject: [cairo] Compositing benchmarks
In-Reply-To: <20070304055020.GA9660@infidigm.net>
References: <20070304055020.GA9660@infidigm.net>
Message-ID: <20070307164243.GA3902@infidigm.net>

On Sun, Mar 04, 2007 at 12:50:20AM -0500, Jeff Muizelaar wrote:
> Here are some results:
> The benchmark is compositing solid square images of exponentially
> increasing size 100 times in a row. The color of the images are src color
> (0xa4045090), dest color (0xe0e01000) (some backends optimize for alpha
> of 255 or 0). The benchmarks were performed on a Intel(R) Xeon(TM) CPU
> 2.80GHz.

Here's another interesting one:
argb32 OVER argb32 IN a8
(./test -b oil,cairo -o OVER --mask-type=1 -s 33 -f ARGB32)

build_plot((('oil', 'cairo'),('dest_width','1')), "backend == '%s' and
src_width=%s", "op='OVER' and src_format='ARGB32' and
dest_format='ARGB32' and mask_width=mask_height and mask_format='A8' and
repetitions='100'")

 - http://people.freedesktop.org/~jrmuizel/composite-bench/over-in-comparison.png
 - Two varients are tested here. The first, '.dest_width', is compositing
   source surface the same size as destination one. The second varient,
   '.1', is compositing a solid source.
 - liboil is the clear winner here, being more than twice as fast as
   cairo. This benchmark is also interesting because I've actually had
   fbCompositeSolidMask_nx8x8888mmx show up promininently while
   profiling some pdf rendering.

-Jeff
From ross at burtonini.com  Wed Mar  7 09:08:28 2007
From: ross at burtonini.com (Ross Burton)
Date: Wed Mar  7 09:08:54 2007
Subject: [cairo] Re: Compositing benchmarks
In-Reply-To: <20070307164243.GA3902@infidigm.net>
References: <20070304055020.GA9660@infidigm.net>
	<20070307164243.GA3902@infidigm.net>
Message-ID: <1173287307.16349.1.camel@blackadder>

On Wed, 2007-03-07 at 11:42 -0500, Jeff Muizelaar wrote:
>  - liboil is the clear winner here, being more than twice as fast as
>    cairo. This benchmark is also interesting because I've actually had
>    fbCompositeSolidMask_nx8x8888mmx show up promininently while
>    profiling some pdf rendering.

If I profile my system using oprofile whilst just doing normal work,
that function is generally the top function that isn't in kernel space
for me...

Ross
-- 
Ross Burton                                 mail: ross@burtonini.com
                                          jabber: ross@burtonini.com
                                     www: http://www.burtonini.com./
 PGP Fingerprint: 1A21 F5B0 D8D0 CFE3 81D4 E25A 2D09 E447 D0B4 33DF



From cworth at cworth.org  Wed Mar  7 09:31:17 2007
From: cworth at cworth.org (Carl Worth)
Date: Wed Mar  7 09:31:30 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <20070307140536.GA24942@inspired.chris-wilson.co.uk>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
	<45EDD273.6030305@mit.edu> <1173219393.11414.34.camel@behdad>
	<20070307140536.GA24942@inspired.chris-wilson.co.uk>
Message-ID: <87bqj5arkq.wl%cworth@cworth.org>

On Wed, 7 Mar 2007 14:05:36 +0000, Chris Wilson wrote:
> This immediately showed that there were a couple of per-test leaks...

Thanks! All pushed out.

> * crosses fingers and hopes he has submitted the patches in the approved
> manner.

Yes, just fine. Generating patches via git commits so that the
authorship and commit messages come through from the beginning is very
appreciated. And that you separated the two logically separate changes
into their own commits. Well done all around!

-Carl

PS. If someone wanted to fix git-am so that it would do the right
thing with a message formatted that way, (that is, a series of
attachments, each as a complete git patch with its own authorship
etc.), that would be great.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070307/741c09f0/attachment.pgp
From daniel.amelang at gmail.com  Wed Mar  7 12:38:31 2007
From: daniel.amelang at gmail.com (Daniel Amelang)
Date: Wed Mar  7 12:38:36 2007
Subject: [cairo] Re: Cairo performance issues.
In-Reply-To: <89B090F9A950384F8D01B633680B5F8301C47A7F@esebe102.NOE.Nokia.com>
References: <89B090F9A950384F8D01B633680B5F8301C47A7F@esebe102.NOE.Nokia.com>
Message-ID: <a65ae5c90703071238p31e10c18jba54706b172c2817@mail.gmail.com>

On 3/7/07, leonid.zolotarev@nokia.com <leonid.zolotarev@nokia.com> wrote:
> Hello Daniel,

Hello Leonid, I hope you don't mind if we take this to the cairo list,
as there's nothing about your questions that are specific to me. Also,
it would be advantageous to get other's help on this, too. And others
might benefit from the answer given.

> I work for Maemo project and currently we are suffering from some severe
> performance issues related to Cairo library.
> We manage to identify two most severe issues which affect the Cairo
> performance on Maemo platform:
>
> 1. 'cairo_xlib_surface_backend - paint' function implementation is missing
> and Cairo does composite fallback for each paint operation because of that.

This is a red herring. The fact that the xlib surface doesn't
implement "paint" does _not_ mean that it falls back to pixman
compositing. The actual compositing is done by the surface's
composite_trapezoids function, which _is_ implemented by the xlib
surface. So, nothing to worry about here, really.

> 2. Cairo does not support 16 bit color bitmaps natively and composite
> operation is very slow because it shall convert from 32/24 to 16 all the
> time.
> You can find more details on these issues from the following bug report:
> https://bugs.freedesktop.org/show_bug.cgi?id=10208

First off, do you really have to recomposite at each scroll step? Are
the two layers that are composited together changing position relative
to one another? If not, try caching the results of the compositing
onto one surface and just scroll that surface.

Now, assuming you do have to recomposite at each scroll step, you can
try making the two surfaces of the same type (it looks like you're
mixing an image surface with an xlib one, is that right? Or are you
using the deprecated CAIRO_FORMAT_RGB16_565 format?).

In other words, try creating two image surfaces and doing your
compositing on those. Or, turn your image into an xlib surface (this
is the "right" thing to do, BTW), so you have two xlib surfaces and
then cairo will push the compositing down into the (theoretically
optimized) X Render implementation for the device.

> Could you, please, help us to resolve at least the first issue because this
> is something that affect the Cairo performance most of all?
>
> I'd also appreciate if you provide us with some guidelines on the second
> issue as well.

Hope that helps.

>
> Regards,
> Leonid.

Dan
From romaxa at gmail.com  Wed Mar  7 13:38:16 2007
From: romaxa at gmail.com (Oleg Romashin)
Date: Wed Mar  7 13:38:25 2007
Subject: [cairo] Re: Cairo performance issues.
In-Reply-To: <a65ae5c90703071238p31e10c18jba54706b172c2817@mail.gmail.com>
References: <89B090F9A950384F8D01B633680B5F8301C47A7F@esebe102.NOE.Nokia.com>
	<a65ae5c90703071238p31e10c18jba54706b172c2817@mail.gmail.com>
Message-ID: <b3501cab0703071338m1f1a60bdl7be3955e9ea6e5a5@mail.gmail.com>

On 3/7/07, Daniel Amelang <daniel.amelang@gmail.com> wrote:
>
> On 3/7/07, leonid.zolotarev@nokia.com <leonid.zolotarev@nokia.com> wrote:
> > Hello Daniel,
>
> Hello Leonid, I hope you don't mind if we take this to the cairo list,
> as there's nothing about your questions that are specific to me. Also,
> it would be advantageous to get other's help on this, too. And others
> might benefit from the answer given.
>
> > I work for Maemo project and currently we are suffering from some severe
> > performance issues related to Cairo library.
> > We manage to identify two most severe issues which affect the Cairo
> > performance on Maemo platform:
> >
> > 1. 'cairo_xlib_surface_backend - paint' function implementation is
> missing
> > and Cairo does composite fallback for each paint operation because of
> that.
>
> This is a red herring. The fact that the xlib surface doesn't
> implement "paint" does _not_ mean that it falls back to pixman
> compositing. The actual compositing is done by the surface's
> composite_trapezoids function, which _is_ implemented by the xlib
> surface. So, nothing to worry about here, really.


cairo-xlib-surface.c
:1628->_cairo_xlib_surface_composite_trapezoids->XRenderComposite
Actually all our problems in non optimized  XRenderComposite, ..... :(,
it is related to our 16 bit color format.....,
and we have no processor MMX support, that can help in fbComposite
functionality...

Even if it works with _cairo_xlib_surface_composite_trapezoids, we probably
still using slow  XRenderComposite... for Images with 32/24 color depth
(Images - our main problem)

> 2. Cairo does not support 16 bit color bitmaps natively and composite
> > operation is very slow because it shall convert from 32/24 to 16 all the
> > time.
> > You can find more details on these issues from the following bug report:
> > https://bugs.freedesktop.org/show_bug.cgi?id=10208
>
> First off, do you really have to recomposite at each scroll step? Are


No, we don't, but cairo doing Xrender(pixman)Composite for each scrolling
step, if  our visible surface contain any Images with alpha channel...  even
without alpha it should to do Composite operation from 24 -> 16...

the two layers that are composited together changing position relative
> to one another? If not, try caching the results of the compositing
> onto one surface and just scroll that surface.


Yep!,  now we are trying to do some workaround for it.... where it should be
done? in cairo_image_surface? or at least in cairo...., xlib... ?

Now, assuming you do have to recomposite at each scroll step, you can
> try making the two surfaces of the same type (it looks like you're
> mixing an image surface with an xlib one, is that right?


maybe, destination surface depth, defined according to our real device
depth...
probably we can create destination surface with the same (fake) depth, and
make composite operations more simple?

Or are you
> using the deprecated CAIRO_FORMAT_RGB16_565 format?).
>
> In other words, try creating two image surfaces and doing your
> compositing on those. Or, turn your image into an xlib surface (this
> is the "right" thing to do, BTW), so you have two xlib surfaces and
> then cairo will push the compositing down into the (theoretically
> optimized) X Render implementation for the device.


Our Xrender composite implementation in our xserver - exactly the same  as
in pixman->fbcompose.c....
and our XrenderComposite operations works with the same CPU usage, but on
xserver side :(


Br, Oleg

> Could you, please, help us to resolve at least the first issue because
> this
> > is something that affect the Cairo performance most of all?
> >
> > I'd also appreciate if you provide us with some guidelines on the second
> > issue as well.
>
> Hope that helps.
>
> >
> > Regards,
> > Leonid.
>
> Dan
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070307/a0dbe985/attachment.html
From emmanuel.pacaud at lapp.in2p3.fr  Wed Mar  7 14:54:08 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Wed Mar  7 14:54:15 2007
Subject: [cairo] Extension of the radial gradient test
Message-ID: <1173308048.18197.18.camel@hobbes>

Hi,

Here's a patch that extends the current radial gradient tests with some
corner cases.

Additionnal tests are:

(a) a test with r0 > r1 ;
(b) a test with r0 == 0 and located on the outer circle edge ;
(c) a test where r1 / (r1 - r0) is not an integer, that may show issue
in rednering the content of the inner circle ;
(d) a test with r1 == r0.

The result with the image backend is here:

http://emmanuel.pacaud.free.fr/screenshots/cairo/radial-gradient-image-argb32-out.png

It looks like the image backend fails for (a) in the CAIRO_EXTEND_NONE
and CAIRO_EXTEND_PAD cases, and for (b) in all cases.

And the result with the SVG backend, rendered using batik is here:

http://emmanuel.pacaud.free.fr/screenshots/cairo/radial-gradient-svg-batik.png

It shows a failure in (c) for CAIRO_EXTEND_REFLECT.

Regarding the (d) test, for all extends except CAIRO_EXTEND_NONE, the
result is erased, since I'm not sure what to expect. The main goal is to
detect crashes in backend implementation.

During my recent work on radial gradient for the SVG backend, I tried to
take care of these corner cases. But I think (a) and (d) should be
handled by cairo before calling the backends, in order to avoid bugs in
each backend implementation.

	Emmanuel.


-------------- next part --------------
A non-text attachment was scrubbed...
Name: cairo-radial-gradient-test.patch
Type: text/x-patch
Size: 3640 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070307/c9bf446a/cairo-radial-gradient-test.bin
From emmanuel.pacaud at lapp.in2p3.fr  Wed Mar  7 14:56:44 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Wed Mar  7 14:56:52 2007
Subject: [cairo] Extension of the radial gradient test
In-Reply-To: <1173308048.18197.18.camel@hobbes>
References: <1173308048.18197.18.camel@hobbes>
Message-ID: <1173308204.18197.19.camel@hobbes>

On mer, 2007-03-07 at 23:54 +0100, Emmanuel Pacaud wrote:
> The result with the image backend is here:
> 
> http://emmanuel.pacaud.free.fr/screenshots/cairo/radial-gradient-image-argb32-out.png
> 
> It looks like the image backend fails for (a) in the CAIRO_EXTEND_NONE
> and CAIRO_EXTEND_PAD cases, and for (b) in all cases.

in (a), CAIRO_EXTEND_REPEAT also fails.

	Emmanuel.

From behdad at behdad.org  Wed Mar  7 16:05:03 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar  7 16:05:05 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1173219393.11414.34.camel@behdad>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
	<45EDD273.6030305@mit.edu>  <1173219393.11414.34.camel@behdad>
Message-ID: <1173312303.29115.12.camel@behdad>

On Tue, 2007-03-06 at 17:16 -0500, Behdad Esfahbod wrote:
> On Tue, 2007-03-06 at 14:43 -0600, Boris Zbarsky wrote:
> > Behdad Esfahbod wrote:
> > >> Are you generally interested in data of this sort?  If there's something I can 
> > >> do to help improve cairo performance, I'd love to help.
> > > 
> > > Definitely.  Pass 'em on.  Specifically, I'm really interested in a call
> > > graph to malloc.  There's a lot we can do to drop those.
> > 
> > I'll try to get together a more exhaustive list, but in the meantime 
> > https://bugzilla.mozilla.org/show_bug.cgi?id=368018 is a decent example 
> > (16% of total pageload time is under malloc/free, most of it called from 
> > cairo).  Most of the other profiles I've seen look much like this, so it 
> > may be worth addressing this one and then reprofiling.
> >
> > I don't have a good way to generate pictorial call graphs, but as far as 
> > cairo calls to malloc in that testcase go (note that some of the 
> > callstacks might have stack frames skipped due to the profiler being 
> > used...):
> 
> Thanks.  The list really helps.  Fortunately all look very easy to
> optimize as I expected.  I just need a test case that gives
> malloc/realloc numbers so I can measure my progress.
> 
> One way would be to write a small .so that overrides malloc/realloc, and
> run perf suite against it.  If we were using glib, such stats were
> free...  Anyway, anyone taking this?

Hacked my own malloc() wrapper, and after disabling visibility
attributes and "#define static", finally got down to good numbers.  Here
is what I get for the pers suite for one iteration:

         TOTAL                   MALLOC                 REALLOC
     num        size         num        size         num        size
       1          12           1          12           0           0    FcBlanksCreate
       1          12           1          12           0           0    _cairo_ft_unscaled_font_map_create
       1          16           1          16           0           0    FT_New_Memory
       1          16           1          16           0           0    _cairo_xlib_surface_font_init
       1          32           1          32           0           0    _XrmInternalStringToQuark
       1          52           1          52           0           0    _cairo_toy_font_face_create
       1          68           1          68           0           0    FcConfigCreate
       1         128           1         128           0           0    FcBlanksAdd
       1         196           1         196           0           0    _cairo_ft_unscaled_font_create_for_pattern
       1         256           0           0           1         256    FcBlanksAdd
       1       1,032           1       1,032           0           0    _cairo_scaled_font_map_lock
       1       2,048           1       2,048           0           0    _XlcCreateLocaleDataBase
       1       2,048           1       2,048           0           0    _XrmInternalStringToQuark
       1       4,115           1       4,115           0           0    FcConfigParseAndLoad
       2          40           2          40           0           0    _cairo_cache_create
       2          56           2          56           0           0    FcLangSetCreate
       2         256           2         256           0           0    FcFontSetAdd
       2         584           2         584           0           0    _cairo_hash_table_resize
       2         608           2         608           0           0    _cairo_ft_scaled_font_create
       3          24           3          24           0           0    FcConfigFilename
       3          29           3          29           0           0    _XlcAddCT
       3          33           3          33           0           0    FcConfigFilename
       3          36           3          36           0           0    FcFontSetCreate
       3          65           3          65           0           0    FcStrCopyFilename
       4         128           4         128           0           0    FcConfigSubstituteWithPat
       4         128           4         128           0           0    FcMatrixCopy
       4         160           4         160           0           0    _create_trapezoid_mask
       5         100           5         100           0           0    _cairo_hash_table_create
       5         860           5         860           0           0    _cairo_hash_table_create
       7         112           7         112           0           0    FcStrSetCreate
       7       4,480           0           0           7       4,480    FcFontSetAdd
      14     838,448          14     838,448           0           0    _XAllocScratch
      19         152          19         152           0           0    FcStrListCreate
      22         352          22         352           0           0    FcPatternCreate
      24       1,626          24       1,626           0           0    FcStrPlus
      24       7,776          24       7,776           0           0    _cairo_gstate_clone
      27       2,556          27       2,556           0           0    _get_bitmap_surface
      46     519,792          46     519,792           0           0    XML_GetBuffer
      47         615          47         615           0           0    _XlcCreateDefaultCharSet
      48         384          48         384           0           0    _XlcAddCharSet
      48         990          48         990           0           0    _XlcCreateDefaultCharSet
      48       2,304          48       2,304           0           0    _XlcCreateDefaultCharSet
      50       1,631          50       1,631           0           0    _XlcAddCT
      52         208          52         208           0           0    _XrmDefaultInitParseInfo
      52         260          52         260           0           0    _X11TransConnectDisplay
      52         624          52         624           0           0    _XOpenLC
      52         832          52         832           0           0    XRenderFindDisplay
      52         832          52         832           0           0    _X11TransConnectDisplay
      52         936          52         936           0           0    _X11TransConnectDisplay
      52         988          52         988           0           0    _X11TransGetPeerAddr
      52       1,092          52       1,092           0           0    XOpenDisplay
      52       1,664          52       1,664           0           0    _cairo_xlib_screen_info_get
      52       1,872          52       1,872           0           0    XOpenDisplay
      52       2,080          52       2,080           0           0    _XPollfdCacheInit
      52       3,744          52       3,744           0           0    XAddExtension
      52       4,160          52       4,160           0           0    XOpenDisplay
      52       4,368          52       4,368           0           0    XOpenDisplay
      52       5,200          52       5,200           0           0    XkbUseExtension
      52       5,824          52       5,824           0           0    XOpenDisplay
      52      31,824          52      31,824           0           0    XOpenDisplay
      52      42,640          52      42,640           0           0    XRenderQueryFormats
      52      52,208          52      52,208           0           0    XRenderQueryFormats
      52      69,472          52      69,472           0           0    XOpenDisplay
      52     353,080          52     353,080           0           0    XOpenDisplay
      52     851,968          52     851,968           0           0    XOpenDisplay
      54       3,052          54       3,052           0           0    _render_glyph_outline
      56       5,152          56       5,152           0           0    _cairo_scaled_glyph_lookup
      88       5,632           0           0          88       5,632    _cairo_rectilinear_stroker_add_segment
      88       9,856          88       9,856           0           0    cairo_pattern_create_linear
     104         208         104         208           0           0    _XlcCreateLC
     104         208         104         208           0           0    _XlcResolveLocaleName
     104         884         104         884           0           0    XInitExtension
     104       2,080         104       2,080           0           0    _XlcCreateLocaleDataBase
     104       3,328         104       3,328           0           0    XauReadAuth
     104       3,640         104       3,640           0           0    _XlcFileName
     104       7,488         104       7,488           0           0    XInitExtension
     104      28,288         104      28,288           0           0    XOpenDisplay
     104      31,616         104      31,616           0           0    _XlcCreateLocaleDataBase
     104     212,992         104     212,992           0           0    _XlcCreateLocaleDataBase
     156       1,248         156       1,248           0           0    _XlcAddLoader
     200      18,400         200      18,400           0           0    cairo_pattern_create_for_surface
     304      20,672         304      20,672           0           0    cairo_create
     304      98,496         304      98,496           0           0    _cairo_gstate_create
     352       6,336           0           0         352       6,336    _cairo_pattern_add_color_stop
     418      13,376         418      13,376           0           0    _XlcSetConverter
     497       7,264         497       7,264           0           0    FcStrCopy
     712   1,877,056         712   1,877,056           0           0    qsort
     882      20,322         882      20,322           0           0    __strdup
    1920   1,228,800        1920   1,228,800           0           0    _cairo_pen_init_copy
    1920   1,413,120        1920   1,413,120           0           0    _cairo_hull_create
    1920   1,413,120           0           0        1920   1,413,120    _cairo_pen_add_points
    1944       7,776        1944       7,776           0           0    XGetImage
    1944     171,072        1944     171,072           0           0    XCreateImage
    2688     182,784        2688     182,784           0           0    _cairo_pixman_image_create_linear_gradient
    2688     290,304        2688     290,304           0           0    _cairo_pixman_image_create_radial_gradient
    2688     311,808        2688     311,808           0           0    _cairo_pixman_image_create_linear_gradient
    2688     311,808        2688     311,808           0           0    _cairo_pixman_image_create_radial_gradient
    3016     667,392        3016     667,392           0           0    _cairo_pen_init
   10038   1,124,256       10038   1,124,256           0           0    XCreateGC
   10672  27,343,136       10672  27,343,136           0           0    _cairo_image_surface_composite_trapezoids
   10728     386,208       10728     386,208           0           0    FbPixelsCreateForData
   12160   1,888,000       12160   1,888,000           0           0    _cairo_utf8_to_ucs4
   12160   9,196,800       12160   9,196,800           0           0    _cairo_scaled_font_text_to_glyphs
   15872     380,928       15872     380,928           0           0    _cairo_gradient_pattern_init_copy
   28380   7,719,360       28380   7,719,360           0           0    _cairo_xlib_surface_create_internal
   32972 160,212,808       32972 160,212,808           0           0    FbPixelsCreate
   35708   8,141,424       35708   8,141,424           0           0    _cairo_image_surface_create_for_pixman_image
   38136   8,265,792       38136   8,265,792           0           0    _cairo_bo_event_queue_init
   38136  45,461,856       38136  45,461,856           0           0    _cairo_bentley_ottmann_tessellate_polygon
   38136  66,126,336       38136  66,126,336           0           0    _cairo_bo_event_queue_init
   42428   1,446,338       42291   1,435,270         137      11,068    (other)
   43691   1,747,640       43691   1,747,640           0           0    _cairo_pixman_format_create_masks
   43700   5,069,200       43700   5,069,200           0           0    pixman_image_createForPixels
   45224     363,584       45224     363,584           0           0    _cairo_surface_fill_region
   49672   3,775,072       49672   3,775,072           0           0    _cairo_path_op_buf_create
   49696  26,040,704       49696  26,040,704           0           0    _cairo_path_arg_buf_create
   58864     470,912       58864     470,912           0           0    _cairo_freelist_alloc
   70104  62,266,368           0           0       70104  62,266,368    _cairo_polygon_grow_by
   74168   9,493,504       74168   9,493,504           0           0    _cairo_pattern_create_solid
   80088   9,610,560       80088   9,610,560           0           0    cairo_pattern_create_radial
  102216 320,289,920           0           0      102216 320,289,920    _cairo_traps_grow_by
  108832  28,188,672           0           0      108832  28,188,672    _cairo_spline_grow_by
  163052   3,035,932      163052   3,035,932           0           0    alloc_node_for_level
  682080   8,184,960      682080   8,184,960           0           0    _cairo_pixman_region_create_simple
 1927116 827,436,080     1643459 415,250,228      283657 412,185,852    (total)

> >    realloc
> >      cairo_polygon_add_edge
> >        cairo_polygon_line_to
> >          cairo_filler_line_to
> >            cairo_path_fixed_interpret
> >              cairo_path_fixed_fill_to_traps
> >                cairo_surface_fallback_fill
> >      cairo_traps_grow_by
> >        cairo_traps_add_trap
> >          cairo_traps_add_trap_from_points
> >            cairo_bentley_ottmann_tessellate_polygon
> >            cairo_bo_edge_end_trap
> >              cairo_bentley_ottmann_tessellate_polygon
> 
> Both realloc an array to fit more items, but oops!  they just enlarge it
> enough to fit the items at hand (I may be wrong, but I don't think I
> am.)  That means, at some point, they will realloc on any operation!
> 
> Easy-fix: exponentially enlarge them.

Seems like I was wrong.  It does do exponential growth.  Just in a weird
way.



-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From daniel.amelang at gmail.com  Wed Mar  7 21:05:16 2007
From: daniel.amelang at gmail.com (Daniel Amelang)
Date: Wed Mar  7 21:05:20 2007
Subject: [cairo] Re: Cairo performance issues.
In-Reply-To: <eaa6fa6a0703071540g514ef83dl50c2814e1759994@mail.gmail.com>
References: <89B090F9A950384F8D01B633680B5F8301C47A7F@esebe102.NOE.Nokia.com>
	<a65ae5c90703071238p31e10c18jba54706b172c2817@mail.gmail.com>
	<b3501cab0703071338m1f1a60bdl7be3955e9ea6e5a5@mail.gmail.com>
	<eaa6fa6a0703071540g514ef83dl50c2814e1759994@mail.gmail.com>
Message-ID: <a65ae5c90703072105i751672f9j999c75d825d5075f@mail.gmail.com>

On 3/7/07, Andrey Petrov <andrey.petrov@gmail.com> wrote:
> On 3/7/07, Oleg Romashin <romaxa@gmail.com> wrote:
> >
> > Yep!,  now we are trying to do some workaround for it.... where it should
> be done? in cairo_image_surface? or at least in cairo...., xlib... ?
>
> Our original guess was that since Cairo and xlib surfaces actually keep the
> image entities on the server side, it would be easy/reasonable to put the
> caching logic there. However it turned out surfaces are quite simple and
> atomic and probably best left alone not worrying about caches.
>
> The images we are talking about do not change positions to each another at
> all (at least in the usecase we are interested in). Therefore I think it is
> purely Cairo client's problem, and we could create a large surface and just
> scroll it (as opposed to create small one with size of the screen, and then
> redo it on every scroll). The problem with this is that we probably will be
> wasting a lot of memory. Perhaps Cairo's client is better to do all the
> expensive alpha-compositions once, cache them (they are static), and put
> these cached surfaces on the frame being rendered.

That's the idea.

>
> So unless Cairo has plans to add some sort of a "super surface" entity which
> would take care of smaller surfaces and provide higher-level functionality
> (scrolling, zooming, ...) I think we should stick to caching on Cairo
> client's side.

No, no plans for a "super surface" (at least that's my understanding).
This level of functionality is meant to be above cairo, like in a
canvas or a UI widget.

Dan
From cairo-2007a at ryandesign.com  Wed Mar  7 22:28:52 2007
From: cairo-2007a at ryandesign.com (Ryan Schmidt)
Date: Wed Mar  7 22:29:06 2007
Subject: [cairo] cairo 1.4.0 with quartz
In-Reply-To: <871wk3ljot.wl%cworth@cworth.org>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
	<B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>
	<2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>
	<871wk3ljot.wl%cworth@cworth.org>
Message-ID: <20851FCB-441D-4110-97AC-78C030867BE1@ryandesign.com>

On Mar 5, 2007, at 10:49, Carl Worth wrote:

> On Mon, 5 Mar 2007 13:58:27 +0000, Baz wrote:
>
>> On 05/03/07, Travis Griggs wrote:
>>
>>> I'd like some clarification pretty please. I'm using 1.2.6 right  
>>> now on PPC
>>> OSX. I actually use both interfaces. I have some stuff that uses  
>>> xlib
>>> interfaces, and other which goes straight through the quartz  
>>> interface. When
>>> I get around to upgrading to 1.4, am I still going to be able to  
>>> do this?
>>
>> Short answer is no, unless you build yourself 2 libraries (or are you
>> using both in the same program?).
>
> Short answer is absolutely yes.
>
> I won't release cairo 1.4 until this is fixed.
>
> There's no reason cairo shouldn't allow you to build it with any
> combination of the available backends.

FYI: The Quartz problem remains in 1.4.0. --enable-atsui now works by  
itself (at least, it compiles properly even when --enable-quartz is  
not used), but trying to --enable-quartz without using --disable-xlib  
still does this:

  gcc -DHAVE_CONFIG_H -I. -I. -I.. -D_GNU_SOURCE -I. -I../pixman/src - 
I../src -I../src -I/opt/local/include/freetype2 -I/opt/local/include - 
I/opt/local/include/libpng12 -DXTHREADS -I/opt/local/include -I/usr/ 
X11R6/include -I/usr/X11R6/include -Wall -Wextra -Wsign-compare - 
Werror-implicit-function-declaration -Wpointer-arith -Wwrite-strings - 
Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations - 
Wnested-externs -Wpacked -Wswitch-enum -Wmissing-format-attribute - 
Wstrict-aliasing=2 -Winit-self -Wdeclaration-after-statement -Wold- 
style-definition -Wno-missing-field-initializers -Wno-unused- 
parameter -fno-strict-aliasing -g -O2 -MT cairo-boilerplate.lo -MD - 
MP -MF .deps/cairo-boilerplate.Tpo -c cairo-boilerplate.c  -fno- 
common -DPIC -o .libs/cairo-boilerplate.o
In file included from /opt/local/include/X11/extensions/Xrender.h:29,
                  from ../src/cairo-xlib-xrender.h:44,
                  from cairo-boilerplate.c:864:
/opt/local/include/X11/extensions/render.h:31: error: conflicting  
types for 'Picture'
/System/Library/Frameworks/ApplicationServices.framework/Frameworks/ 
QD.framework/Headers/Quickdraw.h:309: error: previous declaration of  
'Picture' was here
In file included from /usr/X11R6/include/X11/Xlib.h:59,
                  from /opt/local/include/X11/extensions/Xrender.h:31,
                  from ../src/cairo-xlib-xrender.h:44,
                  from cairo-boilerplate.c:864:
/usr/X11R6/include/X11/X.h:108: error: conflicting types for 'Cursor'
/System/Library/Frameworks/ApplicationServices.framework/Frameworks/ 
QD.framework/Headers/Quickdraw.h:278: error: previous declaration of  
'Cursor' was here
make[2]: *** [cairo-boilerplate.lo] Error 1
make[1]: *** [all-recursive] Error 1
make: *** [all] Error 2




From cworth at cworth.org  Wed Mar  7 22:36:58 2007
From: cworth at cworth.org (Carl Worth)
Date: Wed Mar  7 22:37:12 2007
Subject: [cairo] cairo 1.4.0 with quartz
In-Reply-To: <20851FCB-441D-4110-97AC-78C030867BE1@ryandesign.com>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
	<B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>
	<2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>
	<871wk3ljot.wl%cworth@cworth.org>
	<20851FCB-441D-4110-97AC-78C030867BE1@ryandesign.com>
Message-ID: <87y7m89r79.wl%cworth@cworth.org>

On Thu, 8 Mar 2007 00:28:52 -0600, Ryan Schmidt wrote:
> On Mar 5, 2007, at 10:49, Carl Worth wrote:
> > There's no reason cairo shouldn't allow you to build it with any
> > combination of the available backends.
>
> FYI: The Quartz problem remains in 1.4.0. --enable-atsui now works by
> itself (at least, it compiles properly even when --enable-quartz is
> not used), but trying to --enable-quartz without using --disable-xlib
...
> In file included from /opt/local/include/X11/extensions/Xrender.h:29,
>                   from ../src/cairo-xlib-xrender.h:44,
>                   from cairo-boilerplate.c:864:
> /opt/local/include/X11/extensions/render.h:31: error: conflicting
> types for 'Picture'

Yeah, we didn't quite fix that yet, sorry.

But note that the only problem is in cairo-boilerplate.c which is not
part of the cairo library itself. You should be able to whack the
Makefiles (or Makefile.am files) to not descend into boilerplate/ and
things should work just fine, (you just won't be able to run the test
or perf suites).

Or you can maybe just build with "make -k" and push past the problem
and still get a functional library out of the deal.

So, yeah, this is a nuisance, but you should be able to get past
it. (And yes, we do still need to do the obvious thing and split up
the parts of cairo-boilerplate.c that each depend on an independent
definition of "Picture" to exist in separate files).

And I sure wich system libraries wouldn't pollute the namespace so
badly like that. I'd even feel more comfortable in my indignation if
it were only proprietary or ancient libraries that did this, but this
is the modern, X render library giving us Picture here *sigh*, (though
admittedly, it _is_ just maintaining naming consistency with the
ancient and very namespace-polluting Xlib conventions).

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070307/40c62715/attachment.pgp
From brian.ewins at gmail.com  Thu Mar  8 02:27:19 2007
From: brian.ewins at gmail.com (Baz)
Date: Thu Mar  8 02:27:26 2007
Subject: [cairo] cairo 1.4.0 with quartz
In-Reply-To: <87y7m89r79.wl%cworth@cworth.org>
References: <9DF1811E-3CED-49F2-B165-D71C83B49139@ryandesign.com>
	<2faad3050703031816n10dbc08dxa996ab7718cfff0e@mail.gmail.com>
	<45EA2FBD.4080303@pobox.com>
	<2faad3050703031908j5f9a0bffv29d15ebc80d905bf@mail.gmail.com>
	<DB231508-F427-4F5C-83B8-7F2720A76C51@ryandesign.com>
	<B7B5AD9E-9BBD-47D9-9CDF-DEF08C853627@cincom.com>
	<2faad3050703050558n389aa082sd69baabd0547aa93@mail.gmail.com>
	<871wk3ljot.wl%cworth@cworth.org>
	<20851FCB-441D-4110-97AC-78C030867BE1@ryandesign.com>
	<87y7m89r79.wl%cworth@cworth.org>
Message-ID: <2faad3050703080227l18c3ec8buf018bbd7e69a480c@mail.gmail.com>

On 08/03/07, Carl Worth <cworth@cworth.org> wrote:
> On Thu, 8 Mar 2007 00:28:52 -0600, Ryan Schmidt wrote:
> > On Mar 5, 2007, at 10:49, Carl Worth wrote:
> > > There's no reason cairo shouldn't allow you to build it with any
> > > combination of the available backends.
> >
> > FYI: The Quartz problem remains in 1.4.0. --enable-atsui now works by
> > itself (at least, it compiles properly even when --enable-quartz is
> > not used), but trying to --enable-quartz without using --disable-xlib
> ...
> > In file included from /opt/local/include/X11/extensions/Xrender.h:29,
> >                   from ../src/cairo-xlib-xrender.h:44,
> >                   from cairo-boilerplate.c:864:
> > /opt/local/include/X11/extensions/render.h:31: error: conflicting
> > types for 'Picture'
>
> Yeah, we didn't quite fix that yet, sorry.
[other solutions]

A hack suggested by Behdad I tested the night of the release: at line
742 of cairo-boilerplate.c, just before the #endif (for
CAIRO_HAS_QUARTZ_SURFACE), add:

#undef Picture
#define Picture CairoQuartzPicture
#undef Cursor
#define Cursor CairoQuartzCursor

You'll be able to build without the --disable-xlib, and take your pick
of whether to use atsui or ft in your build. But testing this I ran
into the extend-reflect crash and ran out of time to get it into the
release. Which is probably for the best, I'd like to fix it properly
as Carl described.

Cheers,
Baz
From david at freetype.org  Thu Mar  8 03:07:15 2007
From: david at freetype.org (David Turner)
Date: Thu Mar  8 03:07:20 2007
Subject: [cairo] Faster Radial Gradients patch
Message-ID: <1173352035.384.1178378253@webmail.messagingengine.com>

Hello,

  here's a small patchset that speeds up radial gradient rendering up to 1.48x.
  the trick is simply to optimize the computations through simplifications and
  forward differencing.

    http://david.freetype.org/cairo/faster-radial-gradients-1.patchset

  other tricks like using fixed point arithmetics, or approximating the square
  root extraction per pixel may be used in the future.

  note that the patch also introduces support for degenerate cases like 
  when the two circles are identical, or when they touch on a single point
  of contact (respectively A == 0 && B == 0  and  A == 0 && B != 0)

Regards,

- David Turner
- The FreeType Project  (www.freetype.org)

From jeff at infidigm.net  Thu Mar  8 08:37:48 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Thu Mar  8 08:36:19 2007
Subject: [cairo] slow path annotations
Message-ID: <20070308163748.GA12531@infidigm.net>

The following patch annotates some of the slow paths in cairo with
cairo_slow_path() or pixman_slow_path() as appropriate. If either of
these functions is called, cairo will raise a SIGTRAP. 

If you run the applications with gdb, the SIGTRAP will stop the
application and you will be able to get a backtrace to see what caused
the slow path to be called. After determining the cause, you can either
fix cairo or fix your application.

For example, glitz-test currently draws it's rgba(0,0,0,1) text with
OPERATOR_SOURCE. OPERATOR_SOURCE through a mask is a slow path. Changing
this to OPERATOR_OVER (probably the wanted operator anyways) gives me
about a 3-4fps speed up (old=22fps, new=25fps) using software rendering.

Note, X has the pretty much the same slow paths as pixman, however this
patch will not catch them. You can fix this by rending to a temporary
image surface and then set_source'ing and painting to your X cairo
context.

-Jeff

diff --git a/pixman/src/fbcompose.c b/pixman/src/fbcompose.c
index 233b90c..8f5cb87 100644
--- a/pixman/src/fbcompose.c
+++ b/pixman/src/fbcompose.c
@@ -4206,6 +4206,10 @@ pixman_compositeGeneral (pixman_operator_t	op,
     CARD32 *scanline_buffer = _scanline_buffer;
     FbComposeData compose_data;
 
+    /* Don't treat gradients as a slow path because there is no fast path */
+    if (pSrc->pDrawable)
+	    pixman_slow_path();
+
     if (pSrc->pDrawable)
         srcRepeat = pSrc->repeat == RepeatNormal && !pSrc->transform
                     && (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1);
diff --git a/pixman/src/fbpict.c b/pixman/src/fbpict.c
index 0bd989f..af3ff26 100644
--- a/pixman/src/fbpict.c
+++ b/pixman/src/fbpict.c
@@ -1951,6 +1951,14 @@ pixman_composite (pixman_operator_t	op,
 
     n = pixman_region_num_rects (region);
     pbox = pixman_region_rects (region);
+
+    /* check for compositing a solid surface without a solid varient */
+    if (srcRepeat && pSrc->pDrawable &&
+		    pSrc->pDrawable->height == 1 &&
+		    pSrc->pDrawable->width == 1 &&
+		    (pbox->y2 - pbox->y1 > 1 || pbox->x2 - pbox->x1 > 1))
+	    pixman_slow_path();
+
     while (n--)
     {
 	h = pbox->y2 - pbox->y1;
diff --git a/pixman/src/icint.h b/pixman/src/icint.h
index 47a2220..46cf955 100644
--- a/pixman/src/icint.h
+++ b/pixman/src/icint.h
@@ -117,6 +117,12 @@ typedef pixman_triangle_t	xTriangle;
 #define MAXSHORT SHRT_MAX
 #define MINSHORT SHRT_MIN
 
+#include <signal.h>
+static inline void pixman_slow_path(void)
+{
+	raise(5);
+}
+
 /* XXX: What do we need from here?
 #include "picture.h"
 */
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..3a0cf0f 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -284,14 +284,15 @@ _clip_and_composite_source (cairo_clip_t                  *clip,
     cairo_surface_pattern_t mask_pattern;
     cairo_status_t status;
 
+    /* Single composite operation becomes two.
+     * Two, that are likely not fast */
+    /* If you hit this maybe you should be using OVER instead of SOURCE */
+    cairo_slow_path();
+
     /* Create a surface that is mask IN clip
      */
-    status = _create_composite_mask_pattern (&mask_pattern,
-					     clip,
-					     draw_func, draw_closure,
-					     dst, extents);
-    if (status)
-	return status;
+    status = _create_composite_mask_pattern (&mask_pattern, clip, draw_func,
+		    draw_closure, dst, extents); if (status) return status;
 
     /* Compute dest' = dest OUT (mask IN clip)
      */
diff --git a/src/cairoint.h b/src/cairoint.h
index 19897ff..4ccea82 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -272,6 +272,12 @@ typedef cairo_fixed_16_16_t cairo_fixed_t;
 #define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) CAIRO_BITSWAP8(c)
 #endif
 
+#include <signal.h>
+static inline void cairo_slow_path(void)
+{
+	raise(5);
+}
+
 #include "cairo-hash-private.h"
 #include "cairo-cache-private.h"
 
From behdad at behdad.org  Thu Mar  8 09:42:10 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar  8 09:42:07 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173197090.24503.83.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
	<1173194925.11414.3.camel@behdad>
	<1173197090.24503.83.camel@trinidad.mandrakesoft.com>
Message-ID: <1173375730.20910.6.camel@behdad>

On Tue, 2007-03-06 at 11:04 -0500, Frederic Crozat wrote:
> Le mardi 06 mars 2007 ? 10:28 -0500, Behdad Esfahbod a ?crit :
> > On Tue, 2007-03-06 at 03:47 -0500, Frederic Crozat wrote:
> > > Le lundi 05 mars 2007 ? 16:05 -0500, Behdad Esfahbod a ?crit :
> > > > On Mon, 2007-03-05 at 08:53 -0500, Frederic Crozat wrote:
> > > > > 
> > > > > You need to apply first fix and second one in sequence (I've undo some
> > > > > of the change I did in my first patch, which aren't really needed). 
> > > > 
> > > > In that case, would you mind giving us a final combined patch, without
> > > > any formatting changes please?
> > > 
> > > I wanted git to give me a combined patch with changelog but I'm still a
> > > newbie for that ;)
> > > 
> > > Anyway, new patch attached.
> > 
> > Thanks.  BTW, cairo's configure tries to use -fno-strict-aliasing.  Did
> > you force it off or something to hit this bug?
> 
> Our default packages CFLAGS are :
> on x86 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
> -fomit-frame-pointer -march=i586 -mtune=generic
> -fasynchronous-unwind-tables
> 
> and on x86-64 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
> 
> and they overwrite default CFLAGS in an autoconf/automake setup.
> 
> Which is why we were the only one to see this problem.

I still don't see how that makes cairo not use -fno-strict-aliasing.

> So, I think we can say -fno-strict-aliasing can be removed from cairo
> with my patch :)

Well, it's less harmful now.  But theoretically we still need it,
because we cast different surface types (abstract and specific) all the
time.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From fcrozat at mandriva.com  Thu Mar  8 10:23:04 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Thu Mar  8 10:17:16 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173375730.20910.6.camel@behdad>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
	<1173194925.11414.3.camel@behdad>
	<1173197090.24503.83.camel@trinidad.mandrakesoft.com>
	<1173375730.20910.6.camel@behdad>
Message-ID: <1173378184.16530.50.camel@trinidad.mandrakesoft.com>

Le jeudi 08 mars 2007 ? 12:42 -0500, Behdad Esfahbod a ?crit :
> On Tue, 2007-03-06 at 11:04 -0500, Frederic Crozat wrote:
> > Le mardi 06 mars 2007 ? 10:28 -0500, Behdad Esfahbod a ?crit :
> > > On Tue, 2007-03-06 at 03:47 -0500, Frederic Crozat wrote:
> > > > Le lundi 05 mars 2007 ? 16:05 -0500, Behdad Esfahbod a ?crit :
> > > > > On Mon, 2007-03-05 at 08:53 -0500, Frederic Crozat wrote:
> > > > > > 
> > > > > > You need to apply first fix and second one in sequence (I've undo some
> > > > > > of the change I did in my first patch, which aren't really needed). 
> > > > > 
> > > > > In that case, would you mind giving us a final combined patch, without
> > > > > any formatting changes please?
> > > > 
> > > > I wanted git to give me a combined patch with changelog but I'm still a
> > > > newbie for that ;)
> > > > 
> > > > Anyway, new patch attached.
> > > 
> > > Thanks.  BTW, cairo's configure tries to use -fno-strict-aliasing.  Did
> > > you force it off or something to hit this bug?
> > 
> > Our default packages CFLAGS are :
> > on x86 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
> > -fomit-frame-pointer -march=i586 -mtune=generic
> > -fasynchronous-unwind-tables
> > 
> > and on x86-64 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
> > 
> > and they overwrite default CFLAGS in an autoconf/automake setup.
> > 
> > Which is why we were the only one to see this problem.
> 
> I still don't see how that makes cairo not use -fno-strict-aliasing.

I say you are not doing enough packaging :)

CFLAGS is beging exported when running configure and then grabbed to
replace internal CFLAGS from configure.in.

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva

From behdad at behdad.org  Thu Mar  8 12:40:36 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar  8 12:40:30 2007
Subject: [cairo] slow path annotations
In-Reply-To: <20070308163748.GA12531@infidigm.net>
References: <20070308163748.GA12531@infidigm.net>
Message-ID: <1173386436.22108.35.camel@behdad>

On Thu, 2007-03-08 at 11:37 -0500, Jeff Muizelaar wrote:
> The following patch annotates some of the slow paths in cairo with
> cairo_slow_path() or pixman_slow_path() as appropriate. If either of
> these functions is called, cairo will raise a SIGTRAP. 

Great stuff for the debugging mode.  Lets focus on some bugfixing for a
bit, probably get 1.4.2 out, then start adding debug options and
reworking the test suite.

And we should raise SIGTRAP in cairo_error() too btw!  Maybe by default
even.  Comments?


> Note, X has the pretty much the same slow paths as pixman, however this
> patch will not catch them. You can fix this by rending to a temporary
> image surface and then set_source'ing and painting to your X cairo
> context.

Some of them checks you can do before calling xlib, right?

Thanks
behdad

> -Jeff
> 
> diff --git a/pixman/src/fbcompose.c b/pixman/src/fbcompose.c
> index 233b90c..8f5cb87 100644
> --- a/pixman/src/fbcompose.c
> +++ b/pixman/src/fbcompose.c
> @@ -4206,6 +4206,10 @@ pixman_compositeGeneral (pixman_operator_t	op,
>      CARD32 *scanline_buffer = _scanline_buffer;
>      FbComposeData compose_data;
>  
> +    /* Don't treat gradients as a slow path because there is no fast path */
> +    if (pSrc->pDrawable)
> +	    pixman_slow_path();
> +
>      if (pSrc->pDrawable)
>          srcRepeat = pSrc->repeat == RepeatNormal && !pSrc->transform
>                      && (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1);
> diff --git a/pixman/src/fbpict.c b/pixman/src/fbpict.c
> index 0bd989f..af3ff26 100644
> --- a/pixman/src/fbpict.c
> +++ b/pixman/src/fbpict.c
> @@ -1951,6 +1951,14 @@ pixman_composite (pixman_operator_t	op,
>  
>      n = pixman_region_num_rects (region);
>      pbox = pixman_region_rects (region);
> +
> +    /* check for compositing a solid surface without a solid varient */
> +    if (srcRepeat && pSrc->pDrawable &&
> +		    pSrc->pDrawable->height == 1 &&
> +		    pSrc->pDrawable->width == 1 &&
> +		    (pbox->y2 - pbox->y1 > 1 || pbox->x2 - pbox->x1 > 1))
> +	    pixman_slow_path();
> +
>      while (n--)
>      {
>  	h = pbox->y2 - pbox->y1;
> diff --git a/pixman/src/icint.h b/pixman/src/icint.h
> index 47a2220..46cf955 100644
> --- a/pixman/src/icint.h
> +++ b/pixman/src/icint.h
> @@ -117,6 +117,12 @@ typedef pixman_triangle_t	xTriangle;
>  #define MAXSHORT SHRT_MAX
>  #define MINSHORT SHRT_MIN
>  
> +#include <signal.h>
> +static inline void pixman_slow_path(void)
> +{
> +	raise(5);
> +}
> +
>  /* XXX: What do we need from here?
>  #include "picture.h"
>  */
> diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
> index 1a7d666..3a0cf0f 100644
> --- a/src/cairo-surface-fallback.c
> +++ b/src/cairo-surface-fallback.c
> @@ -284,14 +284,15 @@ _clip_and_composite_source (cairo_clip_t                  *clip,
>      cairo_surface_pattern_t mask_pattern;
>      cairo_status_t status;
>  
> +    /* Single composite operation becomes two.
> +     * Two, that are likely not fast */
> +    /* If you hit this maybe you should be using OVER instead of SOURCE */
> +    cairo_slow_path();
> +
>      /* Create a surface that is mask IN clip
>       */
> -    status = _create_composite_mask_pattern (&mask_pattern,
> -					     clip,
> -					     draw_func, draw_closure,
> -					     dst, extents);
> -    if (status)
> -	return status;
> +    status = _create_composite_mask_pattern (&mask_pattern, clip, draw_func,
> +		    draw_closure, dst, extents); if (status) return status;
>  
>      /* Compute dest' = dest OUT (mask IN clip)
>       */
> diff --git a/src/cairoint.h b/src/cairoint.h
> index 19897ff..4ccea82 100755
> --- a/src/cairoint.h
> +++ b/src/cairoint.h
> @@ -272,6 +272,12 @@ typedef cairo_fixed_16_16_t cairo_fixed_t;
>  #define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) CAIRO_BITSWAP8(c)
>  #endif
>  
> +#include <signal.h>
> +static inline void cairo_slow_path(void)
> +{
> +	raise(5);
> +}
> +
>  #include "cairo-hash-private.h"
>  #include "cairo-cache-private.h"
>  
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From emmanuel.pacaud at lapp.in2p3.fr  Thu Mar  8 12:45:35 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Thu Mar  8 12:45:41 2007
Subject: [cairo] Extension of the radial gradient test
In-Reply-To: <1173308204.18197.19.camel@hobbes>
References: <1173308048.18197.18.camel@hobbes>
	<1173308204.18197.19.camel@hobbes>
Message-ID: <1173386735.7479.1.camel@hobbes>

On mer, 2007-03-07 at 23:56 +0100, Emmanuel Pacaud wrote:
> On mer, 2007-03-07 at 23:54 +0100, Emmanuel Pacaud wrote:
> > The result with the image backend is here:
> > 
> > http://emmanuel.pacaud.free.fr/screenshots/cairo/radial-gradient-image-argb32-out.png
> > 
> > It looks like the image backend fails for (a) in the CAIRO_EXTEND_NONE
> > and CAIRO_EXTEND_PAD cases, and for (b) in all cases.
> 
> in (a), CAIRO_EXTEND_REPEAT also fails.

I've just fixed the failure in the SVG backend.

Here's an updated version of the extended version of radial-gradient.c
patch (I've removed the push_group pop_group calls that triggered image
fallbacks).

	Emmanuel.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test-extended-radial-gradient.patch
Type: text/x-patch
Size: 3667 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070308/0aa91749/test-extended-radial-gradient.bin
From behdad at behdad.org  Thu Mar  8 12:49:57 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar  8 12:49:52 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173378184.16530.50.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
	<1173194925.11414.3.camel@behdad>
	<1173197090.24503.83.camel@trinidad.mandrakesoft.com>
	<1173375730.20910.6.camel@behdad>
	<1173378184.16530.50.camel@trinidad.mandrakesoft.com>
Message-ID: <1173386997.22108.39.camel@behdad>

On Thu, 2007-03-08 at 13:23 -0500, Frederic Crozat wrote:
> Le jeudi 08 mars 2007 ? 12:42 -0500, Behdad Esfahbod a ?crit :
> > On Tue, 2007-03-06 at 11:04 -0500, Frederic Crozat wrote:
> > > Le mardi 06 mars 2007 ? 10:28 -0500, Behdad Esfahbod a ?crit :
> > > > On Tue, 2007-03-06 at 03:47 -0500, Frederic Crozat wrote:
> > > > > Le lundi 05 mars 2007 ? 16:05 -0500, Behdad Esfahbod a ?crit :
> > > > > > On Mon, 2007-03-05 at 08:53 -0500, Frederic Crozat wrote:
> > > > > > > 
> > > > > > > You need to apply first fix and second one in sequence (I've undo some
> > > > > > > of the change I did in my first patch, which aren't really needed). 
> > > > > > 
> > > > > > In that case, would you mind giving us a final combined patch, without
> > > > > > any formatting changes please?
> > > > > 
> > > > > I wanted git to give me a combined patch with changelog but I'm still a
> > > > > newbie for that ;)
> > > > > 
> > > > > Anyway, new patch attached.
> > > > 
> > > > Thanks.  BTW, cairo's configure tries to use -fno-strict-aliasing.  Did
> > > > you force it off or something to hit this bug?
> > > 
> > > Our default packages CFLAGS are :
> > > on x86 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
> > > -fomit-frame-pointer -march=i586 -mtune=generic
> > > -fasynchronous-unwind-tables
> > > 
> > > and on x86-64 : -O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
> > > 
> > > and they overwrite default CFLAGS in an autoconf/automake setup.
> > > 
> > > Which is why we were the only one to see this problem.
> > 
> > I still don't see how that makes cairo not use -fno-strict-aliasing.
> 
> I say you are not doing enough packaging :)

Maybe not.  But in the limited amount that I've done, rarely I've
removed CFLAGS of the package.  Just added to it.


> CFLAGS is beging exported when running configure and then grabbed to
> replace internal CFLAGS from configure.in.
> 
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From ken.carlino at gmail.com  Thu Mar  8 15:55:52 2007
From: ken.carlino at gmail.com (ken carlino)
Date: Thu Mar  8 15:55:56 2007
Subject: [cairo] Cairo on Red Hat Enterprise Linux 4
Message-ID: <b9e408290703081555o2c26db2ob1b43ea9ee1b176c@mail.gmail.com>

Does Cairo install on Red Hat Enterprise Linux 4 ?
I did a 'rpm -q cairo', I don't see it has cairo.

If not, if my application uses cairo and need to be deployed on RHEL4,
what is the best way to do that?  I prefer not to have the user to
download the cairo source and compile/install on RHEL4.

Thank you.
From lsalazar at estudiantes.uci.cu  Thu Mar  8 12:16:14 2007
From: lsalazar at estudiantes.uci.cu (Leonel Salazar Videaux)
Date: Thu Mar  8 16:04:43 2007
Subject: [cairo] Image basic data
References: <20070308200020.209CE9E738@gabe.freedesktop.org>
Message-ID: <CD5D28C6C2E39441B4AC9027771E9AD2033F381C@ucixs56.uci.cu>

How can I know the basic image or picture data using cairo?, I mean, i need to get some memory in a buffer and for do that i need to know data such as width and height, i just want to know how to get this information from a PNG of SVG file.

Leonel.

----------------------------------------
Leonel Salazar Videaux
Ing. Inform?tica (UCI)
5to. A?o
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/ms-tnef
Size: 2517 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070308/69ee3cc5/attachment.bin
From brian.ewins at gmail.com  Thu Mar  8 17:19:25 2007
From: brian.ewins at gmail.com (Baz)
Date: Thu Mar  8 17:19:31 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <45D6DFF1.4080505@gentoo.org>
References: <45D6DFF1.4080505@gentoo.org>
Message-ID: <2faad3050703081719k12c612e3qcc3863887ccb85c4@mail.gmail.com>

On 17/02/07, Luca Barbato <lu_zero@gentoo.org> wrote:
> I completed the fbcompose part the regtest are consistent, hopefully
> I'll start adding the pict ops later in the next week.
>
> lu

The patch fails to compile on apple:

 /usr/libexec/gcc/powerpc-apple-darwin8/4.0.1/cc1 -fpreprocessed
fbpict.i -fPIC -quiet -dumpbase fbpict.c -auxbase-strip .libs/fbpict.o
-Wall -Wextra -Wsign-compare -Werror-implicit-function-declaration
-Wpointer-arith -Wwrite-strings -Wstrict-prototypes
-Wmissing-prototypes -Wmissing-declarations -Wnested-externs -Wpacked
-Wswitch-enum -Wmissing-format-attribute -Wstrict-aliasing=2
-Winit-self -Wdeclaration-after-statement -Wold-style-definition
-Wno-missing-field-initializers -Wno-unused-parameter -version
-fno-common -o fbpict.s
GNU C version 4.0.1 (Apple Computer, Inc. build 5247) (powerpc-apple-darwin8)
        compiled by GNU C version 4.0.1 (Apple Computer, Inc. build 5247).
GGC heuristics: --param ggc-min-expand=65 --param ggc-min-heapsize=65536
Compiler executable checksum: 293c7bb043389dbe08b10e2d17bba0c4
 as -arch ppc -o .libs/fbpict.o fbpict.s
fbpict.s:9430:Parameter syntax error (parameter 1)
make[3]: *** [fbpict.lo] Error 1
make[2]: *** [all-recursive] Error 1
make[1]: *** [all-recursive] Error 1

The offending line was 'vor 0, 0, 0', from your VMX detection code. I
fixed it up using VMX detection from apples docs as below, seems to be
working now - make check seems ok, now I need to run the perf tests.
More later.

#ifdef __APPLE__
#include <sys/sysctl.h>

pixman_private
Bool fbHaveVMX(void) {
  int hasVMX = 0;
  size_t length = sizeof( hasVMX );
  int error = sysctlbyname("hw.optional.altivec", &hasVMX, &length, NULL, 0);
  if( 0 != error ) return 0;
  return hasVMX;
}

#else
#include <signal.h>
#include <setjmp.h>

static sigjmp_buf jmp;
static volatile sig_atomic_t in_test = 0;

static void vmx_test (int sig) {
    if (!in_test) {
        signal(sig, SIG_DFL);
        raise (sig);
    }
    in_test = 0;
    siglongjmp (jmp, 1);
}

pixman_private
Bool fbHaveVMX(void) {
    signal (SIGILL, vmx_test);
    if (sigsetjmp (jmp, 1)) {
        signal (SIGILL, SIG_DFL);
    } else {
        in_test = 1;
        asm volatile ( "vor 0, 0, 0" );
        signal (SIGILL, SIG_DFL);
        return 1;
    }
    return 0;
}
#endif /* __APPLE__ */
#endif //USE_VMX
From slinavlee at gmail.com  Thu Mar  8 17:46:35 2007
From: slinavlee at gmail.com (XinGang Li)
Date: Thu Mar  8 17:46:41 2007
Subject: [cairo] Remove the cairo_public decoration of the test functions
Message-ID: <9b9b15ea0703081746q57717d86r642efb3088f799e2@mail.gmail.com>

When building win32 dll using msvc without a .def file, the cairo_public
decoration of the below test functions are unwanted:

_cairo_pdf_test_force_fallbacks
_cairo_ps_test_force_fallbacks
_cairo_scaled_font_test_set_max_glyphs_cached_per_font
_cairo_svg_test_force_fallbacks
_cairo_xlib_test_disable_render


-- 
Li XinGang
EMail: slinavlee@gmail.com
Blog:   avlee.cnblogs.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070309/cd7930bb/attachment.html
From jonathon.jongsma at gmail.com  Thu Mar  8 18:50:41 2007
From: jonathon.jongsma at gmail.com (Jonathon Jongsma)
Date: Thu Mar  8 18:50:45 2007
Subject: [cairo] CVS to GIT for cairomm?
Message-ID: <ee2fcb570703081850g314b3af9s674a3a5138819989@mail.gmail.com>

The cairo c++ bindings (cairomm) are currently still using
freedesktop.org CVS for version control.  I already use git for
another personal project, so I'm definitely in favor of moving cairomm
to git as well.  The only other cairomm contributor to this point is
Murray Cumming, and I talked to him a while ago and he said he'd be OK
with switching from CVS to git (murray, if this has changed, please
let me know).  So I'd like to explore moving to git for version
control.  How would that work?  and who should I talk to about setting
up the infrastructure?

Thanks

-- 
jonner
From brian.ewins at gmail.com  Thu Mar  8 19:39:23 2007
From: brian.ewins at gmail.com (Baz)
Date: Thu Mar  8 19:39:28 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <2faad3050703081719k12c612e3qcc3863887ccb85c4@mail.gmail.com>
References: <45D6DFF1.4080505@gentoo.org>
	<2faad3050703081719k12c612e3qcc3863887ccb85c4@mail.gmail.com>
Message-ID: <2faad3050703081939i36cebe7cw6b6da9d850b57ccb@mail.gmail.com>

On 09/03/07, Baz <brian.ewins@gmail.com> wrote:
> On 17/02/07, Luca Barbato <lu_zero@gentoo.org> wrote:
> > I completed the fbcompose part the regtest are consistent, hopefully
> > I'll start adding the pict ops later in the next week.
> >
> > lu
>
I'm seeing nearly zero difference in perf-diff (image surface). I
hacked in a check, altivec is definitely being enabled. I suspect
something wrong with perf-diff. The xlib surface is crashing, but its
unrelated to your patch, it crashes both before and after the patch on
that box. Most likely my fault, I'll take another run at it tomorrow.

When I say nearly zero difference, I mean literally zero unless I perf
-diff against several revisions ago (so that other things actually
make a difference), just to proved to myself that perf-diff is still
working. I've never seen it this consistent before, but there were
some changes in 1.4. Am I right in thinking the image backend should
be sufficient to demonstrate an effect of from your patch?

Cheers,
Baz
From cworth at cworth.org  Thu Mar  8 20:39:09 2007
From: cworth at cworth.org (Carl Worth)
Date: Thu Mar  8 20:39:20 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <2faad3050703081939i36cebe7cw6b6da9d850b57ccb@mail.gmail.com>
References: <45D6DFF1.4080505@gentoo.org>
	<2faad3050703081719k12c612e3qcc3863887ccb85c4@mail.gmail.com>
	<2faad3050703081939i36cebe7cw6b6da9d850b57ccb@mail.gmail.com>
Message-ID: <87slcf9gk2.wl%cworth@cworth.org>

On Fri, 9 Mar 2007 03:39:23 +0000, Baz wrote:
> When I say nearly zero difference, I mean literally zero unless I perf
> -diff against several revisions ago (so that other things actually
> make a difference), just to proved to myself that perf-diff is still
> working. I've never seen it this consistent before, but there were
> some changes in 1.4. Am I right in thinking the image backend should
> be sufficient to demonstrate an effect of from your patch?

That would be a bug in perf-diff.

It examines the git has of the src/ directory to decide if anything
has changed, and if the hash is the same it decides there's no point
in checking, so you get exactly matching results.

This fails quite badly when you have a change that affects only
pixman.

A cheesy workaround is to add a commit that adds whitespace to
src/cairo.h or something like that, and then compare the commit before
the altivec additions to the commit after the whitespace change.

And yes, it would be good to come up with a real fix for
cairo-perf-diff here.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070308/d40abb20/attachment.pgp
From mathias.hasselmann at gmx.de  Thu Mar  8 21:50:16 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Thu Mar  8 21:53:30 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1173219393.11414.34.camel@behdad>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
	<45EDD273.6030305@mit.edu>  <1173219393.11414.34.camel@behdad>
Message-ID: <1173419417.5844.1.camel@dali>

Hi, 

Resending as I was using the wrong sender address. I really start
hating Evo for not properly supporting mailing lists... :-(

> >    pixman_region_create_simple
> >      pixman_region_create
> >        cairo_traps_extract_region
> >        clip_and_composite_trapezoids
> >          cairo_surface_fallback_fill
> >      cairo_traps_extract_region
> >        clip_and_composite_trapezoids
> >          cairo_surface_fallback_fill

Behdad: Attached there is a patch removing malloc in this case. 
Still needs testing and at some places I accidently removed
pixman_region_destroy instead of replacing it by pixman_region_uninit by
accident. But it is too late here, to fix and test it now, so I defer to
tomorrow. Usually work better when my mind is fresh.

Ciao,
Mathias
-------------- next part --------------
>From b1db42d981705867cc917000d0743845c1fe1716 Mon Sep 17 00:00:00 2001
From: (null) <(null)>
Date: Fri, 9 Mar 2007 01:41:08 +0100
Subject: [PATCH] Avoid alloc in _cairo_pixman_region_create_simple

---
 pixman/src/pixman.h          |   12 ++-
 pixman/src/pixregion.c       |   18 +--
 pixman/src/pixregionint.h    |    7 +-
 src/cairo-clip-private.h     |    3 +-
 src/cairo-clip.c             |  125 +++++++++------------
 src/cairo-region.c           |   34 +++---
 src/cairo-surface-fallback.c |  249 +++++++++++++++++++++---------------------
 src/cairo-surface.c          |   42 +++-----
 src/cairo-traps.c            |   15 +--
 src/cairoint.h               |   11 +-
 10 files changed, 241 insertions(+), 275 deletions(-)

diff --git a/pixman/src/pixman.h b/pixman/src/pixman.h
index 7f0ef32..8428543 100644
--- a/pixman/src/pixman.h
+++ b/pixman/src/pixman.h
@@ -113,12 +113,17 @@ extern "C" {
 
 /* pixregion.h */
 
-typedef struct pixman_region16 pixman_region16_t;
+typedef struct pixman_region16_data pixman_region16_data_t;
 
 typedef struct pixman_box16 {
     short x1, y1, x2, y2;
 } pixman_box16_t;
 
+typedef struct pixman_region16 {
+    pixman_box16_t          extents;
+    pixman_region16_data_t  *data;
+} pixman_region16_t;
+
 typedef enum {
     PIXMAN_REGION_STATUS_FAILURE,
     PIXMAN_REGION_STATUS_SUCCESS
@@ -133,6 +138,11 @@ pixman_private pixman_region16_t *
 pixman_region_create_simple (pixman_box16_t *extents);
 
 pixman_private void
+pixman_region_init(pixman_region16_t *region, pixman_box16_t *extents);
+pixman_private void
+pixman_region_uninit (pixman_region16_t *region);
+
+pixman_private void
 pixman_region_destroy (pixman_region16_t *region);
 
 /* manipulation */
diff --git a/pixman/src/pixregion.c b/pixman/src/pixregion.c
index 0404dff..f710294 100644
--- a/pixman/src/pixregion.c
+++ b/pixman/src/pixregion.c
@@ -82,12 +82,6 @@ static pixman_region16_t   pixman_brokenregion = { { 0, 0, 0, 0 }, &pixman_broke
 static pixman_region_status_t
 pixman_break (pixman_region16_t *pReg);
 
-static void
-pixman_init (pixman_region16_t *region, pixman_box16_t *rect);
-
-static void
-pixman_uninit (pixman_region16_t *region);
-
 /*
  * The functions in this file implement the Region abstraction used extensively
  * throughout the X11 sample server. A Region is simply a set of disjoint
@@ -318,7 +312,7 @@ pixman_region_create_simple (pixman_box16_t *extents)
     if (region == NULL)
 	return &pixman_brokenregion;
 
-    pixman_init (region, extents);
+    pixman_region_init (region, extents);
 
     return region;
 }
@@ -328,8 +322,8 @@ pixman_region_create_simple (pixman_box16_t *extents)
  *     Outer region rect is statically allocated.
  *****************************************************************/
 
-static void
-pixman_init(pixman_region16_t *region, pixman_box16_t *extents)
+void
+pixman_region_init(pixman_region16_t *region, pixman_box16_t *extents)
 {
     if (extents)
     {
@@ -343,8 +337,8 @@ pixman_init(pixman_region16_t *region, pixman_box16_t *extents)
     }
 }
 
-static void
-pixman_uninit (pixman_region16_t *region)
+void
+pixman_region_uninit (pixman_region16_t *region)
 {
     good (region);
     freeData (region);
@@ -353,7 +347,7 @@ pixman_uninit (pixman_region16_t *region)
 void
 pixman_region_destroy (pixman_region16_t *region)
 {
-    pixman_uninit (region);
+    pixman_region_uninit (region);
 
     if (region != &pixman_brokenregion)
 	free (region);
diff --git a/pixman/src/pixregionint.h b/pixman/src/pixregionint.h
index b5b53fd..385a7f2 100644
--- a/pixman/src/pixregionint.h
+++ b/pixman/src/pixregionint.h
@@ -48,16 +48,11 @@ SOFTWARE.
 
 #include "pixman.h"
 
-typedef struct pixman_region16_data {
+struct pixman_region16_data {
     long		size;
     long		numRects;
     /* XXX: And why, exactly, do we have this bogus struct definition? */
 /*  pixman_box16_t	rects[size];   in memory but not explicitly declared */
-} pixman_region16_data_t;
-
-struct pixman_region16 {
-    pixman_box16_t	extents;
-    pixman_region16_data_t	*data;
 };
 
 typedef struct pixman_region16_point {
diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index 3c4ff0d..381c003 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -72,7 +72,8 @@ struct _cairo_clip {
     /*
      * A clip region that can be placed in the surface
      */
-    pixman_region16_t *region;
+    pixman_region16_t region;
+    cairo_bool_t has_region;
     /*
      * If the surface supports path clipping, we store the list of
      * clipping paths that has been set here as a linked list.
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index 605589b..a1d4d0a 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -58,7 +58,7 @@ _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target)
 
     clip->serial = 0;
 
-    clip->region = NULL;
+    clip->has_region = FALSE;
 
     clip->path = NULL;
 }
@@ -71,9 +71,10 @@ _cairo_clip_fini (cairo_clip_t *clip)
 
     clip->serial = 0;
 
-    if (clip->region)
-	pixman_region_destroy (clip->region);
-    clip->region = NULL;
+    if (clip->has_region) {
+	pixman_region_uninit (&clip->region);
+    	clip->has_region = FALSE;
+    }
 
     _cairo_clip_path_destroy (clip->path);
     clip->path = NULL;
@@ -89,11 +90,11 @@ _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 
     clip->serial = other->serial;
 
-    if (other->region == NULL) {
-	clip->region = other->region;
+    if (other->has_region) {
+        pixman_region_copy (&clip->region, &other->region);
+        clip->has_region = TRUE;
     } else {
-	clip->region = pixman_region_create ();
-	pixman_region_copy (clip->region, other->region);
+        clip->has_region = FALSE;
     }
 
     clip->path = _cairo_clip_path_reference (other->path);
@@ -108,9 +109,10 @@ _cairo_clip_reset (cairo_clip_t *clip)
 
     clip->serial = 0;
 
-    if (clip->region)
-	pixman_region_destroy (clip->region);
-    clip->region = NULL;
+    if (clip->has_region) {
+	pixman_region_uninit (&clip->region);
+        clip->has_region = FALSE;
+    }
 
     _cairo_clip_path_destroy (clip->path);
     clip->path = NULL;
@@ -167,27 +169,19 @@ _cairo_clip_intersect_to_rectangle (cairo_clip_t            *clip,
             return status;
     }
 
-    if (clip->region) {
-	pixman_region16_t *intersection;
-	cairo_status_t status = CAIRO_STATUS_SUCCESS;
-	pixman_region_status_t pixman_status;
+    if (clip->has_region) {
+	pixman_region16_t intersection;
 
-	intersection = _cairo_region_create_from_rectangle (rectangle);
-	if (intersection == NULL)
+	if (_cairo_region_init_from_rectangle (&intersection, rectangle))
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	pixman_status = pixman_region_intersect (intersection,
-					  clip->region,
-					  intersection);
-	if (pixman_status == PIXMAN_REGION_STATUS_SUCCESS)
-	    _cairo_region_extents_rectangle (intersection, rectangle);
-	else
-	    status = CAIRO_STATUS_NO_MEMORY;
-
-	pixman_region_destroy (intersection);
+	if (PIXMAN_REGION_STATUS_SUCCESS !=
+            pixman_region_intersect (&intersection, &clip->region,
+                                     &intersection))
+	    return CAIRO_STATUS_NO_MEMORY;
 
-	if (status)
-	    return status;
+	_cairo_region_extents_rectangle (&intersection, rectangle);
+        return CAIRO_STATUS_SUCCESS;
     }
 
     if (clip->surface)
@@ -207,28 +201,18 @@ _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 	/* Intersect clip path into region. */
     }
 
-    if (clip->region)
-	pixman_region_intersect (region, clip->region, region);
+    if (clip->has_region)
+	pixman_region_intersect (region, &clip->region, region);
 
     if (clip->surface) {
-	pixman_region16_t *clip_rect;
-	pixman_region_status_t pixman_status;
-	cairo_status_t status = CAIRO_STATUS_SUCCESS;
+	pixman_region16_t clip_rect;
 
-	clip_rect = _cairo_region_create_from_rectangle (&clip->surface_rect);
-	if (clip_rect == NULL)
+	if (_cairo_region_init_from_rectangle (&clip_rect, &clip->surface_rect))
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	pixman_status = pixman_region_intersect (region,
-						 clip_rect,
-						 region);
-	if (pixman_status != PIXMAN_REGION_STATUS_SUCCESS)
-	    status = CAIRO_STATUS_NO_MEMORY;
-
-	pixman_region_destroy (clip_rect);
-
-	if (status)
-	    return status;
+        if (PIXMAN_REGION_STATUS_SUCCESS != 
+            pixman_region_intersect (region, &clip_rect, region))
+	    return CAIRO_STATUS_NO_MEMORY;
     }
 
     return CAIRO_STATUS_SUCCESS;
@@ -326,39 +310,36 @@ _cairo_clip_path_destroy (cairo_clip_path_t *clip_path)
     free (clip_path);
 }
 
-static cairo_status_t
+static cairo_int_status_t
 _cairo_clip_intersect_region (cairo_clip_t    *clip,
 			      cairo_traps_t   *traps,
 			      cairo_surface_t *target)
 {
-    pixman_region16_t *region;
-    cairo_status_t status;
+    pixman_region16_t region;
+    cairo_int_status_t status;
 
     if (clip->mode != CAIRO_CLIP_MODE_REGION)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     status = _cairo_traps_extract_region (traps, &region);
+
     if (status)
 	return status;
 
-    if (region == NULL)
-	return CAIRO_INT_STATUS_UNSUPPORTED;
-
     status = CAIRO_STATUS_SUCCESS;
-    if (clip->region == NULL) {
-	clip->region = region;
+
+    if (!clip->has_region) {
+        pixman_region_copy (&clip->region, &region);
+        clip->has_region = TRUE;
     } else {
-	pixman_region16_t *intersection = pixman_region_create();
-
-	if (pixman_region_intersect (intersection,
-				     clip->region, region)
-	    == PIXMAN_REGION_STATUS_SUCCESS) {
-	    pixman_region_destroy (clip->region);
-	    clip->region = intersection;
-	} else {
-	    status = CAIRO_STATUS_NO_MEMORY;
-	}
-	pixman_region_destroy (region);
+	pixman_region16_t intersection;
+        pixman_region_init (&intersection, NULL);
+
+	if (PIXMAN_REGION_STATUS_SUCCESS != 
+            pixman_region_intersect (&intersection, &clip->region, &region))
+            return CAIRO_STATUS_NO_MEMORY;
+
+        pixman_region_copy (&clip->region, &intersection);
     }
 
     clip->serial = _cairo_surface_allocate_clip_serial (target);
@@ -506,8 +487,8 @@ _cairo_clip_translate (cairo_clip_t  *clip,
                        cairo_fixed_t  tx,
                        cairo_fixed_t  ty)
 {
-    if (clip->region) {
-        pixman_region_translate (clip->region,
+    if (clip->has_region) {
+        pixman_region_translate (&clip->region,
                                  _cairo_fixed_integer_part (tx),
                                  _cairo_fixed_integer_part (ty));
     }
@@ -557,9 +538,9 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
         /* We should reapply the original clip path in this case, and let
          * whatever the right handling is happen */
     } else {
-        if (other->region) {
-            clip->region = pixman_region_create ();
-            pixman_region_copy (clip->region, other->region);
+        if (other->has_region) {
+            pixman_region_copy (&clip->region, &other->region);
+            clip->has_region = TRUE;
         }
 
         if (other->surface) {
@@ -610,16 +591,16 @@ _cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate)
     if (clip->path || clip->surface)
         return (cairo_rectangle_list_t*) &_cairo_rectangles_not_representable;
 
-    n_boxes = clip->region ? pixman_region_num_rects (clip->region) : 1;
+    n_boxes = clip->has_region ? pixman_region_num_rects (&clip->region) : 1;
     rectangles = malloc (sizeof (cairo_rectangle_t)*n_boxes);
     if (rectangles == NULL)
         return (cairo_rectangle_list_t*) &_cairo_rectangles_nil;
 
-    if (clip->region) {
+    if (clip->has_region) {
         pixman_box16_t *boxes;
         int i;
         
-        boxes = pixman_region_rects (clip->region);
+        boxes = pixman_region_rects (&clip->region);
         for (i = 0; i < n_boxes; ++i) {
             if (!_cairo_clip_rect_to_user(gstate, boxes[i].x1, boxes[i].y1,
                                           boxes[i].x2 - boxes[i].x1,
diff --git a/src/cairo-region.c b/src/cairo-region.c
index 057f9fe..ea06b9e 100644
--- a/src/cairo-region.c
+++ b/src/cairo-region.c
@@ -36,30 +36,28 @@
 #include <cairoint.h>
 
 /**
- * _cairo_region_create_from_rectangle:
+ * _cairo_region_init_from_rectangle:
+ * @region: a #pixman_region16_t
  * @rect: a #cairo_rectangle_int16_t
  *
- * Creates a region with extents initialized from the given
- * rectangle.
+ * Initializes a region with extents from the given rectangle.
  *
- * Return value: a newly created #pixman_region16_t or %NULL if
- *    memory couldn't a allocated.
+ * Return value: #CAIRO_STATUS_SUCCESS on success, or 
+ * #CAIRO_INT_STATUS_UNSUPPORTED if pixman failes to
+ * initialize the region.
  **/
-pixman_region16_t *
-_cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect)
+cairo_int_status_t
+_cairo_region_init_from_rectangle (pixman_region16_t       *region,
+                                   cairo_rectangle_int16_t *rect)
 {
-    /* We can't use pixman_region_create_simple(), because it doesn't
-     * have an error return
-     */
-    pixman_region16_t *region = pixman_region_create ();
-    if (pixman_region_union_rect (region, region,
-				  rect->x, rect->y,
-				  rect->width, rect->height) != PIXMAN_REGION_STATUS_SUCCESS) {
-	pixman_region_destroy (region);
-	return NULL;
-    }
+    pixman_region_init (region, NULL);
+
+    if (PIXMAN_REGION_STATUS_SUCCESS !=
+        pixman_region_union_rect (region, region, rect->x, rect->y,
+				                  rect->width, rect->height))
+        return CAIRO_INT_STATUS_UNSUPPORTED;	
 
-    return region;
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /**
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..31f4a1a 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -511,147 +511,148 @@ _clip_and_composite_trapezoids (cairo_pattern_t *src,
 				cairo_antialias_t antialias)
 {
     cairo_status_t status;
-    pixman_region16_t *trap_region = NULL;
-    pixman_region16_t *clear_region = NULL;
+    pixman_region16_t trap_region;
+    pixman_region16_t clear_region;
+    cairo_bool_t has_trap_region = FALSE;
+    cairo_bool_t has_clear_region = FALSE;
     cairo_rectangle_int16_t extents;
     cairo_composite_traps_info_t traps_info;
 
     if (traps->num_traps == 0)
-	return CAIRO_STATUS_SUCCESS;
+        return CAIRO_STATUS_SUCCESS;
 
     status = _cairo_surface_get_extents (dst, &extents);
     if (status)
-	return status;
+        return status;
 
     status = _cairo_traps_extract_region (traps, &trap_region);
-    if (status)
-	return status;
-
-    if (_cairo_operator_bounded_by_mask (op))
-    {
-	cairo_rectangle_int16_t trap_extents;
-	if (trap_region) {
-	    status = _cairo_clip_intersect_to_region (clip, trap_region);
-	    if (status)
-		goto out;
-
-	    _cairo_region_extents_rectangle (trap_region, &trap_extents);
-	} else {
-	    cairo_box_t trap_box;
-	    _cairo_traps_extents (traps, &trap_box);
-	    _cairo_box_round_to_rectangle (&trap_box, &trap_extents);
-	}
 
-	_cairo_rectangle_intersect (&extents, &trap_extents);
-	status = _cairo_clip_intersect_to_rectangle (clip, &extents);
-	if (status)
-	    goto out;
+    if (CAIRO_INT_STATUS_UNSUPPORTED == status) {
+        has_trap_region = FALSE;
+    } else if (status) {
+        return status;
+    } else {
+        has_trap_region = TRUE;
     }
-    else
-    {
-	cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
-
-	if (trap_region && !clip_surface) {
-	    /* If we optimize drawing with an unbounded operator to
-	     * _cairo_surface_fill_rectangles() or to drawing with a
-	     * clip region, then we have an additional region to clear.
-	     */
-	    clear_region = _cairo_region_create_from_rectangle (&extents);
-	    if (clear_region == NULL)
-		return CAIRO_STATUS_NO_MEMORY;
-
-	    status = _cairo_clip_intersect_to_region (clip, clear_region);
-	    if (status)
-		return status;
-
-	    _cairo_region_extents_rectangle (clear_region,  &extents);
-
-	    if (pixman_region_subtract (clear_region, clear_region, trap_region) != PIXMAN_REGION_STATUS_SUCCESS)
-		return CAIRO_STATUS_NO_MEMORY;
-
-	    if (!pixman_region_not_empty (clear_region)) {
-		pixman_region_destroy (clear_region);
-		clear_region = NULL;
-	    }
-	} else {
-	    status = _cairo_clip_intersect_to_rectangle (clip, &extents);
-	    if (status)
-		return status;
-	}
-    }
-
-    if (status)
-	goto out;
 
-    if (trap_region)
-    {
-	cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
-
-	if ((src->type == CAIRO_PATTERN_TYPE_SOLID || op == CAIRO_OPERATOR_CLEAR) &&
-	    !clip_surface)
-	{
-	    const cairo_color_t *color;
-
-	    if (op == CAIRO_OPERATOR_CLEAR)
-		color = CAIRO_COLOR_TRANSPARENT;
-	    else
-		color = &((cairo_solid_pattern_t *)src)->color;
-
-	    /* Solid rectangles special case */
-	    status = _cairo_surface_fill_region (dst, op, color, trap_region);
-	    if (!status && clear_region)
-		status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
-						     CAIRO_COLOR_TRANSPARENT,
-						     clear_region);
-
-	    goto out;
-	}
-
-	if ((_cairo_operator_bounded_by_mask (op) && op != CAIRO_OPERATOR_SOURCE) ||
-	    !clip_surface)
-	{
-	    /* For a simple rectangle, we can just use composite(), for more
-	     * rectangles, we have to set a clip region. The cost of rasterizing
-	     * trapezoids is pretty high for most backends currently, so it's
-	     * worthwhile even if a region is needed.
-	     *
-	     * If we have a clip surface, we set it as the mask; this only works
-	     * for bounded operators other than SOURCE; for unbounded operators,
-	     * clip and mask cannot be interchanged. For SOURCE, the operator
-	     * as implemented by the backends is different in it's handling
-	     * of the mask then what we want.
-	     *
-	     * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
-	     * more than rectangle and the destination doesn't support clip
-	     * regions. In that case, we fall through.
-	     */
-	    status = _composite_trap_region (clip, src, op, dst,
-					     trap_region, &extents);
-	    if (status != CAIRO_INT_STATUS_UNSUPPORTED)
-	    {
-		if (!status && clear_region)
-		    status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
-							 CAIRO_COLOR_TRANSPARENT,
-							 clear_region);
-		goto out;
-	    }
-	}
+    if (_cairo_operator_bounded_by_mask (op)) {
+        cairo_rectangle_int16_t trap_extents;
+
+        if (has_trap_region) {
+            status = _cairo_clip_intersect_to_region (clip, &trap_region);
+
+            if (status)
+                return status;
+
+            _cairo_region_extents_rectangle (&trap_region, &trap_extents);
+        } else {
+            cairo_box_t trap_box;
+            _cairo_traps_extents (traps, &trap_box);
+            _cairo_box_round_to_rectangle (&trap_box, &trap_extents);
+        }
+
+        _cairo_rectangle_intersect (&extents, &trap_extents);
+        status = _cairo_clip_intersect_to_rectangle (clip, &extents);
+
+        if (status)
+            return status;
+    } else {
+        cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+
+        if (has_trap_region && !clip_surface) {
+            /* If we optimize drawing with an unbounded operator to
+             * _cairo_surface_fill_rectangles() or to drawing with a
+             * clip region, then we have an additional region to clear.
+             */
+            if (_cairo_region_init_from_rectangle (&clear_region, &extents))
+                return CAIRO_STATUS_NO_MEMORY;
+
+            status = _cairo_clip_intersect_to_region (clip, &clear_region);
+
+            if (status)
+                return status;
+
+            _cairo_region_extents_rectangle (&clear_region,  &extents);
+
+            if (PIXMAN_REGION_STATUS_SUCCESS != 
+                pixman_region_subtract (&clear_region, &clear_region, &trap_region))
+                return CAIRO_STATUS_NO_MEMORY;
+
+            has_clear_region = pixman_region_not_empty (&clear_region);
+            
+            if (has_clear_region) {
+                status = _cairo_clip_intersect_to_rectangle (clip, &extents);
+
+                if (status)
+                    return status;
+            }
+        }
+
+        if (status)
+            return status;
+
+        if (has_trap_region) {
+            cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+
+            if ((src->type == CAIRO_PATTERN_TYPE_SOLID ||
+                 op == CAIRO_OPERATOR_CLEAR) && !clip_surface) {
+                const cairo_color_t *color;
+
+                if (op == CAIRO_OPERATOR_CLEAR) {
+                    color = CAIRO_COLOR_TRANSPARENT;
+                } else {
+                    color = &((cairo_solid_pattern_t *)src)->color;
+                }
+
+                /* Solid rectangles special case */
+                status = _cairo_surface_fill_region (dst, op, color,
+                        has_trap_region ? &trap_region : NULL);
+
+                if (!status && has_clear_region)
+                    status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
+                                                         CAIRO_COLOR_TRANSPARENT,
+                                                         &clear_region);
+
+                return status;
+            }
+
+            if ((_cairo_operator_bounded_by_mask (op) && 
+                 op != CAIRO_OPERATOR_SOURCE) || !clip_surface) {
+                /* For a simple rectangle, we can just use composite(), for more
+                 * rectangles, we have to set a clip region. The cost of rasterizing
+                 * trapezoids is pretty high for most backends currently, so it's
+                 * worthwhile even if a region is needed.
+                 *
+                 * If we have a clip surface, we set it as the mask; this only works
+                 * for bounded operators other than SOURCE; for unbounded operators,
+                 * clip and mask cannot be interchanged. For SOURCE, the operator
+                 * as implemented by the backends is different in it's handling
+                 * of the mask then what we want.
+                 *
+                 * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
+                 * more than rectangle and the destination doesn't support clip
+                 * regions. In that case, we fall through.
+                 */
+                status = _composite_trap_region (clip, src, op, dst,
+                        has_trap_region ? &trap_region : NULL, 
+                        &extents);
+
+                if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
+                    if (!status && has_clear_region)
+                        status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
+                                                             CAIRO_COLOR_TRANSPARENT,
+                                                             &clear_region);
+                    return status;
+                }
+            }
+        }
     }
 
     traps_info.traps = traps;
     traps_info.antialias = antialias;
 
-    status = _clip_and_composite (clip, op, src,
-				  _composite_traps_draw_func, &traps_info,
-				  dst, &extents);
-
- out:
-    if (trap_region)
-	pixman_region_destroy (trap_region);
-    if (clear_region)
-	pixman_region_destroy (clear_region);
-
-    return status;
+    return _clip_and_composite (clip, op, src, _composite_traps_draw_func,
+                                &traps_info, dst, &extents);
 }
 
 cairo_status_t
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index ad9c52d..fdb6b51 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -1702,9 +1702,9 @@ _cairo_surface_set_clip (cairo_surface_t *surface, cairo_clip_t *clip)
 						 clip->path,
 						 clip->serial);
 
-	if (clip->region)
+	if (clip->has_region)
 	    return _cairo_surface_set_clip_region (surface,
-						   clip->region,
+						   &clip->region,
 						   clip->serial);
     }
 
@@ -1867,9 +1867,8 @@ _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
 {
     cairo_rectangle_int16_t dst_rectangle;
     cairo_rectangle_int16_t drawn_rectangle;
-    pixman_region16_t *drawn_region;
-    pixman_region16_t *clear_region;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    pixman_region16_t drawn_region;
+    pixman_region16_t clear_region;
 
     /* The area that was drawn is the area in the destination rectangle but not within
      * the source or the mask.
@@ -1882,36 +1881,23 @@ _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
     drawn_rectangle = dst_rectangle;
 
     if (src_rectangle)
-	_cairo_rectangle_intersect (&drawn_rectangle, src_rectangle);
+        _cairo_rectangle_intersect (&drawn_rectangle, src_rectangle);
 
     if (mask_rectangle)
-	_cairo_rectangle_intersect (&drawn_rectangle, mask_rectangle);
+        _cairo_rectangle_intersect (&drawn_rectangle, mask_rectangle);
 
     /* Now compute the area that is in dst_rectangle but not in drawn_rectangle
      */
-    drawn_region = _cairo_region_create_from_rectangle (&drawn_rectangle);
-    clear_region = _cairo_region_create_from_rectangle (&dst_rectangle);
-    if (!drawn_region || !clear_region) {
-	status = CAIRO_STATUS_NO_MEMORY;
-	goto CLEANUP_REGIONS;
-    }
-
-    if (pixman_region_subtract (clear_region, clear_region, drawn_region) != PIXMAN_REGION_STATUS_SUCCESS) {
-	status = CAIRO_STATUS_NO_MEMORY;
-	goto CLEANUP_REGIONS;
-    }
+    if (_cairo_region_init_from_rectangle (&drawn_region, &drawn_rectangle) ||
+        _cairo_region_init_from_rectangle (&clear_region, &dst_rectangle))
+        return CAIRO_STATUS_NO_MEMORY;
 
-    status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_SOURCE,
-					 CAIRO_COLOR_TRANSPARENT,
-					 clear_region);
+    if (pixman_region_subtract (&clear_region, &clear_region, &drawn_region) != PIXMAN_REGION_STATUS_SUCCESS)
+        return CAIRO_STATUS_NO_MEMORY;
 
- CLEANUP_REGIONS:
-    if (drawn_region)
-	pixman_region_destroy (drawn_region);
-    if (clear_region)
-	pixman_region_destroy (clear_region);
-
-    return status;
+    return _cairo_surface_fill_region (dst, CAIRO_OPERATOR_SOURCE,
+                                       CAIRO_COLOR_TRANSPARENT,
+                                       &clear_region);
 }
 
 /**
diff --git a/src/cairo-traps.c b/src/cairo-traps.c
index 9b3931f..d5aca93 100644
--- a/src/cairo-traps.c
+++ b/src/cairo-traps.c
@@ -937,9 +937,9 @@ _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents)
  *
  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY
  **/
-cairo_status_t
-_cairo_traps_extract_region (cairo_traps_t      *traps,
-			     pixman_region16_t **region)
+cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t     *traps,
+			     pixman_region16_t *region)
 {
     int i;
 
@@ -950,11 +950,10 @@ _cairo_traps_extract_region (cairo_traps_t      *traps,
 	      && _cairo_fixed_is_integer(traps->traps[i].bottom)
 	      && _cairo_fixed_is_integer(traps->traps[i].left.p1.x)
 	      && _cairo_fixed_is_integer(traps->traps[i].right.p1.x))) {
-	    *region = NULL;
-	    return CAIRO_STATUS_SUCCESS;
+	    return CAIRO_INT_STATUS_UNSUPPORTED;
 	}
 
-    *region = pixman_region_create ();
+    pixman_region_init (region, NULL);
 
     for (i = 0; i < traps->num_traps; i++) {
 	int x = _cairo_fixed_integer_part(traps->traps[i].left.p1.x);
@@ -969,9 +968,9 @@ _cairo_traps_extract_region (cairo_traps_t      *traps,
 	if (width == 0 || height == 0)
 	  continue;
 
-	if (pixman_region_union_rect (*region, *region,
+	if (pixman_region_union_rect (region, region,
 				      x, y, width, height) != PIXMAN_REGION_STATUS_SUCCESS) {
-	    pixman_region_destroy (*region);
+	    pixman_region_uninit (region);
 	    return CAIRO_STATUS_NO_MEMORY;
 	}
     }
diff --git a/src/cairoint.h b/src/cairoint.h
index c487a5d..69193a0 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -2296,9 +2296,9 @@ _cairo_traps_contain (cairo_traps_t *traps, double x, double y);
 cairo_private void
 _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents);
 
-cairo_private cairo_status_t
-_cairo_traps_extract_region (cairo_traps_t      *tr,
-			     pixman_region16_t **region);
+cairo_private cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t     *tr,
+			     pixman_region16_t *region);
 
 cairo_private void
 _cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
@@ -2402,8 +2402,9 @@ _cairo_gstate_get_antialias (cairo_gstate_t *gstate);
 
 /* cairo-region.c */
 
-cairo_private pixman_region16_t *
-_cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect);
+cairo_private cairo_int_status_t
+_cairo_region_init_from_rectangle (pixman_region16_t       *region,
+				   cairo_rectangle_int16_t *rect);
 
 cairo_private void
 _cairo_region_extents_rectangle (pixman_region16_t       *region,
-- 
1.4.4.2

From emmanuel.pacaud at lapp.in2p3.fr  Thu Mar  8 23:05:51 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Thu Mar  8 23:05:56 2007
Subject: [cairo] Cairo on Red Hat Enterprise Linux 4
In-Reply-To: <b9e408290703081555o2c26db2ob1b43ea9ee1b176c@mail.gmail.com>
References: <b9e408290703081555o2c26db2ob1b43ea9ee1b176c@mail.gmail.com>
Message-ID: <1173423951.8280.4.camel@lappc-p087.in2p3.fr>

Le jeudi 08 mars 2007 ? 17:55 -0600, ken carlino a ?crit :
> Does Cairo install on Red Hat Enterprise Linux 4 ?
> I did a 'rpm -q cairo', I don't see it has cairo.
> 
> If not, if my application uses cairo and need to be deployed on RHEL4,
> what is the best way to do that?  I prefer not to have the user to
> download the cairo source and compile/install on RHEL4.

RHEL4 ships with gtk 2.4, so I doubt there's an official cairo package
for it, and if there was one, it would be a very old cairo version you
don't want to use.

The best solution for you is to build a package you can give to your
users, probably by backporting a recent Fedora Core one.

	Emmanuel.

-- 
Emmanuel PACAUD
Groupe Virgo
LAPP - Laboratoire d'Annecy-le-Vieux de physique des particules
9, chemin de Bellevue - BP 110
74941 Annecy-le-Vieux CEDEX
France
T?l: (+33)4 50 09 17 89 - Fax: (+33)4 50 27 94 95

From kb_list at yahoo.com  Thu Mar  8 23:50:24 2007
From: kb_list at yahoo.com (Kevin Brooks)
Date: Thu Mar  8 23:57:09 2007
Subject: [cairo] cairo_image_surface_create_from_???
Message-ID: <20070309075024.88096.qmail@web53610.mail.yahoo.com>

Hello,

Are we going to have other image supports in the
future like:

cairo_surface_t* cairo_image_surface_create_from_jpg
                                            (const
char *filename);

or

cairo_surface_t* cairo_image_surface_create_from_bmp
                                            (const
char *filename);

or

cairo_surface_t* cairo_image_surface_create_from_tiff
                                            (const
char *filename);


Regrads,

Kev


 
____________________________________________________________________________________
Finding fabulous fares is fun.  
Let Yahoo! FareChase search your favorite travel sites to find flight and hotel bargains.
http://farechase.yahoo.com/promo-generic-14795097
From andre.nho at gmail.com  Fri Mar  9 06:15:25 2007
From: andre.nho at gmail.com (=?ISO-8859-1?Q?Andr=E9?= Wagner)
Date: Fri Mar  9 06:17:12 2007
Subject: [cairo] Loading a SVG file and displaying it on SDL
Message-ID: <20070309111525.dca7f777.andre.nho@gmail.com>

Hello!

I'm trying to load a SVG file and show it in a SDL window using cairo. This is my code:

	RsvgHandle* h;
	int width = 500;
	int height = 500;
	int stride = width * 4;

	unsigned char* cairo_data = 
		(unsigned char *) calloc(stride * height, 1);
	cairo_surface_t *cairo_surface =
		cairo_image_surface_create_for_data(cairo_data,
				CAIRO_FORMAT_ARGB32, width,
				height, stride);

	cairo_t *cr = cairo_create(cairo_surface);
	cairo_save(cr);
	cairo_scale(cr, width, height);

	cairo_set_source_rgba(cr, 1, 1, 1, 1);
	cairo_paint(cr);

	GError* e = NULL;
	h = rsvg_handle_new_from_file("closedbox.svg", &e);
	if(e != NULL)
		exit(1);

	rsvg_handle_render_cairo(h, cr);

	SDL_Surface* sf;
	sf = SDL_CreateRGBSurfaceFrom((void *) cairo_data, width, 
			height, 32, stride, 0x00ff0000, 0x0000ff00, 
                        0x000000ff, 0xff000000);

	SDL_BlitSurface(sf, NULL, screen, NULL);
	SDL_UpdateRect(screen, 0, 0, 0, 0);

	cairo_destroy(cr);

What am I doing wrong? It displays a white window, so I know (suppose) the transference from cairo to SDL is working. It seems the SVG image I loaded using librsvga is not showing on my cairo surface.

I'm not very skilled with cairo or librsvga, so I might just have a stupid mistake.

I'm using Win32, BTW (I hope this isn't the stupid mistke ;-)

Best regards,

Andr?

-- 
A cura para o t?dio ? a curiosidade.
N?o h? cura para a curiosidade. (Dorothy Parker)
From emmanuel.pacaud at lapp.in2p3.fr  Fri Mar  9 06:50:08 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Fri Mar  9 06:57:46 2007
Subject: [cairo] Loading a SVG file and displaying it on SDL
In-Reply-To: <20070309111525.dca7f777.andre.nho@gmail.com>
References: <20070309111525.dca7f777.andre.nho@gmail.com>
Message-ID: <1173451808.8280.22.camel@lappc-p087.in2p3.fr>

Le vendredi 09 mars 2007 ? 11:15 -0300, Andr? Wagner a ?crit :
> Hello!
> 
> I'm trying to load a SVG file and show it in a SDL window using cairo. This is my code:
> 
> 	RsvgHandle* h;
> 	int width = 500;
> 	int height = 500;
> 	int stride = width * 4;
> 
> 	unsigned char* cairo_data = 
> 		(unsigned char *) calloc(stride * height, 1);
> 	cairo_surface_t *cairo_surface =
> 		cairo_image_surface_create_for_data(cairo_data,
> 				CAIRO_FORMAT_ARGB32, width,
> 				height, stride);
> 
> 	cairo_t *cr = cairo_create(cairo_surface);
> 	cairo_save(cr);
> 	cairo_scale(cr, width, height);
> 
> 	cairo_set_source_rgba(cr, 1, 1, 1, 1);
> 	cairo_paint(cr);
> 
> 	GError* e = NULL;
> 	h = rsvg_handle_new_from_file("closedbox.svg", &e);
> 	if(e != NULL)
> 		exit(1);
> 
> 	rsvg_handle_render_cairo(h, cr);
> 
> 	SDL_Surface* sf;
> 	sf = SDL_CreateRGBSurfaceFrom((void *) cairo_data, width, 
> 			height, 32, stride, 0x00ff0000, 0x0000ff00, 
>                         0x000000ff, 0xff000000);
> 
> 	SDL_BlitSurface(sf, NULL, screen, NULL);
> 	SDL_UpdateRect(screen, 0, 0, 0, 0);
> 
> 	cairo_destroy(cr);
> 
> What am I doing wrong? It displays a white window, so I know (suppose) the transference from cairo to SDL is working. It seems the SVG image I loaded using librsvga is not showing on my cairo surface.
> 
> I'm not very skilled with cairo or librsvga, so I might just have a stupid mistake.

I don't know where is the issue, but it may help to check if the SVG
file is actually renderered in the cairo surface by saving it in a png
file, using:

surface = cairo_get_target (cr);
cairo_surface_write_to_png (surface, "test.png");

You may also want to have a look to the code of rsvg-convert, the
conversion utility included in librsvg:

http://svn.gnome.org/viewcvs/librsvg/trunk/rsvg-convert.c?revision=1094&view=markup

	Emmanuel.

-- 
Emmanuel PACAUD
Groupe Virgo
LAPP - Laboratoire d'Annecy-le-Vieux de physique des particules
9, chemin de Bellevue - BP 110
74941 Annecy-le-Vieux CEDEX
France
T?l: (+33)4 50 09 17 89 - Fax: (+33)4 50 27 94 95

From domlachowicz at gmail.com  Fri Mar  9 07:41:56 2007
From: domlachowicz at gmail.com (Dominic Lachowicz)
Date: Fri Mar  9 07:42:01 2007
Subject: [cairo] GCC 3.4 warnings patch
Message-ID: <2672cf4d0703090741h55318ac0s5ee87d8d3de3d5e2@mail.gmail.com>

Here are a few dozen warning cleanups that I caught with GCC 3.4.4 on
my FC3 machine. All of the warnings were about missing initializers.
It's not much to speak of, so do with it as you like.

Thanks,
Dom
-- 
Counting bodies like sheep to the rhythm of the war drums.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cairo-warnings.diff
Type: application/octet-stream
Size: 4446 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070309/558d0f2f/cairo-warnings.obj
From ken.carlino at gmail.com  Fri Mar  9 08:31:53 2007
From: ken.carlino at gmail.com (ken carlino)
Date: Fri Mar  9 08:31:57 2007
Subject: [cairo] Cairo on Red Hat Enterprise Linux 4
In-Reply-To: <1173423951.8280.4.camel@lappc-p087.in2p3.fr>
References: <b9e408290703081555o2c26db2ob1b43ea9ee1b176c@mail.gmail.com>
	<1173423951.8280.4.camel@lappc-p087.in2p3.fr>
Message-ID: <b9e408290703090831k20ebbed0v6aed98785a7a3c8b@mail.gmail.com>

On 3/9/07, Emmanuel Pacaud <emmanuel.pacaud@lapp.in2p3.fr> wrote:
> Le jeudi 08 mars 2007 ? 17:55 -0600, ken carlino a ?crit :
> > Does Cairo install on Red Hat Enterprise Linux 4 ?
> > I did a 'rpm -q cairo', I don't see it has cairo.
> >
> > If not, if my application uses cairo and need to be deployed on RHEL4,
> > what is the best way to do that?  I prefer not to have the user to
> > download the cairo source and compile/install on RHEL4.
>
> RHEL4 ships with gtk 2.4, so I doubt there's an official cairo package
> for it, and if there was one, it would be a very old cairo version you
> don't want to use.
>

thanks. Does that mean I can build a cairo 1.0.4 on RHEL4?
and package that with my application?


> The best solution for you is to build a package you can give to your
> users, probably by backporting a recent Fedora Core one.
>
>         Emmanuel.
>
> --
> Emmanuel PACAUD
> Groupe Virgo
> LAPP - Laboratoire d'Annecy-le-Vieux de physique des particules
> 9, chemin de Bellevue - BP 110
> 74941 Annecy-le-Vieux CEDEX
> France
> T?l: (+33)4 50 09 17 89 - Fax: (+33)4 50 27 94 95
>
>
From cworth at cworth.org  Fri Mar  9 09:25:39 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  9 09:26:24 2007
Subject: [cairo] Cairo on Red Hat Enterprise Linux 4
In-Reply-To: <b9e408290703090831k20ebbed0v6aed98785a7a3c8b@mail.gmail.com>
References: <b9e408290703081555o2c26db2ob1b43ea9ee1b176c@mail.gmail.com>
	<1173423951.8280.4.camel@lappc-p087.in2p3.fr>
	<b9e408290703090831k20ebbed0v6aed98785a7a3c8b@mail.gmail.com>
Message-ID: <87r6ry9vn0.wl%cworth@cworth.org>

On Fri, 9 Mar 2007 10:31:53 -0600, "ken carlino" wrote:
> thanks. Does that mean I can build a cairo 1.0.4 on RHEL4?
> and package that with my application?

Please don't.

That is, if you're going to build a cairo and package it with your
application, I think you'll be much happier using a recent cairo
(1.4.0) instead of an ancient one (1.0.4).

Oh, or maybe that was just a typo... ?

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070309/420cfa5c/attachment.pgp
From mathias.hasselmann at gmx.de  Fri Mar  9 13:41:32 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Fri Mar  9 13:41:49 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1173419417.5844.1.camel@dali>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
	<45EDD273.6030305@mit.edu>  <1173219393.11414.34.camel@behdad>
	<1173419417.5844.1.camel@dali>
Message-ID: <1173476493.21219.2.camel@dali>

Updated version of the patch which should properly release memory
allocated in pixman_region_init.
-------------- next part --------------
>From 93115b53e151eaad0e476a23864fc3301cf0cf86 Mon Sep 17 00:00:00 2001
From: (null) <(null)>
Date: Fri, 9 Mar 2007 22:37:36 +0100
Subject: [PATCH] Avoid malloc in _cairo_pixman_region_create_simple.

---
 pixman/src/pixman.h          |   12 ++-
 pixman/src/pixregion.c       |   18 +--
 pixman/src/pixregionint.h    |    7 +-
 src/cairo-clip-private.h     |    3 +-
 src/cairo-clip.c             |  125 ++++++++++-----------
 src/cairo-region.c           |   34 +++---
 src/cairo-surface-fallback.c |  255 ++++++++++++++++++++++--------------------
 src/cairo-surface.c          |   56 ++++++----
 src/cairo-traps.c            |   18 ++--
 src/cairoint.h               |   11 +-
 10 files changed, 279 insertions(+), 260 deletions(-)

diff --git a/pixman/src/pixman.h b/pixman/src/pixman.h
index 7f0ef32..8428543 100644
--- a/pixman/src/pixman.h
+++ b/pixman/src/pixman.h
@@ -113,12 +113,17 @@ extern "C" {
 
 /* pixregion.h */
 
-typedef struct pixman_region16 pixman_region16_t;
+typedef struct pixman_region16_data pixman_region16_data_t;
 
 typedef struct pixman_box16 {
     short x1, y1, x2, y2;
 } pixman_box16_t;
 
+typedef struct pixman_region16 {
+    pixman_box16_t          extents;
+    pixman_region16_data_t  *data;
+} pixman_region16_t;
+
 typedef enum {
     PIXMAN_REGION_STATUS_FAILURE,
     PIXMAN_REGION_STATUS_SUCCESS
@@ -133,6 +138,11 @@ pixman_private pixman_region16_t *
 pixman_region_create_simple (pixman_box16_t *extents);
 
 pixman_private void
+pixman_region_init(pixman_region16_t *region, pixman_box16_t *extents);
+pixman_private void
+pixman_region_uninit (pixman_region16_t *region);
+
+pixman_private void
 pixman_region_destroy (pixman_region16_t *region);
 
 /* manipulation */
diff --git a/pixman/src/pixregion.c b/pixman/src/pixregion.c
index 0404dff..f710294 100644
--- a/pixman/src/pixregion.c
+++ b/pixman/src/pixregion.c
@@ -82,12 +82,6 @@ static pixman_region16_t   pixman_brokenregion = { { 0, 0, 0, 0 }, &pixman_broke
 static pixman_region_status_t
 pixman_break (pixman_region16_t *pReg);
 
-static void
-pixman_init (pixman_region16_t *region, pixman_box16_t *rect);
-
-static void
-pixman_uninit (pixman_region16_t *region);
-
 /*
  * The functions in this file implement the Region abstraction used extensively
  * throughout the X11 sample server. A Region is simply a set of disjoint
@@ -318,7 +312,7 @@ pixman_region_create_simple (pixman_box16_t *extents)
     if (region == NULL)
 	return &pixman_brokenregion;
 
-    pixman_init (region, extents);
+    pixman_region_init (region, extents);
 
     return region;
 }
@@ -328,8 +322,8 @@ pixman_region_create_simple (pixman_box16_t *extents)
  *     Outer region rect is statically allocated.
  *****************************************************************/
 
-static void
-pixman_init(pixman_region16_t *region, pixman_box16_t *extents)
+void
+pixman_region_init(pixman_region16_t *region, pixman_box16_t *extents)
 {
     if (extents)
     {
@@ -343,8 +337,8 @@ pixman_init(pixman_region16_t *region, pixman_box16_t *extents)
     }
 }
 
-static void
-pixman_uninit (pixman_region16_t *region)
+void
+pixman_region_uninit (pixman_region16_t *region)
 {
     good (region);
     freeData (region);
@@ -353,7 +347,7 @@ pixman_uninit (pixman_region16_t *region)
 void
 pixman_region_destroy (pixman_region16_t *region)
 {
-    pixman_uninit (region);
+    pixman_region_uninit (region);
 
     if (region != &pixman_brokenregion)
 	free (region);
diff --git a/pixman/src/pixregionint.h b/pixman/src/pixregionint.h
index b5b53fd..385a7f2 100644
--- a/pixman/src/pixregionint.h
+++ b/pixman/src/pixregionint.h
@@ -48,16 +48,11 @@ SOFTWARE.
 
 #include "pixman.h"
 
-typedef struct pixman_region16_data {
+struct pixman_region16_data {
     long		size;
     long		numRects;
     /* XXX: And why, exactly, do we have this bogus struct definition? */
 /*  pixman_box16_t	rects[size];   in memory but not explicitly declared */
-} pixman_region16_data_t;
-
-struct pixman_region16 {
-    pixman_box16_t	extents;
-    pixman_region16_data_t	*data;
 };
 
 typedef struct pixman_region16_point {
diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index 3c4ff0d..381c003 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -72,7 +72,8 @@ struct _cairo_clip {
     /*
      * A clip region that can be placed in the surface
      */
-    pixman_region16_t *region;
+    pixman_region16_t region;
+    cairo_bool_t has_region;
     /*
      * If the surface supports path clipping, we store the list of
      * clipping paths that has been set here as a linked list.
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index 605589b..46179d9 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -58,7 +58,7 @@ _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target)
 
     clip->serial = 0;
 
-    clip->region = NULL;
+    clip->has_region = FALSE;
 
     clip->path = NULL;
 }
@@ -71,9 +71,10 @@ _cairo_clip_fini (cairo_clip_t *clip)
 
     clip->serial = 0;
 
-    if (clip->region)
-	pixman_region_destroy (clip->region);
-    clip->region = NULL;
+    if (clip->has_region) {
+	pixman_region_uninit (&clip->region);
+    	clip->has_region = FALSE;
+    }
 
     _cairo_clip_path_destroy (clip->path);
     clip->path = NULL;
@@ -89,11 +90,11 @@ _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 
     clip->serial = other->serial;
 
-    if (other->region == NULL) {
-	clip->region = other->region;
+    if (other->has_region) {
+        pixman_region_copy (&clip->region, &other->region);
+        clip->has_region = TRUE;
     } else {
-	clip->region = pixman_region_create ();
-	pixman_region_copy (clip->region, other->region);
+        clip->has_region = FALSE;
     }
 
     clip->path = _cairo_clip_path_reference (other->path);
@@ -108,9 +109,10 @@ _cairo_clip_reset (cairo_clip_t *clip)
 
     clip->serial = 0;
 
-    if (clip->region)
-	pixman_region_destroy (clip->region);
-    clip->region = NULL;
+    if (clip->has_region) {
+	pixman_region_uninit (&clip->region);
+        clip->has_region = FALSE;
+    }
 
     _cairo_clip_path_destroy (clip->path);
     clip->path = NULL;
@@ -167,27 +169,25 @@ _cairo_clip_intersect_to_rectangle (cairo_clip_t            *clip,
             return status;
     }
 
-    if (clip->region) {
-	pixman_region16_t *intersection;
+    if (clip->has_region) {
 	cairo_status_t status = CAIRO_STATUS_SUCCESS;
-	pixman_region_status_t pixman_status;
+	pixman_region16_t intersection;
 
-	intersection = _cairo_region_create_from_rectangle (rectangle);
-	if (intersection == NULL)
+	if (_cairo_region_init_from_rectangle (&intersection, rectangle))
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	pixman_status = pixman_region_intersect (intersection,
-					  clip->region,
-					  intersection);
-	if (pixman_status == PIXMAN_REGION_STATUS_SUCCESS)
-	    _cairo_region_extents_rectangle (intersection, rectangle);
-	else
+	if (PIXMAN_REGION_STATUS_SUCCESS !=
+            pixman_region_intersect (&intersection, &clip->region,
+                                     &intersection)) {
 	    status = CAIRO_STATUS_NO_MEMORY;
+	} else {
+            _cairo_region_extents_rectangle (&intersection, rectangle);
+        }
 
-	pixman_region_destroy (intersection);
+        pixman_region_uninit (&intersection);
 
-	if (status)
-	    return status;
+        if (status)
+            return status;
     }
 
     if (clip->surface)
@@ -207,28 +207,24 @@ _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 	/* Intersect clip path into region. */
     }
 
-    if (clip->region)
-	pixman_region_intersect (region, clip->region, region);
+    if (clip->has_region)
+	pixman_region_intersect (region, &clip->region, region);
 
     if (clip->surface) {
-	pixman_region16_t *clip_rect;
-	pixman_region_status_t pixman_status;
 	cairo_status_t status = CAIRO_STATUS_SUCCESS;
+	pixman_region16_t clip_rect;
 
-	clip_rect = _cairo_region_create_from_rectangle (&clip->surface_rect);
-	if (clip_rect == NULL)
+	if (_cairo_region_init_from_rectangle (&clip_rect, &clip->surface_rect))
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	pixman_status = pixman_region_intersect (region,
-						 clip_rect,
-						 region);
-	if (pixman_status != PIXMAN_REGION_STATUS_SUCCESS)
+        if (PIXMAN_REGION_STATUS_SUCCESS != 
+            pixman_region_intersect (region, &clip_rect, region))
 	    status = CAIRO_STATUS_NO_MEMORY;
 
-	pixman_region_destroy (clip_rect);
+        pixman_region_uninit (&clip_rect);
 
-	if (status)
-	    return status;
+        if (status)
+            return status;
     }
 
     return CAIRO_STATUS_SUCCESS;
@@ -326,42 +322,43 @@ _cairo_clip_path_destroy (cairo_clip_path_t *clip_path)
     free (clip_path);
 }
 
-static cairo_status_t
+static cairo_int_status_t
 _cairo_clip_intersect_region (cairo_clip_t    *clip,
 			      cairo_traps_t   *traps,
 			      cairo_surface_t *target)
 {
-    pixman_region16_t *region;
-    cairo_status_t status;
+    pixman_region16_t region;
+    cairo_int_status_t status;
 
     if (clip->mode != CAIRO_CLIP_MODE_REGION)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     status = _cairo_traps_extract_region (traps, &region);
+
     if (status)
 	return status;
 
-    if (region == NULL)
-	return CAIRO_INT_STATUS_UNSUPPORTED;
-
     status = CAIRO_STATUS_SUCCESS;
-    if (clip->region == NULL) {
-	clip->region = region;
+
+    if (!clip->has_region) {
+        pixman_region_copy (&clip->region, &region);
+        clip->has_region = TRUE;
     } else {
-	pixman_region16_t *intersection = pixman_region_create();
+	pixman_region16_t intersection;
+        pixman_region_init (&intersection, NULL);
+
+	if (PIXMAN_REGION_STATUS_SUCCESS == 
+            pixman_region_intersect (&intersection, &clip->region, &region)) {
+            pixman_region_copy (&clip->region, &intersection);
+        } else {
+            status = CAIRO_STATUS_NO_MEMORY;
+        }
 
-	if (pixman_region_intersect (intersection,
-				     clip->region, region)
-	    == PIXMAN_REGION_STATUS_SUCCESS) {
-	    pixman_region_destroy (clip->region);
-	    clip->region = intersection;
-	} else {
-	    status = CAIRO_STATUS_NO_MEMORY;
-	}
-	pixman_region_destroy (region);
+        pixman_region_uninit (&intersection);
     }
 
     clip->serial = _cairo_surface_allocate_clip_serial (target);
+    pixman_region_uninit (&region);
 
     return status;
 }
@@ -506,8 +503,8 @@ _cairo_clip_translate (cairo_clip_t  *clip,
                        cairo_fixed_t  tx,
                        cairo_fixed_t  ty)
 {
-    if (clip->region) {
-        pixman_region_translate (clip->region,
+    if (clip->has_region) {
+        pixman_region_translate (&clip->region,
                                  _cairo_fixed_integer_part (tx),
                                  _cairo_fixed_integer_part (ty));
     }
@@ -557,9 +554,9 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
         /* We should reapply the original clip path in this case, and let
          * whatever the right handling is happen */
     } else {
-        if (other->region) {
-            clip->region = pixman_region_create ();
-            pixman_region_copy (clip->region, other->region);
+        if (other->has_region) {
+            pixman_region_copy (&clip->region, &other->region);
+            clip->has_region = TRUE;
         }
 
         if (other->surface) {
@@ -610,16 +607,16 @@ _cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate)
     if (clip->path || clip->surface)
         return (cairo_rectangle_list_t*) &_cairo_rectangles_not_representable;
 
-    n_boxes = clip->region ? pixman_region_num_rects (clip->region) : 1;
+    n_boxes = clip->has_region ? pixman_region_num_rects (&clip->region) : 1;
     rectangles = malloc (sizeof (cairo_rectangle_t)*n_boxes);
     if (rectangles == NULL)
         return (cairo_rectangle_list_t*) &_cairo_rectangles_nil;
 
-    if (clip->region) {
+    if (clip->has_region) {
         pixman_box16_t *boxes;
         int i;
         
-        boxes = pixman_region_rects (clip->region);
+        boxes = pixman_region_rects (&clip->region);
         for (i = 0; i < n_boxes; ++i) {
             if (!_cairo_clip_rect_to_user(gstate, boxes[i].x1, boxes[i].y1,
                                           boxes[i].x2 - boxes[i].x1,
diff --git a/src/cairo-region.c b/src/cairo-region.c
index 057f9fe..883e1fc 100644
--- a/src/cairo-region.c
+++ b/src/cairo-region.c
@@ -36,30 +36,28 @@
 #include <cairoint.h>
 
 /**
- * _cairo_region_create_from_rectangle:
+ * _cairo_region_init_from_rectangle:
+ * @region: a #pixman_region16_t
  * @rect: a #cairo_rectangle_int16_t
  *
- * Creates a region with extents initialized from the given
- * rectangle.
+ * Initializes a region with extents from the given rectangle.
  *
- * Return value: a newly created #pixman_region16_t or %NULL if
- *    memory couldn't a allocated.
+ * Return value: #CAIRO_STATUS_SUCCESS on success, or
+ * #CAIRO_STATUS_NO_MEMORY when pixman fails to initialize
+ * the region.
  **/
-pixman_region16_t *
-_cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect)
+cairo_status_t
+_cairo_region_init_from_rectangle (pixman_region16_t       *region,
+                                   cairo_rectangle_int16_t *rect)
 {
-    /* We can't use pixman_region_create_simple(), because it doesn't
-     * have an error return
-     */
-    pixman_region16_t *region = pixman_region_create ();
-    if (pixman_region_union_rect (region, region,
-				  rect->x, rect->y,
-				  rect->width, rect->height) != PIXMAN_REGION_STATUS_SUCCESS) {
-	pixman_region_destroy (region);
-	return NULL;
-    }
+    pixman_region_init (region, NULL);
+
+    if (PIXMAN_REGION_STATUS_SUCCESS == pixman_region_union_rect (
+        region, region, rect->x, rect->y, rect->width, rect->height))
+        return CAIRO_STATUS_SUCCESS;
 
-    return region;
+    pixman_region_uninit (region);
+    return CAIRO_STATUS_NO_MEMORY;
 }
 
 /**
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..24c9115 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -511,145 +511,158 @@ _clip_and_composite_trapezoids (cairo_pattern_t *src,
 				cairo_antialias_t antialias)
 {
     cairo_status_t status;
-    pixman_region16_t *trap_region = NULL;
-    pixman_region16_t *clear_region = NULL;
+    pixman_region16_t trap_region;
+    pixman_region16_t clear_region;
+    cairo_bool_t has_trap_region = FALSE;
+    cairo_bool_t has_clear_region = FALSE;
     cairo_rectangle_int16_t extents;
     cairo_composite_traps_info_t traps_info;
 
     if (traps->num_traps == 0)
-	return CAIRO_STATUS_SUCCESS;
+        return CAIRO_STATUS_SUCCESS;
 
     status = _cairo_surface_get_extents (dst, &extents);
-    if (status)
-	return status;
 
-    status = _cairo_traps_extract_region (traps, &trap_region);
     if (status)
-	return status;
+        return status;
 
-    if (_cairo_operator_bounded_by_mask (op))
-    {
-	cairo_rectangle_int16_t trap_extents;
-	if (trap_region) {
-	    status = _cairo_clip_intersect_to_region (clip, trap_region);
-	    if (status)
-		goto out;
-
-	    _cairo_region_extents_rectangle (trap_region, &trap_extents);
-	} else {
-	    cairo_box_t trap_box;
-	    _cairo_traps_extents (traps, &trap_box);
-	    _cairo_box_round_to_rectangle (&trap_box, &trap_extents);
-	}
+    status = _cairo_traps_extract_region (traps, &trap_region);
 
-	_cairo_rectangle_intersect (&extents, &trap_extents);
-	status = _cairo_clip_intersect_to_rectangle (clip, &extents);
-	if (status)
-	    goto out;
-    }
-    else
-    {
-	cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
-
-	if (trap_region && !clip_surface) {
-	    /* If we optimize drawing with an unbounded operator to
-	     * _cairo_surface_fill_rectangles() or to drawing with a
-	     * clip region, then we have an additional region to clear.
-	     */
-	    clear_region = _cairo_region_create_from_rectangle (&extents);
-	    if (clear_region == NULL)
-		return CAIRO_STATUS_NO_MEMORY;
-
-	    status = _cairo_clip_intersect_to_region (clip, clear_region);
-	    if (status)
-		return status;
-
-	    _cairo_region_extents_rectangle (clear_region,  &extents);
-
-	    if (pixman_region_subtract (clear_region, clear_region, trap_region) != PIXMAN_REGION_STATUS_SUCCESS)
-		return CAIRO_STATUS_NO_MEMORY;
-
-	    if (!pixman_region_not_empty (clear_region)) {
-		pixman_region_destroy (clear_region);
-		clear_region = NULL;
-	    }
-	} else {
-	    status = _cairo_clip_intersect_to_rectangle (clip, &extents);
-	    if (status)
-		return status;
-	}
+    if (CAIRO_INT_STATUS_UNSUPPORTED == status) {
+        has_trap_region = FALSE;
+    } else if (status) {
+        return status;
+    } else {
+        has_trap_region = TRUE;
     }
 
-    if (status)
-	goto out;
-
-    if (trap_region)
-    {
-	cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
-
-	if ((src->type == CAIRO_PATTERN_TYPE_SOLID || op == CAIRO_OPERATOR_CLEAR) &&
-	    !clip_surface)
-	{
-	    const cairo_color_t *color;
-
-	    if (op == CAIRO_OPERATOR_CLEAR)
-		color = CAIRO_COLOR_TRANSPARENT;
-	    else
-		color = &((cairo_solid_pattern_t *)src)->color;
-
-	    /* Solid rectangles special case */
-	    status = _cairo_surface_fill_region (dst, op, color, trap_region);
-	    if (!status && clear_region)
-		status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
-						     CAIRO_COLOR_TRANSPARENT,
-						     clear_region);
-
-	    goto out;
-	}
-
-	if ((_cairo_operator_bounded_by_mask (op) && op != CAIRO_OPERATOR_SOURCE) ||
-	    !clip_surface)
-	{
-	    /* For a simple rectangle, we can just use composite(), for more
-	     * rectangles, we have to set a clip region. The cost of rasterizing
-	     * trapezoids is pretty high for most backends currently, so it's
-	     * worthwhile even if a region is needed.
-	     *
-	     * If we have a clip surface, we set it as the mask; this only works
-	     * for bounded operators other than SOURCE; for unbounded operators,
-	     * clip and mask cannot be interchanged. For SOURCE, the operator
-	     * as implemented by the backends is different in it's handling
-	     * of the mask then what we want.
-	     *
-	     * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
-	     * more than rectangle and the destination doesn't support clip
-	     * regions. In that case, we fall through.
-	     */
-	    status = _composite_trap_region (clip, src, op, dst,
-					     trap_region, &extents);
-	    if (status != CAIRO_INT_STATUS_UNSUPPORTED)
-	    {
-		if (!status && clear_region)
-		    status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
-							 CAIRO_COLOR_TRANSPARENT,
-							 clear_region);
-		goto out;
-	    }
-	}
+    if (_cairo_operator_bounded_by_mask (op)) {
+        cairo_rectangle_int16_t trap_extents;
+
+        if (has_trap_region) {
+            status = _cairo_clip_intersect_to_region (clip, &trap_region);
+
+            if (status)
+                goto out;
+
+            _cairo_region_extents_rectangle (&trap_region, &trap_extents);
+        } else {
+            cairo_box_t trap_box;
+            _cairo_traps_extents (traps, &trap_box);
+            _cairo_box_round_to_rectangle (&trap_box, &trap_extents);
+        }
+
+        _cairo_rectangle_intersect (&extents, &trap_extents);
+        status = _cairo_clip_intersect_to_rectangle (clip, &extents);
+
+        if (status)
+            goto out;
+    } else {
+        cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+
+        if (has_trap_region && !clip_surface) {
+            /* If we optimize drawing with an unbounded operator to
+             * _cairo_surface_fill_rectangles() or to drawing with a
+             * clip region, then we have an additional region to clear.
+             */
+            if (_cairo_region_init_from_rectangle (&clear_region, &extents)) {
+                status = CAIRO_STATUS_NO_MEMORY;
+                goto out;
+            }
+
+            has_clear_region = TRUE;
+            status = _cairo_clip_intersect_to_region (clip, &clear_region);
+
+            if (status)
+                goto out;
+
+            _cairo_region_extents_rectangle (&clear_region,  &extents);
+
+            if (PIXMAN_REGION_STATUS_SUCCESS != 
+                pixman_region_subtract (&clear_region, &clear_region, &trap_region)) {
+                status = CAIRO_STATUS_NO_MEMORY;
+                goto out;
+            }
+
+            if (!pixman_region_not_empty (&clear_region)) {
+                pixman_region_uninit (&clear_region);
+                has_clear_region = FALSE;
+            }
+        } else {
+            status = _cairo_clip_intersect_to_rectangle (clip, &extents);
+        }
+
+        if (status)
+            goto out;
+
+        if (has_trap_region) {
+            cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+
+            if ((src->type == CAIRO_PATTERN_TYPE_SOLID ||
+                 op == CAIRO_OPERATOR_CLEAR) && !clip_surface) {
+                const cairo_color_t *color;
+
+                if (op == CAIRO_OPERATOR_CLEAR) {
+                    color = CAIRO_COLOR_TRANSPARENT;
+                } else {
+                    color = &((cairo_solid_pattern_t *)src)->color;
+                }
+
+                /* Solid rectangles special case */
+                status = _cairo_surface_fill_region (dst, op, color,
+                        has_trap_region ? &trap_region : NULL);
+
+                if (!status && has_clear_region)
+                    status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
+                                                         CAIRO_COLOR_TRANSPARENT,
+                                                         &clear_region);
+
+                goto out;
+            }
+
+            if ((_cairo_operator_bounded_by_mask (op) && 
+                 op != CAIRO_OPERATOR_SOURCE) || !clip_surface) {
+                /* For a simple rectangle, we can just use composite(), for more
+                 * rectangles, we have to set a clip region. The cost of rasterizing
+                 * trapezoids is pretty high for most backends currently, so it's
+                 * worthwhile even if a region is needed.
+                 *
+                 * If we have a clip surface, we set it as the mask; this only works
+                 * for bounded operators other than SOURCE; for unbounded operators,
+                 * clip and mask cannot be interchanged. For SOURCE, the operator
+                 * as implemented by the backends is different in it's handling
+                 * of the mask then what we want.
+                 *
+                 * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
+                 * more than rectangle and the destination doesn't support clip
+                 * regions. In that case, we fall through.
+                 */
+                status = _composite_trap_region (clip, src, op, dst,
+                        has_trap_region ? &trap_region : NULL, 
+                        &extents);
+
+                if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
+                    if (!status && has_clear_region)
+                        status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
+                                                             CAIRO_COLOR_TRANSPARENT,
+                                                             &clear_region);
+                    goto out;
+                }
+            }
+        }
     }
 
     traps_info.traps = traps;
     traps_info.antialias = antialias;
 
-    status = _clip_and_composite (clip, op, src,
-				  _composite_traps_draw_func, &traps_info,
-				  dst, &extents);
+    status = _clip_and_composite (clip, op, src, _composite_traps_draw_func,
+                                  &traps_info, dst, &extents);
 
- out:
-    if (trap_region)
-	pixman_region_destroy (trap_region);
-    if (clear_region)
-	pixman_region_destroy (clear_region);
+out:
+    if (has_trap_region)
+        pixman_region_uninit (&trap_region);
+    if (has_clear_region)
+        pixman_region_uninit (&clear_region);
 
     return status;
 }
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index 3162a01..67df039 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -1694,9 +1694,9 @@ _cairo_surface_set_clip (cairo_surface_t *surface, cairo_clip_t *clip)
 						 clip->path,
 						 clip->serial);
 
-	if (clip->region)
+	if (clip->has_region)
 	    return _cairo_surface_set_clip_region (surface,
-						   clip->region,
+						   &clip->region,
 						   clip->serial);
     }
 
@@ -1859,9 +1859,11 @@ _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
 {
     cairo_rectangle_int16_t dst_rectangle;
     cairo_rectangle_int16_t drawn_rectangle;
-    pixman_region16_t *drawn_region;
-    pixman_region16_t *clear_region;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_bool_t has_drawn_region = FALSE;
+    cairo_bool_t has_clear_region = FALSE;
+    pixman_region16_t drawn_region;
+    pixman_region16_t clear_region;
+    cairo_status_t status;
 
     /* The area that was drawn is the area in the destination rectangle but not within
      * the source or the mask.
@@ -1874,34 +1876,42 @@ _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
     drawn_rectangle = dst_rectangle;
 
     if (src_rectangle)
-	_cairo_rectangle_intersect (&drawn_rectangle, src_rectangle);
+        _cairo_rectangle_intersect (&drawn_rectangle, src_rectangle);
 
     if (mask_rectangle)
-	_cairo_rectangle_intersect (&drawn_rectangle, mask_rectangle);
+        _cairo_rectangle_intersect (&drawn_rectangle, mask_rectangle);
 
     /* Now compute the area that is in dst_rectangle but not in drawn_rectangle
      */
-    drawn_region = _cairo_region_create_from_rectangle (&drawn_rectangle);
-    clear_region = _cairo_region_create_from_rectangle (&dst_rectangle);
-    if (!drawn_region || !clear_region) {
-	status = CAIRO_STATUS_NO_MEMORY;
-	goto CLEANUP_REGIONS;
+    if (_cairo_region_init_from_rectangle (&drawn_region, &drawn_rectangle)) {
+        status = CAIRO_STATUS_NO_MEMORY;
+        goto CLEANUP_REGIONS;
     }
 
-    if (pixman_region_subtract (clear_region, clear_region, drawn_region) != PIXMAN_REGION_STATUS_SUCCESS) {
-	status = CAIRO_STATUS_NO_MEMORY;
-	goto CLEANUP_REGIONS;
+    has_drawn_region = TRUE;
+
+    if (_cairo_region_init_from_rectangle (&clear_region, &dst_rectangle)) {
+        status = CAIRO_STATUS_NO_MEMORY;
+        goto CLEANUP_REGIONS;
+    }
+
+    has_clear_region = TRUE;
+
+    if (PIXMAN_REGION_STATUS_SUCCESS != 
+        pixman_region_subtract (&clear_region, &clear_region, &drawn_region)) {
+        status = CAIRO_STATUS_NO_MEMORY;
+        goto CLEANUP_REGIONS;
     }
 
     status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_SOURCE,
-					 CAIRO_COLOR_TRANSPARENT,
-					 clear_region);
-
- CLEANUP_REGIONS:
-    if (drawn_region)
-	pixman_region_destroy (drawn_region);
-    if (clear_region)
-	pixman_region_destroy (clear_region);
+                                         CAIRO_COLOR_TRANSPARENT,
+                                         &clear_region);
+
+CLEANUP_REGIONS:
+    if (has_drawn_region)
+        pixman_region_uninit (&drawn_region);
+    if (has_clear_region)
+        pixman_region_uninit (&clear_region);
 
     return status;
 }
diff --git a/src/cairo-traps.c b/src/cairo-traps.c
index 9b3931f..6acebf8 100644
--- a/src/cairo-traps.c
+++ b/src/cairo-traps.c
@@ -935,11 +935,12 @@ _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents)
  * Determines if a set of trapezoids are exactly representable as a
  * pixman region, and if so creates such a region.
  *
- * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY
+ * Return value: %CAIRO_STATUS_SUCCESS, %CAIRO_INT_STATUS_UNSUPPORTED 
+ * or %CAIRO_STATUS_NO_MEMORY
  **/
-cairo_status_t
-_cairo_traps_extract_region (cairo_traps_t      *traps,
-			     pixman_region16_t **region)
+cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t     *traps,
+			     pixman_region16_t *region)
 {
     int i;
 
@@ -950,11 +951,10 @@ _cairo_traps_extract_region (cairo_traps_t      *traps,
 	      && _cairo_fixed_is_integer(traps->traps[i].bottom)
 	      && _cairo_fixed_is_integer(traps->traps[i].left.p1.x)
 	      && _cairo_fixed_is_integer(traps->traps[i].right.p1.x))) {
-	    *region = NULL;
-	    return CAIRO_STATUS_SUCCESS;
+	    return CAIRO_INT_STATUS_UNSUPPORTED;
 	}
 
-    *region = pixman_region_create ();
+    pixman_region_init (region, NULL);
 
     for (i = 0; i < traps->num_traps; i++) {
 	int x = _cairo_fixed_integer_part(traps->traps[i].left.p1.x);
@@ -969,9 +969,9 @@ _cairo_traps_extract_region (cairo_traps_t      *traps,
 	if (width == 0 || height == 0)
 	  continue;
 
-	if (pixman_region_union_rect (*region, *region,
+	if (pixman_region_union_rect (region, region,
 				      x, y, width, height) != PIXMAN_REGION_STATUS_SUCCESS) {
-	    pixman_region_destroy (*region);
+	    pixman_region_uninit (region);
 	    return CAIRO_STATUS_NO_MEMORY;
 	}
     }
diff --git a/src/cairoint.h b/src/cairoint.h
index 3e54857..3494a92 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -2374,9 +2374,9 @@ _cairo_traps_contain (cairo_traps_t *traps, double x, double y);
 cairo_private void
 _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents);
 
-cairo_private cairo_status_t
-_cairo_traps_extract_region (cairo_traps_t      *tr,
-			     pixman_region16_t **region);
+cairo_private cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t     *tr,
+			     pixman_region16_t *region);
 
 cairo_private void
 _cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
@@ -2480,8 +2480,9 @@ _cairo_gstate_get_antialias (cairo_gstate_t *gstate);
 
 /* cairo-region.c */
 
-cairo_private pixman_region16_t *
-_cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect);
+cairo_private cairo_status_t
+_cairo_region_init_from_rectangle (pixman_region16_t       *region,
+				   cairo_rectangle_int16_t *rect);
 
 cairo_private void
 _cairo_region_extents_rectangle (pixman_region16_t       *region,
-- 
1.4.4.2

From mathias.hasselmann at gmx.de  Fri Mar  9 13:43:20 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Fri Mar  9 13:43:40 2007
Subject: [cairo] Re: Sorry I broke the text tests! (and status update)
In-Reply-To: <1173124897.18079.64.camel@behdad>
References: <1172999923.17604.3.camel@dali>
	<17898.43584.471000.26325@gargle.gargle.HOWL>
	<1173019474.17604.17.camel@dali> <1173043926.9109.10.camel@behdad>
	<1173075763.5590.8.camel@dali> <1173087730.20769.7.camel@dali>
	<87y7mbk4h0.wl%cworth@cworth.org>  <1173123206.10240.5.camel@dali>
	<1173124897.18079.64.camel@behdad>
Message-ID: <1173476600.21219.4.camel@dali>

Am Montag, den 05.03.2007, 15:01 -0500 schrieb Behdad Esfahbod:
>   - all non-public headers should end in "-private.h".  This is relied
> on in the documentation generation stuff.  We talked about moving to a
> scheme that all non-public headers don't start with "cairo-", but that's
> not been done so far.
> 
>   - Please rename all mutexes to be in the shape "_cairo_*_mutex", since
> they are not static anymore.  We can go a bit further and make the
> CAIRO_MUTEX_* macros do the namespacing for us, but we typically avoid
> name mangling in cairo. 

As we missunderstood on IRC you did the renaming already. So I've
produced some updated patch set.
-------------- next part --------------
>From a2ea122c049ce4477651ed7efbb3266d9d4c6a0c Mon Sep 17 00:00:00 2001
From: Mathias Hasselmann <mathias.hasselmann@gmx.de>
Date: Mon, 5 Mar 2007 08:36:26 +0100
Subject: [PATCH] [PATCH] Remove problems causing -Werror to fail

Expect for the problems gcc 3.4.5/mingw finds in cairo-png.c and
expect for the problems gcc 4.1.2 finds in cairo-directfb-surface.c.
---
 boilerplate/cairo-boilerplate.c |   24 +++++++++++++++---------
 src/cairo-font.c                |    2 +-
 src/cairo-image-surface.c       |   14 +++++++++++++-
 src/cairo-matrix.c              |    3 +++
 src/cairo-pattern.c             |   30 ++++++++++++++++--------------
 src/cairo-scaled-font.c         |    2 +-
 src/cairo-surface.c             |    1 +
 src/cairo-svg-surface.c         |    3 ++-
 src/cairo-win32-surface.c       |   13 +++++++++++--
 src/cairo.c                     |    2 +-
 src/cairoint.h                  |    2 +-
 test/pdiff/pdiff.c              |    3 ++-
 12 files changed, 67 insertions(+), 32 deletions(-)

diff --git a/boilerplate/cairo-boilerplate.c b/boilerplate/cairo-boilerplate.c
index 561e6df..791ca3d 100644
--- a/boilerplate/cairo-boilerplate.c
+++ b/boilerplate/cairo-boilerplate.c
@@ -1369,9 +1369,9 @@ cairo_boilerplate_target_t targets[] =
      * for tolerance. There shouldn't ever be anything that is out of
      * our control here. */
     { "image", CAIRO_SURFACE_TYPE_IMAGE, CAIRO_CONTENT_COLOR_ALPHA, 0,
-      create_image_surface, cairo_surface_write_to_png, NULL},
+      create_image_surface, cairo_surface_write_to_png, NULL, NULL, NULL},
     { "image", CAIRO_SURFACE_TYPE_IMAGE, CAIRO_CONTENT_COLOR, 0,
-      create_image_surface, cairo_surface_write_to_png, NULL},
+      create_image_surface, cairo_surface_write_to_png, NULL, NULL, NULL},
 #ifdef CAIRO_HAS_TEST_SURFACES
     { "test-fallback", CAIRO_INTERNAL_SURFACE_TYPE_TEST_FALLBACK,
       CAIRO_CONTENT_COLOR_ALPHA, 0,
@@ -1432,9 +1432,11 @@ cairo_boilerplate_target_t targets[] =
 #endif
 #if CAIRO_HAS_WIN32_SURFACE
     { "win32", CAIRO_SURFACE_TYPE_WIN32, CAIRO_CONTENT_COLOR, 0,
-      create_win32_surface, cairo_surface_write_to_png, cleanup_win32 },
+      create_win32_surface, cairo_surface_write_to_png, cleanup_win32,
+      NULL, NULL },
     { "win32", CAIRO_SURFACE_TYPE_WIN32, CAIRO_CONTENT_COLOR_ALPHA, 0,
-      create_win32_surface, cairo_surface_write_to_png, cleanup_win32 },
+      create_win32_surface, cairo_surface_write_to_png, cleanup_win32,
+      NULL, NULL },
 #endif
 #if CAIRO_HAS_XCB_SURFACE
     /* Acceleration architectures may make the results differ by a
@@ -1456,7 +1458,8 @@ cairo_boilerplate_target_t targets[] =
 #if CAIRO_HAS_PS_SURFACE
     { "ps", CAIRO_SURFACE_TYPE_PS,
       CAIRO_TEST_CONTENT_COLOR_ALPHA_FLATTENED, 0,
-      create_ps_surface, ps_surface_write_to_png, cleanup_ps },
+      create_ps_surface, ps_surface_write_to_png, cleanup_ps,
+      NULL, NULL },
 
     /* XXX: We expect type image here only due to a limitation in
      * the current PS/meta-surface code. A PS surface is
@@ -1467,7 +1470,8 @@ cairo_boilerplate_target_t targets[] =
      * create_similar path for all paginated surfaces currently
      * returns an image surface.*/
     { "ps", CAIRO_SURFACE_TYPE_IMAGE, CAIRO_CONTENT_COLOR, 0,
-      create_ps_surface, ps_surface_write_to_png, cleanup_ps },
+      create_ps_surface, ps_surface_write_to_png, cleanup_ps,
+      NULL, NULL },
 #endif
 #if CAIRO_HAS_PDF_SURFACE && CAIRO_CAN_TEST_PDF_SURFACE
     { "pdf", CAIRO_SURFACE_TYPE_PDF,
@@ -1492,9 +1496,11 @@ cairo_boilerplate_target_t targets[] =
      * tests. XXX: I'd still like to chase these down at some point.
      * For now just set the svg error tolerance to 1. */
     { "svg", CAIRO_SURFACE_TYPE_SVG, CAIRO_CONTENT_COLOR_ALPHA, 1,
-      create_svg_surface, svg_surface_write_to_png, cleanup_svg },
+      create_svg_surface, svg_surface_write_to_png, cleanup_svg,
+      NULL, NULL },
     { "svg", CAIRO_INTERNAL_SURFACE_TYPE_META, CAIRO_CONTENT_COLOR, 1,
-      create_svg_surface, svg_surface_write_to_png, cleanup_svg },
+      create_svg_surface, svg_surface_write_to_png, cleanup_svg,
+      NULL, NULL },
 #endif
 #if CAIRO_HAS_BEOS_SURFACE
     /* BeOS sometimes produces a slightly different image. Perhaps this
@@ -1515,7 +1521,7 @@ cairo_boilerplate_target_t targets[] =
       create_directfb_surface, cairo_surface_write_to_png,cleanup_directfb},
 #endif
 
-    { NULL }
+    { NULL, 0, 0, 0, NULL, NULL, NULL, NULL, NULL }
 };
 
 void
diff --git a/src/cairo-font.c b/src/cairo-font.c
index cacc589..4b768fb 100644
--- a/src/cairo-font.c
+++ b/src/cairo-font.c
@@ -51,7 +51,7 @@ const cairo_font_face_t _cairo_font_face_nil = {
     { 0 },			/* hash_entry */
     CAIRO_STATUS_NO_MEMORY,	/* status */
     CAIRO_REF_COUNT_INVALID,	/* ref_count */
-    { 0, 0, 0, NULL },		/* user_data */
+    { 0, 0, 0, NULL, FALSE },   /* user_data */
     &_cairo_toy_font_face_backend
 };
 
diff --git a/src/cairo-image-surface.c b/src/cairo-image-surface.c
index 6279012..c8e77ea 100644
--- a/src/cairo-image-surface.c
+++ b/src/cairo-image-surface.c
@@ -48,6 +48,7 @@ const cairo_image_surface_t _cairo_image_surface_nil_invalid_format = {
 	  0,	/* num_elements */
 	  0,	/* element_size */
 	  NULL,	/* elements */
+	  FALSE /* is_snapshot */
 	},				/* user_data */
 	{ 1.0, 0.0,
 	  0.0, 1.0,
@@ -1099,7 +1100,18 @@ const cairo_surface_backend_t cairo_image_surface_backend = {
     _cairo_image_surface_set_clip_region,
     NULL, /* intersect_clip_path */
     _cairo_image_surface_get_extents,
-    NULL /* old_show_glyphs */
+    NULL, /* old_show_glyphs */
+    NULL, /* get_font_options */
+    NULL, /* flush */
+    NULL, /* mark_dirty_rectangle */
+    NULL, /* scaled_font_fini */
+    NULL, /* scaled_glyph_fini */
+    NULL, /* paint */
+    NULL, /* mask */
+    NULL, /* stroke */
+    NULL, /* fill */
+    NULL, /* show_glyphs */
+    NULL  /* snapshot */
 };
 
 /* A convenience function for when one needs to coerce an image
diff --git a/src/cairo-matrix.c b/src/cairo-matrix.c
index b689f2a..64e4a47 100644
--- a/src/cairo-matrix.c
+++ b/src/cairo-matrix.c
@@ -34,7 +34,10 @@
  *	Carl D. Worth <cworth@cworth.org>
  */
 
+#ifndef _GNU_SOURCE
 #define _GNU_SOURCE
+#endif
+
 #include <stdlib.h>
 
 #include "cairoint.h"
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index efa0c5a..ad5b348 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -31,23 +31,25 @@
 #include "cairoint.h"
 
 const cairo_solid_pattern_t cairo_pattern_nil = {
-    { CAIRO_PATTERN_TYPE_SOLID, 	/* type */
-      CAIRO_REF_COUNT_INVALID,		/* ref_count */
-      CAIRO_STATUS_NO_MEMORY,	/* status */
-      { 0, 0, 0, NULL },		/* user_data */
-      { 1., 0., 0., 1., 0., 0., }, /* matrix */
-      CAIRO_FILTER_DEFAULT,	/* filter */
-      CAIRO_EXTEND_GRADIENT_DEFAULT },	/* extend */
+    { CAIRO_PATTERN_TYPE_SOLID,         /* type */
+      CAIRO_REF_COUNT_INVALID,          /* ref_count */
+      CAIRO_STATUS_NO_MEMORY,           /* status */
+      { 0, 0, 0, NULL, FALSE },         /* user_data */
+      { 1., 0., 0., 1., 0., 0., },      /* matrix */
+      CAIRO_FILTER_DEFAULT,             /* filter */
+      CAIRO_EXTEND_GRADIENT_DEFAULT },  /* extend */
+    { 0, 0, 0, 0, 0, 0, 0, 0 }          /* color */
 };
 
 static const cairo_solid_pattern_t cairo_pattern_nil_null_pointer = {
-    { CAIRO_PATTERN_TYPE_SOLID, 	/* type */
-      CAIRO_REF_COUNT_INVALID,		/* ref_count */
-      CAIRO_STATUS_NULL_POINTER,/* status */
-      { 0, 0, 0, NULL },		/* user_data */
-      { 1., 0., 0., 1., 0., 0., }, /* matrix */
-      CAIRO_FILTER_DEFAULT,	/* filter */
-      CAIRO_EXTEND_GRADIENT_DEFAULT },	/* extend */
+    { CAIRO_PATTERN_TYPE_SOLID,         /* type */
+      CAIRO_REF_COUNT_INVALID,          /* ref_count */
+      CAIRO_STATUS_NULL_POINTER,        /* status */
+      { 0, 0, 0, NULL, FALSE },         /* user_data */
+      { 1., 0., 0., 1., 0., 0., },      /* matrix */
+      CAIRO_FILTER_DEFAULT,             /* filter */
+      CAIRO_EXTEND_GRADIENT_DEFAULT },  /* extend */
+    { 0, 0, 0, 0, 0, 0, 0, 0 }          /* color */
 };
 
 /**
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 0162a0d..f3b126e 100755
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -75,7 +75,7 @@ const cairo_scaled_font_t _cairo_scaled_font_nil = {
     { 0 },			/* hash_entry */
     CAIRO_STATUS_NO_MEMORY,	/* status */
     CAIRO_REF_COUNT_INVALID,	/* ref_count */
-    { 0, 0, 0, NULL },		/* user_data */
+    { 0, 0, 0, NULL, FALSE },	/* user_data */
     NULL,			/* font_face */
     { 1., 0., 0., 1., 0, 0},	/* font_matrix */
     { 1., 0., 0., 1., 0, 0},	/* ctm */
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index 3162a01..f134bc2 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -53,6 +53,7 @@ const cairo_surface_t name = {					\
       0,	/* num_elements */				\
       0,	/* element_size */				\
       NULL,	/* elements */					\
+      FALSE	/* is_snapshot */				\
     },					/* user_data */		\
     { 1.0, 0.0,							\
       0.0, 1.0,							\
diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index 5cb9ce0..049741a 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -2016,7 +2016,8 @@ static const cairo_surface_backend_t cairo_svg_surface_backend = {
 	_cairo_svg_surface_mask,
 	_cairo_svg_surface_stroke,
 	_cairo_svg_surface_fill,
-	_cairo_svg_surface_show_glyphs
+	_cairo_svg_surface_show_glyphs,
+        NULL /* snapshot */
 };
 
 static cairo_svg_document_t *
diff --git a/src/cairo-win32-surface.c b/src/cairo-win32-surface.c
index 9123b82..f0b75d0 100644
--- a/src/cairo-win32-surface.c
+++ b/src/cairo-win32-surface.c
@@ -835,7 +835,7 @@ _cairo_win32_surface_composite (cairo_operator_t	op,
     int alpha;
     double scalex, scaley;
     cairo_fixed_t x0_fixed, y0_fixed;
-    cairo_int_status_t status;
+    cairo_int_status_t status = CAIRO_STATUS_SUCCESS;
 
     cairo_bool_t needs_alpha, needs_scale, needs_repeat;
     cairo_image_surface_t *src_image = NULL;
@@ -982,7 +982,7 @@ _cairo_win32_surface_composite (cairo_operator_t	op,
 	 * we can't do anything useful here.
 	 */
 	if (src_r.x > src_extents.width || src_r.y > src_extents.height ||
-	    (src_r.x + src_r.width) < 0 || (src_r.y + src_r.height) < 0)
+	    (int)(src_r.x + src_r.width) < 0 || (int)(src_r.y + src_r.height) < 0)
 	{
 	    if (op == CAIRO_OPERATOR_OVER)
 		return CAIRO_STATUS_SUCCESS;
@@ -1919,6 +1919,15 @@ _cairo_win32_initialize (void) {
 }
 
 #if !defined(CAIRO_WIN32_STATIC_BUILD)
+
+/*
+ * Avoid warning regarding missing prototype
+ */
+BOOL WINAPI
+DllMain (HINSTANCE hinstDLL,
+	 DWORD     fdwReason,
+	 LPVOID    lpvReserved);
+
 BOOL WINAPI
 DllMain (HINSTANCE hinstDLL,
 	 DWORD     fdwReason,
diff --git a/src/cairo.c b/src/cairo.c
index 355fcae..4004ccf 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -47,7 +47,7 @@
 static const cairo_t cairo_nil = {
   CAIRO_REF_COUNT_INVALID,	/* ref_count */
   CAIRO_STATUS_NO_MEMORY,	/* status */
-  { 0, 0, 0, NULL },		/* user_data */
+  { 0, 0, 0, NULL, FALSE },	/* user_data */
   { 				/* path */
     NULL, NULL,			   /* op_buf_head, op_buf_tail */
     NULL, NULL,			   /* arg_buf_head, arg_buf_tail */
diff --git a/src/cairoint.h b/src/cairoint.h
index 3e54857..e314152 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -169,7 +169,7 @@ typedef pthread_mutex_t cairo_mutex_t;
 typedef CRITICAL_SECTION cairo_mutex_t;
 # define CAIRO_MUTEX_INIT(mutex) InitializeCriticalSection (mutex)
 # define CAIRO_MUTEX_FINI(mutex) DeleteCriticalSection (mutex)
-# define CAIRO_MUTEX_NIL_INITIALIZER { 0 }
+# define CAIRO_MUTEX_NIL_INITIALIZER { NULL, 0, 0, NULL, NULL, 0 }
 #endif
 
 #if defined(__OS2__) && !defined(CAIRO_MUTEX_DECLARE)
diff --git a/test/pdiff/pdiff.c b/test/pdiff/pdiff.c
index 91e0caf..22c3a6b 100644
--- a/test/pdiff/pdiff.c
+++ b/test/pdiff/pdiff.c
@@ -13,8 +13,9 @@
   You should have received a copy of the GNU General Public License along with this program;
   if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
-
+#ifndef _GNU_SOURCE
 #define _GNU_SOURCE
+#endif
 
 #include "lpyramid.h"
 #include <math.h>
-- 
1.4.4.2

-------------- next part --------------
>From 5af980ccd8c30b07016dfbe8f85a294f0bf63d29 Mon Sep 17 00:00:00 2001
From: Mathias Hasselmann <mathias.hasselmann@gmx.de>
Date: Mon, 5 Mar 2007 10:21:40 +0100
Subject: [PATCH] [PATCH] Initialize mutexes at central location.

---
 src/Makefile.am               |    1 +
 src/cairo-font.c              |    7 +--
 src/cairo-ft-font.c           |    3 +-
 src/cairo-mutex-list.h        |   53 ++++++++++++++++++
 src/cairo-mutex-private.h     |  118 +++++++++++++++++++++++++++++++++++++++++
 src/cairo-mutex.c             |   51 ++++++++++++++++++
 src/cairo-os2-surface.c       |   20 -------
 src/cairo-paginated-surface.c |    1 +
 src/cairo-pattern.c           |    3 +
 src/cairo-scaled-font.c       |    3 +-
 src/cairo-surface.c           |    5 +-
 src/cairo-win32-font.c        |   10 ----
 src/cairo-win32-private.h     |    3 -
 src/cairo-win32-surface.c     |   74 -------------------------
 src/cairo-xlib-screen.c       |    3 +-
 src/cairoint.h                |   71 +++++--------------------
 16 files changed, 250 insertions(+), 176 deletions(-)

diff --git a/src/Makefile.am b/src/Makefile.am
index d2ec4cf..ce2aa6e 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -188,6 +188,7 @@ libcairo_la_SOURCES =				\
 	cairo-image-surface.c			\
 	cairo-lzw.c				\
 	cairo-matrix.c				\
+	cairo-mutex.c				\
 	cairo-operator.c			\
 	cairo-path.c				\
 	cairo-path-private.h			\
diff --git a/src/cairo-font.c b/src/cairo-font.c
index 4b768fb..f2442cd 100644
--- a/src/cairo-font.c
+++ b/src/cairo-font.c
@@ -39,6 +39,7 @@
  */
 
 #include "cairoint.h"
+#include "cairo-mutex-private.h"
 
 /* Forward declare so we can use it as an arbitrary backend for
  * _cairo_font_face_nil.
@@ -59,6 +60,8 @@ void
 _cairo_font_face_init (cairo_font_face_t               *font_face,
 		       const cairo_font_face_backend_t *backend)
 {
+    CAIRO_MUTEX_INITIALIZE ();
+
     font_face->status = CAIRO_STATUS_SUCCESS;
     font_face->ref_count = 1;
     font_face->backend = backend;
@@ -66,10 +69,6 @@ _cairo_font_face_init (cairo_font_face_t               *font_face,
     _cairo_user_data_array_init (&font_face->user_data);
 }
 
-/* This mutex protects both cairo_toy_font_hash_table as well as
-   reference count manipulations for all cairo_font_face_t. */
-CAIRO_MUTEX_DECLARE (_cairo_font_face_mutex);
-
 /**
  * cairo_font_face_reference:
  * @font_face: a #cairo_font_face_t, (may be %NULL in which case this
diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index 27bc2e3..d397655 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -40,6 +40,7 @@
 #include <float.h>
 
 #include "cairo-ft-private.h"
+#include "cairo-mutex-private.h"
 
 #include <fontconfig/fontconfig.h>
 #include <fontconfig/fcfreetype.h>
@@ -150,8 +151,6 @@ typedef struct _cairo_ft_unscaled_font_map {
 
 static cairo_ft_unscaled_font_map_t *cairo_ft_unscaled_font_map = NULL;
 
-CAIRO_MUTEX_DECLARE(_cairo_ft_unscaled_font_map_mutex);
-
 static void
 _font_map_release_face_lock_held (cairo_ft_unscaled_font_map_t *font_map,
 				  cairo_ft_unscaled_font_t *unscaled)
diff --git a/src/cairo-mutex-list.h b/src/cairo-mutex-list.h
new file mode 100644
index 0000000..38d305f
--- /dev/null
+++ b/src/cairo-mutex-list.h
@@ -0,0 +1,53 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright ? 2007 the cairo graphics library project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * Contributor(s):
+ *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
+ */
+
+#ifndef CAIRO_MUTEX_LIST_H
+#define CAIRO_MUTEX_LIST_H
+
+CAIRO_MUTEX_DECLARE (_cairo_font_face_mutex);
+CAIRO_MUTEX_DECLARE (_cairo_scaled_font_map_mutex);
+
+#if CAIRO_HAS_FT_FONT
+CAIRO_MUTEX_DECLARE (_cairo_ft_unscaled_font_map_mutex);
+#endif
+
+#if CAIRO_HAS_XLIB_SURFACE
+CAIRO_MUTEX_DECLARE (_xlib_screen_mutex);
+#endif
+
+#if CAIRO_HAS_OS2_SURFACE
+CAIRO_MUTEX_DECLARE (cairo_toy_font_face_hash_table_mutex);
+CAIRO_MUTEX_DECLARE (_global_image_glyph_cache_mutex);
+#endif
+
+#endif
diff --git a/src/cairo-mutex-private.h b/src/cairo-mutex-private.h
new file mode 100644
index 0000000..fdaeb8b
--- /dev/null
+++ b/src/cairo-mutex-private.h
@@ -0,0 +1,118 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright ? 2002 University of Southern California
+ * Copyright ? 2005 Red Hat, Inc.
+ * Copyright ? 2007 the cairo graphics library project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
+ */
+
+#ifndef CAIRO_MUTEX_PRIVATE_H
+#define CAIRO_MUTEX_PRIVATE_H
+
+#include "cairoint.h"
+
+#if HAVE_PTHREAD_H
+
+# define CAIRO_MUTEX_INITIALIZE() /* no-op */
+# define CAIRO_MUTEX_LOCK(name) pthread_mutex_lock (&name)
+# define CAIRO_MUTEX_UNLOCK(name) pthread_mutex_unlock (&name)
+# define CAIRO_MUTEX_INIT(mutex) do {				\
+    pthread_mutex_t tmp_mutex = PTHREAD_MUTEX_INITIALIZER;      \
+    memcpy (mutex, &tmp_mutex, sizeof (tmp_mutex));             \
+} while (0)
+# define CAIRO_MUTEX_FINI(mutex) pthread_mutex_destroy (mutex)
+# define CAIRO_MUTEX_NIL_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+
+#elif defined CAIRO_HAS_WIN32_SURFACE
+
+# define CAIRO_MUTEX_LOCK(name) EnterCriticalSection (&name)
+# define CAIRO_MUTEX_UNLOCK(name) LeaveCriticalSection (&name)
+# define CAIRO_MUTEX_INIT(mutex) InitializeCriticalSection (mutex)
+# define CAIRO_MUTEX_FINI(mutex) DeleteCriticalSection (mutex)
+# define CAIRO_MUTEX_NIL_INITIALIZER { NULL, 0, 0, NULL, NULL, 0 }
+
+#elif defined __OS2__
+
+# define CAIRO_MUTEX_LOCK(name) DosRequestMutexSem(name, SEM_INDEFINITE_WAIT)
+# define CAIRO_MUTEX_UNLOCK(name) DosReleaseMutexSem(name)
+# define CAIRO_MUTEX_INIT(mutex) DosCreateMutexSem (NULL, mutex, 0L, FALSE)
+# define CAIRO_MUTEX_FINI(mutex) DosCloseMutexSem (*(mutex))
+# define CAIRO_MUTEX_NIL_INITIALIZER 0
+
+#elif defined CAIRO_HAS_BEOS_SURFACE
+
+cairo_private void _cairo_beos_lock(cairo_mutex_t*);
+cairo_private void _cairo_beos_unlock(cairo_mutex_t*);
+
+/* the real initialization takes place in a global constructor */
+# define CAIRO_MUTEX_LOCK(name) _cairo_beos_lock (&name)
+# define CAIRO_MUTEX_UNLOCK(name) _cairo_beos_unlock (&name)
+
+# error "XXX: Someone who understands BeOS needs to add definitions for" \
+        "     cairo_mutex_t, CAIRO_MUTEX_INIT, and CAIRO_MUTEX_FINI," \
+        "     to cairoint.h"
+
+# define CAIRO_MUTEX_INIT(mutex) ???
+# define CAIRO_MUTEX_FINI(mutex) ???
+# define CAIRO_MUTEX_NIL_INITIALIZER {}
+
+#else
+
+# define CAIRO_MUTEX_LOCK(name)
+# define CAIRO_MUTEX_UNLOCK(name)
+
+#endif
+
+#ifndef CAIRO_MUTEX_DECLARE
+#define CAIRO_MUTEX_DECLARE(name) extern cairo_mutex_t name;
+#endif
+
+#include "cairo-mutex-list.h"
+
+#undef CAIRO_MUTEX_DECLARE
+#undef CAIRO_MUTEX_EXTERNAL
+
+#ifndef CAIRO_MUTEX_INITIALIZE
+
+#define CAIRO_MUTEX_INITIALIZE() do { \
+    if (!_cairo_mutex_initialized) \
+        _cairo_mutex_initialize(); \
+} while(0)
+
+cairo_private extern cairo_bool_t _cairo_mutex_initialized;
+cairo_private void _cairo_mutex_initialize(void);
+
+#endif
+
+#endif
diff --git a/src/cairo-mutex.c b/src/cairo-mutex.c
new file mode 100644
index 0000000..8b9437e
--- /dev/null
+++ b/src/cairo-mutex.c
@@ -0,0 +1,51 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright ? 2007 the cairo graphics library project
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * Contributor(s):
+ *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
+ */
+
+#define CAIRO_MUTEX_DECLARE(name) cairo_mutex_t name = CAIRO_MUTEX_NIL_INITIALIZER;
+#include "cairo-mutex-private.h"
+
+#if !HAVE_PTHREAD_H
+
+cairo_bool_t _cairo_mutex_initialized = FALSE;
+
+void _cairo_mutex_initialize (void)
+{
+    if (_cairo_mutex_initialized)
+        return;
+
+#define CAIRO_MUTEX_DECLARE(mutex) CAIRO_MUTEX_INIT (mutex);
+#include "cairo-mutex-list.h"
+#undef CAIRO_MUTEX_DECLARE
+}
+
+#endif
diff --git a/src/cairo-os2-surface.c b/src/cairo-os2-surface.c
index f6ec8f6..6ce77fc 100644
--- a/src/cairo-os2-surface.c
+++ b/src/cairo-os2-surface.c
@@ -68,14 +68,6 @@
 /* Initialization counter: */
 static int cairo_os2_initialization_count = 0;
 
-/* The mutex semaphores Cairo uses all around: */
-HMTX _cairo_scaled_font_map_mutex = 0;
-HMTX _global_image_glyph_cache_mutex = 0;
-HMTX _cairo_font_face_mutex = 0;
-#ifdef CAIRO_HAS_FT_FONT
-HMTX _cairo_ft_unscaled_font_map_mutex = 0;
-#endif
-
 static void inline
 DisableFPUException (void)
 {
@@ -103,18 +95,6 @@ cairo_os2_init (void)
 
     DisableFPUException ();
 
-    /* Create the mutex semaphores we'll use! */
-
-    /* cairo-font.c: */
-    DosCreateMutexSem (NULL, &_cairo_scaled_font_map_mutex, 0, FALSE);
-    DosCreateMutexSem (NULL, &_global_image_glyph_cache_mutex, 0, FALSE);
-    DosCreateMutexSem (NULL, &_cairo_font_face_mutex, 0, FALSE);
-
-#ifdef CAIRO_HAS_FT_FONT
-    /* cairo-ft-font.c: */
-    DosCreateMutexSem (NULL, &_cairo_ft_unscaled_font_map_mutex, 0, FALSE);
-#endif
-
     /* Initialize FontConfig */
     FcInit ();
 }
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index c8e4612..c8c9a72 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -45,6 +45,7 @@
 #include "cairo-paginated-surface-private.h"
 #include "cairo-meta-surface-private.h"
 #include "cairo-analysis-surface-private.h"
+#include "cairo-mutex-private.h"
 
 typedef struct _cairo_paginated_surface {
     cairo_surface_t base;
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index ad5b348..96b0076 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -29,6 +29,7 @@
  */
 
 #include "cairoint.h"
+#include "cairo-mutex-private.h"
 
 const cairo_solid_pattern_t cairo_pattern_nil = {
     { CAIRO_PATTERN_TYPE_SOLID,         /* type */
@@ -84,6 +85,8 @@ _cairo_pattern_set_error (cairo_pattern_t *pattern,
 static void
 _cairo_pattern_init (cairo_pattern_t *pattern, cairo_pattern_type_t type)
 {
+    CAIRO_MUTEX_INITIALIZE ();
+
     pattern->type      = type;
     pattern->ref_count = 1;
     pattern->status    = CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index f3b126e..dd48b8f 100755
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -37,6 +37,7 @@
  */
 
 #include "cairoint.h"
+#include "cairo-mutex-private.h"
 #include "cairo-scaled-font-test.h"
 
 static cairo_bool_t
@@ -185,8 +186,6 @@ typedef struct _cairo_scaled_font_map {
 
 static cairo_scaled_font_map_t *cairo_scaled_font_map = NULL;
 
-CAIRO_MUTEX_DECLARE (_cairo_scaled_font_map_mutex);
-
 static int
 _cairo_scaled_font_keys_equal (const void *abstract_key_a, const void *abstract_key_b);
 
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index f134bc2..f4c68a2 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -39,6 +39,7 @@
 
 #include "cairoint.h"
 #include "cairo-surface-fallback-private.h"
+#include "cairo-mutex-private.h"
 #include "cairo-clip-private.h"
 
 #define DEFINE_NIL_SURFACE(status, name)			\
@@ -181,10 +182,10 @@ _cairo_surface_init (cairo_surface_t			*surface,
 		     const cairo_surface_backend_t	*backend,
 		     cairo_content_t			 content)
 {
-    surface->backend = backend;
+    CAIRO_MUTEX_INITIALIZE ();
 
+    surface->backend = backend;
     surface->content = content;
-
     surface->type = backend->type;
 
     surface->ref_count = 1;
diff --git a/src/cairo-win32-font.c b/src/cairo-win32-font.c
index 679d52d..4932d80 100644
--- a/src/cairo-win32-font.c
+++ b/src/cairo-win32-font.c
@@ -239,8 +239,6 @@ _win32_scaled_font_create (LOGFONTW                   *logfont,
     cairo_matrix_t scale;
     cairo_status_t status;
 
-    _cairo_win32_initialize ();
-
     f = malloc (sizeof(cairo_win32_scaled_font_t));
     if (f == NULL)
 	return NULL;
@@ -472,8 +470,6 @@ _cairo_win32_scaled_font_create_toy (cairo_toy_font_face_t *toy_face,
     int face_name_len;
     cairo_status_t status;
 
-    _cairo_win32_initialize ();
-
     status = _cairo_utf8_to_utf16 (toy_face->family, -1,
 				   &face_name, &face_name_len);
     if (status)
@@ -1510,8 +1506,6 @@ _cairo_win32_font_face_scaled_font_create (void			*abstract_face,
 {
     cairo_win32_font_face_t *font_face = abstract_face;
 
-    _cairo_win32_initialize ();
-
     *font = _win32_scaled_font_create (&font_face->logfont,
 				       font_face->hfont,
 				       &font_face->base,
@@ -1549,8 +1543,6 @@ cairo_win32_font_face_create_for_logfontw (LOGFONTW *logfont)
 {
     cairo_win32_font_face_t *font_face;
 
-    _cairo_win32_initialize ();
-
     font_face = malloc (sizeof (cairo_win32_font_face_t));
     if (!font_face) {
 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
@@ -1584,8 +1576,6 @@ cairo_win32_font_face_create_for_hfont (HFONT font)
 {
     cairo_win32_font_face_t *font_face;
 
-    _cairo_win32_initialize ();
-
     font_face = malloc (sizeof (cairo_win32_font_face_t));
     if (!font_face) {
 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
diff --git a/src/cairo-win32-private.h b/src/cairo-win32-private.h
index 220c9d3..08aeafa 100644
--- a/src/cairo-win32-private.h
+++ b/src/cairo-win32-private.h
@@ -105,7 +105,4 @@ _cairo_win32_print_gdi_error (const char *context);
 cairo_bool_t
 _cairo_surface_is_win32 (cairo_surface_t *surface);
 
-void
-_cairo_win32_initialize (void);
-
 #endif /* CAIRO_WIN32_PRIVATE_H */
diff --git a/src/cairo-win32-surface.c b/src/cairo-win32-surface.c
index f0b75d0..4773783 100644
--- a/src/cairo-win32-surface.c
+++ b/src/cairo-win32-surface.c
@@ -327,8 +327,6 @@ _cairo_win32_surface_create_for_dc (HDC             original_dc,
     char *bits;
     int rowstride;
 
-    _cairo_win32_initialize ();
-
     surface = malloc (sizeof (cairo_win32_surface_t));
     if (surface == NULL) {
 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
@@ -1635,8 +1633,6 @@ cairo_win32_surface_create (HDC hdc)
     int depth;
     cairo_format_t format;
 
-    _cairo_win32_initialize ();
-
     /* Try to figure out the drawing bounds for the Device context
      */
     if (GetClipBox (hdc, &rect) == ERROR) {
@@ -1887,76 +1883,6 @@ static const cairo_surface_backend_t cairo_win32_surface_backend = {
     NULL  /* snapshot */
 };
 
-/*
- * Without pthread, on win32 we need to initialize all the 'mutex'es
- * before use. It is guaranteed that DllMain will get called single
- * threaded before any other function.
- * Initializing more than finally needed should not matter much.
- */
-#if !defined(HAVE_PTHREAD_H) 
-
-CRITICAL_SECTION _cairo_scaled_font_map_mutex;
-#ifdef CAIRO_HAS_FT_FONT
-CRITICAL_SECTION _cairo_ft_unscaled_font_map_mutex;
-#endif
-CRITICAL_SECTION _cairo_font_face_mutex;
-
-static int _cairo_win32_initialized = 0;
-
-void
-_cairo_win32_initialize (void) {
-    if (_cairo_win32_initialized)
-	return;
-
-    /* every 'mutex' from CAIRO_MUTEX_DECALRE needs to be initialized here */
-    InitializeCriticalSection (&_cairo_scaled_font_map_mutex);
-#ifdef CAIRO_HAS_FT_FONT
-    InitializeCriticalSection (&_cairo_ft_unscaled_font_map_mutex);
-#endif
-    InitializeCriticalSection (&_cairo_font_face_mutex);
-
-    _cairo_win32_initialized = 1;
-}
-
-#if !defined(CAIRO_WIN32_STATIC_BUILD)
-
-/*
- * Avoid warning regarding missing prototype
- */
-BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
-	 DWORD     fdwReason,
-	 LPVOID    lpvReserved);
-
-BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
-	 DWORD     fdwReason,
-	 LPVOID    lpvReserved)
-{
-  switch (fdwReason)
-  {
-  case DLL_PROCESS_ATTACH:
-    _cairo_win32_initialize();
-    break;
-  case DLL_PROCESS_DETACH:
-    DeleteCriticalSection (&_cairo_scaled_font_map_mutex);
-#ifdef CAIRO_HAS_FT_FONT
-    DeleteCriticalSection (&_cairo_ft_unscaled_font_map_mutex);
-#endif
-    DeleteCriticalSection (&_cairo_font_face_mutex);
-    break;
-  }
-  return TRUE;
-}
-#endif
-#else
-/* Need a function definition here too since it's called outside of ifdefs */
-void
-_cairo_win32_initialize (void)
-{
-}
-#endif
-
 /* Notes:
  *
  * Win32 alpha-understanding functions
diff --git a/src/cairo-xlib-screen.c b/src/cairo-xlib-screen.c
index 2316fe1..29dd2fb 100644
--- a/src/cairo-xlib-screen.c
+++ b/src/cairo-xlib-screen.c
@@ -55,6 +55,7 @@
 #include <string.h>
 
 #include "cairo-xlib-private.h"
+#include "cairo-mutex-private.h"
 
 #include <fontconfig/fontconfig.h>
 
@@ -243,8 +244,6 @@ _cairo_xlib_init_screen_font_options (cairo_xlib_screen_info_t *info)
     cairo_font_options_set_subpixel_order (&info->font_options, subpixel_order);
 }
 
-CAIRO_MUTEX_DECLARE(_xlib_screen_mutex);
-
 static cairo_xlib_screen_info_t *_cairo_xlib_screen_list = NULL;
 
 /* XXX: From this function we should also run through and cleanup
diff --git a/src/cairoint.h b/src/cairoint.h
index e314152..6c81ff8 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -136,81 +136,38 @@ CAIRO_BEGIN_DECLS
 
 #if HAVE_PTHREAD_H
 # include <pthread.h>
-# define CAIRO_MUTEX_DECLARE(name) static pthread_mutex_t name = PTHREAD_MUTEX_INITIALIZER
-# define CAIRO_MUTEX_DECLARE_GLOBAL(name) pthread_mutex_t name = PTHREAD_MUTEX_INITIALIZER
-# define CAIRO_MUTEX_LOCK(name) pthread_mutex_lock (&name)
-# define CAIRO_MUTEX_UNLOCK(name) pthread_mutex_unlock (&name)
-typedef pthread_mutex_t cairo_mutex_t;
-#define CAIRO_MUTEX_INIT(mutex) do {				\
-    pthread_mutex_t tmp_mutex = PTHREAD_MUTEX_INITIALIZER;      \
-    memcpy (mutex, &tmp_mutex, sizeof (tmp_mutex));             \
-} while (0)
-# define CAIRO_MUTEX_FINI(mutex) pthread_mutex_destroy (mutex)
-# define CAIRO_MUTEX_NIL_INITIALIZER PTHREAD_MUTEX_INITIALIZER
-#endif
 
-#if !defined(CAIRO_MUTEX_DECLARE) && defined CAIRO_HAS_WIN32_SURFACE
-# define WIN32_LEAN_AND_MEAN
+  typedef pthread_mutex_t cairo_mutex_t;
+
+#elif defined CAIRO_HAS_WIN32_SURFACE
+
 /* We require Windows 2000 features. Although we don't use them here, things
  * should still work if this header file ends up being the one to include
  * windows.h into a source file, so: */
 # if !defined(WINVER) || (WINVER < 0x0500)
 #  define WINVER 0x0500
 # endif
+
 # if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)
 #  define _WIN32_WINNT 0x0500
 # endif
+
+# define WIN32_LEAN_AND_MEAN
 # include <windows.h>
-  /* the real initialization must take place in DllMain */
-# define CAIRO_MUTEX_DECLARE(name) extern CRITICAL_SECTION name;
-# define CAIRO_MUTEX_DECLARE_GLOBAL(name) extern LPCRITICAL_SECTION name;
-# define CAIRO_MUTEX_LOCK(name) EnterCriticalSection (&name)
-# define CAIRO_MUTEX_UNLOCK(name) LeaveCriticalSection (&name)
-typedef CRITICAL_SECTION cairo_mutex_t;
-# define CAIRO_MUTEX_INIT(mutex) InitializeCriticalSection (mutex)
-# define CAIRO_MUTEX_FINI(mutex) DeleteCriticalSection (mutex)
-# define CAIRO_MUTEX_NIL_INITIALIZER { NULL, 0, 0, NULL, NULL, 0 }
-#endif
 
-#if defined(__OS2__) && !defined(CAIRO_MUTEX_DECLARE)
+  typedef CRITICAL_SECTION cairo_mutex_t;
+
+#elif defined CAIRO_HAS_OS2_SURFACE
 # define INCL_BASE
 # define INCL_PM
 # include <os2.h>
 
-# define CAIRO_MUTEX_DECLARE(name) extern HMTX name
-# define CAIRO_MUTEX_DECLARE_GLOBAL(name) extern HMTX name
-# define CAIRO_MUTEX_LOCK(name) DosRequestMutexSem(name, SEM_INDEFINITE_WAIT)
-# define CAIRO_MUTEX_UNLOCK(name) DosReleaseMutexSem(name)
-typedef HMTX cairo_mutex_t;
-# define CAIRO_MUTEX_INIT(mutex) DosCreateMutexSem (NULL, mutex, 0L, FALSE)
-# define CAIRO_MUTEX_FINI(mutex) DosCloseMutexSem (*(mutex))
-# define CAIRO_MUTEX_NIL_INITIALIZER 0
-#endif
+  typedef HMTX cairo_mutex_t;
 
-#if !defined(CAIRO_MUTEX_DECLARE) && defined CAIRO_HAS_BEOS_SURFACE
-cairo_private void _cairo_beos_lock(void*);
-cairo_private void _cairo_beos_unlock(void*);
-  /* the real initialization takes place in a global constructor */
-# define CAIRO_MUTEX_DECLARE(name) extern void* name;
-# define CAIRO_MUTEX_DECLARE_GLOBAL(name) extern void* name;
-# define CAIRO_MUTEX_LOCK(name) _cairo_beos_lock (&name)
-# define CAIRO_MUTEX_UNLOCK(name) _cairo_beos_unlock (&name)
-# error "XXX: Someone who understands BeOS needs to add definitions for" \
-        "     cairo_mutex_t, CAIRO_MUTEX_INIT, and CAIRO_MUTEX_FINI," \
-        "     to cairoint.h"
-typedef ??? cairo_mutex_t;
-# define CAIRO_MUTEX_INIT(mutex) ???
-# define CAIRO_MUTEX_FINI(mutex) ???
-# define CAIRO_MUTEX_NIL_INITIALIZER {}
-#endif
+#elif defined CAIRO_HAS_BEOS_SURFACE
+
+  typedef void* cairo_mutex_t;
 
-#ifndef CAIRO_MUTEX_DECLARE
-# error "No mutex declarations. Cairo will not work with multiple threads." \
-	"(Remove this #error directive to acknowledge & accept this limitation)."
-# define CAIRO_MUTEX_DECLARE(name)
-# define CAIRO_MUTEX_DECLARE_GLOBAL(name)
-# define CAIRO_MUTEX_LOCK(name)
-# define CAIRO_MUTEX_UNLOCK(name)
 #endif
 
 #undef MIN
-- 
1.4.4.2

-------------- next part --------------
>From b730791ad1c9f666b7cec40052b5674187aea1c9 Mon Sep 17 00:00:00 2001
From: Mathias Hasselmann <mathias.hasselmann@gmx.de>
Date: Mon, 5 Mar 2007 19:49:19 +0100
Subject: [PATCH] [PATCH] Copyright cleanups and mutex finalization on OS/2

---
 src/cairo-mutex-list.h    |    3 +--
 src/cairo-mutex-private.h |    9 +++++++--
 src/cairo-mutex.c         |    2 +-
 src/cairo-os2-surface.c   |   25 +++----------------------
 4 files changed, 12 insertions(+), 27 deletions(-)

diff --git a/src/cairo-mutex-list.h b/src/cairo-mutex-list.h
index 38d305f..c624242 100644
--- a/src/cairo-mutex-list.h
+++ b/src/cairo-mutex-list.h
@@ -1,6 +1,6 @@
 /* cairo - a vector graphics library with display and print output
  *
- * Copyright ? 2007 the cairo graphics library project
+ * Copyright ? 2007 Mathias Hasselmann
  *
  * This library is free software; you can redistribute it and/or
  * modify it either under the terms of the GNU Lesser General Public
@@ -46,7 +46,6 @@ CAIRO_MUTEX_DECLARE (_xlib_screen_mutex);
 #endif
 
 #if CAIRO_HAS_OS2_SURFACE
-CAIRO_MUTEX_DECLARE (cairo_toy_font_face_hash_table_mutex);
 CAIRO_MUTEX_DECLARE (_global_image_glyph_cache_mutex);
 #endif
 
diff --git a/src/cairo-mutex-private.h b/src/cairo-mutex-private.h
index fdaeb8b..41d0049 100644
--- a/src/cairo-mutex-private.h
+++ b/src/cairo-mutex-private.h
@@ -2,7 +2,7 @@
  *
  * Copyright ? 2002 University of Southern California
  * Copyright ? 2005 Red Hat, Inc.
- * Copyright ? 2007 the cairo graphics library project
+ * Copyright ? 2007 Mathias Hasselmann
  *
  * This library is free software; you can redistribute it and/or
  * modify it either under the terms of the GNU Lesser General Public
@@ -67,7 +67,12 @@
 # define CAIRO_MUTEX_LOCK(name) DosRequestMutexSem(name, SEM_INDEFINITE_WAIT)
 # define CAIRO_MUTEX_UNLOCK(name) DosReleaseMutexSem(name)
 # define CAIRO_MUTEX_INIT(mutex) DosCreateMutexSem (NULL, mutex, 0L, FALSE)
-# define CAIRO_MUTEX_FINI(mutex) DosCloseMutexSem (*(mutex))
+# define CAIRO_MUTEX_FINI(mutex) do {				\
+    if (0 != (mutex)) {						\
+        DosCloseMutexSem (*(mutex));				\
+        (mutex) = 0;						\
+    }								\
+} while (0)
 # define CAIRO_MUTEX_NIL_INITIALIZER 0
 
 #elif defined CAIRO_HAS_BEOS_SURFACE
diff --git a/src/cairo-mutex.c b/src/cairo-mutex.c
index 8b9437e..48ec86b 100644
--- a/src/cairo-mutex.c
+++ b/src/cairo-mutex.c
@@ -1,6 +1,6 @@
 /* cairo - a vector graphics library with display and print output
  *
- * Copyright ? 2007 the cairo graphics library project
+ * Copyright ? 2007 Mathias Hasselmann
  *
  * This library is free software; you can redistribute it and/or
  * modify it either under the terms of the GNU Lesser General Public
diff --git a/src/cairo-os2-surface.c b/src/cairo-os2-surface.c
index 6ce77fc..baaef23 100644
--- a/src/cairo-os2-surface.c
+++ b/src/cairo-os2-surface.c
@@ -117,28 +117,9 @@ cairo_os2_fini (void)
     _cairo_ft_font_reset_static_data ();
 #endif
 
-    /* Destroy the mutex semaphores we've created! */
-    /* cairo-font.c: */
-    if (_cairo_scaled_font_map_mutex) {
-        DosCloseMutexSem (_cairo_scaled_font_map_mutex);
-        _cairo_scaled_font_map_mutex = 0;
-    }
-    if (_global_image_glyph_cache_mutex) {
-        DosCloseMutexSem (_global_image_glyph_cache_mutex);
-        _global_image_glyph_cache_mutex = 0;
-    }
-    if (_cairo_font_face_mutex) {
-        DosCloseMutexSem (_cairo_font_face_mutex);
-        _cairo_font_face_mutex = 0;
-    }
-
-#ifdef CAIRO_HAS_FT_FONT
-    /* cairo-ft-font.c: */
-    if (_cairo_ft_unscaled_font_map_mutex) {
-        DosCloseMutexSem (_cairo_ft_unscaled_font_map_mutex);
-        _cairo_ft_unscaled_font_map_mutex = 0;
-    }
-#endif
+#define CAIRO_MUTEX_DECLARE(name) CAIRO_MUTEX_FINI(name)
+#include "cairo-mutext-list.h"
+#undef CAIRO_MUTEX_DECLARE
 
     /* Uninitialize FontConfig */
     FcFini ();
-- 
1.4.4.2

From cworth at cworth.org  Fri Mar  9 14:20:44 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar  9 14:21:22 2007
Subject: [cairo] Loading a SVG file and displaying it on SDL
In-Reply-To: <20070309111525.dca7f777.andre.nho@gmail.com>
References: <20070309111525.dca7f777.andre.nho@gmail.com>
Message-ID: <87k5xq9hz7.wl%cworth@cworth.org>

On Fri, 9 Mar 2007 11:15:25 -0300, Andr? Wagner wrote:
> 	cairo_scale(cr, width, height);
...
> 	h = rsvg_handle_new_from_file("closedbox.svg", &e);

Is your SVG file designed to cope with that kind of scale? That is,
is it designed such that it only has coordinates from 0.0 to 1.0 ? If
not, you might be simply scaling the image entirely off the
surface. So maybe try again without the cairo_scale in there and see
what happens, (which should draw the SVG file such that one unit in
the SVG file corresponds to one pixel).

> What am I doing wrong? It displays a white window, so I know
> (suppose) the transference from cairo to SDL is working.

Well, white's not all that reliable of a color. Maybe try something
like:

	cairo_set_source_rgb (cr, 0.0, 1.0, 1.0); /* cyan */

instead?

> I'm using Win32, BTW (I hope this isn't the stupid mistke ;-)

I won't comment on whether it's a mistake or not, but cairo is
supposed to function on that platform.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070309/681e2cec/attachment.pgp
From brian.ewins at gmail.com  Fri Mar  9 16:36:28 2007
From: brian.ewins at gmail.com (Baz)
Date: Fri Mar  9 16:36:33 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <87slcf9gk2.wl%cworth@cworth.org>
References: <45D6DFF1.4080505@gentoo.org>
	<2faad3050703081719k12c612e3qcc3863887ccb85c4@mail.gmail.com>
	<2faad3050703081939i36cebe7cw6b6da9d850b57ccb@mail.gmail.com>
	<87slcf9gk2.wl%cworth@cworth.org>
Message-ID: <2faad3050703091636w760ae971pa851b9cb323424c6@mail.gmail.com>

On 09/03/07, Carl Worth <cworth@cworth.org> wrote:
> That would be a bug in perf-diff.

Thanks Carl, that had me scratching my head...

Speedups down to 1.25x, OSX 10.4 PPC:

Speedups
========
image-rgba      paint_solid_rgba_over-256    1.25 3.36% ->   0.45
9.51%:  2.80x speedup
image-rgb       paint_solid_rgba_over-256    1.22 2.01% ->   0.45
4.79%:  2.74x speedup
image-rgb       paint_solid_rgba_over-512    6.52 0.65% ->   3.34
2.02%:  1.95x speedup
image-rgba      paint_solid_rgba_over-512    6.50 1.22% ->   3.35
1.53%:  1.94x speedup
image-rgba      fill_similar_rgb_over-256    2.42 1.84% ->   1.87
2.71%:  1.30x speedup
image-rgb      fill_similar_rgba_over-256    2.34 2.82% ->   1.82
5.47%:  1.29x speedup
image-rgb        fill_image_rgba_over-256    2.33 2.61% ->   1.82
4.33%:  1.28x speedup
image-rgb         fill_image_rgb_over-256    2.41 3.48% ->   1.89
6.44%:  1.28x speedup
image-rgba    fill_similar_rgb_source-256    2.87 1.51% ->   2.26
1.47%:  1.27x speedup
image-rgba       fill_image_rgba_over-256    2.29 1.97% ->   1.81
2.07%:  1.27x speedup
image-rgba     fill_image_rgba_source-256    2.78 1.45% ->   2.19
1.42%:  1.27x speedup
image-rgba     fill_similar_rgba_over-256    2.29 2.17% ->   1.81
2.83%:  1.27x speedup
image-rgba        fill_image_rgb_over-256    2.39 2.09% ->   1.89
2.69%:  1.27x speedup
image-rgba   fill_similar_rgba_source-256    2.78 1.45% ->   2.20
1.73%:  1.27x speedup
image-rgb       fill_similar_rgb_over-256    2.39 3.24% ->   1.89
3.94%:  1.26x speedup
image-rgba      fill_image_rgb_source-256    2.86 1.59% ->   2.27
1.91%:  1.26x speedup
image-rgb      paint_linear_rgba_over-256    3.95 1.79% ->   3.14
0.67%:  1.26x speedup
image-rgb       fill_image_rgb_source-256    3.05 6.15% ->   2.43
4.49%:  1.26x speedup

Top stuff. There are speedups in the 10% range for many, many more
tests. Only a small number of tests slowed down:

Slowdowns (down to 1.01x):
Slowdowns
=========
image-rgba    paint_image_rgba_source-256    0.24 10.84% ->   0.28
18.12%:  1.18x slowdown
image-rgba  paint_similar_rgba_source-256    0.24 4.80% ->   0.26
5.74%:  1.06x slowdown
image-rgba     paint_similar_rgb_over-256    0.58 9.66% ->   0.60
17.04%:  1.03x slowdown
image-rgb   paint_similar_rgba_source-256    0.33 5.44% ->   0.34
7.00%:  1.03x slowdown
image-rgba       paint_image_rgb_over-256    0.58 13.48% ->   0.59
13.47%:  1.02x slowdown
image-rgba      paint_image_rgba_over-256    1.55 5.00% ->   1.58
9.20%:  1.02x slowdown
image-rgba     paint_image_rgb_source-256    0.57 12.74% ->   0.59
11.45%:  1.02x slowdown
image-rgb     paint_image_rgba_source-256    0.34 7.24% ->   0.35
10.38%:  1.02x slowdown
image-rgb         fill_solid_rgb_over-256    1.29 4.68% ->   1.31
3.04%:  1.02x slowdown

That top slowdown looks nasty, but the stdev is pretty high, and it
didn't show up that high on the first run (the second run posted a
large number and it seems to have stuck up there). Overall this looks
great, good work Luca.

So Luca, there's only a few issues remaining with the patch:
- theres a '$cc' test that should be '$CC' in configure.in (fixed)
- I should really test this on PPC Linux and OS X 10.3 to be sure
build glitches have been resolved, which I'll try to do this weekend.
- theres some debug prints, // comments, and trailing space in the
patch that should be tidied up. I'm happy to sort this out.

You mentioned that you have more (the pict ops). Do you want to
produce an updated patch, or go with this one for now, and add them
later?

Cheers,
Baz
From rbrown at gentoo.org  Sat Mar 10 02:53:18 2007
From: rbrown at gentoo.org (Richard Brown)
Date: Sat Mar 10 03:31:47 2007
Subject: [cairo] rcairo-1.4.0 dependency on pkg-config.rb
Message-ID: <45F28E1E.9040004@gentoo.org>

Hi, extconf.rb in rcairo requires a pkg-config.rb, is this supposed to
be included in the tarball, or should I grab it from another package,
e.g. ruby-glib2.

Regards,

-- 
Richard Brown
From kou at cozmixng.org  Sat Mar 10 03:58:23 2007
From: kou at cozmixng.org (Kouhei Sutou)
Date: Sat Mar 10 03:58:32 2007
Subject: [cairo] rcairo-1.4.0 dependency on pkg-config.rb
In-Reply-To: <45F28E1E.9040004@gentoo.org>
References: <45F28E1E.9040004@gentoo.org>
Message-ID: <20070310.205823.190626032.kou@cozmixng.org>

Hi,

> Hi, extconf.rb in rcairo requires a pkg-config.rb, is this supposed to
> be included in the tarball, or should I grab it from another package,
> e.g. ruby-glib2.

I'm sorry. This is my packaging miss. I released 1.4.1 that
includes pkg-config.rb.
  http://cairographics.org/releases/rcairo-1.4.1.tar.gz

Thanks for reporting.


Regards,
--
kou
From rbrown at gentoo.org  Sat Mar 10 07:05:07 2007
From: rbrown at gentoo.org (Richard Brown)
Date: Sat Mar 10 07:05:16 2007
Subject: [cairo] rcairo-1.4.0 dependency on pkg-config.rb
In-Reply-To: <20070310.205823.190626032.kou@cozmixng.org>
References: <45F28E1E.9040004@gentoo.org>
	<20070310.205823.190626032.kou@cozmixng.org>
Message-ID: <45F2C923.4060905@gentoo.org>

Kouhei Sutou wrote:
> I'm sorry. This is my packaging miss. I released 1.4.1 that
> includes pkg-config.rb.
>   http://cairographics.org/releases/rcairo-1.4.1.tar.gz
> 
> Thanks for reporting.

No problem, thanks for the quick fix.

Regards,

--
Richard Brown
From origin.of at gmail.com  Sat Mar 10 12:56:51 2007
From: origin.of at gmail.com (Manuel)
Date: Sat Mar 10 13:09:26 2007
Subject: [cairo] Alpha channel  [pycairo]
Message-ID: <loom.20070310T215235-143@post.gmane.org>

hi all, I've this "program" :

# main.py
# -*- coding: UTF-8 -*-

import pygtk
pygtk.require('2.0')
import gtk, gobject, cairo

# Create a GTK+ widget on which we will draw using Cairo
class Screen(gtk.DrawingArea):

    # Draw in response to an expose-event
    __gsignals__ = { "expose-event": "override" }

    # Handle the expose-event by drawing
    def do_expose_event(self, event):
        cr = self.window.cairo_create()
        self.draw(cr, *self.window.get_size())

    def draw(self, cr, width, height):
        cr.set_tolerance(0.1)
        cr.set_source_rgba(0.0, 0.0, 0.0, 0.5)
        cr.set_operator(cairo.OPERATOR_SOURCE)
        cr.paint()
    
# GTK mumbo-jumbo to show the widget in a window and quit when it's closed
def run(Widget):
    window = gtk.Window(type=gtk.WINDOW_TOPLEVEL)
    window.set_decorated(False)
    window.set_resizable(False)
    window.connect("delete-event", gtk.main_quit)
    widget = Widget()
    
    screen = widget.get_screen()
    color = screen.get_rgba_colormap()
    widget.set_colormap(color)
    
    widget.set_app_paintable(True)
    widget.set_size_request(500, 500)
    widget.show()
    window.add(widget)
    window.present()
    gtk.main()

if __name__ == "__main__":
    run(Screen)

try execute it, the alpha channel doesn't work...
The windows isn't semi-transparent...
cr.set_source_rgba(0.0, 0.0, 0.0, 0.5) doesn't work ??

From whydoubt at yahoo.com  Sat Mar 10 21:07:18 2007
From: whydoubt at yahoo.com (Jeff Smith)
Date: Sat Mar 10 21:07:22 2007
Subject: [cairo] slow path annotations
Message-ID: <904600.90640.qm@web54314.mail.yahoo.com>

> +#include <signal.h>
> +static inline void cairo_slow_path(void)
> +{
> +    raise(5);
> +}
> +

Any reason not to use raise(SIGTRAP)?

 -- Jeff Smith





 
____________________________________________________________________________________
Looking for earth-friendly autos? 
Browse Top Cars by "Green Rating" at Yahoo! Autos' Green Center.
http://autos.yahoo.com/green_center/
From cworth at cworth.org  Sat Mar 10 21:56:32 2007
From: cworth at cworth.org (Carl Worth)
Date: Sat Mar 10 21:56:54 2007
Subject: [cairo] cairo_image_surface_create_from_???
In-Reply-To: <20070309075024.88096.qmail@web53610.mail.yahoo.com>
References: <20070309075024.88096.qmail@web53610.mail.yahoo.com>
Message-ID: <878xe49vcf.wl%cworth@cworth.org>

On Thu, 8 Mar 2007 23:50:24 -0800 (PST), Kevin Brooks wrote:
> Are we going to have other image supports in the
> future like:
>
> cairo_surface_t* cairo_image_surface_create_from_jpg
> cairo_surface_t* cairo_image_surface_create_from_bmp
> cairo_surface_t* cairo_image_surface_create_from_tiff

It's not very likely.

We don't want to let the number of dependencies that cairo has grow
arbitrarily.

And cairo does already allow you to create an image surface from a
buffer of data with the cairo_image_surface_create_for_data
function. So it is already possible to load an image through whatever
means you have available and then create an image surface from
it---all with code built on top of the existing cairo interface.

Some people have even suggested the possibility of a cairo-friendly
interface for creating such image surfaces, (perhaps by building on
top of an existing full-functioned image library whose name I don't
recall now).

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070310/e1b15b04/attachment.pgp
From jeff at infidigm.net  Sat Mar 10 22:31:42 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Sat Mar 10 22:30:08 2007
Subject: [cairo] slow path annotations
In-Reply-To: <904600.90640.qm@web54314.mail.yahoo.com>
References: <904600.90640.qm@web54314.mail.yahoo.com>
Message-ID: <20070311063142.GA28626@infidigm.net>

None. The only reason I use 5 is out of habit.

-Jeff

On Sat, Mar 10, 2007 at 09:07:18PM -0800, Jeff Smith wrote:
> > +#include <signal.h>
> > +static inline void cairo_slow_path(void)
> > +{
> > +    raise(5);
> > +}
> > +
> 
> Any reason not to use raise(SIGTRAP)?
> 
>  -- Jeff Smith
> 
> 
> 
> 
> 
>  
> ____________________________________________________________________________________
> Looking for earth-friendly autos? 
> Browse Top Cars by "Green Rating" at Yahoo! Autos' Green Center.
> http://autos.yahoo.com/green_center/
From kalle.vahlman at gmail.com  Sun Mar 11 17:47:28 2007
From: kalle.vahlman at gmail.com (Kalle Vahlman)
Date: Sun Mar 11 18:24:48 2007
Subject: [cairo] Alpha channel [pycairo]
In-Reply-To: <loom.20070310T215235-143@post.gmane.org>
References: <loom.20070310T215235-143@post.gmane.org>
Message-ID: <177e83dd0703110847g1f04c5e2q7f068ec7e635c427@mail.gmail.com>

2007/3/10, Manuel <origin.of@gmail.com>:
> hi all, I've this "program" :
[snip]
> try execute it, the alpha channel doesn't work...
> The windows isn't semi-transparent...
> cr.set_source_rgba(0.0, 0.0, 0.0, 0.5) doesn't work ??

That's because window transparency doesn't quite work that way.

On X, windows traditionally are always fully opaque. One needs the
help of the Composite extension to achieve transparency, which pretty
much is out of scope for Cairo IMO.

I can't really comment on other systems though.

-- 
Kalle Vahlman, zuh@iki.fi
Powered by http://movial.fi
Interesting stuff at http://syslog.movial.fi
From chris at chris-wilson.co.uk  Sun Mar 11 16:30:04 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Sun Mar 11 16:30:10 2007
Subject: [cairo] A couple of valgrind warning fixes
Message-ID: <20070311233004.GA8145@inspired.chris-wilson.co.uk>

valgrind issued a warning for the gcc-emitted memcpy for the struct
assignment within cairo-suface.c - I'm sure this has been discussed and
worked around on list before. Perhaps I'm thinking of the matrix copies?
Anyway the first patch, checks that the src!=dst before performing the
copy.

The second patch addresses an off-by-one within the convolution code in
lpyramid.c. The code subtracts one too many from the reflected index and
triggers a valgrind warning when it accesses elements before the start
of the array.

--
Chris Wilson.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Avoid-the-struct-copy-when-source-and-destination-ar.patch
Type: text/x-diff
Size: 1638 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070311/2976a839/0001-Avoid-the-struct-copy-when-source-and-destination-ar.bin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0002-Correct-an-off-by-one-in-the-reflection-of-the-convo.patch
Type: text/x-diff
Size: 1230 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070311/2976a839/0002-Correct-an-off-by-one-in-the-reflection-of-the-convo.bin
From mathias.hasselmann at gmx.de  Sun Mar 11 16:44:07 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Sun Mar 11 16:44:23 2007
Subject: [cairo] Cairo and layered application
In-Reply-To: <1173476493.21219.2.camel@dali>
References: <20070227201153.02773785@portvle>
	<a65ae5c90702281700w40f4d55al6f015218a0756d49@mail.gmail.com>
	<20070302123407.08a060fa@ecoup>
	<a65ae5c90703022258j2b5dd924u236831d2bb5220df@mail.gmail.com>
	<45E91E83.8050608@mit.edu> <1172938325.3091.19.camel@behdad>
	<45EDD273.6030305@mit.edu>  <1173219393.11414.34.camel@behdad>
	<1173419417.5844.1.camel@dali>  <1173476493.21219.2.camel@dali>
Message-ID: <1173656648.18956.3.camel@dali>

Last version of my patch still caused some segmentation faults. 
Attached patch set lets "make check" and "make perf" run without any
crashes again.


-------------- next part --------------
>From 93115b53e151eaad0e476a23864fc3301cf0cf86 Mon Sep 17 00:00:00 2001
From: (null) <(null)>
Date: Fri, 9 Mar 2007 22:37:36 +0100
Subject: [PATCH] Avoid malloc in _cairo_pixman_region_create_simple.

---
 pixman/src/pixman.h          |   12 ++-
 pixman/src/pixregion.c       |   18 +--
 pixman/src/pixregionint.h    |    7 +-
 src/cairo-clip-private.h     |    3 +-
 src/cairo-clip.c             |  125 ++++++++++-----------
 src/cairo-region.c           |   34 +++---
 src/cairo-surface-fallback.c |  255 ++++++++++++++++++++++--------------------
 src/cairo-surface.c          |   56 ++++++----
 src/cairo-traps.c            |   18 ++--
 src/cairoint.h               |   11 +-
 10 files changed, 279 insertions(+), 260 deletions(-)

diff --git a/pixman/src/pixman.h b/pixman/src/pixman.h
index 7f0ef32..8428543 100644
--- a/pixman/src/pixman.h
+++ b/pixman/src/pixman.h
@@ -113,12 +113,17 @@ extern "C" {
 
 /* pixregion.h */
 
-typedef struct pixman_region16 pixman_region16_t;
+typedef struct pixman_region16_data pixman_region16_data_t;
 
 typedef struct pixman_box16 {
     short x1, y1, x2, y2;
 } pixman_box16_t;
 
+typedef struct pixman_region16 {
+    pixman_box16_t          extents;
+    pixman_region16_data_t  *data;
+} pixman_region16_t;
+
 typedef enum {
     PIXMAN_REGION_STATUS_FAILURE,
     PIXMAN_REGION_STATUS_SUCCESS
@@ -133,6 +138,11 @@ pixman_private pixman_region16_t *
 pixman_region_create_simple (pixman_box16_t *extents);
 
 pixman_private void
+pixman_region_init(pixman_region16_t *region, pixman_box16_t *extents);
+pixman_private void
+pixman_region_uninit (pixman_region16_t *region);
+
+pixman_private void
 pixman_region_destroy (pixman_region16_t *region);
 
 /* manipulation */
diff --git a/pixman/src/pixregion.c b/pixman/src/pixregion.c
index 0404dff..f710294 100644
--- a/pixman/src/pixregion.c
+++ b/pixman/src/pixregion.c
@@ -82,12 +82,6 @@ static pixman_region16_t   pixman_brokenregion = { { 0, 0, 0, 0 }, &pixman_broke
 static pixman_region_status_t
 pixman_break (pixman_region16_t *pReg);
 
-static void
-pixman_init (pixman_region16_t *region, pixman_box16_t *rect);
-
-static void
-pixman_uninit (pixman_region16_t *region);
-
 /*
  * The functions in this file implement the Region abstraction used extensively
  * throughout the X11 sample server. A Region is simply a set of disjoint
@@ -318,7 +312,7 @@ pixman_region_create_simple (pixman_box16_t *extents)
     if (region == NULL)
 	return &pixman_brokenregion;
 
-    pixman_init (region, extents);
+    pixman_region_init (region, extents);
 
     return region;
 }
@@ -328,8 +322,8 @@ pixman_region_create_simple (pixman_box16_t *extents)
  *     Outer region rect is statically allocated.
  *****************************************************************/
 
-static void
-pixman_init(pixman_region16_t *region, pixman_box16_t *extents)
+void
+pixman_region_init(pixman_region16_t *region, pixman_box16_t *extents)
 {
     if (extents)
     {
@@ -343,8 +337,8 @@ pixman_init(pixman_region16_t *region, pixman_box16_t *extents)
     }
 }
 
-static void
-pixman_uninit (pixman_region16_t *region)
+void
+pixman_region_uninit (pixman_region16_t *region)
 {
     good (region);
     freeData (region);
@@ -353,7 +347,7 @@ pixman_uninit (pixman_region16_t *region)
 void
 pixman_region_destroy (pixman_region16_t *region)
 {
-    pixman_uninit (region);
+    pixman_region_uninit (region);
 
     if (region != &pixman_brokenregion)
 	free (region);
diff --git a/pixman/src/pixregionint.h b/pixman/src/pixregionint.h
index b5b53fd..385a7f2 100644
--- a/pixman/src/pixregionint.h
+++ b/pixman/src/pixregionint.h
@@ -48,16 +48,11 @@ SOFTWARE.
 
 #include "pixman.h"
 
-typedef struct pixman_region16_data {
+struct pixman_region16_data {
     long		size;
     long		numRects;
     /* XXX: And why, exactly, do we have this bogus struct definition? */
 /*  pixman_box16_t	rects[size];   in memory but not explicitly declared */
-} pixman_region16_data_t;
-
-struct pixman_region16 {
-    pixman_box16_t	extents;
-    pixman_region16_data_t	*data;
 };
 
 typedef struct pixman_region16_point {
diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index 3c4ff0d..381c003 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -72,7 +72,8 @@ struct _cairo_clip {
     /*
      * A clip region that can be placed in the surface
      */
-    pixman_region16_t *region;
+    pixman_region16_t region;
+    cairo_bool_t has_region;
     /*
      * If the surface supports path clipping, we store the list of
      * clipping paths that has been set here as a linked list.
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index 605589b..46179d9 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -58,7 +58,7 @@ _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target)
 
     clip->serial = 0;
 
-    clip->region = NULL;
+    clip->has_region = FALSE;
 
     clip->path = NULL;
 }
@@ -71,9 +71,10 @@ _cairo_clip_fini (cairo_clip_t *clip)
 
     clip->serial = 0;
 
-    if (clip->region)
-	pixman_region_destroy (clip->region);
-    clip->region = NULL;
+    if (clip->has_region) {
+	pixman_region_uninit (&clip->region);
+    	clip->has_region = FALSE;
+    }
 
     _cairo_clip_path_destroy (clip->path);
     clip->path = NULL;
@@ -89,11 +90,11 @@ _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 
     clip->serial = other->serial;
 
-    if (other->region == NULL) {
-	clip->region = other->region;
+    if (other->has_region) {
+        pixman_region_copy (&clip->region, &other->region);
+        clip->has_region = TRUE;
     } else {
-	clip->region = pixman_region_create ();
-	pixman_region_copy (clip->region, other->region);
+        clip->has_region = FALSE;
     }
 
     clip->path = _cairo_clip_path_reference (other->path);
@@ -108,9 +109,10 @@ _cairo_clip_reset (cairo_clip_t *clip)
 
     clip->serial = 0;
 
-    if (clip->region)
-	pixman_region_destroy (clip->region);
-    clip->region = NULL;
+    if (clip->has_region) {
+	pixman_region_uninit (&clip->region);
+        clip->has_region = FALSE;
+    }
 
     _cairo_clip_path_destroy (clip->path);
     clip->path = NULL;
@@ -167,27 +169,25 @@ _cairo_clip_intersect_to_rectangle (cairo_clip_t            *clip,
             return status;
     }
 
-    if (clip->region) {
-	pixman_region16_t *intersection;
+    if (clip->has_region) {
 	cairo_status_t status = CAIRO_STATUS_SUCCESS;
-	pixman_region_status_t pixman_status;
+	pixman_region16_t intersection;
 
-	intersection = _cairo_region_create_from_rectangle (rectangle);
-	if (intersection == NULL)
+	if (_cairo_region_init_from_rectangle (&intersection, rectangle))
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	pixman_status = pixman_region_intersect (intersection,
-					  clip->region,
-					  intersection);
-	if (pixman_status == PIXMAN_REGION_STATUS_SUCCESS)
-	    _cairo_region_extents_rectangle (intersection, rectangle);
-	else
+	if (PIXMAN_REGION_STATUS_SUCCESS !=
+            pixman_region_intersect (&intersection, &clip->region,
+                                     &intersection)) {
 	    status = CAIRO_STATUS_NO_MEMORY;
+	} else {
+            _cairo_region_extents_rectangle (&intersection, rectangle);
+        }
 
-	pixman_region_destroy (intersection);
+        pixman_region_uninit (&intersection);
 
-	if (status)
-	    return status;
+        if (status)
+            return status;
     }
 
     if (clip->surface)
@@ -207,28 +207,24 @@ _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 	/* Intersect clip path into region. */
     }
 
-    if (clip->region)
-	pixman_region_intersect (region, clip->region, region);
+    if (clip->has_region)
+	pixman_region_intersect (region, &clip->region, region);
 
     if (clip->surface) {
-	pixman_region16_t *clip_rect;
-	pixman_region_status_t pixman_status;
 	cairo_status_t status = CAIRO_STATUS_SUCCESS;
+	pixman_region16_t clip_rect;
 
-	clip_rect = _cairo_region_create_from_rectangle (&clip->surface_rect);
-	if (clip_rect == NULL)
+	if (_cairo_region_init_from_rectangle (&clip_rect, &clip->surface_rect))
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	pixman_status = pixman_region_intersect (region,
-						 clip_rect,
-						 region);
-	if (pixman_status != PIXMAN_REGION_STATUS_SUCCESS)
+        if (PIXMAN_REGION_STATUS_SUCCESS != 
+            pixman_region_intersect (region, &clip_rect, region))
 	    status = CAIRO_STATUS_NO_MEMORY;
 
-	pixman_region_destroy (clip_rect);
+        pixman_region_uninit (&clip_rect);
 
-	if (status)
-	    return status;
+        if (status)
+            return status;
     }
 
     return CAIRO_STATUS_SUCCESS;
@@ -326,42 +322,43 @@ _cairo_clip_path_destroy (cairo_clip_path_t *clip_path)
     free (clip_path);
 }
 
-static cairo_status_t
+static cairo_int_status_t
 _cairo_clip_intersect_region (cairo_clip_t    *clip,
 			      cairo_traps_t   *traps,
 			      cairo_surface_t *target)
 {
-    pixman_region16_t *region;
-    cairo_status_t status;
+    pixman_region16_t region;
+    cairo_int_status_t status;
 
     if (clip->mode != CAIRO_CLIP_MODE_REGION)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     status = _cairo_traps_extract_region (traps, &region);
+
     if (status)
 	return status;
 
-    if (region == NULL)
-	return CAIRO_INT_STATUS_UNSUPPORTED;
-
     status = CAIRO_STATUS_SUCCESS;
-    if (clip->region == NULL) {
-	clip->region = region;
+
+    if (!clip->has_region) {
+        pixman_region_copy (&clip->region, &region);
+        clip->has_region = TRUE;
     } else {
-	pixman_region16_t *intersection = pixman_region_create();
+	pixman_region16_t intersection;
+        pixman_region_init (&intersection, NULL);
+
+	if (PIXMAN_REGION_STATUS_SUCCESS == 
+            pixman_region_intersect (&intersection, &clip->region, &region)) {
+            pixman_region_copy (&clip->region, &intersection);
+        } else {
+            status = CAIRO_STATUS_NO_MEMORY;
+        }
 
-	if (pixman_region_intersect (intersection,
-				     clip->region, region)
-	    == PIXMAN_REGION_STATUS_SUCCESS) {
-	    pixman_region_destroy (clip->region);
-	    clip->region = intersection;
-	} else {
-	    status = CAIRO_STATUS_NO_MEMORY;
-	}
-	pixman_region_destroy (region);
+        pixman_region_uninit (&intersection);
     }
 
     clip->serial = _cairo_surface_allocate_clip_serial (target);
+    pixman_region_uninit (&region);
 
     return status;
 }
@@ -506,8 +503,8 @@ _cairo_clip_translate (cairo_clip_t  *clip,
                        cairo_fixed_t  tx,
                        cairo_fixed_t  ty)
 {
-    if (clip->region) {
-        pixman_region_translate (clip->region,
+    if (clip->has_region) {
+        pixman_region_translate (&clip->region,
                                  _cairo_fixed_integer_part (tx),
                                  _cairo_fixed_integer_part (ty));
     }
@@ -557,9 +554,9 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
         /* We should reapply the original clip path in this case, and let
          * whatever the right handling is happen */
     } else {
-        if (other->region) {
-            clip->region = pixman_region_create ();
-            pixman_region_copy (clip->region, other->region);
+        if (other->has_region) {
+            pixman_region_copy (&clip->region, &other->region);
+            clip->has_region = TRUE;
         }
 
         if (other->surface) {
@@ -610,16 +607,16 @@ _cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate)
     if (clip->path || clip->surface)
         return (cairo_rectangle_list_t*) &_cairo_rectangles_not_representable;
 
-    n_boxes = clip->region ? pixman_region_num_rects (clip->region) : 1;
+    n_boxes = clip->has_region ? pixman_region_num_rects (&clip->region) : 1;
     rectangles = malloc (sizeof (cairo_rectangle_t)*n_boxes);
     if (rectangles == NULL)
         return (cairo_rectangle_list_t*) &_cairo_rectangles_nil;
 
-    if (clip->region) {
+    if (clip->has_region) {
         pixman_box16_t *boxes;
         int i;
         
-        boxes = pixman_region_rects (clip->region);
+        boxes = pixman_region_rects (&clip->region);
         for (i = 0; i < n_boxes; ++i) {
             if (!_cairo_clip_rect_to_user(gstate, boxes[i].x1, boxes[i].y1,
                                           boxes[i].x2 - boxes[i].x1,
diff --git a/src/cairo-region.c b/src/cairo-region.c
index 057f9fe..883e1fc 100644
--- a/src/cairo-region.c
+++ b/src/cairo-region.c
@@ -36,30 +36,28 @@
 #include <cairoint.h>
 
 /**
- * _cairo_region_create_from_rectangle:
+ * _cairo_region_init_from_rectangle:
+ * @region: a #pixman_region16_t
  * @rect: a #cairo_rectangle_int16_t
  *
- * Creates a region with extents initialized from the given
- * rectangle.
+ * Initializes a region with extents from the given rectangle.
  *
- * Return value: a newly created #pixman_region16_t or %NULL if
- *    memory couldn't a allocated.
+ * Return value: #CAIRO_STATUS_SUCCESS on success, or
+ * #CAIRO_STATUS_NO_MEMORY when pixman fails to initialize
+ * the region.
  **/
-pixman_region16_t *
-_cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect)
+cairo_status_t
+_cairo_region_init_from_rectangle (pixman_region16_t       *region,
+                                   cairo_rectangle_int16_t *rect)
 {
-    /* We can't use pixman_region_create_simple(), because it doesn't
-     * have an error return
-     */
-    pixman_region16_t *region = pixman_region_create ();
-    if (pixman_region_union_rect (region, region,
-				  rect->x, rect->y,
-				  rect->width, rect->height) != PIXMAN_REGION_STATUS_SUCCESS) {
-	pixman_region_destroy (region);
-	return NULL;
-    }
+    pixman_region_init (region, NULL);
+
+    if (PIXMAN_REGION_STATUS_SUCCESS == pixman_region_union_rect (
+        region, region, rect->x, rect->y, rect->width, rect->height))
+        return CAIRO_STATUS_SUCCESS;
 
-    return region;
+    pixman_region_uninit (region);
+    return CAIRO_STATUS_NO_MEMORY;
 }
 
 /**
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..24c9115 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -511,145 +511,158 @@ _clip_and_composite_trapezoids (cairo_pattern_t *src,
 				cairo_antialias_t antialias)
 {
     cairo_status_t status;
-    pixman_region16_t *trap_region = NULL;
-    pixman_region16_t *clear_region = NULL;
+    pixman_region16_t trap_region;
+    pixman_region16_t clear_region;
+    cairo_bool_t has_trap_region = FALSE;
+    cairo_bool_t has_clear_region = FALSE;
     cairo_rectangle_int16_t extents;
     cairo_composite_traps_info_t traps_info;
 
     if (traps->num_traps == 0)
-	return CAIRO_STATUS_SUCCESS;
+        return CAIRO_STATUS_SUCCESS;
 
     status = _cairo_surface_get_extents (dst, &extents);
-    if (status)
-	return status;
 
-    status = _cairo_traps_extract_region (traps, &trap_region);
     if (status)
-	return status;
+        return status;
 
-    if (_cairo_operator_bounded_by_mask (op))
-    {
-	cairo_rectangle_int16_t trap_extents;
-	if (trap_region) {
-	    status = _cairo_clip_intersect_to_region (clip, trap_region);
-	    if (status)
-		goto out;
-
-	    _cairo_region_extents_rectangle (trap_region, &trap_extents);
-	} else {
-	    cairo_box_t trap_box;
-	    _cairo_traps_extents (traps, &trap_box);
-	    _cairo_box_round_to_rectangle (&trap_box, &trap_extents);
-	}
+    status = _cairo_traps_extract_region (traps, &trap_region);
 
-	_cairo_rectangle_intersect (&extents, &trap_extents);
-	status = _cairo_clip_intersect_to_rectangle (clip, &extents);
-	if (status)
-	    goto out;
-    }
-    else
-    {
-	cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
-
-	if (trap_region && !clip_surface) {
-	    /* If we optimize drawing with an unbounded operator to
-	     * _cairo_surface_fill_rectangles() or to drawing with a
-	     * clip region, then we have an additional region to clear.
-	     */
-	    clear_region = _cairo_region_create_from_rectangle (&extents);
-	    if (clear_region == NULL)
-		return CAIRO_STATUS_NO_MEMORY;
-
-	    status = _cairo_clip_intersect_to_region (clip, clear_region);
-	    if (status)
-		return status;
-
-	    _cairo_region_extents_rectangle (clear_region,  &extents);
-
-	    if (pixman_region_subtract (clear_region, clear_region, trap_region) != PIXMAN_REGION_STATUS_SUCCESS)
-		return CAIRO_STATUS_NO_MEMORY;
-
-	    if (!pixman_region_not_empty (clear_region)) {
-		pixman_region_destroy (clear_region);
-		clear_region = NULL;
-	    }
-	} else {
-	    status = _cairo_clip_intersect_to_rectangle (clip, &extents);
-	    if (status)
-		return status;
-	}
+    if (CAIRO_INT_STATUS_UNSUPPORTED == status) {
+        has_trap_region = FALSE;
+    } else if (status) {
+        return status;
+    } else {
+        has_trap_region = TRUE;
     }
 
-    if (status)
-	goto out;
-
-    if (trap_region)
-    {
-	cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
-
-	if ((src->type == CAIRO_PATTERN_TYPE_SOLID || op == CAIRO_OPERATOR_CLEAR) &&
-	    !clip_surface)
-	{
-	    const cairo_color_t *color;
-
-	    if (op == CAIRO_OPERATOR_CLEAR)
-		color = CAIRO_COLOR_TRANSPARENT;
-	    else
-		color = &((cairo_solid_pattern_t *)src)->color;
-
-	    /* Solid rectangles special case */
-	    status = _cairo_surface_fill_region (dst, op, color, trap_region);
-	    if (!status && clear_region)
-		status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
-						     CAIRO_COLOR_TRANSPARENT,
-						     clear_region);
-
-	    goto out;
-	}
-
-	if ((_cairo_operator_bounded_by_mask (op) && op != CAIRO_OPERATOR_SOURCE) ||
-	    !clip_surface)
-	{
-	    /* For a simple rectangle, we can just use composite(), for more
-	     * rectangles, we have to set a clip region. The cost of rasterizing
-	     * trapezoids is pretty high for most backends currently, so it's
-	     * worthwhile even if a region is needed.
-	     *
-	     * If we have a clip surface, we set it as the mask; this only works
-	     * for bounded operators other than SOURCE; for unbounded operators,
-	     * clip and mask cannot be interchanged. For SOURCE, the operator
-	     * as implemented by the backends is different in it's handling
-	     * of the mask then what we want.
-	     *
-	     * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
-	     * more than rectangle and the destination doesn't support clip
-	     * regions. In that case, we fall through.
-	     */
-	    status = _composite_trap_region (clip, src, op, dst,
-					     trap_region, &extents);
-	    if (status != CAIRO_INT_STATUS_UNSUPPORTED)
-	    {
-		if (!status && clear_region)
-		    status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
-							 CAIRO_COLOR_TRANSPARENT,
-							 clear_region);
-		goto out;
-	    }
-	}
+    if (_cairo_operator_bounded_by_mask (op)) {
+        cairo_rectangle_int16_t trap_extents;
+
+        if (has_trap_region) {
+            status = _cairo_clip_intersect_to_region (clip, &trap_region);
+
+            if (status)
+                goto out;
+
+            _cairo_region_extents_rectangle (&trap_region, &trap_extents);
+        } else {
+            cairo_box_t trap_box;
+            _cairo_traps_extents (traps, &trap_box);
+            _cairo_box_round_to_rectangle (&trap_box, &trap_extents);
+        }
+
+        _cairo_rectangle_intersect (&extents, &trap_extents);
+        status = _cairo_clip_intersect_to_rectangle (clip, &extents);
+
+        if (status)
+            goto out;
+    } else {
+        cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+
+        if (has_trap_region && !clip_surface) {
+            /* If we optimize drawing with an unbounded operator to
+             * _cairo_surface_fill_rectangles() or to drawing with a
+             * clip region, then we have an additional region to clear.
+             */
+            if (_cairo_region_init_from_rectangle (&clear_region, &extents)) {
+                status = CAIRO_STATUS_NO_MEMORY;
+                goto out;
+            }
+
+            has_clear_region = TRUE;
+            status = _cairo_clip_intersect_to_region (clip, &clear_region);
+
+            if (status)
+                goto out;
+
+            _cairo_region_extents_rectangle (&clear_region,  &extents);
+
+            if (PIXMAN_REGION_STATUS_SUCCESS != 
+                pixman_region_subtract (&clear_region, &clear_region, &trap_region)) {
+                status = CAIRO_STATUS_NO_MEMORY;
+                goto out;
+            }
+
+            if (!pixman_region_not_empty (&clear_region)) {
+                pixman_region_uninit (&clear_region);
+                has_clear_region = FALSE;
+            }
+        } else {
+            status = _cairo_clip_intersect_to_rectangle (clip, &extents);
+        }
+
+        if (status)
+            goto out;
+
+        if (has_trap_region) {
+            cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+
+            if ((src->type == CAIRO_PATTERN_TYPE_SOLID ||
+                 op == CAIRO_OPERATOR_CLEAR) && !clip_surface) {
+                const cairo_color_t *color;
+
+                if (op == CAIRO_OPERATOR_CLEAR) {
+                    color = CAIRO_COLOR_TRANSPARENT;
+                } else {
+                    color = &((cairo_solid_pattern_t *)src)->color;
+                }
+
+                /* Solid rectangles special case */
+                status = _cairo_surface_fill_region (dst, op, color,
+                        has_trap_region ? &trap_region : NULL);
+
+                if (!status && has_clear_region)
+                    status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
+                                                         CAIRO_COLOR_TRANSPARENT,
+                                                         &clear_region);
+
+                goto out;
+            }
+
+            if ((_cairo_operator_bounded_by_mask (op) && 
+                 op != CAIRO_OPERATOR_SOURCE) || !clip_surface) {
+                /* For a simple rectangle, we can just use composite(), for more
+                 * rectangles, we have to set a clip region. The cost of rasterizing
+                 * trapezoids is pretty high for most backends currently, so it's
+                 * worthwhile even if a region is needed.
+                 *
+                 * If we have a clip surface, we set it as the mask; this only works
+                 * for bounded operators other than SOURCE; for unbounded operators,
+                 * clip and mask cannot be interchanged. For SOURCE, the operator
+                 * as implemented by the backends is different in it's handling
+                 * of the mask then what we want.
+                 *
+                 * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
+                 * more than rectangle and the destination doesn't support clip
+                 * regions. In that case, we fall through.
+                 */
+                status = _composite_trap_region (clip, src, op, dst,
+                        has_trap_region ? &trap_region : NULL, 
+                        &extents);
+
+                if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
+                    if (!status && has_clear_region)
+                        status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
+                                                             CAIRO_COLOR_TRANSPARENT,
+                                                             &clear_region);
+                    goto out;
+                }
+            }
+        }
     }
 
     traps_info.traps = traps;
     traps_info.antialias = antialias;
 
-    status = _clip_and_composite (clip, op, src,
-				  _composite_traps_draw_func, &traps_info,
-				  dst, &extents);
+    status = _clip_and_composite (clip, op, src, _composite_traps_draw_func,
+                                  &traps_info, dst, &extents);
 
- out:
-    if (trap_region)
-	pixman_region_destroy (trap_region);
-    if (clear_region)
-	pixman_region_destroy (clear_region);
+out:
+    if (has_trap_region)
+        pixman_region_uninit (&trap_region);
+    if (has_clear_region)
+        pixman_region_uninit (&clear_region);
 
     return status;
 }
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index 3162a01..67df039 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -1694,9 +1694,9 @@ _cairo_surface_set_clip (cairo_surface_t *surface, cairo_clip_t *clip)
 						 clip->path,
 						 clip->serial);
 
-	if (clip->region)
+	if (clip->has_region)
 	    return _cairo_surface_set_clip_region (surface,
-						   clip->region,
+						   &clip->region,
 						   clip->serial);
     }
 
@@ -1859,9 +1859,11 @@ _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
 {
     cairo_rectangle_int16_t dst_rectangle;
     cairo_rectangle_int16_t drawn_rectangle;
-    pixman_region16_t *drawn_region;
-    pixman_region16_t *clear_region;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_bool_t has_drawn_region = FALSE;
+    cairo_bool_t has_clear_region = FALSE;
+    pixman_region16_t drawn_region;
+    pixman_region16_t clear_region;
+    cairo_status_t status;
 
     /* The area that was drawn is the area in the destination rectangle but not within
      * the source or the mask.
@@ -1874,34 +1876,42 @@ _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
     drawn_rectangle = dst_rectangle;
 
     if (src_rectangle)
-	_cairo_rectangle_intersect (&drawn_rectangle, src_rectangle);
+        _cairo_rectangle_intersect (&drawn_rectangle, src_rectangle);
 
     if (mask_rectangle)
-	_cairo_rectangle_intersect (&drawn_rectangle, mask_rectangle);
+        _cairo_rectangle_intersect (&drawn_rectangle, mask_rectangle);
 
     /* Now compute the area that is in dst_rectangle but not in drawn_rectangle
      */
-    drawn_region = _cairo_region_create_from_rectangle (&drawn_rectangle);
-    clear_region = _cairo_region_create_from_rectangle (&dst_rectangle);
-    if (!drawn_region || !clear_region) {
-	status = CAIRO_STATUS_NO_MEMORY;
-	goto CLEANUP_REGIONS;
+    if (_cairo_region_init_from_rectangle (&drawn_region, &drawn_rectangle)) {
+        status = CAIRO_STATUS_NO_MEMORY;
+        goto CLEANUP_REGIONS;
     }
 
-    if (pixman_region_subtract (clear_region, clear_region, drawn_region) != PIXMAN_REGION_STATUS_SUCCESS) {
-	status = CAIRO_STATUS_NO_MEMORY;
-	goto CLEANUP_REGIONS;
+    has_drawn_region = TRUE;
+
+    if (_cairo_region_init_from_rectangle (&clear_region, &dst_rectangle)) {
+        status = CAIRO_STATUS_NO_MEMORY;
+        goto CLEANUP_REGIONS;
+    }
+
+    has_clear_region = TRUE;
+
+    if (PIXMAN_REGION_STATUS_SUCCESS != 
+        pixman_region_subtract (&clear_region, &clear_region, &drawn_region)) {
+        status = CAIRO_STATUS_NO_MEMORY;
+        goto CLEANUP_REGIONS;
     }
 
     status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_SOURCE,
-					 CAIRO_COLOR_TRANSPARENT,
-					 clear_region);
-
- CLEANUP_REGIONS:
-    if (drawn_region)
-	pixman_region_destroy (drawn_region);
-    if (clear_region)
-	pixman_region_destroy (clear_region);
+                                         CAIRO_COLOR_TRANSPARENT,
+                                         &clear_region);
+
+CLEANUP_REGIONS:
+    if (has_drawn_region)
+        pixman_region_uninit (&drawn_region);
+    if (has_clear_region)
+        pixman_region_uninit (&clear_region);
 
     return status;
 }
diff --git a/src/cairo-traps.c b/src/cairo-traps.c
index 9b3931f..6acebf8 100644
--- a/src/cairo-traps.c
+++ b/src/cairo-traps.c
@@ -935,11 +935,12 @@ _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents)
  * Determines if a set of trapezoids are exactly representable as a
  * pixman region, and if so creates such a region.
  *
- * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY
+ * Return value: %CAIRO_STATUS_SUCCESS, %CAIRO_INT_STATUS_UNSUPPORTED 
+ * or %CAIRO_STATUS_NO_MEMORY
  **/
-cairo_status_t
-_cairo_traps_extract_region (cairo_traps_t      *traps,
-			     pixman_region16_t **region)
+cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t     *traps,
+			     pixman_region16_t *region)
 {
     int i;
 
@@ -950,11 +951,10 @@ _cairo_traps_extract_region (cairo_traps_t      *traps,
 	      && _cairo_fixed_is_integer(traps->traps[i].bottom)
 	      && _cairo_fixed_is_integer(traps->traps[i].left.p1.x)
 	      && _cairo_fixed_is_integer(traps->traps[i].right.p1.x))) {
-	    *region = NULL;
-	    return CAIRO_STATUS_SUCCESS;
+	    return CAIRO_INT_STATUS_UNSUPPORTED;
 	}
 
-    *region = pixman_region_create ();
+    pixman_region_init (region, NULL);
 
     for (i = 0; i < traps->num_traps; i++) {
 	int x = _cairo_fixed_integer_part(traps->traps[i].left.p1.x);
@@ -969,9 +969,9 @@ _cairo_traps_extract_region (cairo_traps_t      *traps,
 	if (width == 0 || height == 0)
 	  continue;
 
-	if (pixman_region_union_rect (*region, *region,
+	if (pixman_region_union_rect (region, region,
 				      x, y, width, height) != PIXMAN_REGION_STATUS_SUCCESS) {
-	    pixman_region_destroy (*region);
+	    pixman_region_uninit (region);
 	    return CAIRO_STATUS_NO_MEMORY;
 	}
     }
diff --git a/src/cairoint.h b/src/cairoint.h
index 3e54857..3494a92 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -2374,9 +2374,9 @@ _cairo_traps_contain (cairo_traps_t *traps, double x, double y);
 cairo_private void
 _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents);
 
-cairo_private cairo_status_t
-_cairo_traps_extract_region (cairo_traps_t      *tr,
-			     pixman_region16_t **region);
+cairo_private cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t     *tr,
+			     pixman_region16_t *region);
 
 cairo_private void
 _cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
@@ -2480,8 +2480,9 @@ _cairo_gstate_get_antialias (cairo_gstate_t *gstate);
 
 /* cairo-region.c */
 
-cairo_private pixman_region16_t *
-_cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect);
+cairo_private cairo_status_t
+_cairo_region_init_from_rectangle (pixman_region16_t       *region,
+				   cairo_rectangle_int16_t *rect);
 
 cairo_private void
 _cairo_region_extents_rectangle (pixman_region16_t       *region,
-- 
1.4.4.2

-------------- next part --------------
>From 8105eb1471775b12cc692114458bd4d2c2b76f53 Mon Sep 17 00:00:00 2001
From: Mathias Hasselmann <mathias.hasselmann@gmx.de>
Date: Sun, 11 Mar 2007 21:03:58 +0100
Subject: [PATCH] Fix infinite recursion introduced by last patch

---
 src/cairo-surface-fallback.c |   93 +++++++++++++++++++++---------------------
 1 files changed, 46 insertions(+), 47 deletions(-)

diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 24c9115..1a0180d 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -591,71 +591,70 @@ _clip_and_composite_trapezoids (cairo_pattern_t *src,
         } else {
             status = _cairo_clip_intersect_to_rectangle (clip, &extents);
         }
+    }
 
-        if (status)
-            goto out;
+    if (status)
+        goto out;
 
-        if (has_trap_region) {
-            cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+    if (has_trap_region) {
+        cairo_surface_t *clip_surface = clip ? clip->surface : NULL;
+
+        if ((src->type == CAIRO_PATTERN_TYPE_SOLID ||
+             op == CAIRO_OPERATOR_CLEAR) && !clip_surface) {
+            const cairo_color_t *color;
+
+            if (op == CAIRO_OPERATOR_CLEAR) {
+                color = CAIRO_COLOR_TRANSPARENT;
+            } else {
+                color = &((cairo_solid_pattern_t *)src)->color;
+            }
+
+            /* Solid rectangles special case */
+            status = _cairo_surface_fill_region (dst, op, color, &trap_region);
 
-            if ((src->type == CAIRO_PATTERN_TYPE_SOLID ||
-                 op == CAIRO_OPERATOR_CLEAR) && !clip_surface) {
-                const cairo_color_t *color;
+            if (!status && has_clear_region)
+                status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
+                                                     CAIRO_COLOR_TRANSPARENT,
+                                                     &clear_region);
 
-                if (op == CAIRO_OPERATOR_CLEAR) {
-                    color = CAIRO_COLOR_TRANSPARENT;
-                } else {
-                    color = &((cairo_solid_pattern_t *)src)->color;
-                }
+            goto out;
+        }
 
-                /* Solid rectangles special case */
-                status = _cairo_surface_fill_region (dst, op, color,
-                        has_trap_region ? &trap_region : NULL);
+        if ((_cairo_operator_bounded_by_mask (op) && 
+             op != CAIRO_OPERATOR_SOURCE) || !clip_surface) {
+            /* For a simple rectangle, we can just use composite(), for more
+             * rectangles, we have to set a clip region. The cost of rasterizing
+             * trapezoids is pretty high for most backends currently, so it's
+             * worthwhile even if a region is needed.
+             *
+             * If we have a clip surface, we set it as the mask; this only works
+             * for bounded operators other than SOURCE; for unbounded operators,
+             * clip and mask cannot be interchanged. For SOURCE, the operator
+             * as implemented by the backends is different in it's handling
+             * of the mask then what we want.
+             *
+             * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
+             * more than rectangle and the destination doesn't support clip
+             * regions. In that case, we fall through.
+             */
+            status = _composite_trap_region (clip, src, op, dst,
+                                             &trap_region, &extents);
 
+            if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
                 if (!status && has_clear_region)
                     status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
                                                          CAIRO_COLOR_TRANSPARENT,
                                                          &clear_region);
-
                 goto out;
             }
-
-            if ((_cairo_operator_bounded_by_mask (op) && 
-                 op != CAIRO_OPERATOR_SOURCE) || !clip_surface) {
-                /* For a simple rectangle, we can just use composite(), for more
-                 * rectangles, we have to set a clip region. The cost of rasterizing
-                 * trapezoids is pretty high for most backends currently, so it's
-                 * worthwhile even if a region is needed.
-                 *
-                 * If we have a clip surface, we set it as the mask; this only works
-                 * for bounded operators other than SOURCE; for unbounded operators,
-                 * clip and mask cannot be interchanged. For SOURCE, the operator
-                 * as implemented by the backends is different in it's handling
-                 * of the mask then what we want.
-                 *
-                 * CAIRO_INT_STATUS_UNSUPPORTED will be returned if the region has
-                 * more than rectangle and the destination doesn't support clip
-                 * regions. In that case, we fall through.
-                 */
-                status = _composite_trap_region (clip, src, op, dst,
-                        has_trap_region ? &trap_region : NULL, 
-                        &extents);
-
-                if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
-                    if (!status && has_clear_region)
-                        status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
-                                                             CAIRO_COLOR_TRANSPARENT,
-                                                             &clear_region);
-                    goto out;
-                }
-            }
         }
     }
 
     traps_info.traps = traps;
     traps_info.antialias = antialias;
 
-    status = _clip_and_composite (clip, op, src, _composite_traps_draw_func,
+    status = _clip_and_composite (clip, op, src,
+                                  _composite_traps_draw_func,
                                   &traps_info, dst, &extents);
 
 out:
-- 
1.4.4.2

-------------- next part --------------
>From c34922eb803fa55efd8a3a7190390710d09a8fe8 Mon Sep 17 00:00:00 2001
From: Mathias Hasselmann <mathias.hasselmann@gmx.de>
Date: Mon, 12 Mar 2007 00:08:40 +0100
Subject: [PATCH] Make sure clip->region is always initialized

---
 src/cairo-clip.c |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index 46179d9..f63fdbb 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -58,6 +58,7 @@ _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target)
 
     clip->serial = 0;
 
+    pixman_region_init (&clip->region, NULL);
     clip->has_region = FALSE;
 
     clip->path = NULL;
@@ -90,6 +91,8 @@ _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 
     clip->serial = other->serial;
 
+    pixman_region_init (&clip->region, NULL);
+
     if (other->has_region) {
         pixman_region_copy (&clip->region, &other->region);
         clip->has_region = TRUE;
@@ -110,7 +113,12 @@ _cairo_clip_reset (cairo_clip_t *clip)
     clip->serial = 0;
 
     if (clip->has_region) {
+        /* pixman_region_uninit just releases the resources used but
+         * doesn't bother with leaving the region in a valid state.
+         * So pixman_region_init has to be called afterwards. */
 	pixman_region_uninit (&clip->region);
+        pixman_region_init (&clip->region, NULL);
+
         clip->has_region = FALSE;
     }
 
-- 
1.4.4.2

-------------- next part --------------
>From 92ddab81ecc330a852c43e7e78b632517d73db64 Mon Sep 17 00:00:00 2001
From: Mathias Hasselmann <mathias.hasselmann@gmx.de>
Date: Mon, 12 Mar 2007 00:23:42 +0100
Subject: [PATCH] Remove redundant _cairo_clip_fini function

---
 src/cairo-clip-private.h |    3 ---
 src/cairo-clip.c         |   19 +------------------
 src/cairo-gstate.c       |    4 ++--
 src/cairo-meta-surface.c |    2 +-
 4 files changed, 4 insertions(+), 24 deletions(-)

diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index 381c003..ee920ae 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -85,9 +85,6 @@ cairo_private void
 _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target);
 
 cairo_private void
-_cairo_clip_fini (cairo_clip_t *clip);
-
-cairo_private void
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other);
 
 cairo_private void
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index f63fdbb..3a3717e 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -65,23 +65,6 @@ _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target)
 }
 
 void
-_cairo_clip_fini (cairo_clip_t *clip)
-{
-    cairo_surface_destroy (clip->surface);
-    clip->surface = NULL;
-
-    clip->serial = 0;
-
-    if (clip->has_region) {
-	pixman_region_uninit (&clip->region);
-    	clip->has_region = FALSE;
-    }
-
-    _cairo_clip_path_destroy (clip->path);
-    clip->path = NULL;
-}
-
-void
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 {
     clip->mode = other->mode;
diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index f2d9280..daca47a 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -200,7 +200,7 @@ _cairo_gstate_fini (cairo_gstate_t *gstate)
     cairo_scaled_font_destroy (gstate->scaled_font);
     gstate->scaled_font = NULL;
 
-    _cairo_clip_fini (&gstate->clip);
+    _cairo_clip_reset (&gstate->clip);
 
     cairo_surface_destroy (gstate->target);
     gstate->target = NULL;
@@ -309,7 +309,7 @@ _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child)
      * since its ref is now owned by gstate->parent_target */
     gstate->target = cairo_surface_reference (child);
 
-    _cairo_clip_fini (&gstate->clip);
+    _cairo_clip_reset (&gstate->clip);
     _cairo_clip_init_deep_copy (&gstate->clip, &gstate->next->clip, child);
 
     /* The clip is in surface backend coordinates for the previous target;
diff --git a/src/cairo-meta-surface.c b/src/cairo-meta-surface.c
index e196df2..457bfe2 100644
--- a/src/cairo-meta-surface.c
+++ b/src/cairo-meta-surface.c
@@ -773,7 +773,7 @@ _cairo_meta_surface_replay (cairo_surface_t *surface,
 	    break;
     }
 
-    _cairo_clip_fini (&clip);
+    _cairo_clip_reset (&clip);
 
     return status;
 }
-- 
1.4.4.2

From robert at ocallahan.org  Sun Mar 11 17:37:06 2007
From: robert at ocallahan.org (Robert O'Callahan)
Date: Sun Mar 11 17:37:09 2007
Subject: [cairo] Alpha channel [pycairo]
In-Reply-To: <177e83dd0703110847g1f04c5e2q7f068ec7e635c427@mail.gmail.com>
References: <loom.20070310T215235-143@post.gmane.org>
	<177e83dd0703110847g1f04c5e2q7f068ec7e635c427@mail.gmail.com>
Message-ID: <11e306600703111737g6b9df683w727c8a9e16365811@mail.gmail.com>

On 3/12/07, Kalle Vahlman <kalle.vahlman@gmail.com> wrote:
>
> 2007/3/10, Manuel <origin.of@gmail.com>:
> > hi all, I've this "program" :
> [snip]
> > try execute it, the alpha channel doesn't work...
> > The windows isn't semi-transparent...
> > cr.set_source_rgba(0.0, 0.0, 0.0, 0.5) doesn't work ??
>
> That's because window transparency doesn't quite work that way.
>
> On X, windows traditionally are always fully opaque. One needs the
> help of the Composite extension to achieve transparency, which pretty
> much is out of scope for Cairo IMO.


Actually all the X *application* needs to do is to choose an RGBA visual for
its windows.

Rob
-- 
"Two men owed money to a certain moneylender. One owed him five hundred
denarii, and the other fifty. Neither of them had the money to pay him back,
so he canceled the debts of both. Now which of them will love him more?"
Simon replied, "I suppose the one who had the bigger debt canceled." "You
have judged correctly," Jesus said. [Luke 7:41-43]
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070312/1d535731/attachment.htm
From chris at chris-wilson.co.uk  Sun Mar 11 18:09:27 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Sun Mar 11 18:09:40 2007
Subject: [cairo] Malloc profiler/callgraph
Message-ID: <20070312010927.GA18928@inspired.chris-wilson.co.uk>

Recently, Behdad has turned his attention to reducing the number of
allocations Cairo makes. In order to measure his progress, he wrote a
tool to hook into malloc and record the callers. Unfortunately in order
to get the best results, he needed to modify the source. As an
alternative, I present this valgrind skin. It is mostly based on the
massif skin, in that it overloads the mallocfree functions and records
the entire stacktrace and accumulates statistics for each unique trace.
At the end it will print a table of the allocators (the function that
called malloc, or rather the first function not listed among --alloc-fn
ala massif) and it will dump out the unique stack traces to a file. At
the moment, I have not translated this output into any common format (I
was thinking of writing it in a callgrind.out format so as to use it in
kcachegrind) and instead include a very simple mp-gui.py to read in the
stack traces and provide a means of reviewing the results.

The patch is relative to valgrind's svn trunk. Apply, reconfigure and
make install. Usage is similar to other valgrind skins:
$ valgrind --tool=memprof --help
$ valgrind --tool=memprof ./cairo-perf

And the output is:
==18877== 216 distinct allocators.
==18877== nBlocks	nBytes		nReallocs  Lifespan (ms)
	...
==18877== 484,619	1,030,781,440	0 1      _cairo_traps_add_trap_from_points [cairo-traps.c::193]
==18877== 528,888	21,155,520	0 0      _cairo_pixman_format_create_masks [icformat.c::102]
==18877== 528,916	69,816,912	0 62     pixman_image_createForPixels [icimage.c::76]
==18877== 598,300	4,786,400	0 2      _cairo_freelist_alloc [cairo-freelist.c::52]
==18877== 967,584	290,275,200	0 2      _cairo_path_fixed_move_to [cairo-path-fixed.c::199]
==18877== 1,408,396	361,163,776	0 0      _cairo_spline_add_point [cairo-spline.c::110]
==18877== 1,763,825	32,374,496	0 2      skip_list_insert [cairo-skiplist.c::293]
==18877== 10,943,515	4,330,076,529	0 145    (total)

The downside to this tool is that it incurs an order of magnitude
performance overhead, which is a nuisance as before it extracted the
stack for each unique callsite it was only about a factor of 3-4 slower.

I hope you find this a useful little tool.
Happy Profiling!
--
Chris Wilson
-------------- next part --------------
A non-text attachment was scrubbed...
Name: vg-memprof.patch.gz
Type: application/octet-stream
Size: 9028 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070312/5bb0fafd/vg-memprof.patch.obj
From brad_e at hotmail.com  Sun Mar 11 18:42:22 2007
From: brad_e at hotmail.com (Brad Elliott)
Date: Sun Mar 11 18:54:25 2007
Subject: [cairo] Transparency troubles with PNGs on Windows
Message-ID: <BAY126-W229932FDF8D04E03AB8F45E07D0@phx.gbl>

Hello,I'm trying to create transparent PNGs and I'm running into a problem where the surface doesn't get cleared when I destroy a cairo+surface pair under Windows. Then when I create a second object there is data left around (a red rectangle) from the original cairo object which corrupts the second image. I suspect that I'm tearing down something incorrectly and the reference counts don't drop to zero (cairo_surface_get_reference_count() doesn't seem to be available on the Windows build on Tor Lillquist's page). Has anyone encountered this before?The following is an example demonstrating this problem on Cairo 1.4.0. When I make the second call to draw() the contents of the original surface are left around in the second image (red rectangle).  Am I doing something wrong in tearing down the surface/cairo object? It works fine under Linux but not under Win32 (Visual Studio .Net 2003 under XP) using the library provided by Tor.Incorrect output on Windows:    http://bradford.elliott.googlepages.com/one_windows.png    http://bradford.elliott.googlepages.com/two_windows.png (red rectangle is left around from one_windows.png)
Correct output on Linux:    http://bradford.elliott.googlepages.com/one_linux.png    http://bradford.elliott.googlepages.com/two_linux.png (no red rectangle which is what I expect)Can anyone tell me what I'm doing wrong? Any help would be appreciated.Thanks,Here is a short snippet demonstrating the problem:   #include <cairo.h>      void draw(const char* output_file, int x, int y)   {      cairo_t*         image;      cairo_surface_t* surface;      int              width  = 126;
      int              height = 24;          surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);      image = cairo_create(surface);          cairo_rectangle(image, x, y, 20, 20);
      cairo_set_source_rgba(image, 0,0,0,1);      cairo_fill(image);          cairo_surface_write_to_png(surface, output_file);      cairo_surface_destroy(surface);      cairo_destroy(image);   }   int main(void)
   {      draw("one.png", 0, 0);      draw("two.png", 10, 10);   }

_________________________________________________________________
Explore the seven wonders of the world
http://search.msn.com/results.aspx?q=7+wonders+world&mkt=en-US&form=QBRE
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070312/226c2e27/attachment.html
From kb_list at yahoo.com  Sun Mar 11 19:06:10 2007
From: kb_list at yahoo.com (Kevin Brooks)
Date: Sun Mar 11 19:06:13 2007
Subject: [cairo] cairo_image_surface_create_from_???
In-Reply-To: <878xe49vcf.wl%cworth@cworth.org>
Message-ID: <716673.82228.qm@web53605.mail.yahoo.com>


--- Carl Worth <cworth@cworth.org> wrote:

> On Thu, 8 Mar 2007 23:50:24 -0800 (PST), Kevin
> Brooks wrote:
> > Are we going to have other image supports in the
> > future like:
> >
> > cairo_surface_t*
> cairo_image_surface_create_from_jpg
> > cairo_surface_t*
> cairo_image_surface_create_from_bmp
> > cairo_surface_t*
> cairo_image_surface_create_from_tiff
> 
> It's not very likely.
> 
> We don't want to let the number of dependencies that
> cairo has grow
> arbitrarily.
> 

Right. I don't like those dependencies as well. 


> And cairo does already allow you to create an image
> surface from a
> buffer of data with the
> cairo_image_surface_create_for_data
> function. So it is already possible to load an image
> through whatever
> means you have available and then create an image
> surface from
> it---all with code built on top of the existing
> cairo interface.
> 

I see your point. cairo_image_surface_create_for_data
is powerful if we can have an efficient image loader.

> Some people have even suggested the possibility of a
> cairo-friendly
> interface for creating such image surfaces, (perhaps
> by building on
> top of an existing full-functioned image library
> whose name I don't
> recall now).
> 
> -Carl
> 

Thanks,

Kev


 
____________________________________________________________________________________
8:00? 8:25? 8:40? Find a flick in no time 
with the Yahoo! Search movie showtime shortcut.
http://tools.search.yahoo.com/shortcuts/#news
From daniel.amelang at gmail.com  Sun Mar 11 23:20:55 2007
From: daniel.amelang at gmail.com (Daniel Amelang)
Date: Sun Mar 11 23:20:59 2007
Subject: [cairo] Image basic data
In-Reply-To: <CD5D28C6C2E39441B4AC9027771E9AD2033F381C@ucixs56.uci.cu>
References: <20070308200020.209CE9E738@gabe.freedesktop.org>
	<CD5D28C6C2E39441B4AC9027771E9AD2033F381C@ucixs56.uci.cu>
Message-ID: <a65ae5c90703112320v3a6ab1bcxf7648571a19fa12c@mail.gmail.com>

On 3/8/07, Leonel Salazar Videaux <lsalazar@estudiantes.uci.cu> wrote:
> How can I know the basic image or picture data using cairo?, I mean, i need to get some memory in a buffer and for do that i need to know data such as width and height, i just want to know how to get this information from a PNG of SVG file.

Hi Leonel, I'm not exactly sure what you're asking here. Are you just
trying to determine the width and height of an image stored in the png
format? I suppose that you can load an image surface with a call to
cairo_image_surface_create_from_png, then get the width and height via
cairo_image_surface_get_width and cairo_image_surface_get_height.
Although, if that's all you need, cairo really is overkill. There are
more lightweight ways of doing this.

Hope that helps,

Dan
From otaylor at redhat.com  Mon Mar 12 05:59:50 2007
From: otaylor at redhat.com (Owen Taylor)
Date: Mon Mar 12 05:59:56 2007
Subject: [cairo] Transparency troubles with PNGs on Windows
In-Reply-To: <BAY126-W229932FDF8D04E03AB8F45E07D0@phx.gbl>
References: <BAY126-W229932FDF8D04E03AB8F45E07D0@phx.gbl>
Message-ID: <1173704391.2565.277.camel@localhost.localdomain>

It's really very simple here ... an image surface isn't cleared
or initialized in any way 


> 
> The following is an example demonstrating this problem on Cairo 1.4.0.
> When I make the second call to draw() the contents of the original
> surface are left around in the second image (red rectangle).  Am I
> doing something wrong in tearing down the surface/cairo object? It
> works fine under Linux but not under Win32 (Visual Studio .Net 2003
> under XP) using the library provided by Tor.
> 
> Incorrect output on Windows:
>     http://bradford.elliott.googlepages.com/one_windows.png
>     http://bradford.elliott.googlepages.com/two_windows.png (red
> rectangle is left around from one_windows.png)
> 
> Correct output on Linux:
>     http://bradford.elliott.googlepages.com/one_linux.png
>     http://bradford.elliott.googlepages.com/two_linux.png (no red
> rectangle which is what I expect)
> 
> Can anyone tell me what I'm doing wrong? Any help would be
> appreciated.
> 
> Thanks,
> 
> Here is a short snippet demonstrating the problem:
> 
>    #include <cairo.h>
>    
>    void draw(const char* output_file, int x, int y)
>    {
>       cairo_t*         image;
>       cairo_surface_t* surface;
>       int              width  = 126; 
>       int              height = 24;
>     
>       surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width,
> height);
>       image = cairo_create(surface);
>     
>       cairo_rectangle(image, x, y, 20, 20);
>       cairo_set_source_rgba(image, 0,0,0,1);
>       cairo_fill(image);
>     
>       cairo_surface_write_to_png(surface, output_file);
>       cairo_surface_destroy(surface);
>       cairo_destroy(image);
>    }
> 
>    int main(void) 
>    {
>       draw("one.png", 0, 0);
>       draw("two.png", 10, 10);
>    }
> 
> 
> 
> 
> ______________________________________________________________________
> Explore the seven wonders of the world Learn more!
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo

From otaylor at redhat.com  Mon Mar 12 06:05:35 2007
From: otaylor at redhat.com (Owen Taylor)
Date: Mon Mar 12 06:05:40 2007
Subject: [cairo] Transparency troubles with PNGs on Windows
In-Reply-To: <BAY126-W229932FDF8D04E03AB8F45E07D0@phx.gbl>
References: <BAY126-W229932FDF8D04E03AB8F45E07D0@phx.gbl>
Message-ID: <1173704736.2565.284.camel@localhost.localdomain>

[ Sorry for the last mail, hit send accidentally ]

On Mon, 2007-03-12 at 01:42 +0000, Brad Elliott wrote:
> Hello,
> 
> I'm trying to create transparent PNGs and I'm running into a problem
> where the surface doesn't get cleared when I destroy a cairo+surface
> pair under Windows. Then when I create a second object there is data
> left around (a red rectangle) from the original cairo object which
> corrupts the second image. I suspect that I'm tearing down something
> incorrectly and the reference counts don't drop to zero
> (cairo_surface_get_reference_count() doesn't seem to be available on
> the Windows build on Tor Lillquist's page). Has anyone encountered
> this before?

It's really very simple (I think) with older version's of Cairo an image
surface isn't cleared or initialized in any way when it's created. You
need to do that yourself;
e.g. with:

 cairo_save(cr);
 cairo_set_operation(cr, CAIRO_CLEAR);
 cairo_paint(cr);
 cairo_restore(cr);

That was changed more "recently" - see:

 https://bugs.freedesktop.org/show_bug.cgi?id=5816

You don't say what version of the Windows library you are using, but
perhaps you are using something quite old?

					- Owen



From david at freetype.org  Mon Mar 12 07:27:37 2007
From: david at freetype.org (David Turner)
Date: Mon Mar 12 07:27:39 2007
Subject: [cairo] Faster gradients patchset, take 2
Message-ID: <1173709657.29680.1178998863@webmail.messagingengine.com>

Hello,

here's another patchset to speed up gradient rendering. It includes the previous one that sped up the radial
case, as well as a simple technique to speed up the pretty common case where all color stops are opaque, which
saves quite a lot of per-pixel computations.

  http://david.freetype.org/cairo/faster-gradients-2.patchset

Apparently, this means speed-ups of up to x2.04 for radial gradients, and x1.67 for linear ones

Enjoy,

- David Turner
- The FreeType Project  (www.freetype.org)
From brad_e at hotmail.com  Mon Mar 12 12:19:49 2007
From: brad_e at hotmail.com (Brad Elliott)
Date: Mon Mar 12 12:19:54 2007
Subject: [cairo] Transparency troubles with PNGs on Windows
Message-ID: <BAY126-W15A3BE72708BB977B00D66E07D0@phx.gbl>


Hi Owen,

Now that I know what is wrong I fixed the issue by using the right version of libcairo2.dll. I thought I was using version 1.4.0 but it turns out I had an older version of libcairo2.dll first in my path because I installed the GIMP ages ago and it required GTK. It was picking up that version of the DLL instead of the correct one. Now that I'm using the correct DLL the surface is being cleared on initialization. I guess that points out the obvious fact that I should be checking the cairo version in my code.

Thanks a lot for the help. I appreciate it.

Brad

----------------------------------------
> Subject: Re: [cairo] Transparency troubles with PNGs on Windows
> From: otaylor@redhat.com
> To: brad_e@hotmail.com
> CC: cairo@cairographics.org
> Date: Mon, 12 Mar 2007 08:59:50 -0400
> 
> It's really very simple here ... an image surface isn't cleared
> or initialized in any way 
> 
> 
> > 
> > The following is an example demonstrating this problem on Cairo 1.4.0.
> > When I make the second call to draw() the contents of the original
> > surface are left around in the second image (red rectangle).  Am I
> > doing something wrong in tearing down the surface/cairo object? It
> > works fine under Linux but not under Win32 (Visual Studio .Net 2003
> > under XP) using the library provided by Tor.
> > 
> > Incorrect output on Windows:
> >     http://bradford.elliott.googlepages.com/one_windows.png
> >     http://bradford.elliott.googlepages.com/two_windows.png (red
> > rectangle is left around from one_windows.png)
> > 
> > Correct output on Linux:
> >     http://bradford.elliott.googlepages.com/one_linux.png
> >     http://bradford.elliott.googlepages.com/two_linux.png (no red
> > rectangle which is what I expect)
> > 
> > Can anyone tell me what I'm doing wrong? Any help would be
> > appreciated.
> > 
> > Thanks,
> > 
> > Here is a short snippet demonstrating the problem:
> > 
> >    #include 
> >    
> >    void draw(const char* output_file, int x, int y)
> >    {
> >       cairo_t*         image;
> >       cairo_surface_t* surface;
> >       int              width  = 126; 
> >       int              height = 24;
> >     
> >       surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width,
> > height);
> >       image = cairo_create(surface);
> >     
> >       cairo_rectangle(image, x, y, 20, 20);
> >       cairo_set_source_rgba(image, 0,0,0,1);
> >       cairo_fill(image);
> >     
> >       cairo_surface_write_to_png(surface, output_file);
> >       cairo_surface_destroy(surface);
> >       cairo_destroy(image);
> >    }
> > 
> >    int main(void) 
> >    {
> >       draw("one.png", 0, 0);
> >       draw("two.png", 10, 10);
> >    }
> > 
> > 
> > 
> > 
> > ______________________________________________________________________
> > Explore the seven wonders of the world Learn more!
> > _______________________________________________
> > cairo mailing list
> > cairo@cairographics.org
> > http://cairographics.org/cgi-bin/mailman/listinfo/cairo
> 

_________________________________________________________________
Discover the new Windows Vista
http://search.msn.com/results.aspx?q=windows+vista&mkt=en-US&form=QBRE
From cworth at cworth.org  Mon Mar 12 14:50:35 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar 12 14:51:24 2007
Subject: [cairo] A couple of valgrind warning fixes
In-Reply-To: <20070311233004.GA8145@inspired.chris-wilson.co.uk>
References: <20070311233004.GA8145@inspired.chris-wilson.co.uk>
Message-ID: <87r6ruxhas.wl%cworth@cworth.org>

Skipped content of type multipart/mixed-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070312/522e17d9/attachment.pgp
From behdad at behdad.org  Mon Mar 12 20:07:08 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar 12 20:07:03 2007
Subject: [cairo] METRICS_HINTING_OFF in win32 font backend
Message-ID: <1173755228.15986.25.camel@behdad>

Hi,

Seems like the win32 font backend returns hinted font-metrics no matter
what font options are set.  This bug has code for testing:

	http://bugzilla.gnome.org/show_bug.cgi?id=377795

I suspect the second branch in _cairo_win32_scaled_font_set_metrics() is
enough to get the right metrics.  In that case, it's a one-line patch.

Can someone familiar with the win32 backend test and fix please.

Thanks.
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Mon Mar 12 22:46:28 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Mon Mar 12 22:46:23 2007
Subject: [cairo] Re: METRICS_HINTING_OFF in win32 font backend
In-Reply-To: <1173755228.15986.25.camel@behdad>
References: <1173755228.15986.25.camel@behdad>
Message-ID: <1173764788.8040.2.camel@behdad>

On Mon, 2007-03-12 at 23:07 -0400, Behdad Esfahbod wrote:
> Hi,
> 
> Seems like the win32 font backend returns hinted font-metrics no matter
> what font options are set.  This bug has code for testing:
> 
> 	http://bugzilla.gnome.org/show_bug.cgi?id=377795
> 
> I suspect the second branch in _cairo_win32_scaled_font_set_metrics() is
> enough to get the right metrics.  In that case, it's a one-line patch.
>
> Can someone familiar with the win32 backend test and fix please.

So, muntyan actually tested that and it works after fixing another,
really embarrassing bug in there.  That is:

@@ -723,7 +723,7 @@ _cairo_win32_scaled_font_set_metrics (cairo_win32_scaled_font_t *scaled_font)
        _cairo_win32_scaled_font_done_unscaled_font (&scaled_font->base);
 
        extents.ascent = (double)metrics.tmAscent / scaled_font->em_square;
-       extents.descent = metrics.tmDescent * scaled_font->em_square;
+       extents.descent = (double)metrics.tmDescent / scaled_font->em_square;
        extents.height = (double)(metrics.tmHeight + metrics.tmExternalLeading) / scaled_font->em_square;
        extents.max_x_advance = (double)(metrics.tmMaxCharWidth) / scaled_font->em_square;
        extents.max_y_advance = 0;

And the original patch should look like:

--- a/src/cairo-win32-font.c
+++ b/src/cairo-win32-font.c
@@ -693,7 +693,7 @@ _cairo_win32_scaled_font_set_metrics (cairo_win32_scaled_font_t *scaled_font)
     if (!hdc)
        return CAIRO_STATUS_NO_MEMORY;
 
-    if (scaled_font->preserve_axes) {
+    if (scaled_font->preserve_axes || scaled_font->options.hint_metrics == CAIRO_HINT_METRICS_OFF) {
        /* For 90-degree rotations (including 0), we get the metrics
         * from the GDI in logical space, then convert back to font space
         */

I'll go on and commit this unless someone comments or beats me to it.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From chris at chris-wilson.co.uk  Tue Mar 13 03:32:36 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Tue Mar 13 03:53:36 2007
Subject: [cairo] cairo-perf cleanups
Message-ID: <20070313103236.GC18928@inspired.chris-wilson.co.uk>

I'm having a little difficulty getting stable results out of cairo-perf.
I took a look through the source and have a fix for one bug and a couple
of cosmetic suggestions. Afterwards the results appear move consistent,
but I still worry that the default number of iterations for
cairo-perf-diff is insufficient. What I had thought had been implemented
(or was it only discussed?) was to ensure that each test ran for a
minimum length of time.
--
Chris Wilson
-------------- next part --------------
>From c8797eeec0dbd5f6f0626fa6b22348b2588d082e Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 09:43:01 +0000
Subject: [PATCH] Compute std.dev over values[min_valid : min_valid + num_valid]
---
 perf/cairo-stats.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/perf/cairo-stats.c b/perf/cairo-stats.c
index 2c6c7dc..43711a9 100644
--- a/perf/cairo-stats.c
+++ b/perf/cairo-stats.c
@@ -92,7 +92,7 @@ _cairo_stats_compute (cairo_stats_t		*st
     stats->median_ticks = values[min_valid + num_valid / 2];
 
     sum = 0.0;
-    for (i = min_valid; i < num_valid; i++) {
+    for (i = min_valid; i < min_valid + num_valid; i++) {
 	delta = values[i] - mean;
 	sum += delta * delta;
     }
-- 
1.4.1

-------------- next part --------------
>From 9e594a10a04b124724ca370ff5f230e2d665a72f Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 10:09:52 +0000
Subject: [PATCH] Discard statistically insignificant differences.

Discard as an "uninteresting change" if the two timings lie within 2
sigma of each other.
---
 perf/cairo-perf-diff-files.c |   16 +++++++++++++---
 perf/cairo-stats.c           |    3 ++-
 perf/cairo-stats.h           |    1 +
 3 files changed, 16 insertions(+), 4 deletions(-)

diff --git a/perf/cairo-perf-diff-files.c b/perf/cairo-perf-diff-files.c
index 8b6292a..8495efb 100644
--- a/perf/cairo-perf-diff-files.c
+++ b/perf/cairo-perf-diff-files.c
@@ -560,6 +560,7 @@ cairo_perf_report_diff (cairo_perf_repor
     }
 
     for (i = 0; i < num_diffs; i++) {
+	double min_value, max_value;
 	diff = &diffs[i];
 
 	change = diff->speedup;
@@ -572,9 +573,18 @@ cairo_perf_report_diff (cairo_perf_repor
 	if (change - 1.0 < min_change)
 	    continue;
 
-	/* Also discard as uninteresting if the change is less than
-	 * the sum each of the standard deviations. */
-	if (change - 1.0 < diff->old->stats.std_dev + diff->new->stats.std_dev)
+	/* Also discard as uninteresting if the change is the new value is
+	 * within 95% [2 sigma] of old value. */
+	min_value = diff->old->stats.mean * (1 - 2*diff->old->stats.std_dev);
+	max_value = diff->old->stats.mean * (1 + 2*diff->old->stats.std_dev);
+	if (diff->new->stats.mean > min_value &&
+		diff->new->stats.mean < max_value)
+	    continue;
+	/* similary, check vice versa. */
+	min_value = diff->new->stats.mean * (1 - 2*diff->new->stats.std_dev);
+	max_value = diff->new->stats.mean * (1 + 2*diff->new->stats.std_dev);
+	if (diff->old->stats.mean > min_value &&
+		diff->old->stats.mean < max_value)
 	    continue;
 
 	if (diff->speedup > 1.0 && ! printed_speedup) {
diff --git a/perf/cairo-stats.c b/perf/cairo-stats.c
index 43711a9..baa4e1d 100644
--- a/perf/cairo-stats.c
+++ b/perf/cairo-stats.c
@@ -61,7 +61,7 @@ _cairo_stats_compute (cairo_stats_t		*st
     qsort (values, num_values,
 	   sizeof (cairo_perf_ticks_t), _cairo_perf_ticks_cmp);
 
-    q1	 	= values[(1*num_values)/4];
+    q1		= values[(1*num_values)/4];
     q3		= values[(3*num_values)/4];
 
     iqr = q3 - q1;
@@ -100,4 +100,5 @@ _cairo_stats_compute (cairo_stats_t		*st
     /* Let's use a std. deviation normalized to the mean for easier
      * comparison. */
     stats->std_dev = sqrt(sum / num_valid) / mean;
+    stats->mean = mean;
 }
diff --git a/perf/cairo-stats.h b/perf/cairo-stats.h
index 3f8a988..48db0be 100644
--- a/perf/cairo-stats.h
+++ b/perf/cairo-stats.h
@@ -33,6 +33,7 @@ typedef struct _cairo_stats {
     cairo_perf_ticks_t median_ticks;
     double ticks_per_ms;
     double std_dev;
+    double mean;
     int iterations;
 } cairo_stats_t;
 
-- 
1.4.1

-------------- next part --------------
>From 38db7e352a7e02c1337ae9c9a2de6fe1478cff31 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 10:19:15 +0000
Subject: [PATCH] Switch between millseconds and microseconds for timings.

Sometimes the timing is too small to display accurately in milliseconds
using %4.2f, so use microsecond results as appropiate.
---
 perf/cairo-perf-diff-files.c |   34 +++++++++++++++++++++++++---------
 1 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/perf/cairo-perf-diff-files.c b/perf/cairo-perf-diff-files.c
index 8495efb..b2a26e8 100644
--- a/perf/cairo-perf-diff-files.c
+++ b/perf/cairo-perf-diff-files.c
@@ -561,6 +561,7 @@ cairo_perf_report_diff (cairo_perf_repor
 
     for (i = 0; i < num_diffs; i++) {
 	double min_value, max_value;
+	double old_value, new_value;
 	diff = &diffs[i];
 
 	change = diff->speedup;
@@ -573,8 +574,13 @@ cairo_perf_report_diff (cairo_perf_repor
 	if (change - 1.0 < min_change)
 	    continue;
 
-	/* Also discard as uninteresting if the change is the new value is
-	 * within 95% [2 sigma] of old value. */
+	/* Also discard as uninteresting if the change is less than
+	 * the sum each of the standard deviations. */
+	if (change - 1.0 < hypot(diff->old->stats.std_dev, diff->new->stats.std_dev))
+	    continue;
+
+	/* And discard as uninteresting if the new mean is within
+	 * 95% [2 sigma] of old value. */
 	min_value = diff->old->stats.mean * (1 - 2*diff->old->stats.std_dev);
 	max_value = diff->old->stats.mean * (1 + 2*diff->old->stats.std_dev);
 	if (diff->new->stats.mean > min_value &&
@@ -598,14 +604,24 @@ cairo_perf_report_diff (cairo_perf_repor
 	    printed_slowdown = 1;
 	}
 
-	printf ("%5s-%-4s %26s-%-3d  %6.2f %4.2f%% -> %6.2f %4.2f%%: %5.2fx ",
+	printf ("%5s-%-4s %26s-%-3d  ",
 		diff->old->backend, diff->old->content,
-		diff->old->name, diff->old->size,
-		diff->old->stats.min_ticks / diff->old->stats.ticks_per_ms,
-		diff->old->stats.std_dev * 100,
-		diff->new->stats.min_ticks / diff->new->stats.ticks_per_ms,
-		diff->new->stats.std_dev * 100,
-		change);
+		diff->old->name, diff->old->size);
+	old_value = diff->old->stats.min_ticks / diff->old->stats.ticks_per_ms;
+	new_value = diff->new->stats.min_ticks / diff->new->stats.ticks_per_ms;
+	if (old_value < 1 || new_value < 1) {
+	    old_value *= 1000;
+	    new_value *= 1000;
+	    printf ("%6.2f?s %4.2f%% -> %6.2f?s %4.2f%%: %5.2fx ",
+		    old_value, diff->old->stats.std_dev * 100,
+		    new_value, diff->new->stats.std_dev * 100,
+		    change);
+	} else {
+	    printf ("%6.2fms %4.2f%% -> %6.2fms %4.2f%%: %5.2fx ",
+		    old_value, diff->old->stats.std_dev * 100,
+		    new_value, diff->new->stats.std_dev * 100,
+		    change);
+	}
 
 	if (diff->speedup > 1.0)
 	    printf ("speedup\n");
-- 
1.4.1

From chris at chris-wilson.co.uk  Tue Mar 13 13:57:33 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Tue Mar 13 13:57:42 2007
Subject: [cairo] Clear the glyph caches on XCloseDisplay
Message-ID: <20070313205733.GA26420@inspired.chris-wilson.co.uk>

After introducing the use of ->cleanup() for cairo-perf, failures were
noticed in the xlib backend. These were due to not releasing the XRender
glyph cache after closing the display, and reusing the old data with a
new display.

This series of patches introduces a hook into the
_cairo_xlib_close_display() routine and uses it to reset the cached
data.
-------------- next part --------------
>From b83a8768857e13a380b5b13367246d88e2930806 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 20:11:49 +0000
Subject: [PATCH] Introduce hooks for _cairo_xlib_close_display()

This patch adds a simple hook data type for a notifier style callback
and introduces two functions to manipulate a list of callbacks for
cleaning up on display closure.
---
 src/cairo-xlib-private.h |   15 +++++
 src/cairo-xlib-screen.c  |  153 ++++++++++++++++++++++++++++++++++++----------
 2 files changed, 136 insertions(+), 32 deletions(-)

diff --git a/src/cairo-xlib-private.h b/src/cairo-xlib-private.h
index ddac05a..8ba46a2 100644
--- a/src/cairo-xlib-private.h
+++ b/src/cairo-xlib-private.h
@@ -37,6 +37,14 @@
 #include "cairo-xlib.h"
 
 typedef struct _cairo_xlib_screen_info cairo_xlib_screen_info_t;
+typedef struct _cairo_xlib_hook cairo_xlib_hook_t;
+
+struct _cairo_xlib_hook {
+    cairo_xlib_hook_t *next;
+    void (*func) (Display *display, void *data);
+    void *data;
+    void *key;
+};
 
 struct _cairo_xlib_screen_info {
     cairo_xlib_screen_info_t *next;
@@ -46,11 +54,18 @@ struct _cairo_xlib_screen_info {
     cairo_bool_t has_render;
 
     cairo_font_options_t font_options;
+
+    cairo_xlib_hook_t *close_display_hooks;
 };
 
 cairo_private cairo_xlib_screen_info_t *
 _cairo_xlib_screen_info_get (Display *display, Screen *screen);
 
+cairo_private cairo_bool_t
+_cairo_xlib_add_close_display_hook (Display *display, void (*func) (Display *, void *), void *data, void *key);
+cairo_private void
+_cairo_xlib_remove_close_display_hook (Display *display, void *key);
+
 #if CAIRO_HAS_XLIB_XRENDER_SURFACE
 
 #include "cairo-xlib-xrender.h"
diff --git a/src/cairo-xlib-screen.c b/src/cairo-xlib-screen.c
index 2316fe1..4c34608 100644
--- a/src/cairo-xlib-screen.c
+++ b/src/cairo-xlib-screen.c
@@ -247,31 +247,36 @@ CAIRO_MUTEX_DECLARE(_xlib_screen_mutex);
 
 static cairo_xlib_screen_info_t *_cairo_xlib_screen_list = NULL;
 
-/* XXX: From this function we should also run through and cleanup
- * anything else that still has a pointer to this Display*. For
- * example, we should clean up any Xlib-specific glyph caches. */
 static int
 _cairo_xlib_close_display (Display *dpy, XExtCodes *codes)
 {
-    cairo_xlib_screen_info_t *info, *prev;
+    cairo_xlib_screen_info_t *info, **prev, *next;
 
     /*
      * Unhook from the global list
      */
     CAIRO_MUTEX_LOCK (_xlib_screen_mutex);
 
-    prev = NULL;
-    for (info = _cairo_xlib_screen_list; info; info = info->next) {
+    prev = &_cairo_xlib_screen_list;
+    for (info = _cairo_xlib_screen_list; info; info = next) {
+	next = info->next;
 	if (info->display == dpy) {
-	    if (prev)
-		prev->next = info->next;
-	    else
-		_cairo_xlib_screen_list = info->next;
+	    *prev = next;
+	    /* call all registered shutdown routines */
+	    while (info->close_display_hooks) {
+		cairo_xlib_hook_t *hook = info->close_display_hooks;
+		info->close_display_hooks = hook->next;
+
+		hook->func (dpy, hook->data);
+
+		free (hook);
+	    }
 	    free (info);
-	    break;
+	} else {
+	    prev = &info->next;
 	}
-	prev = info;
     }
+    *prev = NULL;
     CAIRO_MUTEX_UNLOCK (_xlib_screen_mutex);
 
     /* Return value in accordance with requirements of
@@ -291,6 +296,11 @@ _cairo_xlib_screen_info_reset (void)
 
     for (info = _cairo_xlib_screen_list; info; info = next) {
 	next = info->next;
+	while (info->close_display_hooks) {
+	    cairo_xlib_hook_t *hook = info->close_display_hooks;
+	    info->close_display_hooks = hook->next;
+	    free (hook);
+	}
 	free (info);
     }
 
@@ -300,8 +310,8 @@ _cairo_xlib_screen_info_reset (void)
 
 }
 
-cairo_xlib_screen_info_t *
-_cairo_xlib_screen_info_get (Display *dpy, Screen *screen)
+static cairo_xlib_screen_info_t *
+_cairo_xlib_screen_info_get_unlocked (Display *dpy, Screen *screen)
 {
     cairo_xlib_screen_info_t *info;
     cairo_xlib_screen_info_t **prev;
@@ -309,26 +319,15 @@ _cairo_xlib_screen_info_get (Display *dpy, Screen *screen)
     XExtCodes *codes;
     cairo_bool_t seen_display = FALSE;
 
-    /* There is an apparent deadlock between this mutex and the
-     * mutex for the display, but it's actually safe. For the
-     * app to call XCloseDisplay() while any other thread is
-     * inside this function would be an error in the logic
-     * app, and the CloseDisplay hook is the only other place we
-     * acquire this mutex.
-     */
-    CAIRO_MUTEX_LOCK (_xlib_screen_mutex);
-
     for (prev = &_cairo_xlib_screen_list; (info = *prev); prev = &(*prev)->next)
     {
 	if (info->display == dpy) {
 	    seen_display = TRUE;
-	    if (info->screen == screen)
-	    {
+	    if (info->screen == screen || screen == NULL) {
 		/*
 		 * MRU the list
 		 */
-		if (prev != &_cairo_xlib_screen_list)
-		{
+		if (prev != &_cairo_xlib_screen_list) {
 		    *prev = info->next;
 		    info->next = _cairo_xlib_screen_list;
 		    _cairo_xlib_screen_list = info;
@@ -339,18 +338,17 @@ _cairo_xlib_screen_info_get (Display *dpy, Screen *screen)
     }
 
     if (info)
-	goto out;
+	return info;
 
     info = malloc (sizeof (cairo_xlib_screen_info_t));
     if (!info)
-	goto out;
+	return NULL;
 
     if (!seen_display) {
 	codes = XAddExtension (dpy);
 	if (!codes) {
 	    free (info);
-	    info = NULL;
-	    goto out;
+	    return NULL;
 	}
 
 	XESetCloseDisplay (dpy, codes->extension, _cairo_xlib_close_display);
@@ -361,17 +359,108 @@ _cairo_xlib_screen_info_get (Display *dpy, Screen *screen)
     info->has_render = (XRenderQueryExtension (dpy, &event_base, &error_base) &&
 			(XRenderFindVisualFormat (dpy, DefaultVisual (dpy, DefaultScreen (dpy))) != 0));
 
+    info->close_display_hooks = NULL;
+
     _cairo_xlib_init_screen_font_options (info);
 
     info->next = _cairo_xlib_screen_list;
     _cairo_xlib_screen_list = info;
 
- out:
+    return info;
+}
+cairo_xlib_screen_info_t *
+_cairo_xlib_screen_info_get (Display *dpy, Screen *screen)
+{
+    cairo_xlib_screen_info_t *info;
+
+    /* There is an apparent deadlock between this mutex and the
+     * mutex for the display, but it's actually safe. For the
+     * app to call XCloseDisplay() while any other thread is
+     * inside this function would be an error in the logic
+     * app, and the CloseDisplay hook is the only other place we
+     * acquire this mutex.
+     */
+    CAIRO_MUTEX_LOCK (_xlib_screen_mutex);
+
+    info = _cairo_xlib_screen_info_get_unlocked (dpy, screen);
+
     CAIRO_MUTEX_UNLOCK (_xlib_screen_mutex);
 
     return info;
 }
 
+cairo_bool_t
+_cairo_xlib_add_close_display_hook (Display *dpy, void (*func) (Display *, void *), void *data, void *key)
+{
+    cairo_xlib_screen_info_t *info;
+    cairo_xlib_hook_t *hook;
+    cairo_xlib_hook_t **prev;
+    cairo_bool_t success = FALSE;
+
+    CAIRO_MUTEX_LOCK (_xlib_screen_mutex);
+
+    info = _cairo_xlib_screen_info_get_unlocked (dpy,  NULL);
+    if (!info)
+	goto unlock;
+
+    for (prev = &info->close_display_hooks; (hook = *prev); prev = &hook->next)
+    {
+	if (hook->key == key) {
+	    /*
+	     * MRU the list
+	     */
+	    if (prev != &info->close_display_hooks) {
+		*prev = hook->next;
+		hook->next = info->close_display_hooks;
+		info->close_display_hooks = hook;
+	    }
+	    break;
+	}
+    }
+
+    if (!hook) {
+	hook = malloc (sizeof (cairo_xlib_hook_t));
+	if (!hook)
+	    goto unlock;
+	hook->func = func;
+	hook->data = data;
+	hook->key = key;
+	hook->next = info->close_display_hooks;
+	info->close_display_hooks = hook;
+    }
+
+    success = TRUE;
+ unlock:
+    CAIRO_MUTEX_UNLOCK (_xlib_screen_mutex);
+    return success;
+}
+
+void
+_cairo_xlib_remove_close_display_hook (Display *dpy, void *key)
+{
+    cairo_xlib_screen_info_t *info;
+    cairo_xlib_hook_t *hook;
+    cairo_xlib_hook_t **prev;
+
+    CAIRO_MUTEX_LOCK (_xlib_screen_mutex);
+
+    info = _cairo_xlib_screen_info_get_unlocked (dpy, NULL);
+    if (!info)
+	goto unlock;
+
+    for (prev = &info->close_display_hooks; (hook = *prev); prev = &hook->next)
+    {
+	if (hook->key == key) {
+	    *prev = hook->next;
+	    free (hook);
+	    break;
+	}
+    }
+
+unlock:
+    CAIRO_MUTEX_UNLOCK (_xlib_screen_mutex);
+}
+
 void
 _cairo_xlib_screen_reset_static_data (void)
 {
-- 
1.4.4.2

-------------- next part --------------
>From 9da9ef046952f3ba4b3c76c2106e2ec4d357bbce Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 20:42:09 +0000
Subject: [PATCH] Privately export a function to reset the scaled font's glyph caches.

---
 src/cairo-scaled-font.c |    9 +++++++++
 src/cairoint.h          |    3 +++
 2 files changed, 12 insertions(+), 0 deletions(-)

diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 0162a0d..6efde80 100755
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -391,6 +391,15 @@ _cairo_scaled_font_thaw_cache (cairo_scaled_font_t *scaled_font)
 }
 
 void
+_cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font)
+{
+    _cairo_cache_destroy (scaled_font->glyphs);
+    scaled_font->glyphs = _cairo_cache_create (_cairo_scaled_glyph_keys_equal,
+					       _cairo_scaled_glyph_destroy,
+					       max_glyphs_cached_per_font);
+}
+
+void
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics)
 {
diff --git a/src/cairoint.h b/src/cairoint.h
index 3251950..10c546d 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -1628,6 +1628,9 @@ cairo_private void
 _cairo_scaled_font_thaw_cache (cairo_scaled_font_t *scaled_font);
 
 cairo_private void
+_cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font);
+
+cairo_private void
 _cairo_scaled_font_set_error (cairo_scaled_font_t *scaled_font,
 			      cairo_status_t status);
 
-- 
1.4.4.2

-------------- next part --------------
>From 7980bd3c65ad7540706eacb3f4d40d9c66a2b776 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 20:17:22 +0000
Subject: [PATCH] Clear the XRender data on display closure.

Use the new hook functions to register a callback for xlib to clear
the private glyph data when the display is closed. In order to do this
we need to reset the glyph cache inside the generic scaled font as well.
---
 src/cairo-xlib-surface.c |   25 +++++++++++++++++++++++++
 1 files changed, 25 insertions(+), 0 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 6a0d3e4..49cb00f 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -2268,6 +2268,24 @@ typedef struct _cairo_xlib_surface_font_private {
     XRenderPictFormat	*xrender_format;
 } cairo_xlib_surface_font_private_t;
 
+static void
+_cairo_xlib_surface_remove_scaled_font (Display *dpy,
+	                               void    *data)
+{
+    cairo_scaled_font_t *scaled_font = data;
+    cairo_xlib_surface_font_private_t	*font_private = scaled_font->surface_private;
+
+    _cairo_scaled_font_reset_cache (scaled_font);
+
+    /* separate function to avoid deadlock if we tried to remove the
+     * close display hook ala _cairo_xlib_surface_scaled_font_fini() */
+    if (font_private) {
+	XRenderFreeGlyphSet (font_private->dpy, font_private->glyphset);
+	free (font_private);
+	scaled_font->surface_private = NULL;
+    }
+}
+
 static cairo_status_t
 _cairo_xlib_surface_font_init (Display		    *dpy,
 			       cairo_scaled_font_t  *scaled_font,
@@ -2275,6 +2293,11 @@ _cairo_xlib_surface_font_init (Display		    *dpy,
 {
     cairo_xlib_surface_font_private_t	*font_private;
 
+    if (!_cairo_xlib_add_close_display_hook (dpy,
+	       	_cairo_xlib_surface_remove_scaled_font,
+	       	scaled_font, scaled_font))
+	return CAIRO_STATUS_NO_MEMORY;
+
     font_private = malloc (sizeof (cairo_xlib_surface_font_private_t));
     if (!font_private)
 	return CAIRO_STATUS_NO_MEMORY;
@@ -2285,6 +2308,7 @@ _cairo_xlib_surface_font_init (Display		    *dpy,
     font_private->glyphset = XRenderCreateGlyphSet (dpy, font_private->xrender_format);
     scaled_font->surface_private = font_private;
     scaled_font->surface_backend = &cairo_xlib_surface_backend;
+
     return CAIRO_STATUS_SUCCESS;
 }
 
@@ -2294,6 +2318,7 @@ _cairo_xlib_surface_scaled_font_fini (cairo_scaled_font_t *scaled_font)
     cairo_xlib_surface_font_private_t	*font_private = scaled_font->surface_private;
 
     if (font_private) {
+	_cairo_xlib_remove_close_display_hook (font_private->dpy, scaled_font);
 	XRenderFreeGlyphSet (font_private->dpy, font_private->glyphset);
 	free (font_private);
     }
-- 
1.4.4.2

-------------- next part --------------
>From b8d739bf3c29dfe9c7479bd3dcadef52fcc63a87 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 20:45:39 +0000
Subject: [PATCH] Whitespace.

---
 src/cairo-xlib-surface.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 49cb00f..49bdaae 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -2294,8 +2294,8 @@ _cairo_xlib_surface_font_init (Display		    *dpy,
     cairo_xlib_surface_font_private_t	*font_private;
 
     if (!_cairo_xlib_add_close_display_hook (dpy,
-	       	_cairo_xlib_surface_remove_scaled_font,
-	       	scaled_font, scaled_font))
+		_cairo_xlib_surface_remove_scaled_font,
+		scaled_font, scaled_font))
 	return CAIRO_STATUS_NO_MEMORY;
 
     font_private = malloc (sizeof (cairo_xlib_surface_font_private_t));
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Tue Mar 13 16:29:02 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Tue Mar 13 16:29:09 2007
Subject: [cairo] Cache solid patterns
Message-ID: <20070313232902.GB26420@inspired.chris-wilson.co.uk>

This is the old solid colour surface cache moved up a level to cache
the allocated patterns. This is important for toolkits such as GTK+,
which tend to use a small colour palette across many widgets and trigger
frequent reallocation of the same solid patterns.
-------------- next part --------------
>From d03b6613880eb0ae0d7b4431b23ad48d8a146ae1 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 22:51:12 +0000
Subject: [PATCH] Cache solid patterns

We use a small cache of size 16 for patterns created from solid colors,
e.g. cairo_set_source_rgb(). This helps with toolkits that draw many
widgets using the same colour scheme.

The cache uses a static index variable, which itself acts like a cache
of size 1, remembering the most recently used colour. So repeated
lookups for the same colour hit immediately. If that fails, the cache
is searched linearly, and if that fails too, a new pattern is created
and a random member of the cache is evicted.
---
 src/cairo-color.c   |    7 +++++
 src/cairo-debug.c   |    2 +
 src/cairo-pattern.c |   65 +++++++++++++++++++++++++++++++++++++++++++++++++-
 src/cairoint.h      |    7 +++++
 4 files changed, 79 insertions(+), 2 deletions(-)

diff --git a/src/cairo-color.c b/src/cairo-color.c
index a348839..ec3799c 100644
--- a/src/cairo-color.c
+++ b/src/cairo-color.c
@@ -159,3 +159,10 @@ _cairo_color_get_rgba_premultiplied (cairo_color_t *color,
     *blue  = color->blue  * color->alpha;
     *alpha = color->alpha;
 }
+
+cairo_bool_t
+_cairo_color_equal (const cairo_color_t *color_a,
+	            const cairo_color_t *color_b)
+{
+    return memcmp (color_a, color_b, sizeof (cairo_color_t)) == 0;
+}
diff --git a/src/cairo-debug.c b/src/cairo-debug.c
index 7c29932..dd57dd7 100644
--- a/src/cairo-debug.c
+++ b/src/cairo-debug.c
@@ -68,4 +68,6 @@ cairo_debug_reset_static_data (void)
 #if CAIRO_HAS_FT_FONT
     _cairo_ft_font_reset_static_data ();
 #endif
+
+    _cairo_pattern_reset_static_data ();
 }
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index efa0c5a..6287378 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -252,18 +252,79 @@ _cairo_pattern_init_radial (cairo_radial_pattern_t *pattern,
     pattern->gradient.c2.radius = _cairo_fixed_from_double (fabs (radius1));
 }
 
+/* We use a small cache here, because we don't want to constantly
+ * reallocate simple colors. */
+#define MAX_PATTERN_CACHE_SIZE 16
+static struct {
+    struct {
+	cairo_color_t          color;
+	cairo_solid_pattern_t *pattern;
+    } cache[MAX_PATTERN_CACHE_SIZE];
+    int size;
+} solid_pattern_cache;
+
+CAIRO_MUTEX_DECLARE (solid_pattern_cache_lock);
+
 cairo_pattern_t *
 _cairo_pattern_create_solid (const cairo_color_t *color)
 {
-    cairo_solid_pattern_t *pattern;
+    static int cache_index;
+    void *pattern;
+
+    CAIRO_MUTEX_LOCK (solid_pattern_cache_lock);
+
+    /* Check cache first. */
+    if (cache_index < solid_pattern_cache.size &&
+	    _cairo_color_equal (
+		&solid_pattern_cache.cache[cache_index].color, color))
+	goto DONE;
 
+    for (cache_index = 0; cache_index < solid_pattern_cache.size; cache_index++)
+	if (_cairo_color_equal (
+		    &solid_pattern_cache.cache[cache_index].color, color))
+	    goto DONE;
+
+    /* Not cached, need to create a new pattern. */
     pattern = malloc (sizeof (cairo_solid_pattern_t));
     if (pattern == NULL)
 	return (cairo_pattern_t *) &cairo_pattern_nil.base;
 
     _cairo_pattern_init_solid (pattern, color);
 
-    return &pattern->base;
+    /* And insert it into the cache. */
+    if (solid_pattern_cache.size < MAX_PATTERN_CACHE_SIZE) {
+	solid_pattern_cache.size ++;
+	/* cache_index == solid_pattern_cache.size */
+    } else { 
+	/* Evict an old pattern. */
+	cache_index = rand () % MAX_PATTERN_CACHE_SIZE;
+	cairo_pattern_destroy (
+		&solid_pattern_cache.cache[cache_index].pattern->base);
+    }
+
+    solid_pattern_cache.cache[cache_index].color = *color;
+    solid_pattern_cache.cache[cache_index].pattern = pattern;
+
+DONE:
+    pattern = cairo_pattern_reference (
+	    &solid_pattern_cache.cache[cache_index].pattern->base);
+    CAIRO_MUTEX_UNLOCK (solid_pattern_cache_lock);
+
+    return pattern;
+}
+
+void
+_cairo_pattern_reset_static_data (void)
+{
+    int i;
+
+    CAIRO_MUTEX_LOCK (solid_pattern_cache_lock);
+
+    for (i = 0; i < solid_pattern_cache.size; i++)
+	cairo_pattern_destroy (&solid_pattern_cache.cache[i].pattern->base);
+    solid_pattern_cache.size = 0;
+
+    CAIRO_MUTEX_UNLOCK (solid_pattern_cache_lock);
 }
 
 static const cairo_pattern_t *
diff --git a/src/cairoint.h b/src/cairoint.h
index 3251950..6cb31b6 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -1619,6 +1619,10 @@ _cairo_color_get_rgba_premultiplied (cairo_color_t *color,
 				     double	   *blue,
 				     double	   *alpha);
 
+cairo_private cairo_bool_t
+_cairo_color_equal (const cairo_color_t *color_a,
+                    const cairo_color_t *color_b);
+
 /* cairo-font.c */
 
 cairo_private void
@@ -2477,6 +2481,9 @@ cairo_private cairo_status_t
 _cairo_pattern_get_extents (cairo_pattern_t	    *pattern,
 			    cairo_rectangle_int16_t *extents);
 
+cairo_private void
+_cairo_pattern_reset_static_data (void);
+
 cairo_private cairo_status_t
 _cairo_gstate_set_antialias (cairo_gstate_t *gstate,
 			     cairo_antialias_t antialias);
-- 
1.4.4.2

-------------- next part --------------
>From 0b27d6dd2b76e3209265f2fe00d67bb43a510da7 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 13 Mar 2007 23:16:20 +0000
Subject: [PATCH] A very simple stress test for the pattern cache.

---
 test/Makefile.am                  |    1 +
 test/solid-pattern-cache-stress.c |   83 +++++++++++++++++++++++++++++++++++++
 2 files changed, 84 insertions(+), 0 deletions(-)

diff --git a/test/Makefile.am b/test/Makefile.am
index ea4787c..74de256 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -85,6 +85,7 @@ self-copy			\
 self-intersecting		\
 set-source			\
 show-text-current-point		\
+solid-pattern-cache-stress	\
 source-clip			\
 source-clip-scale		\
 source-surface-scale-paint	\
diff --git a/test/solid-pattern-cache-stress.c b/test/solid-pattern-cache-stress.c
new file mode 100644
index 0000000..855c8b7
--- /dev/null
+++ b/test/solid-pattern-cache-stress.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright ? 2007 Chris Wilson.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of
+ * Chris Wilson. not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission. Chris Wilson makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * CHRIS WILSON DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL CHRIS WILSON BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+ * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author: Chris Wilson <chris@chris-wilson.co.uk>
+ */
+
+#include "cairo-test.h"
+
+static cairo_test_draw_function_t draw;
+
+cairo_test_t test = {
+    "solid-pattern-cache-stress",
+    "Stress the solid pattern cache and ensure it behaves",
+    0, 0,
+    draw
+};
+#include <cairo.h>
+#include <stdlib.h>
+
+#define LOOPS 10
+#define NRAND 100
+
+static cairo_test_status_t
+draw (cairo_t *cr, int width, int height)
+{
+    int loop;
+    int i;
+
+    for (loop = 0; loop < LOOPS; loop++) {
+	cairo_set_source_rgb (cr, 0.0, 0.0, 0.0); /* black */
+	cairo_set_source_rgb (cr, 1.0, 0.0, 0.0); /* red */
+	cairo_set_source_rgb (cr, 0.0, 1.0, 0.0); /* green */
+	cairo_set_source_rgb (cr, 1.0, 1.0, 0.0); /* yellow */
+	cairo_set_source_rgb (cr, 0.0, 0.0, 1.0); /* blue */
+	cairo_set_source_rgb (cr, 1.0, 0.0, 1.0); /* magenta */
+	cairo_set_source_rgb (cr, 0.0, 1.0, 1.0); /* cyan */
+	cairo_set_source_rgb (cr, 1.0, 1.0, 1.0); /* white */
+
+	cairo_set_source_rgba (cr, 0.0, 0.0, 0.0, 1.0); /* black */
+	cairo_set_source_rgba (cr, 1.0, 0.0, 0.0, 1.0); /* red */
+	cairo_set_source_rgba (cr, 0.0, 1.0, 0.0, 1.0); /* green */
+	cairo_set_source_rgba (cr, 1.0, 1.0, 0.0, 1.0); /* yellow */
+	cairo_set_source_rgba (cr, 0.0, 0.0, 1.0, 1.0); /* blue */
+	cairo_set_source_rgba (cr, 1.0, 0.0, 1.0, 1.0); /* magenta */
+	cairo_set_source_rgba (cr, 0.0, 1.0, 1.0, 1.0); /* cyan */
+	cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, 1.0); /* white */
+
+	for (i = 0; i < NRAND; i++)
+	    cairo_set_source_rgba (cr,
+		                   drand48 (),
+				   drand48 (),
+				   drand48 (),
+				   drand48 ());
+    }
+
+    return CAIRO_TEST_SUCCESS;
+}
+
+int
+main (void)
+{
+    return cairo_test (&test);
+}
+
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Tue Mar 13 18:50:27 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Tue Mar 13 18:50:32 2007
Subject: [cairo] Use stack buffer for _cairo_surface_fill_region()
Message-ID: <20070314015026.GA18428@inspired.chris-wilson.co.uk>

I don't know just how many times this patch may arrive at the list as I
was experimenting with git-format-patch and piping to mutt. Since I've
not seen the message yet, I assume the experiment failed.

This is a simple patch to use a stack buffer for
_cairo_surface_fill_region() when the num_rects does not exceed
CAIRO_STACK_BUFFER_SIZE / sizeof (cairo_rectangle_in16_t). This is
another function that is called for almost every GTK+ expose event
(assuming double-buffered widgets) and so a frequent allocator.
--
Chris Wilson
-------------- next part --------------
>From ef3ecca582496f2370a5ed8b05aa3f791c9e3d65 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 14 Mar 2007 01:31:58 +0000
Subject: [PATCH] Use a stack buffer for small numbers of rectangles.

---
 src/cairo-surface.c |   13 +++++++++----
 1 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index 5dbac58..da093db 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -1164,6 +1164,7 @@ _cairo_surface_fill_region (cairo_surface_t	   *surface,
 {
     int num_rects = pixman_region_num_rects (region);
     pixman_box16_t *boxes = pixman_region_rects (region);
+    cairo_rectangle_int16_t stack_rects[CAIRO_STACK_BUFFER_SIZE / sizeof (cairo_rectangle_int16_t)];
     cairo_rectangle_int16_t *rects;
     cairo_status_t status;
     int i;
@@ -1173,9 +1174,12 @@ _cairo_surface_fill_region (cairo_surface_t	   *surface,
     if (!num_rects)
 	return CAIRO_STATUS_SUCCESS;
 
-    rects = malloc (sizeof (pixman_rectangle_t) * num_rects);
-    if (!rects)
-	return CAIRO_STATUS_NO_MEMORY;
+    rects = stack_rects;
+    if (num_rects > sizeof (stack_rects) / sizeof (stack_rects[0])) {
+	rects = malloc (sizeof (cairo_rectangle_int16_t) * num_rects);
+	if (!rects)
+	    return CAIRO_STATUS_NO_MEMORY;
+    }
 
     for (i = 0; i < num_rects; i++) {
 	rects[i].x = boxes[i].x1;
@@ -1187,7 +1191,8 @@ _cairo_surface_fill_region (cairo_surface_t	   *surface,
     status =  _cairo_surface_fill_rectangles (surface, op,
 					      color, rects, num_rects);
 
-    free (rects);
+    if (rects != stack_rects)
+	free (rects);
 
     return status;
 }
-- 
1.4.4.2

From mathias.hasselmann at gmx.de  Wed Mar 14 05:19:14 2007
From: mathias.hasselmann at gmx.de (Mathias Hasselmann)
Date: Wed Mar 14 05:26:08 2007
Subject: [cairo] Matrix visualization of cairo-perf-diff output
Message-ID: <1173874754.12859.4.camel@localhost>

Want to know quickly, which tests of cairo-perf where affected by my
patches. Therefore I've hacked some little Python script to visualise
the output of cairo-perf-diff as matrix. Attached you'll find the script
and the output for my static-regions2 branch.

Ciao,
Mathias
-------------- next part --------------
A non-text attachment was scrubbed...
Name: perf-matrix
Type: text/x-python
Size: 1765 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070314/9ba35312/perf-matrix.py
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070314/9ba35312/perf-matrix.html
From stevech1097 at yahoo.com.au  Wed Mar 14 03:51:00 2007
From: stevech1097 at yahoo.com.au (Steve Chaplin)
Date: Wed Mar 14 08:13:10 2007
Subject: [cairo] [cairo-announce] ANN: pycairo release 1.4.0 now available
Message-ID: <1173869460.840.2.camel@localhost.localdomain>

Pycairo is a set of Python bindings for the multi-platform 2D graphics
library cairo.
 http://cairographics.org
 http://cairographics.org/pycairo

A new pycairo release 1.4.0 is now available from:

        http://cairographics.org/releases/pycairo-1.4.0.tar.gz
        http://cairographics.org/releases/pycairo-1.4.0.tar.gz.md5

        e26e77919b606113f565d70036c1f504  pycairo-1.4.0.tar.gz

Overview of changes from pycairo 1.2.6 to pycairo 1.4.0
=======================================================
General changes:
Pycairo 1.4.0 requires cairo 1.4.0 (or later).

New methods:
    Context.clip_extents
    Context.copy_clip_rectangles
    Context.get_dash
    Context.get_dash_count
    Context.get_scaled_font
    Context.glyph_extents
    Context.glyph_path
    Context.show_glyphs
    LinearGradient.get_linear_points
    RadialGradient.get_radial_circles
    SolidPattern.get_rgba
    SurfacePattern.get_surface

Deleted methods:
    ImageSurface.create_for_array
    Remove Numeric Python support, since Numeric has been made obsolete
    by numpy, and numpy data can be read using
    ImageSurface.create_for_data.

Other changes:
    the module cairo.gtk has been removed (pygtk 2.7.0 onwards has cairo
    support built in).


Send instant messages to your online friends http://au.messenger.yahoo.com 
_______________________________________________
cairo-announce mailing list
cairo-announce@cairographics.org
http://cairographics.org/cgi-bin/mailman/listinfo/cairo-announce
From murrayc at murrayc.com  Wed Mar 14 08:05:08 2007
From: murrayc at murrayc.com (Murray Cumming)
Date: Wed Mar 14 08:40:58 2007
Subject: [cairo] Early Initialization?
Message-ID: <1173884708.5780.19.camel@murrayc-desktop>

The maemo-launcher project reduces application startup time by
initializing GTK+ before applications start:
http://maemo.org/lxr/source/maemo-launcher/README

I wonder, is there any Cairo initialization that we can do at that time?
For GTK+ 2.6 maemo-launcher initialized Xft, so maybe there's an
equivalent for GTK+ 2.10.

-- 
Murray Cumming
murrayc@murrayc.com
www.murrayc.com
www.openismus.com

From brian.ewins at gmail.com  Wed Mar 14 09:28:03 2007
From: brian.ewins at gmail.com (Baz)
Date: Wed Mar 14 10:07:22 2007
Subject: [cairo] Any objections to dropping
	_cairo_atsui_font_old_show_glyphs?
Message-ID: <2faad3050703140928u27cd1969ma42986583ab39df5@mail.gmail.com>

Just looking for comment on this. _cairo_atsui_font_old_show_glyphs
was used to display glyphs under the old quartz code, for all
surfaces. More recently its become unnecessary for any surface and in
fact only gets used in these (rare) circumstances:

- atsui text is being rendered to a quartz surface
- and we cannot render the text in cairo-quartz-surface (this happens
because, eg we cannot convert a pattern to a CGShadingRef);
- and we can extract a destination image surface from the quartz
surface. The code looks like the original quartz surface could be
used, but this is actually unreachable.
- and we can create a CGBitmapContext matching the destination image
surface. This should always succeed.

If any of that fails it ends up using glyph surfaces, which should
work anyway - they are used for all non-quartz surfaces.

Does anyone see this code[1] getting used in the real world? It isn't
being hit by any of the tests any more, but of course its still just
as buggy as it was with the old quartz :). If no-one is actually using
it, I think we'd be better off without.

The cut would just be 150 lines or so. Some of this comes from
inlining what little of of cairo-atsui's
CGBitmapContextCreateWithCairoImageSurface is still required.

Cheers,
Baz
From cworth at cworth.org  Wed Mar 14 10:09:18 2007
From: cworth at cworth.org (Carl Worth)
Date: Wed Mar 14 10:09:57 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <1173884708.5780.19.camel@murrayc-desktop>
References: <1173884708.5780.19.camel@murrayc-desktop>
Message-ID: <87k5xjycox.wl%cworth@cworth.org>

On Wed, 14 Mar 2007 16:05:08 +0100, Murray Cumming wrote:
> I wonder, is there any Cairo initialization that we can do at that time?
> For GTK+ 2.6 maemo-launcher initialized Xft, so maybe there's an
> equivalent for GTK+ 2.10.

With GTK+ 2.10, cairo does replace Xft, and there's probably some
non-trivial application startup time to be saved there, (I'm thinking
of fontconfig initialization).

But I don't know what would be the right sequence of cairo calls to
make to force that, (we don't have anything like cairo_init, and even
cairo_create;cairo_destroy is optimized for lazy creation of fonts and
such, so that wouldn't even help).

Maybe all you need is a call to cairo_font_extents() ?

Anyone else have some better suggestion here?

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070314/b525b85c/attachment.pgp
From behdad at behdad.org  Wed Mar 14 11:02:56 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 14 11:02:52 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <87k5xjycox.wl%cworth@cworth.org>
References: <1173884708.5780.19.camel@murrayc-desktop>
	<87k5xjycox.wl%cworth@cworth.org>
Message-ID: <1173895376.14946.2.camel@behdad>

On Wed, 2007-03-14 at 13:09 -0400, Carl Worth wrote:
> On Wed, 14 Mar 2007 16:05:08 +0100, Murray Cumming wrote:
> > I wonder, is there any Cairo initialization that we can do at that time?
> > For GTK+ 2.6 maemo-launcher initialized Xft, so maybe there's an
> > equivalent for GTK+ 2.10.
> 
> With GTK+ 2.10, cairo does replace Xft, and there's probably some
> non-trivial application startup time to be saved there, (I'm thinking
> of fontconfig initialization).
> 
> But I don't know what would be the right sequence of cairo calls to
> make to force that, (we don't have anything like cairo_init, and even
> cairo_create;cairo_destroy is optimized for lazy creation of fonts and
> such, so that wouldn't even help).
> 
> Maybe all you need is a call to cairo_font_extents() ?
> 
> Anyone else have some better suggestion here?

Create an image surface and render something in the default language and
default font ("Sans"?) to it using pangocairo.

I wanted to say create an X pixmap, but I figure the launcher has to
close the display and reopen it...

> -Carl

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Wed Mar 14 11:04:19 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 14 11:04:15 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <1173895376.14946.2.camel@behdad>
References: <1173884708.5780.19.camel@murrayc-desktop>
	<87k5xjycox.wl%cworth@cworth.org>  <1173895376.14946.2.camel@behdad>
Message-ID: <1173895459.14946.4.camel@behdad>

On Wed, 2007-03-14 at 14:02 -0400, Behdad Esfahbod wrote:
> On Wed, 2007-03-14 at 13:09 -0400, Carl Worth wrote:
> > On Wed, 14 Mar 2007 16:05:08 +0100, Murray Cumming wrote:
> > > I wonder, is there any Cairo initialization that we can do at that time?
> > > For GTK+ 2.6 maemo-launcher initialized Xft, so maybe there's an
> > > equivalent for GTK+ 2.10.
> > 
> > With GTK+ 2.10, cairo does replace Xft, and there's probably some
> > non-trivial application startup time to be saved there, (I'm thinking
> > of fontconfig initialization).
> > 
> > But I don't know what would be the right sequence of cairo calls to
> > make to force that, (we don't have anything like cairo_init, and even
> > cairo_create;cairo_destroy is optimized for lazy creation of fonts and
> > such, so that wouldn't even help).
> > 
> > Maybe all you need is a call to cairo_font_extents() ?
> > 
> > Anyone else have some better suggestion here?
> 
> Create an image surface and render something in the default language and
> default font ("Sans"?) to it using pangocairo.

For extra, do it for all font-descriptions that your UI uses (all
"default" font face+size combinations).

> I wanted to say create an X pixmap, but I figure the launcher has to
> close the display and reopen it...
> 
> > -Carl
> 
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Wed Mar 14 11:12:21 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 14 11:12:18 2007
Subject: [cairo] Any objections to dropping
	_cairo_atsui_font_old_show_glyphs?
In-Reply-To: <2faad3050703140928u27cd1969ma42986583ab39df5@mail.gmail.com>
References: <2faad3050703140928u27cd1969ma42986583ab39df5@mail.gmail.com>
Message-ID: <1173895942.14946.10.camel@behdad>

On Wed, 2007-03-14 at 12:28 -0400, Baz wrote:
> Just looking for comment on this. _cairo_atsui_font_old_show_glyphs
> was used to display glyphs under the old quartz code, for all
> surfaces. More recently its become unnecessary for any surface and in
> fact only gets used in these (rare) circumstances:
> 
> - atsui text is being rendered to a quartz surface
> - and we cannot render the text in cairo-quartz-surface (this happens
> because, eg we cannot convert a pattern to a CGShadingRef);
> - and we can extract a destination image surface from the quartz
> surface. The code looks like the original quartz surface could be
> used, but this is actually unreachable.
> - and we can create a CGBitmapContext matching the destination image
> surface. This should always succeed.
> 
> If any of that fails it ends up using glyph surfaces, which should
> work anyway - they are used for all non-quartz surfaces.
> 
> Does anyone see this code[1] getting used in the real world? It isn't
> being hit by any of the tests any more, but of course its still just
> as buggy as it was with the old quartz :). If no-one is actually using
> it, I think we'd be better off without.
> 
> The cut would just be 150 lines or so. Some of this comes from
> inlining what little of of cairo-atsui's
> CGBitmapContextCreateWithCairoImageSurface is still required.
> 
> Cheers,
> Baz

Go ahead from me!

Vlad, comments?

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From cworth at cworth.org  Wed Mar 14 15:14:37 2007
From: cworth at cworth.org (Carl Worth)
Date: Wed Mar 14 15:15:34 2007
Subject: [cairo] [PATCH] Altivec optimizations
In-Reply-To: <2faad3050703091636w760ae971pa851b9cb323424c6@mail.gmail.com>
References: <45D6DFF1.4080505@gentoo.org>
	<2faad3050703081719k12c612e3qcc3863887ccb85c4@mail.gmail.com>
	<2faad3050703081939i36cebe7cw6b6da9d850b57ccb@mail.gmail.com>
	<87slcf9gk2.wl%cworth@cworth.org>
	<2faad3050703091636w760ae971pa851b9cb323424c6@mail.gmail.com>
Message-ID: <87hcsnxyk2.wl%cworth@cworth.org>

On Sat, 10 Mar 2007 00:36:28 +0000, Baz wrote:
> On 09/03/07, Carl Worth <cworth@cworth.org> wrote:
> > That would be a bug in perf-diff.
>
> Thanks Carl, that had me scratching my head...

By the way, Mathias Hasselmann just pushed out a fix for this bug. Now
cairo-perf-diff will use the hashes of both src/ and pixman/src/ when
computing a cache file name.

And Mathias, welcome as our most recently added cairo maintainer!

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070314/43adf71e/attachment.pgp
From cworth at cworth.org  Wed Mar 14 17:39:26 2007
From: cworth at cworth.org (Carl Worth)
Date: Wed Mar 14 17:40:02 2007
Subject: [cairo] Clear the glyph caches on XCloseDisplay
In-Reply-To: <20070313205733.GA26420@inspired.chris-wilson.co.uk>
References: <20070313205733.GA26420@inspired.chris-wilson.co.uk>
Message-ID: <87fy87xrup.wl%cworth@cworth.org>

On Tue, 13 Mar 2007 20:57:33 +0000, Chris Wilson wrote:
> After introducing the use of ->cleanup() for cairo-perf, failures were
> noticed in the xlib backend. These were due to not releasing the XRender
> glyph cache after closing the display, and reusing the old data with a
> new display.

Thanks for the fix. I've pushed this out now, (it's very nice to be
able to use cairo-perf once again). And it's also quite nice to see
XXX comments disappearing from the code:

> -/* XXX: From this function we should also run through and cleanup
> - * anything else that still has a pointer to this Display*. For
> - * example, we should clean up any Xlib-specific glyph caches. */

Beautiful, just beautiful.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070314/0f63f93f/attachment.pgp
From jeff at infidigm.net  Thu Mar 15 11:22:03 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Thu Mar 15 11:20:23 2007
Subject: [cairo] slow path annotations
In-Reply-To: <20070308163748.GA12531@infidigm.net>
References: <20070308163748.GA12531@infidigm.net>
Message-ID: <20070315182203.GA26631@infidigm.net>

Here's an updated patch. It changes raise(5) to raise(SIGTRAP) and makes
cairo_path_with_alpha() a slow path (the explanation is inline).

-Jeff

diff --git a/pixman/src/fbcompose.c b/pixman/src/fbcompose.c
index 233b90c..8f5cb87 100644
--- a/pixman/src/fbcompose.c
+++ b/pixman/src/fbcompose.c
@@ -4206,6 +4206,10 @@ pixman_compositeGeneral (pixman_operator_t	op,
     CARD32 *scanline_buffer = _scanline_buffer;
     FbComposeData compose_data;
 
+    /* Don't treat gradients as a slow path because there is no fast path */
+    if (pSrc->pDrawable)
+	    pixman_slow_path();
+
     if (pSrc->pDrawable)
         srcRepeat = pSrc->repeat == RepeatNormal && !pSrc->transform
                     && (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1);
diff --git a/pixman/src/fbpict.c b/pixman/src/fbpict.c
index 0bd989f..af3ff26 100644
--- a/pixman/src/fbpict.c
+++ b/pixman/src/fbpict.c
@@ -1951,6 +1951,14 @@ pixman_composite (pixman_operator_t	op,
 
     n = pixman_region_num_rects (region);
     pbox = pixman_region_rects (region);
+
+    /* check for compositing a solid surface without a solid varient */
+    if (srcRepeat && pSrc->pDrawable &&
+		    pSrc->pDrawable->height == 1 &&
+		    pSrc->pDrawable->width == 1 &&
+		    (pbox->y2 - pbox->y1 > 1 || pbox->x2 - pbox->x1 > 1))
+	    pixman_slow_path();
+
     while (n--)
     {
 	h = pbox->y2 - pbox->y1;
diff --git a/pixman/src/icint.h b/pixman/src/icint.h
index 47a2220..8669337 100644
--- a/pixman/src/icint.h
+++ b/pixman/src/icint.h
@@ -117,6 +117,12 @@ typedef pixman_triangle_t	xTriangle;
 #define MAXSHORT SHRT_MAX
 #define MINSHORT SHRT_MIN
 
+#include <signal.h>
+static inline void pixman_slow_path(void)
+{
+	raise(SIGTRAP);
+}
+
 /* XXX: What do we need from here?
 #include "picture.h"
 */
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..3a0cf0f 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -284,14 +284,15 @@ _clip_and_composite_source (cairo_clip_t                  *clip,
     cairo_surface_pattern_t mask_pattern;
     cairo_status_t status;
 
+    /* Single composite operation becomes two.
+     * Two, that are likely not fast */
+    /* If you hit this maybe you should be using OVER instead of SOURCE */
+    cairo_slow_path();
+
     /* Create a surface that is mask IN clip
      */
-    status = _create_composite_mask_pattern (&mask_pattern,
-					     clip,
-					     draw_func, draw_closure,
-					     dst, extents);
-    if (status)
-	return status;
+    status = _create_composite_mask_pattern (&mask_pattern, clip, draw_func,
+		    draw_closure, dst, extents); if (status) return status;
 
     /* Compute dest' = dest OUT (mask IN clip)
      */
diff --git a/src/cairo.c b/src/cairo.c
index 21303de..3ab3146 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -1870,6 +1870,10 @@ cairo_paint_with_alpha (cairo_t *cr,
     _cairo_color_init_rgba (&color, 1., 1., 1., alpha);
     _cairo_pattern_init_solid (&pattern.solid, &color);
 
+    /* _cairo_pattern_init_solid will create a ARGB32 format surface
+     * masking through ARGB32 surfaces is not a fast path in pixman */
+    cairo_slow_path();
+
     cr->status = _cairo_gstate_mask (cr->gstate, &pattern.base);
     if (cr->status)
 	_cairo_set_error (cr, cr->status);
diff --git a/src/cairoint.h b/src/cairoint.h
index 0ac5961..33e4134 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -272,6 +272,12 @@ typedef cairo_fixed_16_16_t cairo_fixed_t;
 #define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) CAIRO_BITSWAP8(c)
 #endif
 
+#include <signal.h>
+static inline void cairo_slow_path(void)
+{
+	raise(SIGTRAP);
+}
+
 #ifdef WORDS_BIGENDIAN
 
 #define cpu_to_be16(v) (v)
From andre.nho at gmail.com  Fri Mar 16 04:58:37 2007
From: andre.nho at gmail.com (=?ISO-8859-1?Q?Andr=E9?= Wagner)
Date: Fri Mar 16 05:00:34 2007
Subject: [cairo] Scales, CTMs and transformations
Message-ID: <20070316085837.ad46d9d6.andre.nho@gmail.com>

Hello,

I'm kinda new to cairo, and I'm having trouble understanding the Scales/CTMs/Transformations concept. I read the "Cairo Tutorail for Python Programmers" and the API documentation, but with no success.

Is there any document that explain these concepts in a easier way?

Thank you in advance.

Andr?

-- 
A cura para o t?dio ? a curiosidade.
N?o h? cura para a curiosidade. (Dorothy Parker)
From cworth at cworth.org  Fri Mar 16 09:23:59 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar 16 09:24:49 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
Message-ID: <87zm6dw40w.wl%cworth@cworth.org>

Ever since 1.4.0 I'd been planning to update our ROADMAP and post
plans for all the fixes I wanted to see in 1.4.2, (originally thinking
of an early April release to be on time for the next GNOME update and
the Fedora freeze).

But now it looks like we've accrued enough critical fixes that I think
I'll just push out what we have already as 1.4.2, (and we can still
target early April for a subsequent 1.4.4 with the rest of the fixes
we originally had planned for 1.4.2). There are a couple of minor
little issues in bugzilla that I'll fix first.

If anybody has anything, (of a bug fix nature) they'd like to be sure
to get into the release today, please let me know, (here in email or
on IRC).

Thanks,

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070316/08575f0e/attachment.pgp
From chris at chris-wilson.co.uk  Fri Mar 16 09:40:45 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 16 09:40:52 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
Message-ID: <20070316164045.GB11712@inspired.chris-wilson.co.uk>

[Apologies Carl, replied to you instead of the list...]

Carl Worth (cworth@cworth.org) said: 
> If anybody has anything, (of a bug fix nature) they'd like to be sure
> to get into the release today, please let me know, (here in email or
> on IRC).

Following Behad's suggestion that Cairo really should suffer some
malloc-failure testing, I wrote a simple valgrind skin to randomly
return NULL.

The effort was justified as it's already pinpointed a few places that
needed some error checking.
--
Chris Wilson
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0003-Check-for-malloc-failure.patch
Type: text/x-diff
Size: 724 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070316/0a1233cf/0003-Check-for-malloc-failure.bin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0004-Check-for-malloc-failure.patch
Type: text/x-diff
Size: 752 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070316/0a1233cf/0004-Check-for-malloc-failure.bin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0005-Handle-and-return-out-of-memory-condition.patch
Type: text/x-diff
Size: 1736 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070316/0a1233cf/0005-Handle-and-return-out-of-memory-condition.bin
From chris at chris-wilson.co.uk  Fri Mar 16 09:59:11 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 16 09:59:17 2007
Subject: [cairo] Fault Injector
Message-ID: <20070316165911.GA4618@inspired.chris-wilson.co.uk>

Behdad made a very good suggestion that Cairo should undergo 
malloc-failure testing. We could either replace all calls to malloc and
kin with _cairo_malloc() and implement a system similar to dbus. Or do
something similar with LD_PRELOAD (except becareful for calls outside of
Cairo that do not handle a NULL return, e.g. in the test harnesses).

The method I chose was to make a very simple valgrind skin. The
fault-injector wraps malloc() and checks the callstack for named
functions (or simple cairo* style globs) and if found will randomly
fail. Similary it checks another list to see if should protect the
caller from failure.  For example,
$ ./libtool --mode=execute valgrind --tool=faultinjector \
	--allow-regex=cairo* \
 	--deny-fn=xasprintf \
	--deny-fn=xmalloc \
	--deny-fn=cairo_create \
	perf/cairo-perf

Seems to be a good start. Patch against valgrind trunk. 
[memprof is included as well for good measure ;-]
--
Chris Wilson
From chris at chris-wilson.co.uk  Fri Mar 16 10:07:05 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 16 10:07:12 2007
Subject: [cairo] Fault Injector
In-Reply-To: <20070316165911.GA4618@inspired.chris-wilson.co.uk>
References: <20070316165911.GA4618@inspired.chris-wilson.co.uk>
Message-ID: <20070316170705.GC4618@inspired.chris-wilson.co.uk>

I wrote:
> Seems to be a good start. Patch against valgrind trunk. 
> [memprof is included as well for good measure ;-]

Oh no it wasn't...
--
Chris Wilson
-------------- next part --------------
A non-text attachment was scrubbed...
Name: vg_fi_mp.patch.gz
Type: application/octet-stream
Size: 11606 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070316/bcd260ea/vg_fi_mp.patch-0001.obj
From behdad at behdad.org  Fri Mar 16 11:40:18 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar 16 11:40:15 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <20070316164045.GB11712@inspired.chris-wilson.co.uk>
References: <20070316164045.GB11712@inspired.chris-wilson.co.uk>
Message-ID: <1174070418.30335.4.camel@behdad>

On Fri, 2007-03-16 at 12:40 -0400, Chris Wilson wrote:
> [Apologies Carl, replied to you instead of the list...]
> 
> Carl Worth (cworth@cworth.org) said: 
> > If anybody has anything, (of a bug fix nature) they'd like to be sure
> > to get into the release today, please let me know, (here in email or
> > on IRC).
> 
> Following Behad's suggestion that Cairo really should suffer some
> malloc-failure testing, I wrote a simple valgrind skin to randomly
> return NULL.
> 
> The effort was justified as it's already pinpointed a few places that
> needed some error checking.
> --
> Chris Wilson

Wow, this is great stuff Chris!  Are you pushing your valgrind skins
upstream?  How does this one work btw?  Does it take a rate of failure?
Also useful would be to take a number n and fail every n'th malloc().
That way you can brute force on n...

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Fri Mar 16 11:51:53 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar 16 11:51:49 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <87zm6dw40w.wl%cworth@cworth.org>
References: <87zm6dw40w.wl%cworth@cworth.org>
Message-ID: <1174071113.30335.7.camel@behdad>

On Fri, 2007-03-16 at 12:23 -0400, Carl Worth wrote:
> Ever since 1.4.0 I'd been planning to update our ROADMAP and post
> plans for all the fixes I wanted to see in 1.4.2, (originally thinking
> of an early April release to be on time for the next GNOME update and
> the Fedora freeze).
> 
> But now it looks like we've accrued enough critical fixes that I think
> I'll just push out what we have already as 1.4.2, (and we can still
> target early April for a subsequent 1.4.4 with the rest of the fixes
> we originally had planned for 1.4.2). There are a couple of minor
> little issues in bugzilla that I'll fix first.
> 
> If anybody has anything, (of a bug fix nature) they'd like to be sure
> to get into the release today, please let me know, (here in email or
> on IRC).

http://lists.freedesktop.org/archives/cairo/2007-March/010064.html

I hope Vlad, Hans, or tml have time to test and commit this.


> Thanks,
> 
> -Carl
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From chris at chris-wilson.co.uk  Fri Mar 16 13:16:59 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 16 13:17:07 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <87zm6dw40w.wl%cworth@cworth.org>
References: <87zm6dw40w.wl%cworth@cworth.org>
Message-ID: <20070316201659.GD4618@inspired.chris-wilson.co.uk>

A few more easily caught missing error checks.
--
Chris Wilson.

-------------- next part --------------
>From f4a72a8009737f139b99cdc0fd9aae432ab84639 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 18:08:53 +0000
Subject: [PATCH] Check for error status otherwise we may spin for quite some time...

---
 perf/text.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/perf/text.c b/perf/text.c
index de5e0cd..efe7d91 100644
--- a/perf/text.c
+++ b/perf/text.c
@@ -40,14 +40,14 @@ do_text (cairo_t *cr, int width, int height)
 	cairo_move_to (cr, 0, i * 10);
 	cairo_show_text (cr, text + i);
 	cairo_get_current_point (cr, &x, &y);
-	while (x < width) {
+	while (x < width && cairo_status (cr) == CAIRO_STATUS_SUCCESS) {
 	    cairo_show_text (cr, text);
 	    cairo_get_current_point (cr, &x, &y);
 	}
 	i++;
 	if (i >= len)
 	    i = 0;
-    } while (y < height);
+    } while (y < height && cairo_status (cr) == CAIRO_STATUS_SUCCESS);
 
     cairo_perf_timer_stop ();
 
-- 
1.4.4.2

-------------- next part --------------
>From eb2f61a355f626100972d13a690d5cc1d34bb110 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 18:40:08 +0000
Subject: [PATCH] Handle malloc failure during scaled_font initialisation.

---
 src/cairo-ft-font.c     |    9 +++++++--
 src/cairo-scaled-font.c |    9 ++++++---
 2 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index d2df281..20a2ffb 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -1443,10 +1443,15 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
     _cairo_font_options_init_copy (&scaled_font->ft_options.base, options);
     _cairo_ft_options_merge (&scaled_font->ft_options, &ft_options);
 
-    _cairo_scaled_font_init (&scaled_font->base,
+    if (_cairo_scaled_font_init (&scaled_font->base,
 			     font_face,
 			     font_matrix, ctm, options,
-			     &cairo_ft_scaled_font_backend);
+			     &cairo_ft_scaled_font_backend)) {
+	_cairo_scaled_font_fini (&scaled_font->base);
+	free (scaled_font);
+	_cairo_ft_unscaled_font_unlock_face (unscaled);
+	return NULL;
+    }
 
     _cairo_ft_unscaled_font_set_scale (unscaled,
 				       &scaled_font->base.scale);
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 0162a0d..1671358 100755
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -366,15 +366,18 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			   &scaled_font->ctm);
 
     CAIRO_MUTEX_INIT (&scaled_font->mutex);
-    scaled_font->glyphs = _cairo_cache_create (_cairo_scaled_glyph_keys_equal,
-					       _cairo_scaled_glyph_destroy,
-					       max_glyphs_cached_per_font);
 
     scaled_font->surface_backend = NULL;
     scaled_font->surface_private = NULL;
 
     scaled_font->backend = backend;
 
+    scaled_font->glyphs = _cairo_cache_create (_cairo_scaled_glyph_keys_equal,
+					       _cairo_scaled_glyph_destroy,
+					       max_glyphs_cached_per_font);
+    if (!scaled_font->glyphs)
+	return CAIRO_STATUS_NO_MEMORY;
+
     return CAIRO_STATUS_SUCCESS;
 }
 
-- 
1.4.4.2

-------------- next part --------------
>From 304e0b7562544b67bfe8a6d1d3651129f71ee971 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 18:57:13 +0000
Subject: [PATCH] Handle stroker initialisation failure.

---
 src/cairo-path-stroke.c |   16 +++++++++-------
 1 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index 09bafbf..ebe7c90 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -67,7 +67,7 @@ typedef struct cairo_stroker {
 } cairo_stroker_t;
 
 /* private functions */
-static void
+static cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -148,7 +148,7 @@ _cairo_stroker_step_dash (cairo_stroker_t *stroker, double step)
     }
 }
 
-static void
+static cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -162,10 +162,6 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
     stroker->tolerance = tolerance;
     stroker->traps = traps;
 
-    _cairo_pen_init (&stroker->pen,
-		     stroke_style->line_width / 2.0,
-		     tolerance, ctm);
-
     stroker->has_current_face = FALSE;
     stroker->has_first_face = FALSE;
     stroker->has_initial_sub_path = FALSE;
@@ -174,6 +170,10 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 	_cairo_stroker_start_dash (stroker);
     else
 	stroker->dashed = FALSE;
+
+    return _cairo_pen_init (&stroker->pen,
+		            stroke_style->line_width / 2.0,
+		            tolerance, ctm);
 }
 
 static void
@@ -967,9 +967,11 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
     if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 	return status;
 
-    _cairo_stroker_init (&stroker, stroke_style,
+    status = _cairo_stroker_init (&stroker, stroke_style,
 			 ctm, ctm_inverse, tolerance,
 			 traps);
+    if (status)
+	goto BAIL;
 
     if (stroker.style->dash)
 	status = _cairo_path_fixed_interpret (path,
-- 
1.4.4.2

-------------- next part --------------
>From 679ba02b7cd1df810cf3542b48cf92530b01adb3 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 19:20:10 +0000
Subject: [PATCH] Reset the global cairo_scaled_font_map to NULL after freeing.

---
 src/cairo-scaled-font.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 1671358..8fc8d5f 100755
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -213,6 +213,7 @@ _cairo_scaled_font_map_lock (void)
 
  CLEANUP_SCALED_FONT_MAP:
     free (cairo_scaled_font_map);
+    cairo_scaled_font_map = NULL;
  CLEANUP_MUTEX_LOCK:
     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
     return NULL;
-- 
1.4.4.2

-------------- next part --------------
>From a7e2cee5b29d35291c861e884010e88edd95a8ca Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 19:28:25 +0000
Subject: [PATCH] A copy more pattern init failure checks.

---
 src/cairo-gstate.c  |    4 +++-
 src/cairo-pattern.c |    5 ++++-
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index c87eff6..1ed1df9 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -754,7 +754,9 @@ _cairo_gstate_paint (cairo_gstate_t *gstate)
     if (status)
 	return status;
 
-    _cairo_gstate_copy_transformed_source (gstate, &pattern.base);
+    status = _cairo_gstate_copy_transformed_source (gstate, &pattern.base);
+    if (status)
+	return status;
 
     status = _cairo_surface_paint (gstate->target,
 				   gstate->op,
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index 697be30..e15e048 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -163,8 +163,11 @@ _cairo_pattern_init_copy (cairo_pattern_t	*pattern,
     } break;
     }
 
+    if (pattern->status)
+	return pattern->status;
+
     pattern->ref_count = 1;
-    return pattern->status;
+    return CAIRO_STATUS_SUCCESS;
 }
 
 void
-- 
1.4.4.2

-------------- next part --------------
>From 2749e50dcebfee5c56ca71f4f0e93ffc764d20ed Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 19:35:02 +0000
Subject: [PATCH] Handle failure to allocate a GC.

---
 src/cairo-xlib-surface.c |   51 ++++++++++++++++++++++++++++++---------------
 1 files changed, 34 insertions(+), 17 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 6a0d3e4..21fa380 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -51,7 +51,7 @@ typedef int (*cairo_xlib_error_func_t) (Display     *display,
 
 typedef struct _cairo_xlib_surface cairo_xlib_surface_t;
 
-static void
+static cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface);
 
 static void
@@ -587,22 +587,27 @@ _get_image_surface (cairo_xlib_surface_t    *surface,
 	 * retry, but to keep things simple, we just create a
 	 * temporary pixmap
 	 */
-	Pixmap pixmap = XCreatePixmap (surface->dpy,
+	Pixmap pixmap;
+	cairo_status_t status = _cairo_xlib_surface_ensure_gc (surface);
+	if (status)
+	    return status;
+
+	pixmap = XCreatePixmap (surface->dpy,
 				       surface->drawable,
 				       x2 - x1, y2 - y1,
 				       surface->depth);
-	_cairo_xlib_surface_ensure_gc (surface);
-
-	XCopyArea (surface->dpy, surface->drawable, pixmap, surface->gc,
-		   x1, y1, x2 - x1, y2 - y1, 0, 0);
+	if (pixmap) {
+	    XCopyArea (surface->dpy, surface->drawable, pixmap, surface->gc,
+		       x1, y1, x2 - x1, y2 - y1, 0, 0);
 
-	ximage = XGetImage (surface->dpy,
-			    pixmap,
-			    0, 0,
-			    x2 - x1, y2 - y1,
-			    AllPlanes, ZPixmap);
+	    ximage = XGetImage (surface->dpy,
+				pixmap,
+				0, 0,
+				x2 - x1, y2 - y1,
+				AllPlanes, ZPixmap);
 
-	XFreePixmap (surface->dpy, pixmap);
+	    XFreePixmap (surface->dpy, pixmap);
+	}
     }
     if (!ximage)
 	return CAIRO_STATUS_NO_MEMORY;
@@ -728,18 +733,23 @@ _cairo_xlib_surface_ensure_dst_picture (cairo_xlib_surface_t    *surface)
 
 }
 
-static void
+static cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface)
 {
     XGCValues gcv;
 
     if (surface->gc)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     gcv.graphics_exposures = False;
     surface->gc = XCreateGC (surface->dpy, surface->drawable,
 			     GCGraphicsExposures, &gcv);
+    if (!surface->gc)
+	return CAIRO_STATUS_NO_MEMORY;
+
     _cairo_xlib_surface_set_gc_clip_rects (surface);
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
@@ -755,6 +765,7 @@ _draw_image_surface (cairo_xlib_surface_t   *surface,
     XImage ximage;
     unsigned int bpp, alpha, red, green, blue;
     int native_byte_order = _native_byte_order_lsb () ? LSBFirst : MSBFirst;
+    cairo_status_t status;
 
     pixman_format_get_masks (pixman_image_get_format (image->pixman_image),
 			     &bpp, &alpha, &red, &green, &blue);
@@ -777,7 +788,9 @@ _draw_image_surface (cairo_xlib_surface_t   *surface,
 
     XInitImage (&ximage);
 
-    _cairo_xlib_surface_ensure_gc (surface);
+    status = _cairo_xlib_surface_ensure_gc (surface);
+    if (status)
+	return status;
     XPutImage(surface->dpy, surface->drawable, surface->gc,
 	      &ximage, src_x, src_y, dst_x, dst_y,
 	      width, height);
@@ -1361,7 +1374,9 @@ _cairo_xlib_surface_composite (cairo_operator_t		op,
 	break;
 
     case DO_XCOPYAREA:
-	_cairo_xlib_surface_ensure_gc (dst);
+	status = _cairo_xlib_surface_ensure_gc (dst);
+	if (status)
+	    goto BAIL;
 	XCopyArea (dst->dpy,
 		   src->drawable,
 		   dst->drawable,
@@ -1381,7 +1396,9 @@ _cairo_xlib_surface_composite (cairo_operator_t		op,
 	 * _recategorize_composite_operation.
 	 */
 
-	_cairo_xlib_surface_ensure_gc (dst);
+	status = _cairo_xlib_surface_ensure_gc (dst);
+	if (status)
+	    goto BAIL;
 	_cairo_matrix_is_integer_translation (&src_attr.matrix, &itx, &ity);
 
 	XSetTSOrigin (dst->dpy, dst->gc,
-- 
1.4.4.2

-------------- next part --------------
>From d77a27ca35805b34af25162d533374dcb14c961a Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 20:04:26 +0000
Subject: [PATCH] Detect when a substitute image surface is returned for a solid pattern,
and avoid mixed image/xlib composite operations.
---
 src/cairo-xlib-surface.c |    7 ++++++-
 1 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 21fa380..321857d 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -1214,7 +1214,12 @@ _recategorize_composite_operation (cairo_xlib_surface_t	      *dst,
 {
     cairo_bool_t is_integer_translation =
 	_cairo_matrix_is_integer_translation (&src_attr->matrix, NULL, NULL);
-    cairo_bool_t needs_alpha_composite =
+    cairo_bool_t needs_alpha_composite;
+
+    if (!_cairo_surface_is_xlib (&src->base))
+	return DO_UNSUPPORTED;
+
+    needs_alpha_composite =
 	_operator_needs_alpha_composite (op, _surface_has_alpha (src));
 
     if (!have_mask &&
-- 
1.4.4.2

From vladimir at pobox.com  Fri Mar 16 13:50:32 2007
From: vladimir at pobox.com (Vladimir Vukicevic)
Date: Fri Mar 16 13:50:44 2007
Subject: [cairo] Any objections to dropping
	_cairo_atsui_font_old_show_glyphs?
In-Reply-To: <1173895942.14946.10.camel@behdad>
References: <2faad3050703140928u27cd1969ma42986583ab39df5@mail.gmail.com>
	<1173895942.14946.10.camel@behdad>
Message-ID: <45FB0318.7050700@pobox.com>

Behdad Esfahbod wrote:
> On Wed, 2007-03-14 at 12:28 -0400, Baz wrote:
>> Just looking for comment on this. _cairo_atsui_font_old_show_glyphs
>> was used to display glyphs under the old quartz code, for all
>> surfaces. More recently its become unnecessary for any surface and in
>> fact only gets used in these (rare) circumstances:
>>
>> - atsui text is being rendered to a quartz surface
>> - and we cannot render the text in cairo-quartz-surface (this happens
>> because, eg we cannot convert a pattern to a CGShadingRef);
>> - and we can extract a destination image surface from the quartz
>> surface. The code looks like the original quartz surface could be
>> used, but this is actually unreachable.
>> - and we can create a CGBitmapContext matching the destination image
>> surface. This should always succeed.
>>
>> If any of that fails it ends up using glyph surfaces, which should
>> work anyway - they are used for all non-quartz surfaces.
>>
>> Does anyone see this code[1] getting used in the real world? It isn't
>> being hit by any of the tests any more, but of course its still just
>> as buggy as it was with the old quartz :). If no-one is actually using
>> it, I think we'd be better off without.
>>
>> The cut would just be 150 lines or so. Some of this comes from
>> inlining what little of of cairo-atsui's
>> CGBitmapContextCreateWithCairoImageSurface is still required.
>>
>> Cheers,
>> Baz
> 
> Go ahead from me!
> 
> Vlad, comments?

Killing it sounds great to me!

     - Vlad
From behdad at behdad.org  Fri Mar 16 13:54:31 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar 16 13:54:36 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <20070316201659.GD4618@inspired.chris-wilson.co.uk>
References: <87zm6dw40w.wl%cworth@cworth.org>
	<20070316201659.GD4618@inspired.chris-wilson.co.uk>
Message-ID: <1174078471.28587.6.camel@behdad>


Great stuff again!

Should we use some gcc attribute to get warnings about ignoring
cairo_status_t and cairo_int_status_t return values?


On Fri, 2007-03-16 at 16:16 -0400, Chris Wilson wrote:
> -    _cairo_scaled_font_init (&scaled_font->base,
> +    if (_cairo_scaled_font_init (&scaled_font->base,
>                              font_face,
>                              font_matrix, ctm, options,
> -                            &cairo_ft_scaled_font_backend);
> +                            &cairo_ft_scaled_font_backend)) {
> +       _cairo_scaled_font_fini (&scaled_font->base);
> +       free (scaled_font);
> +       _cairo_ft_unscaled_font_unlock_face (unscaled);
> +       return NULL;
> +    } 

The idiom is that if an _init() fails, it should clean after itself and
_fini() should not be called on it.  So, the _fini() here should be
removed, and _init() fixed to clean.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Fri Mar 16 14:06:37 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar 16 14:06:41 2007
Subject: [cairo] Cache solid patterns
In-Reply-To: <20070313232902.GB26420@inspired.chris-wilson.co.uk>
References: <20070313232902.GB26420@inspired.chris-wilson.co.uk>
Message-ID: <1174079197.28587.12.camel@behdad>

On Tue, 2007-03-13 at 19:29 -0400, Chris Wilson wrote:

> This is the old solid colour surface cache moved up a level to cache
> the allocated patterns. This is important for toolkits such as GTK+,
> which tend to use a small colour palette across many widgets and
> trigger frequent reallocation of the same solid patterns.

Looks good.  Please commit after Mathias commits his MUTEX patch so we
don't regress again.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Fri Mar 16 14:07:54 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar 16 14:07:58 2007
Subject: [cairo] Use stack buffer for _cairo_surface_fill_region()
In-Reply-To: <20070314015026.GA18428@inspired.chris-wilson.co.uk>
References: <20070314015026.GA18428@inspired.chris-wilson.co.uk>
Message-ID: <1174079274.28587.14.camel@behdad>

On Tue, 2007-03-13 at 21:50 -0400, Chris Wilson wrote:
> 
> I don't know just how many times this patch may arrive at the list as
> I
> was experimenting with git-format-patch and piping to mutt. Since I've
> not seen the message yet, I assume the experiment failed.
> 
> This is a simple patch to use a stack buffer for
> _cairo_surface_fill_region() when the num_rects does not exceed
> CAIRO_STACK_BUFFER_SIZE / sizeof (cairo_rectangle_in16_t). This is
> another function that is called for almost every GTK+ expose event
> (assuming double-buffered widgets) and so a frequent allocator.

Looks good to commit after 1.4.2.

> --
> Chris Wilson
> 
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From brian.ewins at gmail.com  Fri Mar 16 15:29:20 2007
From: brian.ewins at gmail.com (Baz)
Date: Fri Mar 16 15:29:25 2007
Subject: [cairo] Any objections to dropping
	_cairo_atsui_font_old_show_glyphs?
In-Reply-To: <45FB0318.7050700@pobox.com>
References: <2faad3050703140928u27cd1969ma42986583ab39df5@mail.gmail.com>
	<1173895942.14946.10.camel@behdad> <45FB0318.7050700@pobox.com>
Message-ID: <2faad3050703161529v7ba6b0cas6900b1ead8b09f0f@mail.gmail.com>

Great. Consider it gone!

On 16/03/07, Vladimir Vukicevic <vladimir@pobox.com> wrote:
> Behdad Esfahbod wrote:
> > On Wed, 2007-03-14 at 12:28 -0400, Baz wrote:
> >> Just looking for comment on this. _cairo_atsui_font_old_show_glyphs
> >> was used to display glyphs under the old quartz code, for all
> >> surfaces. More recently its become unnecessary for any surface and in
> >> fact only gets used in these (rare) circumstances:
> >>
> >> - atsui text is being rendered to a quartz surface
> >> - and we cannot render the text in cairo-quartz-surface (this happens
> >> because, eg we cannot convert a pattern to a CGShadingRef);
> >> - and we can extract a destination image surface from the quartz
> >> surface. The code looks like the original quartz surface could be
> >> used, but this is actually unreachable.
> >> - and we can create a CGBitmapContext matching the destination image
> >> surface. This should always succeed.
> >>
> >> If any of that fails it ends up using glyph surfaces, which should
> >> work anyway - they are used for all non-quartz surfaces.
> >>
> >> Does anyone see this code[1] getting used in the real world? It isn't
> >> being hit by any of the tests any more, but of course its still just
> >> as buggy as it was with the old quartz :). If no-one is actually using
> >> it, I think we'd be better off without.
> >>
> >> The cut would just be 150 lines or so. Some of this comes from
> >> inlining what little of of cairo-atsui's
> >> CGBitmapContextCreateWithCairoImageSurface is still required.
> >>
> >> Cheers,
> >> Baz
> >
> > Go ahead from me!
> >
> > Vlad, comments?
>
> Killing it sounds great to me!
>
>      - Vlad
>
From hugo.vincent at gmail.com  Fri Mar 16 21:30:16 2007
From: hugo.vincent at gmail.com (Hugo Vincent)
Date: Fri Mar 16 21:30:25 2007
Subject: [cairo] Re: 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <20070316222928.1FDEE9E817@gabe.freedesktop.org>
References: <20070316222928.1FDEE9E817@gabe.freedesktop.org>
Message-ID: <ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>

Can the patch for bug 10036 (Cairo-Quartz Line-width-scaling problem)  
be accepted for into 1.4.2 (or even 1.4.4)? Please!?
https://bugs.freedesktop.org/show_bug.cgi?id=10036

Also, I have been playing round with Rsvg on Mac OS X, rendering into  
a Cairo-Quartz context. It mostly works (except for the above  
mentioned bug), however in certain cases it crashes rather  
ungracefully when trying to do fallback operations for things that  
aren't supported natively by Cairo-Quartz (certain radial gradients  
seem to be the culprit). I'll prepare a proper test case and submit a  
bug soon after I've tried it with 1.4.2.

Cheers,
Hugo Vincent

> Date: Fri, 16 Mar 2007 09:23:59 -0700
> From: Carl Worth <cworth@cworth.org>
> Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
> To: cairo@cairographics.org
> Message-ID: <87zm6dw40w.wl%cworth@cworth.org>
> Content-Type: text/plain; charset="us-ascii"
>
> Ever since 1.4.0 I'd been planning to update our ROADMAP and post
> plans for all the fixes I wanted to see in 1.4.2, (originally thinking
> of an early April release to be on time for the next GNOME update and
> the Fedora freeze).
>
> But now it looks like we've accrued enough critical fixes that I think
> I'll just push out what we have already as 1.4.2, (and we can still
> target early April for a subsequent 1.4.4 with the rest of the fixes
> we originally had planned for 1.4.2). There are a couple of minor
> little issues in bugzilla that I'll fix first.
>
> If anybody has anything, (of a bug fix nature) they'd like to be sure
> to get into the release today, please let me know, (here in email or
> on IRC).
>
> Thanks,
>
> -Carl
From delza at livingcode.org  Fri Mar 16 21:36:28 2007
From: delza at livingcode.org (Dethe Elza)
Date: Fri Mar 16 21:36:37 2007
Subject: [cairo] [cairo-announce] ANN: pycairo release 1.4.0 now available
In-Reply-To: <1173869460.840.2.camel@localhost.localdomain>
References: <1173869460.840.2.camel@localhost.localdomain>
Message-ID: <38CBE8BA-0D17-437D-BF95-F8A56E8D6859@livingcode.org>

This is great news, Steve, thanks for keeping the python bindings  
caught up with the latest Cairo.

Does this by any chance support the Quartz backend, and if not, what  
would it take to hook PyCairo up to Quartz?

Thanks again,

--Dethe

On 14-Mar-07, at 3:51 AM, Steve Chaplin wrote:

> Pycairo is a set of Python bindings for the multi-platform 2D graphics
> library cairo.
>  http://cairographics.org
>  http://cairographics.org/pycairo
>
> A new pycairo release 1.4.0 is now available from:
>
>         http://cairographics.org/releases/pycairo-1.4.0.tar.gz
>         http://cairographics.org/releases/pycairo-1.4.0.tar.gz.md5
>
>         e26e77919b606113f565d70036c1f504  pycairo-1.4.0.tar.gz
>
> Overview of changes from pycairo 1.2.6 to pycairo 1.4.0
> =======================================================
> General changes:
> Pycairo 1.4.0 requires cairo 1.4.0 (or later).
>
> New methods:
>     Context.clip_extents
>     Context.copy_clip_rectangles
>     Context.get_dash
>     Context.get_dash_count
>     Context.get_scaled_font
>     Context.glyph_extents
>     Context.glyph_path
>     Context.show_glyphs
>     LinearGradient.get_linear_points
>     RadialGradient.get_radial_circles
>     SolidPattern.get_rgba
>     SurfacePattern.get_surface
>
> Deleted methods:
>     ImageSurface.create_for_array
>     Remove Numeric Python support, since Numeric has been made  
> obsolete
>     by numpy, and numpy data can be read using
>     ImageSurface.create_for_data.
>
> Other changes:
>     the module cairo.gtk has been removed (pygtk 2.7.0 onwards has  
> cairo
>     support built in).
>
>
> Send instant messages to your online friends http:// 
> au.messenger.yahoo.com
> _______________________________________________
> cairo-announce mailing list
> cairo-announce@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo-announce
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo



You need to lay out the user interface components visually, by hand,  
with total control over where they go. Automated LayoutManagers don?t  
cut it. A corollary of this is that you can?t move a UI layout from  
one platform to another and have the computer make everything fit.  
Computers don?t lay out interfaces by themselves any better than they  
can translate French to English by themselves. -- Jens Alfke



From stevech1097 at yahoo.com.au  Sat Mar 17 18:44:01 2007
From: stevech1097 at yahoo.com.au (Steve Chaplin)
Date: Sat Mar 17 17:50:47 2007
Subject: [cairo] [cairo-announce] ANN: pycairo release 1.4.0 now available
In-Reply-To: <38CBE8BA-0D17-437D-BF95-F8A56E8D6859@livingcode.org>
References: <1173869460.840.2.camel@localhost.localdomain>
	<38CBE8BA-0D17-437D-BF95-F8A56E8D6859@livingcode.org>
Message-ID: <1174182241.2781.11.camel@localhost.localdomain>

On Fri, 2007-03-16 at 21:36 -0700, Dethe Elza wrote:
> This is great news, Steve, thanks for keeping the python bindings  
> caught up with the latest Cairo.
> 
> Does this by any chance support the Quartz backend, and if not, what  
> would it take to hook PyCairo up to Quartz?

There is no Quartz support in Pycairo. Note that in cairo the Quartz
backend is still experimental and not supported.

Using Quartz from Pycairo would require a Quartz user write and test a
QuartzSurface(Surface) class to be added to cairo/pycairo-surface.c

The new class would wrap the cairo C functions:
cairo_surface_t *
cairo_quartz_surface_create (cairo_format_t format,
                             unsigned int width,
                             unsigned int height);

cairo_surface_t *
cairo_quartz_surface_create_for_cg_context (CGContextRef cgContext,
                                            unsigned int width,
                                            unsigned int height);

CGContextRef
cairo_quartz_surface_get_cg_context (cairo_surface_t *surface);

The first function prototype looks like it should be easy to do. The
second and third use CGContextRef, which I understand is a pointer, and
can't used by pycairo unless there is a preexisting python binding for
CGContextRef.

Regards
Steve


Send instant messages to your online friends http://au.messenger.yahoo.com 
From delza at livingcode.org  Sat Mar 17 21:00:16 2007
From: delza at livingcode.org (Dethe Elza)
Date: Sat Mar 17 21:07:30 2007
Subject: [cairo] [cairo-announce] ANN: pycairo release 1.4.0 now available
In-Reply-To: <1174182241.2781.11.camel@localhost.localdomain>
References: <1173869460.840.2.camel@localhost.localdomain>
	<38CBE8BA-0D17-437D-BF95-F8A56E8D6859@livingcode.org>
	<1174182241.2781.11.camel@localhost.localdomain>
Message-ID: <89970840-60C0-4E35-BA7F-87FBEDABAC04@livingcode.org>

Hi Steve,

Thanks for the tips.  When I get time I will try to look into it  
further, now that you've given me a good place to start.

--Dethe

On 17-Mar-07, at 6:44 PM, Steve Chaplin wrote:

> On Fri, 2007-03-16 at 21:36 -0700, Dethe Elza wrote:
>> This is great news, Steve, thanks for keeping the python bindings
>> caught up with the latest Cairo.
>>
>> Does this by any chance support the Quartz backend, and if not, what
>> would it take to hook PyCairo up to Quartz?
>
> There is no Quartz support in Pycairo. Note that in cairo the Quartz
> backend is still experimental and not supported.
>
> Using Quartz from Pycairo would require a Quartz user write and test a
> QuartzSurface(Surface) class to be added to cairo/pycairo-surface.c
>
> The new class would wrap the cairo C functions:
> cairo_surface_t *
> cairo_quartz_surface_create (cairo_format_t format,
>                              unsigned int width,
>                              unsigned int height);
>
> cairo_surface_t *
> cairo_quartz_surface_create_for_cg_context (CGContextRef cgContext,
>                                             unsigned int width,
>                                             unsigned int height);
>
> CGContextRef
> cairo_quartz_surface_get_cg_context (cairo_surface_t *surface);
>
> The first function prototype looks like it should be easy to do. The
> second and third use CGContextRef, which I understand is a pointer,  
> and
> can't used by pycairo unless there is a preexisting python binding for
> CGContextRef.
>
> Regards
> Steve
>
>
> Send instant messages to your online friends http:// 
> au.messenger.yahoo.com


"The good thing about reinventing the wheel is that you can get a  
round one." --Douglas Crockford


From ajohnson at redneon.com  Sat Mar 17 22:00:40 2007
From: ajohnson at redneon.com (Adrian Johnson)
Date: Sat Mar 17 22:00:49 2007
Subject: [cairo] PDF Transparent Gradients
Message-ID: <45FCC778.8010307@redneon.com>

Attached are two patches that implement transparent gradients for the
PDF backend.

The first patch is based on the patch by Mikl?s Erd?lyi at
http://lists.freedesktop.org/archives/cairo/2006-August/007648.html

I have separated out the transparent gradient functions from Mikl?s'
patch, fixed various bugs and improved compatibility with different PDF
Viewers (Mikl?s patch only worked with acroread 7).

Other parts of Mikl?s patch have been rewritten to remove redundant
code. I have not yet added support for the repeat and reflect extended
modes. Selecting these modes will use the image fallbacks.

The second patch fixes some issues with using acroread.

I have tested these patches with:
  - Ghostscript 8.54
  - ESP Ghostscript 8.15.3
  - Evince (with Popper 0.5.4)
  - Xpdf 3.02
  - Adobe Reader 7 and 8
	
Some viewers do not support all the features that cairo supports.

ESP Ghostscript crashed when stroking a line with a gradient pattern.

Xpdf and Poppler do not appear to support text patterns or stroke patterns.

Poppler does not appear to support SMasks. Also, enabling padding with a
radial gradient did not pad out the entire rectangle I was filling.


-------------- next part --------------
>From 4760076394afea1d76f25dc4013b8d03036592e1 Mon Sep 17 00:00:00 2001
From: Adrian Johnson <ajohnson@redneon.com>
Date: Sun, 18 Mar 2007 11:29:14 +1030
Subject: [PATCH] PDF: Add support for transparent gradients
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This is based on the gradient patch written by Mikl?s Erd?lyi at
http://lists.freedesktop.org/archives/cairo/2006-August/007648.html
---
 src/cairo-pdf-surface.c |  836 +++++++++++++++++++++++++++++++++++++----------
 1 files changed, 665 insertions(+), 171 deletions(-)

diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 924b80c..4f05a7f 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -64,8 +64,6 @@
  *
  * - Surface patterns.
  *
- * - Alpha channels in gradients.
- *
  * - Should/does cairo support drawing into a scratch surface and then
  *   using that as a fill pattern?  For this backend, that would involve
  *   using a tiling pattern (4.6.2).  How do you create such a scratch
@@ -101,6 +99,18 @@ typedef struct _cairo_pdf_font {
     cairo_pdf_resource_t subset_resource;
 } cairo_pdf_font_t;
 
+typedef struct _cairo_pdf_rgb_linear_function {
+    cairo_pdf_resource_t resource;
+    double               color1[3];
+    double               color2[3];
+} cairo_pdf_rgb_linear_function_t;
+
+typedef struct _cairo_pdf_alpha_linear_function {
+    cairo_pdf_resource_t resource;
+    double               alpha1;
+    double               alpha2;
+} cairo_pdf_alpha_linear_function_t;
+
 typedef struct _cairo_pdf_surface {
     cairo_surface_t base;
 
@@ -117,6 +127,9 @@ typedef struct _cairo_pdf_surface {
     cairo_array_t xobjects;
     cairo_array_t streams;
     cairo_array_t alphas;
+    cairo_array_t smasks;
+    cairo_array_t rgb_linear_functions;
+    cairo_array_t alpha_linear_functions;
 
     cairo_scaled_font_subsets_t *font_subsets;
     cairo_array_t fonts;
@@ -133,6 +146,16 @@ typedef struct _cairo_pdf_surface {
         cairo_output_stream_t *old_output;
     } current_stream;
 
+    struct {
+        cairo_pattern_type_t type;
+        double red;
+        double green;
+        double blue;
+        int alpha;
+        cairo_pdf_resource_t smask;
+        cairo_pdf_resource_t pattern;
+    } emitted_pattern;
+
     cairo_bool_t has_clip;
 
     cairo_paginated_mode_t paginated_mode;
@@ -226,27 +249,31 @@ _cairo_pdf_surface_add_pattern (cairo_pd
     _cairo_array_append (&surface->patterns, &pattern);
 }
 
-static cairo_pdf_resource_t
+static void
+_cairo_pdf_surface_add_smask (cairo_pdf_surface_t  *surface,
+                              cairo_pdf_resource_t  smask)
+{
+    /* XXX: Should be checking the return value here. */
+    _cairo_array_append (&surface->smasks, &smask);
+}
+
+static int
 _cairo_pdf_surface_add_alpha (cairo_pdf_surface_t *surface, double alpha)
 {
-    cairo_pdf_resource_t resource;
     int num_alphas, i;
     double other;
 
     num_alphas = _cairo_array_num_elements (&surface->alphas);
     for (i = 0; i < num_alphas; i++) {
 	_cairo_array_copy_element (&surface->alphas, i, &other);
-	if (alpha == other) {
-	    resource.id  = i;
-	    return resource;
-	}
+	if (alpha == other)
+	    return i;
     }
 
     /* XXX: Should be checking the return value here. */
     _cairo_array_append (&surface->alphas, &alpha);
 
-    resource.id = _cairo_array_num_elements (&surface->alphas) - 1;
-    return resource;
+    return _cairo_array_num_elements (&surface->alphas) - 1;
 }
 
 static cairo_surface_t *
@@ -276,6 +303,14 @@ _cairo_pdf_surface_create_for_stream_int
     _cairo_array_init (&surface->xobjects, sizeof (cairo_pdf_resource_t));
     _cairo_array_init (&surface->streams, sizeof (cairo_pdf_resource_t));
     _cairo_array_init (&surface->alphas, sizeof (double));
+    _cairo_array_init (&surface->smasks, sizeof (cairo_pdf_resource_t));
+    _cairo_array_init (&surface->rgb_linear_functions, sizeof (cairo_pdf_rgb_linear_function_t));
+    _cairo_array_init (&surface->alpha_linear_functions, sizeof (cairo_pdf_alpha_linear_function_t));
+
+
+    /* Add alpha=1 as the first element as this is the most frequently
+     * referenced value. */
+    _cairo_pdf_surface_add_alpha (surface, 1);
 
     surface->font_subsets = _cairo_scaled_font_subsets_create (PDF_SURFACE_MAX_GLYPHS_PER_FONT,
                                                                PDF_SURFACE_MAX_GLYPHS_PER_FONT);
@@ -577,6 +612,9 @@ _cairo_pdf_surface_finish (void *abstrac
     _cairo_array_fini (&surface->xobjects);
     _cairo_array_fini (&surface->streams);
     _cairo_array_fini (&surface->alphas);
+    _cairo_array_fini (&surface->smasks);
+    _cairo_array_fini (&surface->rgb_linear_functions);
+    _cairo_array_fini (&surface->alpha_linear_functions);
 
     if (surface->font_subsets) {
 	_cairo_scaled_font_subsets_destroy (surface->font_subsets);
@@ -610,6 +648,36 @@ _cairo_pdf_surface_resume_content_stream
     _cairo_pdf_surface_add_stream (surface, stream);
 }
 
+static cairo_pdf_resource_t
+_cairo_pdf_surface_begin_group (cairo_pdf_surface_t *surface)
+{
+    cairo_pdf_resource_t group;
+
+    _cairo_pdf_surface_pause_content_stream (surface);
+    group = _cairo_pdf_surface_open_stream (surface,
+                                            TRUE,
+                                            "   /Type /XObject\r\n"
+                                            "   /Subtype /Form\r\n"
+                                            "   /BBox [ 0 0 %f %f ]\r\n"
+                                            "   /Group <<\r\n"
+                                            "      /Type /Group\r\n"
+                                            "      /S /Transparency\r\n"
+                                            "      /CS /DeviceRGB\r\n"
+                                            "   >>\r\n",
+                                            surface->width,
+                                            surface->height);
+
+    _cairo_array_append (&surface->xobjects, &group);
+    return group;
+}
+
+static void
+_cairo_pdf_surface_end_group (cairo_pdf_surface_t *surface)
+{
+    _cairo_pdf_surface_close_stream (surface);
+    _cairo_pdf_surface_resume_content_stream (surface);
+}
+
 static cairo_int_status_t
 _cairo_pdf_surface_start_page (void *abstract_surface)
 {
@@ -728,9 +796,9 @@ _cairo_pdf_surface_emit_smask (cairo_pdf
 /* Emit image data into the given surface, providing a resource that
  * can be used to reference the data in image_ret. */
 static cairo_status_t
-_cairo_pdf_surface_emit_image (cairo_pdf_surface_t		*surface,
-	    cairo_image_surface_t	*image,
-	    cairo_pdf_resource_t	*image_ret)
+_cairo_pdf_surface_emit_image (cairo_pdf_surface_t   *surface,
+                               cairo_image_surface_t *image,
+                               cairo_pdf_resource_t  *image_ret)
 {
     cairo_status_t status = CAIRO_STATUS_SUCCESS;
     char *rgb, *compressed;
@@ -842,32 +910,26 @@ _cairo_pdf_surface_emit_image (cairo_pdf
 
 static cairo_status_t
 _cairo_pdf_surface_emit_solid_pattern (cairo_pdf_surface_t *surface,
-		    cairo_solid_pattern_t *pattern)
+                                       cairo_solid_pattern_t *pattern)
 {
-    cairo_pdf_resource_t alpha;
+    int alpha;
 
     alpha = _cairo_pdf_surface_add_alpha (surface, pattern->color.alpha);
 
-    /* With some work, we could separate the stroking
-     * or non-stroking color here as actually needed. */
-    _cairo_output_stream_printf (surface->output,
-				 "%f %f %f RG "
-				 "%f %f %f rg "
-				 "/a%d gs\r\n",
-				 pattern->color.red,
-				 pattern->color.green,
-				 pattern->color.blue,
-				 pattern->color.red,
-				 pattern->color.green,
-				 pattern->color.blue,
-				 alpha.id);
+    surface->emitted_pattern.type = CAIRO_PATTERN_TYPE_SOLID;
+    surface->emitted_pattern.red = pattern->color.red;
+    surface->emitted_pattern.green = pattern->color.green;
+    surface->emitted_pattern.blue = pattern->color.blue;
+    surface->emitted_pattern.alpha = alpha;
+    surface->emitted_pattern.smask.id = 0;
+    surface->emitted_pattern.pattern.id = 0;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
-_cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	*surface,
-		      cairo_surface_pattern_t	*pattern)
+_cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	 *surface,
+                                         cairo_surface_pattern_t *pattern)
 {
     cairo_pdf_resource_t stream;
     cairo_surface_t *pat_surface;
@@ -875,7 +937,7 @@ _cairo_pdf_surface_emit_surface_pattern
     cairo_image_surface_t *image;
     void *image_extra;
     cairo_status_t status = CAIRO_STATUS_SUCCESS;
-    cairo_pdf_resource_t alpha, image_resource = {0}; /* squelch bogus compiler warning */
+    cairo_pdf_resource_t image_resource = {0}; /* squelch bogus compiler warning */
     cairo_matrix_t cairo_p2d, pdf_p2d;
     cairo_extend_t extend = cairo_pattern_get_extend (&pattern->base);
     double xstep, ystep;
@@ -1012,14 +1074,10 @@ _cairo_pdf_surface_emit_surface_pattern
 
     _cairo_pdf_surface_add_pattern (surface, stream);
 
-    alpha = _cairo_pdf_surface_add_alpha (surface, 1.0);
-    /* With some work, we could separate the stroking
-     * or non-stroking pattern here as actually needed. */
-    _cairo_output_stream_printf (surface->output,
-				 "/Pattern CS /res%d SCN "
-				 "/Pattern cs /res%d scn "
-				 "/a%d gs\r\n",
-				 stream.id, stream.id, alpha.id);
+    surface->emitted_pattern.type = CAIRO_PATTERN_TYPE_SURFACE;
+    surface->emitted_pattern.alpha = _cairo_pdf_surface_add_alpha (surface, 1.0);
+    surface->emitted_pattern.smask.id = 0;
+    surface->emitted_pattern.pattern = stream;
 
  BAIL:
     _cairo_surface_release_source_image (pat_surface, image, image_extra);
@@ -1030,56 +1088,128 @@ _cairo_pdf_surface_emit_surface_pattern
 }
 
 typedef struct _cairo_pdf_color_stop {
-    double	  		offset;
-    cairo_pdf_resource_t	gradient;
-    unsigned char		color_char[4];
+    double offset;
+    double color[4];
+    cairo_pdf_resource_t resource;
 } cairo_pdf_color_stop_t;
 
 static cairo_pdf_resource_t
-_cairo_pdf_surface_emit_linear_colorgradient (cairo_pdf_surface_t		*surface,
-			   cairo_pdf_color_stop_t	*stop1,
-			   cairo_pdf_color_stop_t	*stop2)
+cairo_pdf_surface_emit_rgb_linear_function (cairo_pdf_surface_t    *surface,
+                                            cairo_pdf_color_stop_t *stop1,
+                                            cairo_pdf_color_stop_t *stop2)
 {
-    cairo_pdf_resource_t function = _cairo_pdf_surface_new_object (surface);
+    int num_elems, i;
+    cairo_pdf_rgb_linear_function_t elem;
+    cairo_pdf_resource_t function;
+
+    num_elems = _cairo_array_num_elements (&surface->rgb_linear_functions);
+    for (i = 0; i < num_elems; i++) {
+	_cairo_array_copy_element (&surface->rgb_linear_functions, i, &elem);
+        if (memcmp (&elem.color1[0], &stop1->color[0], sizeof (double)*3) != 0)
+            continue;
+        if (memcmp (&elem.color2[0], &stop2->color[0], sizeof (double)*3) != 0)
+            continue;
+
+        return elem.resource;
+    }
+
+    function = _cairo_pdf_surface_new_object (surface);
 
     _cairo_output_stream_printf (surface->output,
 				 "%d 0 obj\r\n"
-				 "<< /FunctionType 0\r\n"
+				 "<< /FunctionType 2\r\n"
 				 "   /Domain [ 0 1 ]\r\n"
-				 "   /Size [ 2 ]\r\n"
-				 "   /BitsPerSample 8\r\n"
-				 "   /Range [ 0 1 0 1 0 1 ]\r\n"
-				 "   /Length 6\r\n"
+				 "   /C0 [ %f %f %f ]\r\n"
+				 "   /C1 [ %f %f %f ]\r\n"
+				 "   /N 1\r\n"
 				 ">>\r\n"
-				 "stream\r\n",
-				 function.id);
+				 "endobj\r\n",
+				 function.id,
+                                 stop1->color[0],
+                                 stop1->color[1],
+                                 stop1->color[2],
+                                 stop2->color[0],
+                                 stop2->color[1],
+                                 stop2->color[2]);
+
+    elem.resource = function;
+    memcpy (&elem.color1[0], &stop1->color[0], sizeof (double)*3);
+    memcpy (&elem.color2[0], &stop2->color[0], sizeof (double)*3);
+
+    /* XXX: Should be checking the return value here. */
+    _cairo_array_append (&surface->rgb_linear_functions, &elem);
+
+    return function;
+}
+
+static cairo_pdf_resource_t
+cairo_pdf_surface_emit_alpha_linear_function (cairo_pdf_surface_t    *surface,
+                                              cairo_pdf_color_stop_t *stop1,
+                                              cairo_pdf_color_stop_t *stop2)
+{
+    int num_elems, i;
+    cairo_pdf_alpha_linear_function_t elem;
+    cairo_pdf_resource_t function;
+
+    num_elems = _cairo_array_num_elements (&surface->alpha_linear_functions);
+    for (i = 0; i < num_elems; i++) {
+	_cairo_array_copy_element (&surface->alpha_linear_functions, i, &elem);
+        if (elem.alpha1 != stop1->color[3])
+            continue;
+        if (elem.alpha2 != stop2->color[3])
+            continue;
+
+        return elem.resource;
+    }
+
+    function = _cairo_pdf_surface_new_object (surface);
 
-    _cairo_output_stream_write (surface->output, stop1->color_char, 3);
-    _cairo_output_stream_write (surface->output, stop2->color_char, 3);
     _cairo_output_stream_printf (surface->output,
-				 "\r\n"
-				 "endstream\r\n"
-				 "endobj\r\n");
+				 "%d 0 obj\r\n"
+				 "<< /FunctionType 2\r\n"
+				 "   /Domain [ 0 1 ]\r\n"
+				 "   /C0 [ %f ]\r\n"
+				 "   /C1 [ %f ]\r\n"
+				 "   /N 1\r\n"
+				 ">>\r\n"
+				 "endobj\r\n",
+				 function.id,
+                                 stop1->color[3],
+                                 stop2->color[3]);
+
+    elem.resource = function;
+    elem.alpha1 = stop1->color[3];
+    elem.alpha2 = stop2->color[3];
+
+    /* XXX: Should be checking the return value here. */
+    _cairo_array_append (&surface->alpha_linear_functions, &elem);
 
     return function;
 }
 
 static cairo_pdf_resource_t
-_cairo_pdf_surface_emit_stitched_colorgradient (cairo_pdf_surface_t   *surface,
-			    unsigned int 	   n_stops,
-			    cairo_pdf_color_stop_t stops[])
+_cairo_pdf_surface_emit_stitched_colorgradient (cairo_pdf_surface_t    *surface,
+                                                unsigned int 	        n_stops,
+                                                cairo_pdf_color_stop_t *stops,
+                                                cairo_bool_t	        is_alpha)
 {
     cairo_pdf_resource_t function;
     unsigned int i;
 
-    /* emit linear gradients between pairs of subsequent stops... */
+/* emit linear gradients between pairs of subsequent stops... */
     for (i = 0; i < n_stops-1; i++) {
-	stops[i].gradient = _cairo_pdf_surface_emit_linear_colorgradient (surface,
-						       &stops[i],
-						       &stops[i+1]);
+        if (is_alpha) {
+            stops[i].resource = cairo_pdf_surface_emit_alpha_linear_function (surface,
+                                                                              &stops[i],
+                                                                              &stops[i+1]);
+        } else {
+            stops[i].resource = cairo_pdf_surface_emit_rgb_linear_function (surface,
+                                                                            &stops[i],
+                                                                            &stops[i+1]);
+        }
     }
 
-    /* ... and stitch them together */
+/* ... and stitch them together */
     function = _cairo_pdf_surface_new_object (surface);
     _cairo_output_stream_printf (surface->output,
 				 "%d 0 obj\r\n"
@@ -1090,30 +1220,24 @@ _cairo_pdf_surface_emit_stitched_colorgr
     _cairo_output_stream_printf (surface->output,
 				 "   /Functions [ ");
     for (i = 0; i < n_stops-1; i++)
-    {
         _cairo_output_stream_printf (surface->output,
-				     "%d 0 R ", stops[i].gradient.id);
-    }
+                                     "%d 0 R ", stops[i].resource.id);
     _cairo_output_stream_printf (surface->output,
 		    		 "]\r\n");
 
     _cairo_output_stream_printf (surface->output,
 				 "   /Bounds [ ");
     for (i = 1; i < n_stops-1; i++)
-    {
         _cairo_output_stream_printf (surface->output,
 				     "%f ", stops[i].offset);
-    }
     _cairo_output_stream_printf (surface->output,
 		    		 "]\r\n");
 
     _cairo_output_stream_printf (surface->output,
 				 "   /Encode [ ");
     for (i = 1; i < n_stops; i++)
-    {
         _cairo_output_stream_printf (surface->output,
 				     "0 1 ");
-    }
     _cairo_output_stream_printf (surface->output,
 	    			 "]\r\n");
 
@@ -1126,29 +1250,36 @@ _cairo_pdf_surface_emit_stitched_colorgr
 
 #define COLOR_STOP_EPSILON 1e-6
 
-static cairo_pdf_resource_t
-_cairo_pdf_surface_emit_pattern_stops (cairo_pdf_surface_t *surface, cairo_gradient_pattern_t *pattern)
+static void
+_cairo_pdf_surface_emit_pattern_stops (cairo_pdf_surface_t      *surface,
+                                       cairo_gradient_pattern_t *pattern,
+                                       cairo_pdf_resource_t     *color_function,
+                                       cairo_pdf_resource_t     *alpha_function)
 {
-    cairo_pdf_resource_t    function;
     cairo_pdf_color_stop_t *allstops, *stops;
-    unsigned int i, n_stops;
+    unsigned int n_stops;
+    unsigned int i;
+    cairo_bool_t emit_alpha = FALSE;
 
-    function = _cairo_pdf_surface_new_object (surface);
+    color_function->id = 0;
+    alpha_function->id = 0;
 
     allstops = malloc ((pattern->n_stops + 2) * sizeof (cairo_pdf_color_stop_t));
     if (allstops == NULL) {
 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
-	function.id = 0;
-	return function;
+	return;
     }
+
     stops = &allstops[1];
     n_stops = pattern->n_stops;
 
-    for (i = 0; i < pattern->n_stops; i++) {
-	stops[i].color_char[0] = pattern->stops[i].color.red   >> 8;
-	stops[i].color_char[1] = pattern->stops[i].color.green >> 8;
-	stops[i].color_char[2] = pattern->stops[i].color.blue  >> 8;
-	stops[i].color_char[3] = pattern->stops[i].color.alpha >> 8;
+    for (i = 0; i < n_stops; i++) {
+	stops[i].color[0] = pattern->stops[i].color.red / 65535.0;
+	stops[i].color[1] = pattern->stops[i].color.green / 65535.0;
+	stops[i].color[2] = pattern->stops[i].color.blue / 65535.0;
+	stops[i].color[3] = pattern->stops[i].color.alpha / 65535.0;
+        if (!CAIRO_ALPHA_IS_OPAQUE (stops[i].color[3]))
+            emit_alpha = TRUE;
 	stops[i].offset = _cairo_fixed_to_double (pattern->stops[i].x);
     }
 
@@ -1157,44 +1288,136 @@ _cairo_pdf_surface_emit_pattern_stops (c
     if (stops[0].offset > COLOR_STOP_EPSILON) {
 	    memcpy (allstops, stops, sizeof (cairo_pdf_color_stop_t));
 	    stops = allstops;
-	    stops[0].offset = 0.0;
 	    n_stops++;
     }
+    stops[0].offset = 0.0;
+
     if (stops[n_stops-1].offset < 1.0 - COLOR_STOP_EPSILON) {
 	    memcpy (&stops[n_stops],
 		    &stops[n_stops - 1],
 		    sizeof (cairo_pdf_color_stop_t));
-	    stops[n_stops].offset = 1.0;
 	    n_stops++;
     }
+    stops[n_stops-1].offset = 1.0;
 
     if (n_stops == 2) {
 	/* no need for stitched function */
-	function = _cairo_pdf_surface_emit_linear_colorgradient (surface, &stops[0], &stops[1]);
+        *color_function = cairo_pdf_surface_emit_rgb_linear_function (surface,
+                                                                      &stops[0],
+                                                                      &stops[1]);
+        if (emit_alpha) {
+            *alpha_function = cairo_pdf_surface_emit_alpha_linear_function (surface,
+                                                                            &stops[0],
+                                                                            &stops[1]);
+        }
     } else {
-	/* multiple stops: stitch. XXX possible optimization: regulary spaced
+        /* multiple stops: stitch. XXX possible optimization: regulary spaced
 	 * stops do not require stitching. XXX */
-	function = _cairo_pdf_surface_emit_stitched_colorgradient (surface,
-					       n_stops,
-					       stops);
+        *color_function = _cairo_pdf_surface_emit_stitched_colorgradient (surface,
+                                                                          n_stops,
+                                                                          stops,
+                                                                          FALSE);
+        if (emit_alpha) {
+            *alpha_function = _cairo_pdf_surface_emit_stitched_colorgradient (surface,
+                                                                              n_stops,
+                                                                              stops,
+                                                                              TRUE);
+        }
     }
-
     free (allstops);
+}
 
-    return function;
+static cairo_pdf_resource_t
+cairo_pdf_surface_emit_transparency_group (cairo_pdf_surface_t  *surface,
+                                           cairo_pdf_resource_t  gradient_mask)
+{
+    cairo_pdf_resource_t xobj_resource, smask_resource, gstate_resource;
+
+    xobj_resource = _cairo_pdf_surface_open_stream (surface,
+                                                    TRUE,
+                                                    "   /Type /XObject\r\n"
+                                                    "   /Subtype /Form\r\n"
+                                                    "   /FormType 1\r\n"
+                                                    "   /BBox [ 0 0 %f %f ]\r\n"
+                                                    "   /Resources\r\n"
+                                                    "      << /ExtGState\r\n"
+                                                    "            << /a0 << /ca 1 /CA 1 >>"
+                                                    "      >>\r\n"
+                                                    "         /Pattern\r\n"
+                                                    "            << /res%d %d 0 R >>\r\n"
+                                                    "      >>\r\n"
+                                                    "   /Group\r\n"
+                                                    "      << /Type /Group\r\n"
+                                                    "         /S /Transparency\r\n"
+                                                    "         /CS /DeviceGray\r\n"
+                                                    "      >>\r\n",
+                                                    surface->width,
+                                                    surface->height,
+                                                    gradient_mask.id,
+                                                    gradient_mask.id);
+
+    _cairo_output_stream_printf (surface->output,
+                                 "q\r\n"
+                                 "/a0 gs\r\n"
+                                 "/Pattern cs /res%d scn\r\n"
+                                 "0 0 %f %f re\r\n"
+                                 "f\r\n"
+                                 "Q\r\n",
+                                 gradient_mask.id,
+                                 surface->width,
+                                 surface->height);
+
+    _cairo_pdf_surface_close_stream (surface);
+
+    smask_resource = _cairo_pdf_surface_new_object (surface);
+    _cairo_output_stream_printf (surface->output,
+                                 "%d 0 obj\r\n"
+                                 "<< /Type /Mask\r\n"
+                                 "   /S /Luminosity\r\n"
+                                 "   /G %d 0 R\r\n"
+                                 "   /BC [ 0.0 ]\r\n"
+                                 ">>\r\n"
+                                 "endobj\r\n",
+                                 smask_resource.id,
+                                 xobj_resource.id);
+
+    /* Create GState which uses the transparency group as an SMask. */
+    gstate_resource = _cairo_pdf_surface_new_object (surface);
+    _cairo_output_stream_printf (surface->output,
+                                 "%d 0 obj\r\n"
+                                 "<< /Type /ExtGState\r\n"
+                                 "   /SMask %d 0 R\r\n"
+                                 "   /ca 1\r\n"
+                                 "   /CA 1\r\n"
+                                 "   /AIS false\r\n"
+                                 ">>\r\n"
+                                 "endobj\r\n",
+                                 gstate_resource.id,
+                                 smask_resource.id);
+
+    _cairo_pdf_surface_add_smask (surface, gstate_resource);
+
+    return gstate_resource;
 }
 
 static cairo_status_t
-_cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_linear_pattern_t *pattern)
+_cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t    *surface,
+                                        cairo_linear_pattern_t *pattern)
 {
-    cairo_pdf_resource_t function, pattern_resource, alpha;
+    cairo_pdf_resource_t pattern_resource, smask;
+    cairo_pdf_resource_t color_function, alpha_function;
     double x0, y0, x1, y1;
     cairo_matrix_t p2u;
+    cairo_extend_t extend;
 
+    extend = cairo_pattern_get_extend (&pattern->base.base);
     _cairo_pdf_surface_pause_content_stream (surface);
 
-    function = _cairo_pdf_surface_emit_pattern_stops (surface, &pattern->base);
-    if (function.id == 0)
+    _cairo_pdf_surface_emit_pattern_stops (surface,
+                                           &pattern->base,
+                                           &color_function,
+                                           &alpha_function);
+    if (color_function.id == 0)
 	return CAIRO_STATUS_NO_MEMORY;
 
     p2u = pattern->base.base.matrix;
@@ -1212,35 +1435,77 @@ _cairo_pdf_surface_emit_linear_pattern (
 				 "%d 0 obj\r\n"
 				 "<< /Type /Pattern\r\n"
 				 "   /PatternType 2\r\n"
-				 "   /Matrix [ 1 0 0 -1 0 %f ]\r\n"
+                                 "   /Matrix [ 1 0 0 -1 0 %f ]\r\n"
 				 "   /Shading\r\n"
 				 "      << /ShadingType 2\r\n"
 				 "         /ColorSpace /DeviceRGB\r\n"
 				 "         /Coords [ %f %f %f %f ]\r\n"
-				 "         /Function %d 0 R\r\n"
-				 "         /Extend [ true true ]\r\n"
-				 "      >>\r\n"
-				 ">>\r\n"
-				 "endobj\r\n",
+				 "         /Function %d 0 R\r\n",
 				 pattern_resource.id,
-				 surface->height,
+                                 surface->height,
 				 x0, y0, x1, y1,
-				 function.id);
+				 color_function.id);
 
-    _cairo_pdf_surface_add_pattern (surface, pattern_resource);
-
-    alpha = _cairo_pdf_surface_add_alpha (surface, 1.0);
+    if (extend == CAIRO_EXTEND_PAD) {
+        _cairo_output_stream_printf (surface->output,
+                                     "         /Extend [ true true ]\r\n");
+    } else {
+        _cairo_output_stream_printf (surface->output,
+                                     "         /Extend [ false false ]\r\n");
+    }
 
-    /* Use pattern */
-    /* With some work, we could separate the stroking
-     * or non-stroking pattern here as actually needed. */
     _cairo_output_stream_printf (surface->output,
-				 "/Pattern CS /res%d SCN "
-				 "/Pattern cs /res%d scn "
-				 "/a%d gs\r\n",
-				 pattern_resource.id,
-				 pattern_resource.id,
-				 alpha.id);
+				 "      >>\r\n"
+				 ">>\r\n"
+				 "endobj\r\n");
+
+    if (alpha_function.id == 0)
+    {
+        surface->emitted_pattern.smask.id = 0;
+    }
+    else
+    {
+	cairo_pdf_resource_t mask_resource;
+
+	/* Create pattern for SMask. */
+	mask_resource = _cairo_pdf_surface_new_object (surface);
+	_cairo_output_stream_printf (surface->output,
+				     "%d 0 obj\r\n"
+				     "<< /Type /Pattern\r\n"
+				     "   /PatternType 2\r\n"
+                                     "   /Matrix [ 1 0 0 -1 0 %f ]\r\n"
+				     "   /Shading\r\n"
+				     "      << /ShadingType 2\r\n"
+				     "         /ColorSpace /DeviceGray\r\n"
+				     "         /Coords [ %f %f %f %f ]\r\n"
+				     "         /Function %d 0 R\r\n",
+				     mask_resource.id,
+                                     surface->height,
+				     x0, y0, x1, y1,
+				     alpha_function.id);
+
+        if (extend == CAIRO_EXTEND_PAD) {
+            _cairo_output_stream_printf (surface->output,
+                                         "         /Extend [ true true ]\r\n");
+        } else {
+            _cairo_output_stream_printf (surface->output,
+                                         "         /Extend [ false false ]\r\n");
+        }
+
+        _cairo_output_stream_printf (surface->output,
+				     "      >>\r\n"
+				     ">>\r\n"
+				     "endobj\r\n");
+	_cairo_pdf_surface_add_pattern (surface, mask_resource);
+
+	smask = cairo_pdf_surface_emit_transparency_group (surface, mask_resource);
+        surface->emitted_pattern.smask = smask;
+    }
+
+    surface->emitted_pattern.type = CAIRO_PATTERN_TYPE_LINEAR;
+    surface->emitted_pattern.alpha = _cairo_pdf_surface_add_alpha (surface, 1);
+    surface->emitted_pattern.pattern = pattern_resource;
+    _cairo_pdf_surface_add_pattern (surface, pattern_resource);
 
     _cairo_pdf_surface_resume_content_stream (surface);
 
@@ -1248,16 +1513,23 @@ _cairo_pdf_surface_emit_linear_pattern (
 }
 
 static cairo_status_t
-_cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radial_pattern_t *pattern)
+_cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t    *surface,
+                                        cairo_radial_pattern_t *pattern)
 {
-    cairo_pdf_resource_t function, pattern_resource, alpha;
+    cairo_pdf_resource_t pattern_resource, smask;
+    cairo_pdf_resource_t color_function, alpha_function;
     double x0, y0, x1, y1, r0, r1;
-    cairo_matrix_t p2u;
+    cairo_matrix_t p2u, pdf_p2d;
+    cairo_extend_t extend;
 
+    extend = cairo_pattern_get_extend (&pattern->base.base);
     _cairo_pdf_surface_pause_content_stream (surface);
 
-    function = _cairo_pdf_surface_emit_pattern_stops (surface, &pattern->base);
-    if (function.id == 0)
+    _cairo_pdf_surface_emit_pattern_stops (surface,
+                                           &pattern->base,
+                                           &color_function,
+                                           &alpha_function);
+    if (color_function.id == 0)
 	return CAIRO_STATUS_NO_MEMORY;
 
     p2u = pattern->base.base.matrix;
@@ -1266,57 +1538,95 @@ _cairo_pdf_surface_emit_radial_pattern (
     x0 = _cairo_fixed_to_double (pattern->gradient.c1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.c1.y);
     r0 = _cairo_fixed_to_double (pattern->gradient.c1.radius);
-    cairo_matrix_transform_point (&p2u, &x0, &y0);
     x1 = _cairo_fixed_to_double (pattern->gradient.c2.x);
     y1 = _cairo_fixed_to_double (pattern->gradient.c2.y);
     r1 = _cairo_fixed_to_double (pattern->gradient.c2.radius);
-    cairo_matrix_transform_point (&p2u, &x1, &y1);
 
-    /* FIXME: This is surely crack, but how should you scale a radius
-     * in a non-orthogonal coordinate system? */
-    cairo_matrix_transform_distance (&p2u, &r0, &r1);
-
-    /* FIXME: There is a difference between the cairo gradient extend
-     * semantics and PDF extend semantics. PDFs extend=false means
-     * that nothing is painted outside the gradient boundaries,
-     * whereas cairo takes this to mean that the end color is padded
-     * to infinity. Setting extend=true in PDF gives the cairo default
-     * behavoir, not yet sure how to implement the cairo mirror and
-     * repeat behaviour. */
+    cairo_matrix_init_identity (&pdf_p2d);
+    cairo_matrix_translate (&pdf_p2d, 0.0, surface->height);
+    cairo_matrix_scale (&pdf_p2d, 1.0, -1.0);
+    cairo_matrix_multiply (&pdf_p2d, &p2u, &pdf_p2d);
+
     pattern_resource = _cairo_pdf_surface_new_object (surface);
     _cairo_output_stream_printf (surface->output,
 				 "%d 0 obj\r\n"
 				 "<< /Type /Pattern\r\n"
 				 "   /PatternType 2\r\n"
-				 "   /Matrix [ 1 0 0 -1 0 %f ]\r\n"
-				 "   /Shading\r\n"
-				 "      << /ShadingType 3\r\n"
-				 "         /ColorSpace /DeviceRGB\r\n"
+                                 "   /Matrix [ %f %f %f %f %f %f ]\r\n"
+                                 "   /Shading\r\n"
+                                 "      << /ShadingType 3\r\n"
+                                 "         /ColorSpace /DeviceRGB\r\n"
 				 "         /Coords [ %f %f %f %f %f %f ]\r\n"
-				 "         /Function %d 0 R\r\n"
-				 "         /Extend [ true true ]\r\n"
-				 "      >>\r\n"
-				 ">>\r\n"
-				 "endobj\r\n",
+				 "         /Function %d 0 R\r\n",
 				 pattern_resource.id,
-				 surface->height,
+				 pdf_p2d.xx, pdf_p2d.yx,
+				 pdf_p2d.xy, pdf_p2d.yy,
+				 pdf_p2d.x0, pdf_p2d.y0,
 				 x0, y0, r0, x1, y1, r1,
-				 function.id);
-
-    _cairo_pdf_surface_add_pattern (surface, pattern_resource);
+				 color_function.id);
 
-    alpha = _cairo_pdf_surface_add_alpha (surface, 1.0);
+    if (extend == CAIRO_EXTEND_PAD) {
+        _cairo_output_stream_printf (surface->output,
+                                     "         /Extend [ true true ]\r\n");
+    } else {
+        _cairo_output_stream_printf (surface->output,
+                                     "         /Extend [ false false ]\r\n");
+    }
 
-    /* Use pattern */
-    /* With some work, we could separate the stroking
-     * or non-stroking pattern here as actually needed. */
     _cairo_output_stream_printf (surface->output,
-				 "/Pattern CS /res%d SCN "
-				 "/Pattern cs /res%d scn "
-				 "/a%d gs\r\n",
-				 pattern_resource.id,
-				 pattern_resource.id,
-				 alpha.id);
+				 "      >>\r\n"
+				 ">>\r\n"
+				 "endobj\r\n");
+
+    if (alpha_function.id == 0)
+    {
+        surface->emitted_pattern.smask.id = 0;
+    }
+    else
+    {
+	cairo_pdf_resource_t mask_resource;
+
+        /* Create pattern for SMask. */
+	mask_resource = _cairo_pdf_surface_new_object (surface);
+	_cairo_output_stream_printf (surface->output,
+				     "%d 0 obj\r\n"
+				     "<< /Type /Pattern\r\n"
+				     "   /PatternType 2\r\n"
+				     "   /Matrix [ %f %f %f %f %f %f ]\r\n"
+				     "   /Shading\r\n"
+				     "      << /ShadingType 3\r\n"
+				     "         /ColorSpace /DeviceGray\r\n"
+				     "         /Coords [ %f %f %f %f %f %f ]\r\n"
+				     "         /Function %d 0 R\r\n",
+				     mask_resource.id,
+                                     pdf_p2d.xx, pdf_p2d.yx,
+                                     pdf_p2d.xy, pdf_p2d.yy,
+                                     pdf_p2d.x0, pdf_p2d.y0,
+				     x0, y0, r0, x1, y1, r1,
+				     alpha_function.id);
+
+        if (extend == CAIRO_EXTEND_PAD) {
+            _cairo_output_stream_printf (surface->output,
+                                         "         /Extend [ true true ]\r\n");
+        } else {
+            _cairo_output_stream_printf (surface->output,
+                                         "         /Extend [ false false ]\r\n");
+        }
+
+        _cairo_output_stream_printf (surface->output,
+                                     "      >>\r\n"
+				     ">>\r\n"
+				     "endobj\r\n");
+
+	smask = cairo_pdf_surface_emit_transparency_group (surface, mask_resource);
+        surface->emitted_pattern.smask = smask;
+    }
+
+    surface->emitted_pattern.type = CAIRO_PATTERN_TYPE_RADIAL;
+    surface->emitted_pattern.alpha = _cairo_pdf_surface_add_alpha (surface, 1.0);
+    surface->emitted_pattern.pattern = pattern_resource;
+
+    _cairo_pdf_surface_add_pattern (surface, pattern_resource);
 
     _cairo_pdf_surface_resume_content_stream (surface);
 
@@ -1345,6 +1655,46 @@ _cairo_pdf_surface_emit_pattern (cairo_p
     return CAIRO_STATUS_PATTERN_TYPE_MISMATCH;
 }
 
+static cairo_status_t
+_cairo_pdf_surface_select_pattern (cairo_pdf_surface_t *surface,
+                                   cairo_bool_t         is_stroke)
+{
+    if (surface->emitted_pattern.type == CAIRO_PATTERN_TYPE_SOLID) {
+	_cairo_output_stream_printf (surface->output,
+                                     "%f %f %f ",
+                                     surface->emitted_pattern.red,
+                                     surface->emitted_pattern.green,
+                                     surface->emitted_pattern.blue);
+
+        if (is_stroke)
+            _cairo_output_stream_printf (surface->output, "RG ");
+        else
+            _cairo_output_stream_printf (surface->output, "rg ");
+
+        _cairo_output_stream_printf (surface->output,
+                                     "/a%d gs\r\n",
+                                     surface->emitted_pattern.alpha);
+    } else {
+        if (is_stroke) {
+            _cairo_output_stream_printf (surface->output,
+                                         "/Pattern CS /res%d SCN ",
+                                         surface->emitted_pattern.pattern);
+        } else {
+            _cairo_output_stream_printf (surface->output,
+                                         "/Pattern cs /res%d scn ",
+                                         surface->emitted_pattern.pattern);
+        }
+
+        _cairo_output_stream_printf (surface->output,
+                                     "/a%d gs ",
+                                     surface->emitted_pattern.alpha );
+
+        _cairo_output_stream_printf (surface->output, "\r\n");
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
 static cairo_int_status_t
 _cairo_pdf_surface_copy_page (void *abstract_surface)
 {
@@ -1546,10 +1896,10 @@ _cairo_pdf_surface_write_info (cairo_pdf
 static void
 _cairo_pdf_surface_write_pages (cairo_pdf_surface_t *surface)
 {
-    cairo_pdf_resource_t page, *res;
+    cairo_pdf_resource_t page, *res, smask;
     cairo_pdf_font_t font;
     int num_pages, num_fonts, i;
-    int num_alphas, num_resources;
+    int num_alphas, num_smasks, num_resources;
     double alpha;
 
     _cairo_pdf_surface_update_object (surface, surface->pages_resource);
@@ -1571,19 +1921,25 @@ _cairo_pdf_surface_write_pages (cairo_pd
     _cairo_output_stream_printf (surface->output, "   /Resources <<\r\n");
 
     num_alphas =  _cairo_array_num_elements (&surface->alphas);
-    if (num_alphas > 0) {
+    num_smasks =  _cairo_array_num_elements (&surface->smasks);
+    if (num_alphas > 0 || num_smasks > 0) {
 	_cairo_output_stream_printf (surface->output,
 				     "      /ExtGState <<\r\n");
 
 	for (i = 0; i < num_alphas; i++) {
-	    /* With some work, we could separate the stroking
-	     * or non-stroking alpha here as actually needed. */
 	    _cairo_array_copy_element (&surface->alphas, i, &alpha);
 	    _cairo_output_stream_printf (surface->output,
 					 "         /a%d << /CA %f /ca %f >>\r\n",
 					 i, alpha, alpha);
 	}
 
+        for (i = 0; i < num_smasks; i++) {
+	    _cairo_array_copy_element (&surface->smasks, i, &smask);
+	    _cairo_output_stream_printf (surface->output,
+					 "         /sm%d %d 0 R\r\n",
+					 smask.id, smask.id);
+	}
+
 	_cairo_output_stream_printf (surface->output,
 				     "      >>\r\n");
     }
@@ -1619,14 +1975,20 @@ _cairo_pdf_surface_write_pages (cairo_pd
 				     " >>\r\n");
     }
 
-    _cairo_output_stream_printf (surface->output,"      /Font <<\r\n");
     num_fonts = _cairo_array_num_elements (&surface->fonts);
-    for (i = 0; i < num_fonts; i++) {
-	_cairo_array_copy_element (&surface->fonts, i, &font);
-	_cairo_output_stream_printf (surface->output, "         /CairoFont-%d-%d %d 0 R\r\n",
-				     font.font_id, font.subset_id, font.subset_resource.id);
+    if (num_fonts > 0) {
+        _cairo_output_stream_printf (surface->output,"      /Font <<\r\n");
+        num_fonts = _cairo_array_num_elements (&surface->fonts);
+        for (i = 0; i < num_fonts; i++) {
+            _cairo_array_copy_element (&surface->fonts, i, &font);
+            _cairo_output_stream_printf (surface->output,
+                                         "         /CairoFont-%d-%d %d 0 R\r\n",
+                                         font.font_id,
+                                         font.subset_id,
+                                         font.subset_resource.id);
+        }
+        _cairo_output_stream_printf (surface->output, "      >>\r\n");
     }
-    _cairo_output_stream_printf (surface->output, "      >>\r\n");
 
     _cairo_output_stream_printf (surface->output,
 				 "   >>\r\n");
@@ -2583,11 +2945,49 @@ _surface_pattern_supported (cairo_surfac
 }
 
 static cairo_bool_t
+_gradient_pattern_supported (cairo_pattern_t *pattern)
+{
+    cairo_extend_t extend;
+
+    extend = cairo_pattern_get_extend (pattern);
+
+    if (extend == CAIRO_EXTEND_REPEAT ||
+        extend == CAIRO_EXTEND_REFLECT) {
+        return FALSE;
+    }
+
+    /* Radial gradients are currently only supported when one circle
+     * is inside the other. */
+    if (pattern->type == CAIRO_PATTERN_TYPE_RADIAL) {
+        double x1, y1, x2, y2, r1, r2, d;
+        cairo_radial_pattern_t *radial = (cairo_radial_pattern_t *) pattern;
+
+        x1 = _cairo_fixed_to_double (radial->gradient.c1.x);
+        y1 = _cairo_fixed_to_double (radial->gradient.c1.y);
+        r1 = _cairo_fixed_to_double (radial->gradient.c1.radius);
+        x2 = _cairo_fixed_to_double (radial->gradient.c2.x);
+        y2 = _cairo_fixed_to_double (radial->gradient.c2.y);
+        r2 = _cairo_fixed_to_double (radial->gradient.c2.radius);
+
+        d = sqrt((x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1));
+        if (d > fabs(r2 - r1)) {
+            return FALSE;
+        }
+    }
+
+    return TRUE;
+}
+
+static cairo_bool_t
 _pattern_supported (cairo_pattern_t *pattern)
 {
     if (pattern->type == CAIRO_PATTERN_TYPE_SOLID)
 	return TRUE;
 
+    if (pattern->type == CAIRO_PATTERN_TYPE_LINEAR ||
+	pattern->type == CAIRO_PATTERN_TYPE_RADIAL)
+	return _gradient_pattern_supported (pattern);
+
     if (pattern->type == CAIRO_PATTERN_TYPE_SURFACE)
 	return _surface_pattern_supported ((cairo_surface_pattern_t *) pattern);
 
@@ -2650,6 +3050,7 @@ _cairo_pdf_surface_paint (void			*abstra
 			  cairo_pattern_t	*source)
 {
     cairo_pdf_surface_t *surface = abstract_surface;
+    cairo_pdf_resource_t group = {0}; /* squelch bogus compiler warning */
     cairo_status_t status;
 
     if (surface->paginated_mode == CAIRO_PAGINATED_MODE_ANALYZE)
@@ -2669,10 +3070,33 @@ _cairo_pdf_surface_paint (void			*abstra
     if (status)
 	return status;
 
+    if (surface->emitted_pattern.smask.id != 0) {
+	group = _cairo_pdf_surface_begin_group (surface);
+        _cairo_output_stream_printf (surface->output,
+                                     "1 0 0 -1 0 %f cm\r\n",
+                                     surface->height);
+    } else {
+        _cairo_output_stream_printf (surface->output, "q ");
+    }
+
+    _cairo_pdf_surface_select_pattern (surface, FALSE);
+
     _cairo_output_stream_printf (surface->output,
 				 "0 0 %f %f re f\r\n",
 				 surface->width, surface->height);
 
+    if (surface->emitted_pattern.smask.id != 0) {
+        _cairo_pdf_surface_end_group (surface);
+
+        _cairo_output_stream_printf (surface->output,
+                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
+                                     surface->height,
+                                     surface->emitted_pattern.smask,
+                                     group.id);
+    } else {
+        _cairo_output_stream_printf (surface->output, "Q\r\n");
+    }
+
     return _cairo_output_stream_get_status (surface->output);
 }
 
@@ -2770,6 +3194,7 @@ _cairo_pdf_surface_stroke (void			*abstr
 			   cairo_antialias_t	 antialias)
 {
     cairo_pdf_surface_t *surface = abstract_surface;
+    cairo_pdf_resource_t group = {0}; /* squelch bogus compiler warning */
     pdf_path_info_t info;
     cairo_status_t status;
 
@@ -2782,6 +3207,17 @@ _cairo_pdf_surface_stroke (void			*abstr
     if (status)
 	return status;
 
+    if (surface->emitted_pattern.smask.id != 0) {
+	group = _cairo_pdf_surface_begin_group (surface);
+        _cairo_output_stream_printf (surface->output,
+                                     "1 0 0 -1 0 %f cm\r\n",
+                                     surface->height);
+    } else {
+        _cairo_output_stream_printf (surface->output, "q ");
+    }
+
+    _cairo_pdf_surface_select_pattern (surface, TRUE);
+
     status = _cairo_pdf_surface_emit_stroke_style (surface,
 						   style);
     if (status)
@@ -2805,6 +3241,18 @@ _cairo_pdf_surface_stroke (void			*abstr
 
     _cairo_output_stream_printf (surface->output, "S Q\r\n");
 
+    if (surface->emitted_pattern.smask.id != 0) {
+        _cairo_pdf_surface_end_group (surface);
+
+        _cairo_output_stream_printf (surface->output,
+                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
+                                     surface->height,
+                                     surface->emitted_pattern.smask,
+                                     group.id);
+    } else {
+        _cairo_output_stream_printf (surface->output, "Q\r\n");
+    }
+
     return status;
 }
 
@@ -2818,6 +3266,7 @@ _cairo_pdf_surface_fill (void			*abstrac
 			 cairo_antialias_t	 antialias)
 {
     cairo_pdf_surface_t *surface = abstract_surface;
+    cairo_pdf_resource_t group = {0}; /* squelch bogus compiler warning */
     const char *pdf_operator;
     cairo_status_t status;
     pdf_path_info_t info;
@@ -2831,9 +3280,18 @@ _cairo_pdf_surface_fill (void			*abstrac
     if (status)
 	return status;
 
+    if (surface->emitted_pattern.smask.id != 0) {
+	group = _cairo_pdf_surface_begin_group (surface);
+        _cairo_output_stream_printf (surface->output,
+                                     "1 0 0 -1 0 %f cm\r\n",
+                                     surface->height);
+    } else {
+        _cairo_output_stream_printf (surface->output, "q ");
+    }
+
+    _cairo_pdf_surface_select_pattern (surface, FALSE);
     info.output = surface->output;
     info.ctm_inverse = NULL;
-
     status = _cairo_path_fixed_interpret (path,
 					  CAIRO_DIRECTION_FORWARD,
 					  _cairo_pdf_path_move_to,
@@ -2857,6 +3315,18 @@ _cairo_pdf_surface_fill (void			*abstrac
 				 "%s\r\n",
 				 pdf_operator);
 
+    if (surface->emitted_pattern.smask.id != 0) {
+        _cairo_pdf_surface_end_group (surface);
+
+        _cairo_output_stream_printf (surface->output,
+                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
+                                     surface->height,
+                                     surface->emitted_pattern.smask,
+                                     group.id);
+    } else {
+        _cairo_output_stream_printf (surface->output, "Q\r\n");
+    }
+
     return status;
 }
 
@@ -2869,6 +3339,7 @@ _cairo_pdf_surface_show_glyphs (void			*
 				cairo_scaled_font_t	*scaled_font)
 {
     cairo_pdf_surface_t *surface = abstract_surface;
+    cairo_pdf_resource_t group = {0}; /* squelch bogus compiler warning */
     unsigned int current_subset_id = (unsigned int)-1;
     unsigned int font_id, subset_id, subset_glyph_index;
     cairo_bool_t diagonal;
@@ -2884,6 +3355,17 @@ _cairo_pdf_surface_show_glyphs (void			*
     if (status)
 	return status;
 
+    if (surface->emitted_pattern.smask.id != 0) {
+	group = _cairo_pdf_surface_begin_group (surface);
+        _cairo_output_stream_printf (surface->output,
+                                     "1 0 0 -1 0 %f cm\r\n",
+                                     surface->height);
+    } else {
+        _cairo_output_stream_printf (surface->output, "q ");
+    }
+
+    _cairo_pdf_surface_select_pattern (surface, FALSE);
+
     _cairo_output_stream_printf (surface->output,
 				 "BT\r\n");
 
@@ -2928,6 +3410,18 @@ _cairo_pdf_surface_show_glyphs (void			*
     _cairo_output_stream_printf (surface->output,
 				 "ET\r\n");
 
+    if (surface->emitted_pattern.smask.id != 0) {
+        _cairo_pdf_surface_end_group (surface);
+
+        _cairo_output_stream_printf (surface->output,
+                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
+                                     surface->height,
+                                     surface->emitted_pattern.smask,
+                                     group.id);
+    } else {
+        _cairo_output_stream_printf (surface->output, "Q\r\n");
+    }
+
     return _cairo_output_stream_get_status (surface->output);
 }
 
-- 
1.4.3.4

-------------- next part --------------
>From e2ffa70d39f70b5f92579a149b923e0e49e37c68 Mon Sep 17 00:00:00 2001
From: Adrian Johnson <ajohnson@redneon.com>
Date: Sun, 18 Mar 2007 11:31:17 +1030
Subject: [PATCH] [PATCH] PDF: Change CTM to identity

Some PDF viewers forget the CTM when drawing gradient patterns
with SMasks. This patch works around these bugs by using the default
identity matrix for the CTM. All paths are transformed from
cairo to pdf coordinates before writing to the pdf file.
---
 src/cairo-pdf-surface.c |  163 +++++++++++++++++++++++------------------------
 1 files changed, 79 insertions(+), 84 deletions(-)

diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 4f05a7f..3ee2b8e 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -120,6 +120,7 @@ typedef struct _cairo_pdf_surface {
 
     double width;
     double height;
+    cairo_matrix_t cairo_to_pdf;
 
     cairo_array_t objects;
     cairo_array_t pages;
@@ -296,6 +297,7 @@ _cairo_pdf_surface_create_for_stream_int
 
     surface->width = width;
     surface->height = height;
+    cairo_matrix_init (&surface->cairo_to_pdf, 1, 0, 0, -1, 0, height);
 
     _cairo_array_init (&surface->objects, sizeof (cairo_pdf_object_t));
     _cairo_array_init (&surface->pages, sizeof (cairo_pdf_resource_t));
@@ -694,10 +696,6 @@ _cairo_pdf_surface_start_page (void *abs
 
     _cairo_pdf_surface_add_stream (surface, stream);
 
-    _cairo_output_stream_printf (surface->output,
-				 "1 0 0 -1 0 %f cm\r\n",
-				 surface->height);
-
     return CAIRO_STATUS_SUCCESS;
 }
 
@@ -1406,8 +1404,8 @@ _cairo_pdf_surface_emit_linear_pattern (
 {
     cairo_pdf_resource_t pattern_resource, smask;
     cairo_pdf_resource_t color_function, alpha_function;
-    double x0, y0, x1, y1;
-    cairo_matrix_t p2u;
+    double x1, y1, x2, y2;
+    cairo_matrix_t pat_to_pdf;
     cairo_extend_t extend;
 
     extend = cairo_pattern_get_extend (&pattern->base.base);
@@ -1420,31 +1418,32 @@ _cairo_pdf_surface_emit_linear_pattern (
     if (color_function.id == 0)
 	return CAIRO_STATUS_NO_MEMORY;
 
-    p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+     pat_to_pdf = pattern->base.base.matrix;
+     cairo_matrix_invert (&pat_to_pdf);
+     cairo_matrix_multiply (&pat_to_pdf, &pat_to_pdf, &surface->cairo_to_pdf);
 
-    x0 = _cairo_fixed_to_double (pattern->gradient.p1.x);
-    y0 = _cairo_fixed_to_double (pattern->gradient.p1.y);
-    cairo_matrix_transform_point (&p2u, &x0, &y0);
-    x1 = _cairo_fixed_to_double (pattern->gradient.p2.x);
-    y1 = _cairo_fixed_to_double (pattern->gradient.p2.y);
-    cairo_matrix_transform_point (&p2u, &x1, &y1);
+     x1 = _cairo_fixed_to_double (pattern->gradient.p1.x);
+     y1 = _cairo_fixed_to_double (pattern->gradient.p1.y);
+     x2 = _cairo_fixed_to_double (pattern->gradient.p2.x);
+     y2 = _cairo_fixed_to_double (pattern->gradient.p2.y);
 
     pattern_resource = _cairo_pdf_surface_new_object (surface);
     _cairo_output_stream_printf (surface->output,
 				 "%d 0 obj\r\n"
 				 "<< /Type /Pattern\r\n"
 				 "   /PatternType 2\r\n"
-                                 "   /Matrix [ 1 0 0 -1 0 %f ]\r\n"
+                                 "   /Matrix [ %f %f %f %f %f %f ]\r\n"
 				 "   /Shading\r\n"
 				 "      << /ShadingType 2\r\n"
 				 "         /ColorSpace /DeviceRGB\r\n"
 				 "         /Coords [ %f %f %f %f ]\r\n"
 				 "         /Function %d 0 R\r\n",
 				 pattern_resource.id,
-                                 surface->height,
-				 x0, y0, x1, y1,
-				 color_function.id);
+                                 pat_to_pdf.xx, pat_to_pdf.yx,
+                                 pat_to_pdf.xy, pat_to_pdf.yy,
+                                 pat_to_pdf.x0, pat_to_pdf.y0,
+                                 x1, y1, x2, y2,
+                                 color_function.id);
 
     if (extend == CAIRO_EXTEND_PAD) {
         _cairo_output_stream_printf (surface->output,
@@ -1473,15 +1472,17 @@ _cairo_pdf_surface_emit_linear_pattern (
 				     "%d 0 obj\r\n"
 				     "<< /Type /Pattern\r\n"
 				     "   /PatternType 2\r\n"
-                                     "   /Matrix [ 1 0 0 -1 0 %f ]\r\n"
+                                     "   /Matrix [ %f %f %f %f %f %f ]\r\n"
 				     "   /Shading\r\n"
 				     "      << /ShadingType 2\r\n"
 				     "         /ColorSpace /DeviceGray\r\n"
 				     "         /Coords [ %f %f %f %f ]\r\n"
 				     "         /Function %d 0 R\r\n",
 				     mask_resource.id,
-                                     surface->height,
-				     x0, y0, x1, y1,
+                                     pat_to_pdf.xx, pat_to_pdf.yx,
+                                     pat_to_pdf.xy, pat_to_pdf.yy,
+                                     pat_to_pdf.x0, pat_to_pdf.y0,
+                                     x1, y1, x2, y2,
 				     alpha_function.id);
 
         if (extend == CAIRO_EXTEND_PAD) {
@@ -1518,8 +1519,8 @@ _cairo_pdf_surface_emit_radial_pattern (
 {
     cairo_pdf_resource_t pattern_resource, smask;
     cairo_pdf_resource_t color_function, alpha_function;
-    double x0, y0, x1, y1, r0, r1;
-    cairo_matrix_t p2u, pdf_p2d;
+    double x1, y1, x2, y2, r1, r2;
+    cairo_matrix_t pat_to_pdf;
     cairo_extend_t extend;
 
     extend = cairo_pattern_get_extend (&pattern->base.base);
@@ -1532,20 +1533,16 @@ _cairo_pdf_surface_emit_radial_pattern (
     if (color_function.id == 0)
 	return CAIRO_STATUS_NO_MEMORY;
 
-    p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    pat_to_pdf = pattern->base.base.matrix;
+    cairo_matrix_invert (&pat_to_pdf);
+    cairo_matrix_multiply (&pat_to_pdf, &pat_to_pdf, &surface->cairo_to_pdf);
 
-    x0 = _cairo_fixed_to_double (pattern->gradient.c1.x);
-    y0 = _cairo_fixed_to_double (pattern->gradient.c1.y);
-    r0 = _cairo_fixed_to_double (pattern->gradient.c1.radius);
-    x1 = _cairo_fixed_to_double (pattern->gradient.c2.x);
-    y1 = _cairo_fixed_to_double (pattern->gradient.c2.y);
-    r1 = _cairo_fixed_to_double (pattern->gradient.c2.radius);
-
-    cairo_matrix_init_identity (&pdf_p2d);
-    cairo_matrix_translate (&pdf_p2d, 0.0, surface->height);
-    cairo_matrix_scale (&pdf_p2d, 1.0, -1.0);
-    cairo_matrix_multiply (&pdf_p2d, &p2u, &pdf_p2d);
+    x1 = _cairo_fixed_to_double (pattern->gradient.c1.x);
+    y1 = _cairo_fixed_to_double (pattern->gradient.c1.y);
+    r1 = _cairo_fixed_to_double (pattern->gradient.c1.radius);
+    x2 = _cairo_fixed_to_double (pattern->gradient.c2.x);
+    y2 = _cairo_fixed_to_double (pattern->gradient.c2.y);
+    r2 = _cairo_fixed_to_double (pattern->gradient.c2.radius);
 
     pattern_resource = _cairo_pdf_surface_new_object (surface);
     _cairo_output_stream_printf (surface->output,
@@ -1559,10 +1556,10 @@ _cairo_pdf_surface_emit_radial_pattern (
 				 "         /Coords [ %f %f %f %f %f %f ]\r\n"
 				 "         /Function %d 0 R\r\n",
 				 pattern_resource.id,
-				 pdf_p2d.xx, pdf_p2d.yx,
-				 pdf_p2d.xy, pdf_p2d.yy,
-				 pdf_p2d.x0, pdf_p2d.y0,
-				 x0, y0, r0, x1, y1, r1,
+                                 pat_to_pdf.xx, pat_to_pdf.yx,
+                                 pat_to_pdf.xy, pat_to_pdf.yy,
+                                 pat_to_pdf.x0, pat_to_pdf.y0,
+                                 x1, y1, r1, x2, y2, r2,
 				 color_function.id);
 
     if (extend == CAIRO_EXTEND_PAD) {
@@ -1599,10 +1596,10 @@ _cairo_pdf_surface_emit_radial_pattern (
 				     "         /Coords [ %f %f %f %f %f %f ]\r\n"
 				     "         /Function %d 0 R\r\n",
 				     mask_resource.id,
-                                     pdf_p2d.xx, pdf_p2d.yx,
-                                     pdf_p2d.xy, pdf_p2d.yy,
-                                     pdf_p2d.x0, pdf_p2d.y0,
-				     x0, y0, r0, x1, y1, r1,
+                                     pat_to_pdf.xx, pat_to_pdf.yx,
+                                     pat_to_pdf.xy, pat_to_pdf.yy,
+                                     pat_to_pdf.x0, pat_to_pdf.y0,
+                                     x1, y1, r1, x2, y2, r2,
 				     alpha_function.id);
 
         if (extend == CAIRO_EXTEND_PAD) {
@@ -1739,6 +1736,7 @@ _cairo_pdf_surface_get_extents (void
 
 typedef struct _pdf_path_info {
     cairo_output_stream_t   *output;
+    cairo_matrix_t	    *cairo_to_pdf;
     cairo_matrix_t	    *ctm_inverse;
 } pdf_path_info_t;
 
@@ -1749,6 +1747,8 @@ _cairo_pdf_path_move_to (void *closure,
     double x = _cairo_fixed_to_double (point->x);
     double y = _cairo_fixed_to_double (point->y);
 
+    if (info->cairo_to_pdf)
+        cairo_matrix_transform_point (info->cairo_to_pdf, &x, &y);
     if (info->ctm_inverse)
 	cairo_matrix_transform_point (info->ctm_inverse, &x, &y);
 
@@ -1765,6 +1765,8 @@ _cairo_pdf_path_line_to (void *closure,
     double x = _cairo_fixed_to_double (point->x);
     double y = _cairo_fixed_to_double (point->y);
 
+    if (info->cairo_to_pdf)
+        cairo_matrix_transform_point (info->cairo_to_pdf, &x, &y);
     if (info->ctm_inverse)
 	cairo_matrix_transform_point (info->ctm_inverse, &x, &y);
 
@@ -1787,6 +1789,11 @@ _cairo_pdf_path_curve_to (void
     double dx = _cairo_fixed_to_double (d->x);
     double dy = _cairo_fixed_to_double (d->y);
 
+    if (info->cairo_to_pdf) {
+        cairo_matrix_transform_point (info->cairo_to_pdf, &bx, &by);
+        cairo_matrix_transform_point (info->cairo_to_pdf, &cx, &cy);
+        cairo_matrix_transform_point (info->cairo_to_pdf, &dx, &dy);
+    }
     if (info->ctm_inverse) {
 	cairo_matrix_transform_point (info->ctm_inverse, &bx, &by);
 	cairo_matrix_transform_point (info->ctm_inverse, &cx, &cy);
@@ -1835,6 +1842,7 @@ _cairo_pdf_surface_intersect_clip_path (
     }
 
     info.output = surface->output;
+    info.cairo_to_pdf = &surface->cairo_to_pdf;
     info.ctm_inverse = NULL;
 
     status = _cairo_path_fixed_interpret (path,
@@ -2499,6 +2507,7 @@ _cairo_pdf_surface_emit_outline_glyph (c
 				 -_cairo_fixed_to_double (scaled_glyph->bbox.p1.y));
 
     info.output = surface->output;
+    info.cairo_to_pdf = &surface->cairo_to_pdf;
     info.ctm_inverse = NULL;
 
     status = _cairo_path_fixed_interpret (scaled_glyph->path,
@@ -3070,14 +3079,10 @@ _cairo_pdf_surface_paint (void			*abstra
     if (status)
 	return status;
 
-    if (surface->emitted_pattern.smask.id != 0) {
+    if (surface->emitted_pattern.smask.id != 0)
 	group = _cairo_pdf_surface_begin_group (surface);
-        _cairo_output_stream_printf (surface->output,
-                                     "1 0 0 -1 0 %f cm\r\n",
-                                     surface->height);
-    } else {
+    else
         _cairo_output_stream_printf (surface->output, "q ");
-    }
 
     _cairo_pdf_surface_select_pattern (surface, FALSE);
 
@@ -3089,8 +3094,7 @@ _cairo_pdf_surface_paint (void			*abstra
         _cairo_pdf_surface_end_group (surface);
 
         _cairo_output_stream_printf (surface->output,
-                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
-                                     surface->height,
+                                     "q /sm%d gs /res%d Do Q\r\n",
                                      surface->emitted_pattern.smask,
                                      group.id);
     } else {
@@ -3197,6 +3201,7 @@ _cairo_pdf_surface_stroke (void			*abstr
     cairo_pdf_resource_t group = {0}; /* squelch bogus compiler warning */
     pdf_path_info_t info;
     cairo_status_t status;
+    cairo_matrix_t m;
 
     if (surface->paginated_mode == CAIRO_PAGINATED_MODE_ANALYZE)
 	return _cairo_pdf_surface_analyze_operation (surface, op, source);
@@ -3207,14 +3212,10 @@ _cairo_pdf_surface_stroke (void			*abstr
     if (status)
 	return status;
 
-    if (surface->emitted_pattern.smask.id != 0) {
-	group = _cairo_pdf_surface_begin_group (surface);
-        _cairo_output_stream_printf (surface->output,
-                                     "1 0 0 -1 0 %f cm\r\n",
-                                     surface->height);
-    } else {
+    if (surface->emitted_pattern.smask.id != 0)
+        group = _cairo_pdf_surface_begin_group (surface);
+    else
         _cairo_output_stream_printf (surface->output, "q ");
-    }
 
     _cairo_pdf_surface_select_pattern (surface, TRUE);
 
@@ -3224,12 +3225,14 @@ _cairo_pdf_surface_stroke (void			*abstr
 	return status;
 
     info.output = surface->output;
+    info.cairo_to_pdf = NULL;
     info.ctm_inverse = ctm_inverse;
 
+    cairo_matrix_multiply (&m, ctm, &surface->cairo_to_pdf);
     _cairo_output_stream_printf (surface->output,
 				 "q %f %f %f %f %f %f cm\r\n",
-				 ctm->xx, ctm->yx, ctm->xy, ctm->yy,
-				 ctm->x0, ctm->y0);
+				 m.xx, m.yx, m.xy, m.yy,
+				 m.x0, m.y0);
 
     status = _cairo_path_fixed_interpret (path,
 					  CAIRO_DIRECTION_FORWARD,
@@ -3245,8 +3248,7 @@ _cairo_pdf_surface_stroke (void			*abstr
         _cairo_pdf_surface_end_group (surface);
 
         _cairo_output_stream_printf (surface->output,
-                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
-                                     surface->height,
+                                     "q /sm%d gs /res%d Do Q\r\n",
                                      surface->emitted_pattern.smask,
                                      group.id);
     } else {
@@ -3280,18 +3282,17 @@ _cairo_pdf_surface_fill (void			*abstrac
     if (status)
 	return status;
 
-    if (surface->emitted_pattern.smask.id != 0) {
-	group = _cairo_pdf_surface_begin_group (surface);
-        _cairo_output_stream_printf (surface->output,
-                                     "1 0 0 -1 0 %f cm\r\n",
-                                     surface->height);
-    } else {
+    if (surface->emitted_pattern.smask.id != 0)
+        group = _cairo_pdf_surface_begin_group (surface);
+    else
         _cairo_output_stream_printf (surface->output, "q ");
-    }
 
     _cairo_pdf_surface_select_pattern (surface, FALSE);
+
     info.output = surface->output;
+    info.cairo_to_pdf = &surface->cairo_to_pdf;
     info.ctm_inverse = NULL;
+
     status = _cairo_path_fixed_interpret (path,
 					  CAIRO_DIRECTION_FORWARD,
 					  _cairo_pdf_path_move_to,
@@ -3319,8 +3320,7 @@ _cairo_pdf_surface_fill (void			*abstrac
         _cairo_pdf_surface_end_group (surface);
 
         _cairo_output_stream_printf (surface->output,
-                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
-                                     surface->height,
+                                     "q /sm%d gs /res%d Do Q\r\n",
                                      surface->emitted_pattern.smask,
                                      group.id);
     } else {
@@ -3355,14 +3355,10 @@ _cairo_pdf_surface_show_glyphs (void			*
     if (status)
 	return status;
 
-    if (surface->emitted_pattern.smask.id != 0) {
+    if (surface->emitted_pattern.smask.id != 0)
 	group = _cairo_pdf_surface_begin_group (surface);
-        _cairo_output_stream_printf (surface->output,
-                                     "1 0 0 -1 0 %f cm\r\n",
-                                     surface->height);
-    } else {
+    else
         _cairo_output_stream_printf (surface->output, "q ");
-    }
 
     _cairo_pdf_surface_select_pattern (surface, FALSE);
 
@@ -3391,18 +3387,18 @@ _cairo_pdf_surface_show_glyphs (void			*
             _cairo_output_stream_printf (surface->output,
                                          "%f %f %f %f %f %f Tm <%02x> Tj\r\n",
                                          scaled_font->scale.xx,
-                                         scaled_font->scale.yx,
+                                         -scaled_font->scale.yx,
                                          -scaled_font->scale.xy,
-                                         -scaled_font->scale.yy,
+                                         scaled_font->scale.yy,
                                          glyphs[i].x,
-                                         glyphs[i].y,
+                                         surface->height - glyphs[i].y,
                                          subset_glyph_index);
 	    current_subset_id = subset_id;
         } else {
             _cairo_output_stream_printf (surface->output,
                                          "%f %f Td <%02x> Tj\r\n",
                                          (glyphs[i].x - glyphs[i-1].x)/scaled_font->scale.xx,
-                                         (glyphs[i].y - glyphs[i-1].y)/-scaled_font->scale.yy,
+                                         -(glyphs[i].y - glyphs[i-1].y)/scaled_font->scale.yy,
                                          subset_glyph_index);
         }
     }
@@ -3414,8 +3410,7 @@ _cairo_pdf_surface_show_glyphs (void			*
         _cairo_pdf_surface_end_group (surface);
 
         _cairo_output_stream_printf (surface->output,
-                                     "q 1 0 0 -1 0 %f cm /sm%d gs /res%d Do Q\r\n",
-                                     surface->height,
+                                     "q /sm%d gs /res%d Do Q\r\n",
                                      surface->emitted_pattern.smask,
                                      group.id);
     } else {
-- 
1.4.3.4

From hugo.vincent at gmail.com  Sat Mar 17 22:12:12 2007
From: hugo.vincent at gmail.com (Hugo Vincent)
Date: Sat Mar 17 23:12:04 2007
Subject: [cairo] Re: [cairo-announce] ANN: pycairo release 1.4.0 now
	available
In-Reply-To: <20070318050052.CE7399E887@gabe.freedesktop.org>
References: <20070318050052.CE7399E887@gabe.freedesktop.org>
Message-ID: <0EAA0738-5084-4839-9300-0CC3988E8E2B@gmail.com>

> Date: Sun, 18 Mar 2007 09:44:01 +0800
> From: Steve Chaplin <stevech1097@yahoo.com.au>
> Subject: Re: [cairo] [cairo-announce] ANN: pycairo release 1.4.0 now
> 	available
> To: Dethe Elza <delza@livingcode.org>
> Cc: cairo@cairographics.org
> Message-ID: <1174182241.2781.11.camel@localhost.localdomain>
> Content-Type: text/plain
>
> On Fri, 2007-03-16 at 21:36 -0700, Dethe Elza wrote:
>> This is great news, Steve, thanks for keeping the python bindings
>> caught up with the latest Cairo.
>>
>> Does this by any chance support the Quartz backend, and if not, what
>> would it take to hook PyCairo up to Quartz?
>
> There is no Quartz support in Pycairo. Note that in cairo the Quartz
> backend is still experimental and not supported.
>
> Using Quartz from Pycairo would require a Quartz user write and test a
> QuartzSurface(Surface) class to be added to cairo/pycairo-surface.c
>
> The new class would wrap the cairo C functions:
> cairo_surface_t *
> cairo_quartz_surface_create (cairo_format_t format,
>                              unsigned int width,
>                              unsigned int height);
>
> cairo_surface_t *
> cairo_quartz_surface_create_for_cg_context (CGContextRef cgContext,
>                                             unsigned int width,
>                                             unsigned int height);
>
> CGContextRef
> cairo_quartz_surface_get_cg_context (cairo_surface_t *surface);
>
> The first function prototype looks like it should be easy to do. The
> second and third use CGContextRef, which I understand is a pointer,  
> and
> can't used by pycairo unless there is a preexisting python binding for
> CGContextRef.
>
> Regards
> Steve

As it happens, there are preexisting Python bindings for CGContextRef  
and it ships with Mac OS, although they are proprietary and binary-only.

http://developer.apple.com/graphicsimaging/pythonandquartz.html

http://developer.apple.com/documentation/GraphicsImaging/Conceptual/ 
drawingwithquartz2d/dq_python/chapter_17_section_1.html

Unfortunately, I suspect with the implementation details hidden from  
us (seeing as these bindings are proprietary) it may not be of any  
use for this purpose.

From jeff at infidigm.net  Sun Mar 18 05:59:22 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Sun Mar 18 05:57:39 2007
Subject: [cairo] PDF Transparent Gradients
In-Reply-To: <45FCC778.8010307@redneon.com>
References: <45FCC778.8010307@redneon.com>
Message-ID: <20070318125922.GA3524@infidigm.net>

On Sun, Mar 18, 2007 at 03:30:40PM +1030, Adrian Johnson wrote:
> Poppler does not appear to support SMasks. Also, enabling padding with a
> radial gradient did not pad out the entire rectangle I was filling.

Poppler should support SMasks. What isn't working?

-Jeff
From cook_jim at yahoo.com  Sun Mar 18 09:49:19 2007
From: cook_jim at yahoo.com (Jim Cook)
Date: Sun Mar 18 09:56:03 2007
Subject: [cairo] pyCairo installation
Message-ID: <20070318164919.90725.qmail@web32602.mail.mud.yahoo.com>

I'd like to experiment with pyCairo, but I'm having
installation problems.  I've placed DLL's for cairo
1.4.0, libpng 1.2.8, and zlib 1.2.3 in the directory
c:\python25\dlls\.  However, when I try to install
pycairo 1.4.0 using "setup.py install" I get an error
message from the installer saying that it can't find
cairo 1.4.0.  I'm running Python 2.5 on WinXP.  Any suggestions?

PLEASE REPLY TO: cook_jim@yahoo.com
From ajohnson at redneon.com  Sun Mar 18 15:21:06 2007
From: ajohnson at redneon.com (Adrian Johnson)
Date: Sun Mar 18 15:21:20 2007
Subject: [cairo] PDF Transparent Gradients
In-Reply-To: <20070318125922.GA3524@infidigm.net>
References: <45FCC778.8010307@redneon.com> <20070318125922.GA3524@infidigm.net>
Message-ID: <45FDBB52.2000806@redneon.com>

Jeff Muizelaar wrote:
> On Sun, Mar 18, 2007 at 03:30:40PM +1030, Adrian Johnson wrote:
>> Poppler does not appear to support SMasks. Also, enabling padding with a
>> radial gradient did not pad out the entire rectangle I was filling.
> 
> Poppler should support SMasks. What isn't working?
> 
> -Jeff

I've attached two pdf files containing a linear gradient with a red and
green color stop and the extend mode CAIRO_EXTEND_PAD.  The only
difference between the two is the the green color stop in
transparent_gradient.pdf has 0.5 alpha while in opaque_gradient.pdf it
is 1.0. The red color stop has alpha = 1 in both files.

I've also attached screen captures of each pdf as displayed by evince
and ghostscript. The evince output appears to be identical for both
pdf files.

I am using evince 0.6.1, poppler 0.5.4, and ghostscript 8.54.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: evince_opaque.png
Type: image/png
Size: 25281 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/221f312e/evince_opaque-0001.png
-------------- next part --------------
A non-text attachment was scrubbed...
Name: evince_transparent.png
Type: image/png
Size: 24960 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/221f312e/evince_transparent-0001.png
-------------- next part --------------
A non-text attachment was scrubbed...
Name: gs_opaque.png
Type: image/png
Size: 5252 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/221f312e/gs_opaque-0001.png
-------------- next part --------------
A non-text attachment was scrubbed...
Name: gs_transparent.png
Type: image/png
Size: 9251 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/221f312e/gs_transparent-0001.png
-------------- next part --------------
A non-text attachment was scrubbed...
Name: opaque_gradient.pdf
Type: application/pdf
Size: 9947 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/221f312e/opaque_gradient-0001.pdf
-------------- next part --------------
A non-text attachment was scrubbed...
Name: transparent_gradient.pdf
Type: application/pdf
Size: 11720 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/221f312e/transparent_gradient-0001.pdf
From brian.ewins at gmail.com  Sun Mar 18 15:48:34 2007
From: brian.ewins at gmail.com (Baz)
Date: Sun Mar 18 15:48:38 2007
Subject: [cairo] Re: 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>
References: <20070316222928.1FDEE9E817@gabe.freedesktop.org>
	<ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>
Message-ID: <2faad3050703181548s72a2130qf01c8255f46a9c2b@mail.gmail.com>

On 17/03/07, Hugo Vincent <hugo.vincent@gmail.com> wrote:
> Can the patch for bug 10036 (Cairo-Quartz Line-width-scaling problem)
> be accepted for into 1.4.2 (or even 1.4.4)? Please!?
> https://bugs.freedesktop.org/show_bug.cgi?id=10036

Hugo, I'm about to look at that one again. The patch introduces a new
bug unfortunately - the text-rotate test produces some entertainingly
bad results on quartz when there is an offset in the ctm. I'll be
re-issuing the patch when I have that one fixed (tonight).

Cheers,
Baz
From govindsalinas at gmail.com  Mon Mar 19 00:31:41 2007
From: govindsalinas at gmail.com (Govind Salinas)
Date: Mon Mar 19 00:31:50 2007
Subject: [cairo] Problems erasing a line.
Message-ID: <1174289501.14565.22.camel@govind-desktop>

Hey guys,

I am writing a small project to familiarize myself with c# and all the
new stuff that has come into the gnome-related world lately,
specifically Cairo.  One thing I was trying to do was make a
Gtk.DrawingArea.  When I get a left mouse click I start a rubber band
line to the current mouse location (mouse move events).  As the cursor
moves, I white out my background, erase my old line and draw a new one.
However I keep seeing artifacts of my previous line.

Here is the relevant code:

void draw (Cairo.Context gr, double x, double y, double width, double
height)
{
   gr.Color = m_fillColor; //white

   gr.Rectangle(x, y, width, height);
   gr.Fill();

   if (m_oldTrackX != m_trackX || m_oldTrackY != m_trackY)            
   {
      gr.MoveTo(m_clickX, m_clickY);
      gr.LineTo(m_oldTrackX, m_oldTrackY);
      gr.Stroke();
   }

   gr.Color = m_drawColor; //black
   if (m_clickX > 0 && m_trackX > 0)
   {
      gr.MoveTo(m_clickX, m_clickY);
      gr.LineTo(m_trackX, m_trackY);
      gr.Stroke();
   }
}

This more or less works other than I get artifacts of previous lines.

As an experiment I tried this:

void draw (Cairo.Context gr, double x, double y, double width, double
height)
{
   gr.Color = m_fillColor; //white

   gr.Rectangle(x, y, width, height);
   gr.Fill();

   gr.Color = m_drawColor; //black
   if (m_clickX > 0 && m_trackX > 0)
   {
      gr.MoveTo(m_clickX, m_clickY);
      gr.LineTo(m_trackX, m_trackY);
      gr.StrokePreserve();
      gr.Color = m_fillColor; //white
      gr.Stroke();
   }
}

What I get from this is the outside of the line I was drawing (I
successfully erased the middle of the line but left two thinner lines in
its place).  I would expect that this leaves me with a blank canvas.  Is
there some fundamental thing that I am missing that will get this to
work?  The only way I have gotten this to draw cleanly is to invalidate
the whole area (QueueDraw() for example) and then draw the new line.
While this works its seems like an expensive way to erase a line.  Can
someone tell me where I am going wrong?


Thanks,
Govind.

From spitzak at d2.com  Mon Mar 19 03:53:15 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Mon Mar 19 03:53:29 2007
Subject: [cairo] Problems erasing a line.
In-Reply-To: <1174289501.14565.22.camel@govind-desktop>
References: <1174289501.14565.22.camel@govind-desktop>
Message-ID: <45FE6B9B.3060507@d2.com>

Erasing the entire area and drawing all over again (your third solution) 
is the proper way to do it under Cairo.

The problem you are having is that antialiasing makes exact erasure of 
the previous line impossible because you are drawing a white line with 
transparent edges. You could probably erase the line by drawing a white 
rectangle of 1 pixel larger than the two line ends or a thicker white 
line. But you will quickly run into trouble if the background is not a 
plain white area, which is what would happen in any interesting real 
program.

Trying to do "incremenatal update" like you are doing is pretty much 
obsolete nowadays. The graphics i/o is way too fast to put up with the 
limits on what kinds of graphics that are drawn and the errors in 
display because of bugs due to unexpected combinations of updates. And 
on some hardware designs it is faster to draw from scratch, as 
retireving the old picture to draw onto it is slower than anything else.
From chris at chris-wilson.co.uk  Sun Mar 18 16:41:00 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Mon Mar 19 08:11:43 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <1174078471.28587.6.camel@behdad>
References: <87zm6dw40w.wl%cworth@cworth.org>
	<20070316201659.GD4618@inspired.chris-wilson.co.uk>
	<1174078471.28587.6.camel@behdad>
Message-ID: <20070318234100.GA13779@inspired.chris-wilson.co.uk>

Behdad Esfahbod (behdad@behdad.org) said: 
> Should we use some gcc attribute to get warnings about ignoring
> cairo_status_t and cairo_int_status_t return values?

Tested this out and the results are in favour of the compiler versus the
programmer. The attached patches add a CAIRO_WARN_UNUSED_RESULT to all
cairo_[int_]_status_t functions and fixes up the majority by simplying
propagating the status. The 'few' that are left were either marked as
being ignored or looked a bit too complex for me to touch.

Please review and check that this is sane - it passes make check, but
these changes should have only affected error paths...
--
Chris Wilson
-------------- next part --------------
>From 1bca6e4ed407c570595c65501cfbcdbe10e95591 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sun, 18 Mar 2007 21:45:46 +0000
Subject: [PATCH] Add the warn-if-result-unused attribute to all private functions
returning a status.
---
 src/cairoint.h |  260 +++++++++++++++++++++++++++++---------------------------
 1 files changed, 134 insertions(+), 126 deletions(-)

diff --git a/src/cairoint.h b/src/cairoint.h
index 357a8b1..d67ea93 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -101,6 +101,14 @@ CAIRO_BEGIN_DECLS
 #define CAIRO_PRINTF_FORMAT(fmt_index, va_index)
 #endif
 
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#define CAIRO_WARN_UNUSED_RESULT 		\
+  __attribute__((warn_unused_result))
+#else
+#define CAIRO_WARN_UNUSED_RESULT
+#endif /* __GNUC__ */
+
+
 /* slim_internal.h */
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
 #define cairo_private		__attribute__((__visibility__("hidden")))
@@ -491,21 +499,21 @@ _cairo_array_init_snapshot (cairo_array_t	*array,
 cairo_private void
 _cairo_array_fini (cairo_array_t *array);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_array_grow_by (cairo_array_t *array, int additional);
 
 cairo_private void
 _cairo_array_truncate (cairo_array_t *array, unsigned int num_elements);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_array_append (cairo_array_t *array, const void *element);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_array_append_multiple (cairo_array_t	*array,
 			      const void	*elements,
 			      int		 num_elements);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_array_allocate (cairo_array_t	 *array,
 		       unsigned int	  num_elements,
 		       void		**elements);
@@ -534,7 +542,7 @@ cairo_private void *
 _cairo_user_data_array_get_data (cairo_user_data_array_t     *array,
 				 const cairo_user_data_key_t *key);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_user_data_array_set_data (cairo_user_data_array_t     *array,
 				 const cairo_user_data_key_t *key,
 				 void			     *user_data,
@@ -1312,7 +1320,7 @@ cairo_private int
 _cairo_fixed_integer_ceil (cairo_fixed_t f);
 
 /* cairo_gstate.c */
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_init (cairo_gstate_t  *gstate,
 		    cairo_surface_t *target);
 
@@ -1343,52 +1351,52 @@ _cairo_gstate_get_original_target (cairo_gstate_t *gstate);
 cairo_private cairo_clip_t *
 _cairo_gstate_get_clip (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_source (cairo_gstate_t *gstate, cairo_pattern_t *source);
 
 cairo_private cairo_pattern_t *
 _cairo_gstate_get_source (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_operator (cairo_gstate_t *gstate, cairo_operator_t op);
 
 cairo_private cairo_operator_t
 _cairo_gstate_get_operator (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_tolerance (cairo_gstate_t *gstate, double tolerance);
 
 cairo_private double
 _cairo_gstate_get_tolerance (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_fill_rule (cairo_gstate_t *gstate, cairo_fill_rule_t fill_rule);
 
 cairo_private cairo_fill_rule_t
 _cairo_gstate_get_fill_rule (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_line_width (cairo_gstate_t *gstate, double width);
 
 cairo_private double
 _cairo_gstate_get_line_width (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_line_cap (cairo_gstate_t *gstate, cairo_line_cap_t line_cap);
 
 cairo_private cairo_line_cap_t
 _cairo_gstate_get_line_cap (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_line_join (cairo_gstate_t *gstate, cairo_line_join_t line_join);
 
 cairo_private cairo_line_join_t
 _cairo_gstate_get_line_join (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_dash (cairo_gstate_t *gstate, const double *dash, int num_dashes, double offset);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_miter_limit (cairo_gstate_t *gstate, double limit);
 
 cairo_private double
@@ -1397,36 +1405,36 @@ _cairo_gstate_get_miter_limit (cairo_gstate_t *gstate);
 cairo_private void
 _cairo_gstate_get_matrix (cairo_gstate_t *gstate, cairo_matrix_t *matrix);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_translate (cairo_gstate_t *gstate, double tx, double ty);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_scale (cairo_gstate_t *gstate, double sx, double sy);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_rotate (cairo_gstate_t *gstate, double angle);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_transform (cairo_gstate_t	      *gstate,
 			 const cairo_matrix_t *matrix);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_matrix (cairo_gstate_t       *gstate,
 			  const cairo_matrix_t *matrix);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_identity_matrix (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_user_to_device (cairo_gstate_t *gstate, double *x, double *y);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_user_to_device_distance (cairo_gstate_t *gstate, double *dx, double *dy);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_device_to_user (cairo_gstate_t *gstate, double *x, double *y);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_device_to_user_distance (cairo_gstate_t *gstate, double *dx, double *dy);
 
 cairo_private void
@@ -1441,58 +1449,58 @@ _cairo_gstate_backend_to_user_rectangle (cairo_gstate_t *gstate,
                                          double *x2, double *y2,
                                          cairo_bool_t *is_tight);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_paint (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_mask (cairo_gstate_t  *gstate,
 		    cairo_pattern_t *mask);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_stroke (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_fill (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_copy_page (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_show_page (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_stroke_extents (cairo_gstate_t	 *gstate,
 			      cairo_path_fixed_t *path,
                               double *x1, double *y1,
 			      double *x2, double *y2);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_fill_extents (cairo_gstate_t     *gstate,
 			    cairo_path_fixed_t *path,
                             double *x1, double *y1,
 			    double *x2, double *y2);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_in_stroke (cairo_gstate_t	    *gstate,
 			 cairo_path_fixed_t *path,
 			 double		     x,
 			 double		     y,
 			 cairo_bool_t	    *inside_ret);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_in_fill (cairo_gstate_t	  *gstate,
 		       cairo_path_fixed_t *path,
 		       double		   x,
 		       double		   y,
 		       cairo_bool_t	  *inside_ret);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_clip (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_reset_clip (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_clip_extents (cairo_gstate_t *gstate,
 		            double         *x1,
 		            double         *y1,
@@ -1502,7 +1510,7 @@ _cairo_gstate_clip_extents (cairo_gstate_t *gstate,
 cairo_private cairo_rectangle_list_t*
 _cairo_gstate_copy_clip_rectangle_list (cairo_gstate_t *gstate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_show_surface (cairo_gstate_t	*gstate,
 			    cairo_surface_t	*surface,
 			    double		 x,
@@ -1510,13 +1518,13 @@ _cairo_gstate_show_surface (cairo_gstate_t	*gstate,
 			    double		width,
 			    double		height);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_select_font_face (cairo_gstate_t *gstate,
 				const char *family,
 				cairo_font_slant_t slant,
 				cairo_font_weight_t weight);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_font_size (cairo_gstate_t *gstate,
 			     double          size);
 
@@ -1524,7 +1532,7 @@ cairo_private void
 _cairo_gstate_get_font_matrix (cairo_gstate_t *gstate,
 			       cairo_matrix_t *matrix);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_font_matrix (cairo_gstate_t	    *gstate,
 			       const cairo_matrix_t *matrix);
 
@@ -1532,27 +1540,27 @@ cairo_private void
 _cairo_gstate_get_font_options (cairo_gstate_t       *gstate,
 				cairo_font_options_t *options);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_font_options (cairo_gstate_t	           *gstate,
 				const cairo_font_options_t *options);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_get_font_face (cairo_gstate_t     *gstate,
 			     cairo_font_face_t **font_face);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_get_scaled_font (cairo_gstate_t       *gstate,
 			       cairo_scaled_font_t **scaled_font);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_get_font_extents (cairo_gstate_t *gstate,
 				cairo_font_extents_t *extents);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_font_face (cairo_gstate_t    *gstate,
 			     cairo_font_face_t *font_face);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_text_to_glyphs (cairo_gstate_t *font,
 			      const char     *utf8,
 			      double	      x,
@@ -1560,18 +1568,18 @@ _cairo_gstate_text_to_glyphs (cairo_gstate_t *font,
 			      cairo_glyph_t **glyphs,
 			      int	     *num_glyphs);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_glyph_extents (cairo_gstate_t *gstate,
 			     const cairo_glyph_t *glyphs,
 			     int num_glyphs,
 			     cairo_text_extents_t *extents);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_show_glyphs (cairo_gstate_t *gstate,
 			   const cairo_glyph_t *glyphs,
 			   int num_glyphs);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_glyph_path (cairo_gstate_t      *gstate,
 			  const cairo_glyph_t *glyphs,
 			  int		       num_glyphs,
@@ -1671,7 +1679,7 @@ _cairo_font_options_init_copy (cairo_font_options_t		*options,
 			       const cairo_font_options_t	*other);
 
 /* cairo_hull.c */
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices);
 
 /* cairo-lzw.c */
@@ -1689,7 +1697,7 @@ _cairo_operator_always_translucent (cairo_operator_t op);
 cairo_private void
 _cairo_path_fixed_init (cairo_path_fixed_t *path);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_init_copy (cairo_path_fixed_t *path,
 			     cairo_path_fixed_t *other);
 
@@ -1702,7 +1710,7 @@ _cairo_path_fixed_fini (cairo_path_fixed_t *path);
 cairo_private void
 _cairo_path_fixed_destroy (cairo_path_fixed_t *path);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_move_to (cairo_path_fixed_t  *path,
 			   cairo_fixed_t	x,
 			   cairo_fixed_t	y);
@@ -1710,37 +1718,37 @@ _cairo_path_fixed_move_to (cairo_path_fixed_t  *path,
 cairo_private void
 _cairo_path_fixed_new_sub_path (cairo_path_fixed_t *path);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_rel_move_to (cairo_path_fixed_t *path,
 			       cairo_fixed_t	   dx,
 			       cairo_fixed_t	   dy);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_line_to (cairo_path_fixed_t *path,
 			   cairo_fixed_t	x,
 			   cairo_fixed_t	y);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_rel_line_to (cairo_path_fixed_t *path,
 			       cairo_fixed_t	   dx,
 			       cairo_fixed_t	   dy);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_curve_to (cairo_path_fixed_t	*path,
 			    cairo_fixed_t x0, cairo_fixed_t y0,
 			    cairo_fixed_t x1, cairo_fixed_t y1,
 			    cairo_fixed_t x2, cairo_fixed_t y2);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_rel_curve_to (cairo_path_fixed_t *path,
 				cairo_fixed_t dx0, cairo_fixed_t dy0,
 				cairo_fixed_t dx1, cairo_fixed_t dy1,
 				cairo_fixed_t dx2, cairo_fixed_t dy2);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_close_path (cairo_path_fixed_t *path);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_get_current_point (cairo_path_fixed_t *path,
 				     cairo_fixed_t	*x,
 				     cairo_fixed_t	*y);
@@ -1762,7 +1770,7 @@ typedef cairo_status_t
 typedef cairo_status_t
 (cairo_path_fixed_close_path_func_t) (void *closure);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_interpret (cairo_path_fixed_t		  *path,
 		       cairo_direction_t		   dir,
 		       cairo_path_fixed_move_to_func_t	  *move_to,
@@ -1771,7 +1779,7 @@ _cairo_path_fixed_interpret (cairo_path_fixed_t		  *path,
 		       cairo_path_fixed_close_path_func_t *close_path,
 		       void				  *closure);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_bounds (cairo_path_fixed_t *path,
 			  double *x1, double *y1,
 			  double *x2, double *y2);
@@ -1781,14 +1789,14 @@ _cairo_path_fixed_device_transform (cairo_path_fixed_t	*path,
 				    cairo_matrix_t	*device_transform);
 
 /* cairo_path_fill.c */
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_fill_to_traps (cairo_path_fixed_t *path,
 				 cairo_fill_rule_t   fill_rule,
 				 double              tolerance,
 				 cairo_traps_t      *traps);
 
 /* cairo_path_stroke.c */
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
 				   cairo_stroke_style_t	*stroke_style,
 				   cairo_matrix_t	*ctm,
@@ -1798,7 +1806,7 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
 
 /* cairo-scaled-font.c */
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			 cairo_font_face_t		   *font_face,
 			 const cairo_matrix_t              *font_matrix,
@@ -1813,11 +1821,11 @@ _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 cairo_private void
 _cairo_scaled_font_fini (cairo_scaled_font_t *scaled_font);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_font_extents (cairo_scaled_font_t  *scaled_font,
 				 cairo_font_extents_t *extents);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t	*scaled_font,
 				   double		x,
 				   double		y,
@@ -1825,13 +1833,13 @@ _cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t	*scaled_font,
 				   cairo_glyph_t       **glyphs,
 				   int 		        *num_glyphs);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t	 *scaled_font,
 					 const cairo_glyph_t	 *glyphs,
 					 int                      num_glyphs,
 					 cairo_rectangle_int16_t *extents);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_show_glyphs (cairo_scaled_font_t *scaled_font,
 				cairo_operator_t     op,
 				cairo_pattern_t	    *source,
@@ -1845,7 +1853,7 @@ _cairo_scaled_font_show_glyphs (cairo_scaled_font_t *scaled_font,
 				cairo_glyph_t	    *glyphs,
 				int		     num_glyphs);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_glyph_path (cairo_scaled_font_t *scaled_font,
 			       const cairo_glyph_t *glyphs,
 			       int                  num_glyphs,
@@ -1866,7 +1874,7 @@ _cairo_scaled_glyph_set_path (cairo_scaled_glyph_t *scaled_glyph,
 			      cairo_scaled_font_t *scaled_font,
 			      cairo_path_fixed_t *path);
 
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_scaled_glyph_lookup (cairo_scaled_font_t *scaled_font,
 			    unsigned long index,
 			    cairo_scaled_glyph_info_t info,
@@ -1880,7 +1888,7 @@ _cairo_scaled_font_map_destroy (void);
 cairo_private void
 _cairo_stroke_style_init (cairo_stroke_style_t *style);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroke_style_init_copy (cairo_stroke_style_t *style,
 			       cairo_stroke_style_t *other);
 
@@ -1923,7 +1931,7 @@ _cairo_surface_set_font_options (cairo_surface_t       *surface,
 cairo_private cairo_clip_mode_t
 _cairo_surface_get_clip_mode (cairo_surface_t *surface);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_composite (cairo_operator_t	op,
 			  cairo_pattern_t	*src,
 			  cairo_pattern_t	*mask,
@@ -1937,7 +1945,7 @@ _cairo_surface_composite (cairo_operator_t	op,
 			  unsigned int		width,
 			  unsigned int		height);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fill_rectangle (cairo_surface_t	   *surface,
 			       cairo_operator_t	    op,
 			       const cairo_color_t *color,
@@ -1946,31 +1954,31 @@ _cairo_surface_fill_rectangle (cairo_surface_t	   *surface,
 			       int		    width,
 			       int		    height);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fill_region (cairo_surface_t	   *surface,
 			    cairo_operator_t	    op,
 			    const cairo_color_t    *color,
 			    pixman_region16_t      *region);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fill_rectangles (cairo_surface_t		*surface,
 				cairo_operator_t         op,
 				const cairo_color_t	*color,
 				cairo_rectangle_int16_t *rects,
 				int			 num_rects);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_paint (cairo_surface_t	*surface,
 		      cairo_operator_t	 op,
 		      cairo_pattern_t	*source);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_mask (cairo_surface_t	*surface,
 		     cairo_operator_t	 op,
 		     cairo_pattern_t	*source,
 		     cairo_pattern_t	*mask);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_stroke (cairo_surface_t		*surface,
 		       cairo_operator_t		 op,
 		       cairo_pattern_t		*source,
@@ -1981,7 +1989,7 @@ _cairo_surface_stroke (cairo_surface_t		*surface,
 		       double			 tolerance,
 		       cairo_antialias_t	 antialias);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fill (cairo_surface_t	*surface,
 		     cairo_operator_t	 op,
 		     cairo_pattern_t	*source,
@@ -1990,7 +1998,7 @@ _cairo_surface_fill (cairo_surface_t	*surface,
 		     double		 tolerance,
 		     cairo_antialias_t	 antialias);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_show_glyphs (cairo_surface_t	*surface,
 			    cairo_operator_t	 op,
 			    cairo_pattern_t	*source,
@@ -1998,7 +2006,7 @@ _cairo_surface_show_glyphs (cairo_surface_t	*surface,
 			    int			 num_glyphs,
 			    cairo_scaled_font_t	*scaled_font);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_composite_trapezoids (cairo_operator_t	op,
 				     cairo_pattern_t	*pattern,
 				     cairo_surface_t	*dst,
@@ -2012,13 +2020,13 @@ _cairo_surface_composite_trapezoids (cairo_operator_t	op,
 				     cairo_trapezoid_t	*traps,
 				     int		ntraps);
 
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_surface_copy_page (cairo_surface_t *surface);
 
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_surface_show_page (cairo_surface_t *surface);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_acquire_source_image (cairo_surface_t         *surface,
 				     cairo_image_surface_t  **image_out,
 				     void                   **image_extra);
@@ -2028,7 +2036,7 @@ _cairo_surface_release_source_image (cairo_surface_t        *surface,
 				     cairo_image_surface_t  *image,
 				     void                   *image_extra);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_acquire_dest_image (cairo_surface_t         *surface,
 				   cairo_rectangle_int16_t *interest_rect,
 				   cairo_image_surface_t  **image_out,
@@ -2042,7 +2050,7 @@ _cairo_surface_release_dest_image (cairo_surface_t        *surface,
 				   cairo_rectangle_int16_t      *image_rect,
 				   void                   *image_extra);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_clone_similar (cairo_surface_t  *surface,
 			      cairo_surface_t  *src,
 			      int               src_x,
@@ -2060,29 +2068,29 @@ _cairo_surface_get_current_clip_serial (cairo_surface_t *surface);
 cairo_private unsigned int
 _cairo_surface_allocate_clip_serial (cairo_surface_t *surface);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_reset_clip (cairo_surface_t *surface);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_set_clip_region (cairo_surface_t	    *surface,
 				pixman_region16_t   *region,
 				unsigned int	    serial);
 
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_surface_intersect_clip_path (cairo_surface_t    *surface,
 				    cairo_path_fixed_t *path,
 				    cairo_fill_rule_t   fill_rule,
 				    double		tolerance,
 				    cairo_antialias_t	antialias);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_set_clip (cairo_surface_t *surface, cairo_clip_t *clip);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_get_extents (cairo_surface_t         *surface,
 			    cairo_rectangle_int16_t *rectangle);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*pattern,
@@ -2096,7 +2104,7 @@ _cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
 				cairo_glyph_t		*glyphs,
 				int			 num_glyphs);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_composite_fixup_unbounded (cairo_surface_t            *dst,
 					  cairo_surface_attributes_t *src_attr,
 					  int                         src_width,
@@ -2113,7 +2121,7 @@ _cairo_surface_composite_fixup_unbounded (cairo_surface_t            *dst,
 					  unsigned int		      width,
 					  unsigned int		      height);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
 						cairo_surface_attributes_t *src_attr,
 						int                         src_width,
@@ -2221,7 +2229,7 @@ _cairo_image_surface_assume_ownership_of_data (cairo_image_surface_t *surface);
  * backends, so doing that will require synchronizing several backend
  * maintainers.
  */
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_image_surface_set_clip_region (void *abstract_surface,
 				      pixman_region16_t *region);
 
@@ -2236,42 +2244,42 @@ cairo_private cairo_bool_t
 _cairo_surface_is_meta (const cairo_surface_t *surface);
 
 /* cairo_pen.c */
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_init (cairo_pen_t	*pen,
 		 double		 radius,
 		 double		 tolerance,
 		 cairo_matrix_t	*ctm);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_init_empty (cairo_pen_t *pen);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_init_copy (cairo_pen_t *pen, cairo_pen_t *other);
 
 cairo_private void
 _cairo_pen_fini (cairo_pen_t *pen);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_add_points_for_slopes (cairo_pen_t *pen,
 				  cairo_point_t *a,
 				  cairo_point_t *b,
 				  cairo_point_t *c,
 				  cairo_point_t *d);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_find_active_cw_vertex_index (cairo_pen_t *pen,
 					cairo_slope_t *slope,
 					int *active);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_find_active_ccw_vertex_index (cairo_pen_t *pen,
 					 cairo_slope_t *slope,
 					 int *active);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_stroke_spline (cairo_pen_t *pen,
 			  cairo_spline_t *spline,
 			  double tolerance,
@@ -2284,27 +2292,27 @@ _cairo_polygon_init (cairo_polygon_t *polygon);
 cairo_private void
 _cairo_polygon_fini (cairo_polygon_t *polygon);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_polygon_add_edge (cairo_polygon_t *polygon, cairo_point_t *p1, cairo_point_t *p2);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_polygon_move_to (cairo_polygon_t *polygon, cairo_point_t *point);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_polygon_line_to (cairo_polygon_t *polygon, cairo_point_t *point);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_polygon_close (cairo_polygon_t *polygon);
 
 /* cairo_spline.c */
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_spline_init (cairo_spline_t *spline,
 		    cairo_point_t *a,
 		    cairo_point_t *b,
 		    cairo_point_t *c,
 		    cairo_point_t *d);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_spline_decompose (cairo_spline_t *spline, double tolerance);
 
 cairo_private void
@@ -2326,7 +2334,7 @@ _cairo_matrix_transform_bounding_box (const cairo_matrix_t *matrix,
 cairo_private void
 _cairo_matrix_compute_determinant (const cairo_matrix_t *matrix, double *det);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_matrix_compute_scale_factors (const cairo_matrix_t *matrix,
 				     double *sx, double *sy, int x_major);
 
@@ -2351,7 +2359,7 @@ _cairo_matrix_to_pixman_matrix (const cairo_matrix_t	*matrix,
 cairo_private void
 _cairo_traps_init (cairo_traps_t *traps);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_init_box (cairo_traps_t *traps,
 		       cairo_box_t   *box);
 
@@ -2361,23 +2369,23 @@ _cairo_traps_fini (cairo_traps_t *traps);
 cairo_private void
 _cairo_traps_translate (cairo_traps_t *traps, int x, int y);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_tessellate_triangle (cairo_traps_t *traps, cairo_point_t t[3]);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_tessellate_convex_quad (cairo_traps_t *traps, cairo_point_t q[4]);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_tessellate_polygon (cairo_traps_t *traps,
 				 cairo_polygon_t *poly,
 				 cairo_fill_rule_t fill_rule);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_add_trap_from_points (cairo_traps_t *traps, cairo_fixed_t top, cairo_fixed_t bottom,
 				   cairo_point_t left_p1, cairo_point_t left_p2,
 				   cairo_point_t right_p1, cairo_point_t right_p2);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t      *traps,
 					   cairo_polygon_t      *polygon,
 					   cairo_fill_rule_t     fill_rule);
@@ -2388,7 +2396,7 @@ _cairo_traps_contain (cairo_traps_t *traps, double x, double y);
 cairo_private void
 _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_extract_region (cairo_traps_t      *tr,
 			     pixman_region16_t **region);
 
@@ -2414,7 +2422,7 @@ _cairo_slope_counter_clockwise (cairo_slope_t *a, cairo_slope_t *b);
 
 /* cairo_pattern.c */
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pattern_init_copy (cairo_pattern_t	*pattern,
 			  const cairo_pattern_t *other);
 
@@ -2451,7 +2459,7 @@ _cairo_pattern_is_opaque_solid (const cairo_pattern_t *pattern);
 cairo_private cairo_bool_t
 _cairo_pattern_is_opaque (const cairo_pattern_t *abstract_pattern);
 
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pattern_acquire_surface (cairo_pattern_t		   *pattern,
 				cairo_surface_t		   *dst,
 				int			   x,
@@ -2466,7 +2474,7 @@ _cairo_pattern_release_surface (cairo_pattern_t		   *pattern,
 				cairo_surface_t		   *surface,
 				cairo_surface_attributes_t *attributes);
 
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pattern_acquire_surfaces (cairo_pattern_t	    *src,
 				 cairo_pattern_t	    *mask,
 				 cairo_surface_t	    *dst,
@@ -2481,11 +2489,11 @@ _cairo_pattern_acquire_surfaces (cairo_pattern_t	    *src,
 				 cairo_surface_attributes_t *src_attributes,
 				 cairo_surface_attributes_t *mask_attributes);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pattern_get_extents (cairo_pattern_t	    *pattern,
 			    cairo_rectangle_int16_t *extents);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_set_antialias (cairo_gstate_t *gstate,
 			     cairo_antialias_t antialias);
 
@@ -2503,13 +2511,13 @@ _cairo_region_extents_rectangle (pixman_region16_t       *region,
 
 /* cairo_unicode.c */
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_utf8_to_ucs4 (const unsigned char *str,
 		     int		  len,
 		     uint32_t	        **result,
 		     int		 *items_written);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_utf8_to_utf16 (const unsigned char *str,
 		      int		   len,
 		      uint16_t		 **result,
-- 
1.4.4.2

-------------- next part --------------
>From 6b9b0c1e7def3d06d626d1f6e75c813e7cf9d68c Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sun, 18 Mar 2007 22:42:17 +0000
Subject: [PATCH] Fixup the majority of warn-if-unused-results.

Propagate status returns for all the simple cases.
---
 pixman/src/icimage.c          |    2 +-
 src/cairo-clip-private.h      |   12 +++---
 src/cairo-clip.c              |   19 +++++++++--
 src/cairo-ft-font.c           |   31 ++++++++++++++----
 src/cairo-gstate.c            |   24 ++++++++++++--
 src/cairo-meta-surface.c      |    9 ++++-
 src/cairo-paginated-surface.c |   17 +++++++---
 src/cairo-path-fill.c         |    2 +-
 src/cairo-path-stroke.c       |   65 ++++++++++++++++++++++++++++----------
 src/cairo-path.c              |    5 ++-
 src/cairo-pattern.c           |   23 +++++++------
 src/cairo-pdf-surface.c       |   20 +++++------
 src/cairo-pen.c               |   28 ++++++++++------
 src/cairo-polygon.c           |    8 ++---
 src/cairo-ps-surface.c        |   30 ++++++++++-------
 src/cairo-scaled-font.c       |   33 ++++++++++++++-----
 src/cairo-surface-fallback.c  |   11 +++++--
 src/cairo-surface.c           |   12 +++++--
 src/cairo-svg-surface.c       |   10 +++++-
 src/cairo.c                   |   70 ++++++++++++++++++++++++++++-------------
 src/cairoint.h                |    6 ++--
 21 files changed, 299 insertions(+), 138 deletions(-)

diff --git a/pixman/src/icimage.c b/pixman/src/icimage.c
index c9b525d..8be3d00 100644
--- a/pixman/src/icimage.c
+++ b/pixman/src/icimage.c
@@ -188,7 +188,7 @@ _pixman_create_source_image (void)
 
     image = (pixman_image_t *) malloc (sizeof (pixman_image_t));
     if (!image)
-	return;
+	return NULL;
     image->pDrawable   = NULL;
     image->pixels      = NULL;
     image->format_code = PICT_a8r8g8b8;
diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index 3c4ff0d..bfd8d77 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -89,15 +89,15 @@ _cairo_clip_fini (cairo_clip_t *clip);
 cairo_private void
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other);
 
-cairo_private void
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_reset (cairo_clip_t *clip);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_clip (cairo_clip_t       *clip,
 		  cairo_path_fixed_t *path,
 		  cairo_fill_rule_t   fill_rule,
@@ -105,15 +105,15 @@ _cairo_clip_clip (cairo_clip_t       *clip,
 		  cairo_antialias_t   antialias,
 		  cairo_surface_t    *target);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_intersect_to_rectangle (cairo_clip_t            *clip,
 				    cairo_rectangle_int16_t *rectangle);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 				 pixman_region16_t *region);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_combine_to_surface (cairo_clip_t                  *clip,
 				cairo_operator_t               op,
 				cairo_surface_t               *dst,
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index efecd89..966cf74 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -549,11 +549,12 @@ _cairo_clip_path_reapply_clip_path (cairo_clip_t      *clip,
                                 clip_path->antialias);
 }
 
-void
+cairo_status_t
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target)
 {
+    cairo_status_t status;
     _cairo_clip_init (clip, target);
 
     if (other->mode != clip->mode) {
@@ -562,16 +563,23 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
     } else {
         if (other->region) {
             clip->region = pixman_region_create ();
+	    if (!clip->region)
+		return CAIRO_STATUS_NO_MEMORY;
             pixman_region_copy (clip->region, other->region);
         }
 
         if (other->surface) {
-            _cairo_surface_clone_similar (target, other->surface,
+            status = _cairo_surface_clone_similar (target, other->surface,
 					  other->surface_rect.x,
 					  other->surface_rect.y,
 					  other->surface_rect.width,
 					  other->surface_rect.height,
 					  &clip->surface);
+	    if (status) {
+		if (clip->region)
+		    pixman_region_destroy (clip->region);
+		return status;
+	    }
             clip->surface_rect = other->surface_rect;
         }
 
@@ -579,6 +587,8 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
             _cairo_clip_path_reapply_clip_path (clip, other->path);
         }
     }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 const cairo_rectangle_list_t _cairo_rectangles_nil =
@@ -635,8 +645,9 @@ _cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate)
         }
     } else {
         cairo_rectangle_int16_t extents;
-        _cairo_surface_get_extents (_cairo_gstate_get_target (gstate), &extents);
-        if (!_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
+	cairo_status_t status;
+        status = _cairo_surface_get_extents (_cairo_gstate_get_target (gstate), &extents);
+        if (status || !_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
                                       extents.width, extents.height,
                                       rectangles)) {
             free (rectangles);
diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index 04095c2..c174275 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -574,12 +574,13 @@ _cairo_ft_unscaled_font_unlock_face (cairo_ft_unscaled_font_t *unscaled)
 }
 slim_hidden_def (cairo_ft_scaled_font_unlock_face);
 
-static void
+static cairo_status_t
 _compute_transform (cairo_ft_font_transform_t *sf,
 		    cairo_matrix_t      *scale)
 {
     cairo_matrix_t normalized = *scale;
     double tx, ty;
+    cairo_status_t status;
 
     /* The font matrix has x and y "scale" components which we extract and
      * use as character scale values. These influence the way freetype
@@ -588,9 +589,11 @@ _compute_transform (cairo_ft_font_transform_t *sf,
      * freetype's transformation.
      */
 
-    _cairo_matrix_compute_scale_factors (&normalized,
+    status = _cairo_matrix_compute_scale_factors (&normalized,
 					 &sf->x_scale, &sf->y_scale,
 					 /* XXX */ 1);
+    if (status)
+	return status;
 
     if (sf->x_scale != 0 && sf->y_scale != 0) {
 	cairo_matrix_scale (&normalized, 1.0 / sf->x_scale, 1.0 / sf->y_scale);
@@ -603,6 +606,8 @@ _compute_transform (cairo_ft_font_transform_t *sf,
 	sf->shape[0][0] = sf->shape[1][1] = 1.0;
 	sf->shape[0][1] = sf->shape[1][0] = 0.0;
     }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /* Temporarily scales an unscaled font to the give scale. We catch
@@ -613,6 +618,7 @@ _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 				   cairo_matrix_t	      *scale)
 {
     cairo_ft_font_transform_t sf;
+    cairo_status_t status;
     FT_Matrix mat;
     FT_Error error;
 
@@ -628,7 +634,8 @@ _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
     unscaled->have_scale = TRUE;
     unscaled->current_scale = *scale;
 
-    _compute_transform (&sf, scale);
+    status = _compute_transform (&sf, scale);
+    assert (status == CAIRO_STATUS_SUCCESS);
 
     unscaled->x_scale = sf.x_scale;
     unscaled->y_scale = sf.y_scale;
@@ -1156,23 +1163,27 @@ _transform_glyph_bitmap (cairo_matrix_t         * shape,
 
     /* Initialize it to empty
      */
-    _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
+    status = _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
 				   CAIRO_COLOR_TRANSPARENT,
 				   0, 0,
 				   width, height);
+    if (status)
+	return status;
 
     /* Draw the original bitmap transformed into the new bitmap
      */
     _cairo_pattern_init_for_surface (&pattern, &(*surface)->base);
     cairo_pattern_set_matrix (&pattern.base, &transformed_to_original);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+    status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
 			      &pattern.base, NULL, image,
 			      0, 0, 0, 0, 0, 0,
 			      width,
 			      height);
 
     _cairo_pattern_fini (&pattern.base);
+    if (status)
+	return status;
 
     /* Now update the cache entry for the new bitmap, recomputing
      * the origin based on the final transform.
@@ -1527,6 +1538,7 @@ _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
     int fcweight;
     cairo_matrix_t scale;
     cairo_ft_font_transform_t sf;
+    cairo_status_t status;
     cairo_ft_options_t ft_options;
     unsigned char *family = (unsigned char*) toy_face->family;
 
@@ -1567,7 +1579,9 @@ _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
 	goto FREE_PATTERN;
 
     cairo_matrix_multiply (&scale, font_matrix, ctm);
-    _compute_transform (&sf, &scale);
+    status = _compute_transform (&sf, &scale);
+    if (status)
+	return status;
 
     FcPatternAddInteger (pattern, FC_PIXEL_SIZE, sf.y_scale);
 
@@ -1725,6 +1739,7 @@ _decompose_glyph_outline (FT_Face		  face,
 
     FT_GlyphSlot glyph;
     cairo_path_fixed_t *path;
+    cairo_status_t status;
 
     path = _cairo_path_fixed_create ();
     if (!path)
@@ -1736,7 +1751,9 @@ _decompose_glyph_outline (FT_Face		  face,
     FT_Outline_Transform (&glyph->outline, &invert_y);
     FT_Outline_Decompose (&glyph->outline, &outline_funcs, path);
 
-    _cairo_path_fixed_close_path (path);
+    status = _cairo_path_fixed_close_path (path);
+    if (status)
+	return status;
 
     *pathp = path;
 
diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index d109e3e..7a57494 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -64,6 +64,8 @@ cairo_status_t
 _cairo_gstate_init (cairo_gstate_t  *gstate,
 		    cairo_surface_t *target)
 {
+    cairo_status_t status;
+
     gstate->op = CAIRO_GSTATE_OPERATOR_DEFAULT;
 
     gstate->tolerance = CAIRO_GSTATE_TOLERANCE_DEFAULT;
@@ -88,7 +90,9 @@ _cairo_gstate_init (cairo_gstate_t  *gstate,
     gstate->parent_target = NULL;
     gstate->original_target = cairo_surface_reference (target);
 
-    _cairo_gstate_identity_matrix (gstate);
+    status = _cairo_gstate_identity_matrix (gstate);
+    if (status)
+	return status;
     gstate->source_ctm_inverse = gstate->ctm_inverse;
 
     gstate->source = _cairo_pattern_create_solid (CAIRO_COLOR_BLACK);
@@ -252,9 +256,11 @@ _cairo_gstate_recursive_apply_clip_path (cairo_gstate_t *gstate,
  * original #cairo_t target, the clip will be INVALID after this call,
  * and the caller should either recreate or reset the clip.
  **/
-void
+cairo_status_t
 _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child)
 {
+    cairo_status_t status;
+
     /* If this gstate is already redirected, this is an error; we need a
      * new gstate to be able to redirect */
     assert (gstate->parent_target == NULL);
@@ -270,13 +276,20 @@ _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child)
     gstate->target = cairo_surface_reference (child);
 
     _cairo_clip_fini (&gstate->clip);
-    _cairo_clip_init_deep_copy (&gstate->clip, &gstate->next->clip, child);
+    status = _cairo_clip_init_deep_copy (&gstate->clip, &gstate->next->clip, child);
+    if (status) {
+	cairo_surface_destroy (gstate->target);
+	gstate->target = NULL;
+	return status;
+    }
 
     /* The clip is in surface backend coordinates for the previous target;
      * translate it into the child's backend coordinates. */
     _cairo_clip_translate (&gstate->clip,
                            _cairo_fixed_from_double (child->device_transform.x0 - gstate->parent_target->device_transform.x0),
                            _cairo_fixed_from_double (child->device_transform.y0 - gstate->parent_target->device_transform.y0));
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /**
@@ -1209,12 +1222,15 @@ _cairo_gstate_select_font_face (cairo_gstate_t       *gstate,
 				cairo_font_weight_t   weight)
 {
     cairo_font_face_t *font_face;
+    cairo_status_t status;
 
     font_face = _cairo_toy_font_face_create (family, slant, weight);
     if (font_face->status)
 	return font_face->status;
 
-    _cairo_gstate_set_font_face (gstate, font_face);
+    status = _cairo_gstate_set_font_face (gstate, font_face);
+    if (status)
+	return status;
     cairo_font_face_destroy (font_face);
 
     return CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-meta-surface.c b/src/cairo-meta-surface.c
index e196df2..b6665cb 100644
--- a/src/cairo-meta-surface.c
+++ b/src/cairo-meta-surface.c
@@ -212,7 +212,10 @@ static cairo_status_t
 _init_pattern_with_snapshot (cairo_pattern_t       *pattern,
 			     const cairo_pattern_t *other)
 {
-    _cairo_pattern_init_copy (pattern, other);
+    cairo_status_t status;
+    status = _cairo_pattern_init_copy (pattern, other);
+    if (status)
+	return status;
 
     if (pattern->type == CAIRO_PATTERN_TYPE_SURFACE) {
 	cairo_surface_pattern_t *surface_pattern =
@@ -668,7 +671,9 @@ _cairo_meta_surface_replay (cairo_surface_t *surface,
 
 	dev_path = _cairo_command_get_path (command);
 	if (dev_path && has_device_transform) {
-	    _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    status = _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    if (status)
+		break;
 	    _cairo_path_fixed_device_transform (&path_copy, device_transform);
 	    dev_path = &path_copy;
 	}
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index c8e4612..023f2a7 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -202,8 +202,11 @@ _cairo_paginated_surface_acquire_source_image (void	       *abstract_surface,
     cairo_paginated_surface_t *surface = abstract_surface;
     cairo_surface_t *image;
     cairo_rectangle_int16_t extents;
+    cairo_status_t status;
 
-    _cairo_surface_get_extents (surface->target, &extents);
+    status = _cairo_surface_get_extents (surface->target, &extents);
+    if (status)
+	return status;
 
     image = _cairo_paginated_surface_create_image_surface (surface,
 							   extents.width,
@@ -231,7 +234,7 @@ _paint_page (cairo_paginated_surface_t *surface)
     cairo_surface_t *analysis;
     cairo_surface_t *image;
     cairo_pattern_t *pattern;
-    cairo_status_t status;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
 
     analysis = _cairo_analysis_surface_create (surface->target,
 					       surface->width, surface->height);
@@ -263,7 +266,9 @@ _paint_page (cairo_paginated_surface_t *surface)
 	cairo_matrix_init_scale (&matrix, x_scale, y_scale);
 	cairo_pattern_set_matrix (pattern, &matrix);
 
-	_cairo_surface_paint (surface->target, CAIRO_OPERATOR_SOURCE, pattern);
+	status = _cairo_surface_paint (surface->target,
+		                       CAIRO_OPERATOR_SOURCE,
+				       pattern);
 
 	cairo_pattern_destroy (pattern);
 
@@ -276,7 +281,7 @@ _paint_page (cairo_paginated_surface_t *surface)
 
     cairo_surface_destroy (analysis);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
@@ -325,7 +330,9 @@ _cairo_paginated_surface_show_page (void *abstract_surface)
 
     _paint_page (surface);
 
-    _cairo_surface_show_page (surface->target);
+    status = _cairo_surface_show_page (surface->target);
+    if (status)
+	return status;
 
     cairo_surface_destroy (surface->meta);
 
diff --git a/src/cairo-path-fill.c b/src/cairo-path-fill.c
index b1b7a12..d2a9118 100644
--- a/src/cairo-path-fill.c
+++ b/src/cairo-path-fill.c
@@ -138,7 +138,7 @@ _cairo_filler_curve_to (void *closure,
     if (status == CAIRO_INT_STATUS_DEGENERATE)
 	return CAIRO_STATUS_SUCCESS;
 
-    _cairo_spline_decompose (&spline, filler->tolerance);
+    status = _cairo_spline_decompose (&spline, filler->tolerance);
     if (status)
 	goto CLEANUP_SPLINE;
 
diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index ebe7c90..d4db605 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -75,7 +75,7 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     double			 tolerance,
 		     cairo_traps_t		*traps);
 
-static void
+static cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker);
 
 static cairo_status_t
@@ -176,10 +176,10 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		            tolerance, ctm);
 }
 
-static void
+static cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker)
 {
-    _cairo_pen_fini (&stroker->pen);
+    return _cairo_pen_fini (&stroker->pen);
 }
 
 static void
@@ -205,6 +205,7 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 {
     int			clockwise = _cairo_stroker_face_clockwise (out, in);
     cairo_point_t	*inpt, *outpt;
+    cairo_status_t status;
 
     if (in->cw.x == out->cw.x
 	&& in->cw.y == out->cw.y
@@ -231,13 +232,21 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 
 	tri[0] = in->point;
 	if (clockwise) {
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = -1;
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	} else {
-	    _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = +1;
-	    _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	}
 
 	i = start;
@@ -245,7 +254,9 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 	while (i != stop) {
 	    tri[2] = in->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	    i += step;
 	    if (i < 0)
@@ -378,17 +389,23 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	cairo_pen_t *pen = &stroker->pen;
 
 	slope = f->dev_vector;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	if (status)
+	    return status;
 	slope.dx = -slope.dx;
 	slope.dy = -slope.dy;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	if (status)
+	    return status;
 
 	tri[0] = f->point;
 	tri[1] = f->cw;
 	for (i=start; i != stop; i = (i+1) % pen->num_vertices) {
 	    tri[2] = f->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	}
 	tri[2] = f->ccw;
@@ -414,13 +431,24 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	ocw.y = f->cw.y + fvector.dy;
 
 	_cairo_polygon_init (&polygon);
-	_cairo_polygon_move_to (&polygon, &f->cw);
-	_cairo_polygon_line_to (&polygon, &ocw);
-	_cairo_polygon_line_to (&polygon, &occw);
-	_cairo_polygon_line_to (&polygon, &f->ccw);
-	_cairo_polygon_close (&polygon);
+	status = _cairo_polygon_move_to (&polygon, &f->cw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &ocw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &occw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &f->ccw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_close (&polygon);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
 
 	status = _cairo_bentley_ottmann_tessellate_polygon (stroker->traps, &polygon, CAIRO_FILL_RULE_WINDING);
+CLEANUP_LINE_CAP_SQUARE:
 	_cairo_polygon_fini (&polygon);
 
 	return status;
@@ -779,6 +807,7 @@ _cairo_stroker_curve_to (void *closure,
 			 cairo_point_t *d)
 {
     cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status2;
     cairo_stroker_t *stroker = closure;
     cairo_spline_t spline;
     cairo_pen_t pen;
@@ -830,7 +859,9 @@ _cairo_stroker_curve_to (void *closure,
 	goto CLEANUP_PEN;
 
   CLEANUP_PEN:
-    _cairo_pen_fini (&pen);
+    status2 = _cairo_pen_fini (&pen);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
   CLEANUP_SPLINE:
     _cairo_spline_fini (&spline);
 
diff --git a/src/cairo-path.c b/src/cairo-path.c
index 7c2374c..a12db36 100644
--- a/src/cairo-path.c
+++ b/src/cairo-path.c
@@ -136,13 +136,14 @@ _cairo_path_count (cairo_path_t		*path,
 		   cairo_bool_t		 flatten)
 {
     cpc_t cpc;
+    cairo_status_t status;
 
     cpc.count = 0;
     cpc.tolerance = tolerance;
     cpc.current_point.x = 0;
     cpc.current_point.y = 0;
 
-    _cairo_path_fixed_interpret (path_fixed,
+    status = _cairo_path_fixed_interpret (path_fixed,
 				 CAIRO_DIRECTION_FORWARD,
 				 _cpc_move_to,
 				 _cpc_line_to,
@@ -151,6 +152,8 @@ _cairo_path_count (cairo_path_t		*path,
 				 _cpc_curve_to,
 				 _cpc_close_path,
 				 &cpc);
+    if (status)
+	return 0;
 
     return cpc.count;
 }
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index 1f53ae1..e3857ba 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -1608,7 +1608,9 @@ _cairo_pattern_acquire_surfaces (cairo_pattern_t	    *src,
     }
     else
     {
-	_cairo_pattern_init_copy (&src_tmp.base, src);
+	status = _cairo_pattern_init_copy (&src_tmp.base, src);
+	if (status)
+	    return status;
     }
 
     status = _cairo_pattern_acquire_surface (&src_tmp.base, dst,
@@ -1627,16 +1629,17 @@ _cairo_pattern_acquire_surfaces (cairo_pattern_t	    *src,
 	return CAIRO_STATUS_SUCCESS;
     }
 
-    _cairo_pattern_init_copy (&mask_tmp.base, mask);
-
-    status = _cairo_pattern_acquire_surface (&mask_tmp.base, dst,
-					     mask_x, mask_y,
-					     width, height,
-					     mask_out, mask_attributes);
+    status = _cairo_pattern_init_copy (&mask_tmp.base, mask);
 
-    if (status)
-	_cairo_pattern_release_surface (&src_tmp.base,
-					*src_out, src_attributes);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	status = _cairo_pattern_acquire_surface (&mask_tmp.base, dst,
+						 mask_x, mask_y,
+						 width, height,
+						 mask_out, mask_attributes);
+	if (status)
+	    _cairo_pattern_release_surface (&src_tmp.base,
+					    *src_out, src_attributes);
+    }
 
     _cairo_pattern_fini (&src_tmp.base);
     _cairo_pattern_fini (&mask_tmp.base);
diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 924b80c..25e5058 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -900,7 +900,9 @@ _cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	*surface,
     if (status)
 	goto BAIL;
 
-    _cairo_surface_get_extents (&surface->base, &surface_extents);
+    status = _cairo_surface_get_extents (&surface->base, &surface_extents);
+    if (status)
+	goto BAIL;
 
     switch (extend) {
     /* We implement EXTEND_PAD like EXTEND_NONE for now */
@@ -1822,11 +1824,11 @@ _cairo_pdf_surface_emit_cff_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_cff_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
@@ -1931,9 +1933,7 @@ _cairo_pdf_surface_emit_type1_font (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 #if CAIRO_HAS_FT_FONT
@@ -2102,11 +2102,11 @@ _cairo_pdf_surface_emit_truetype_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_truetype_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_int_status_t
@@ -2387,9 +2387,7 @@ _cairo_pdf_surface_emit_type3_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 static void
diff --git a/src/cairo-pen.c b/src/cairo-pen.c
index 1af8c36..66984b3 100644
--- a/src/cairo-pen.c
+++ b/src/cairo-pen.c
@@ -106,13 +106,13 @@ _cairo_pen_init (cairo_pen_t	*pen,
     return CAIRO_STATUS_SUCCESS;
 }
 
-void
+cairo_status_t
 _cairo_pen_fini (cairo_pen_t *pen)
 {
     free (pen->vertices);
     pen->vertices = NULL;
 
-    _cairo_pen_init_empty (pen);
+    return _cairo_pen_init_empty (pen);
 }
 
 cairo_status_t
@@ -135,6 +135,7 @@ cairo_status_t
 _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
 {
     cairo_pen_vertex_t *vertices;
+    cairo_status_t status;
     int num_vertices;
     int i;
 
@@ -150,7 +151,9 @@ _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
     for (i=0; i < num_points; i++)
 	pen->vertices[pen->num_vertices-num_points+i].point = point[i];
 
-    _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    status = _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    if (status)
+	return status;
 
     _cairo_pen_compute_slopes (pen);
 
@@ -388,7 +391,9 @@ _cairo_pen_stroke_spline_half (cairo_pen_t *pen,
 	final_slope.dy = -final_slope.dy;
     }
 
-    _cairo_pen_find_active_cw_vertex_index (pen, &initial_slope, &active);
+    status = _cairo_pen_find_active_cw_vertex_index (pen, &initial_slope, &active);
+    if (status)
+	return status;
 
     i = start;
     while (i != stop) {
@@ -437,19 +442,22 @@ _cairo_pen_stroke_spline (cairo_pen_t		*pen,
 
     status = _cairo_spline_decompose (spline, tolerance);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_FORWARD, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_REVERSE, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
-    _cairo_polygon_close (&polygon);
-    _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
+    status = _cairo_polygon_close (&polygon);
+    if (status)
+	goto BAIL;
+    status = _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
+BAIL:
     _cairo_polygon_fini (&polygon);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
diff --git a/src/cairo-polygon.c b/src/cairo-polygon.c
index 52c72b7..86191ca 100644
--- a/src/cairo-polygon.c
+++ b/src/cairo-polygon.c
@@ -135,9 +135,7 @@ _cairo_polygon_add_edge (cairo_polygon_t *polygon, cairo_point_t *p1, cairo_poin
     polygon->num_edges++;
 
   DONE:
-    _cairo_polygon_move_to (polygon, p2);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_polygon_move_to (polygon, p2);
 }
 
 cairo_status_t
@@ -154,12 +152,12 @@ _cairo_polygon_move_to (cairo_polygon_t *polygon, cairo_point_t *point)
 cairo_status_t
 _cairo_polygon_line_to (cairo_polygon_t *polygon, cairo_point_t *point)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
 
     if (polygon->has_current_point) {
 	status = _cairo_polygon_add_edge (polygon, &polygon->current_point, point);
     } else {
-	_cairo_polygon_move_to (polygon, point);
+	status = _cairo_polygon_move_to (polygon, point);
     }
 
     return status;
diff --git a/src/cairo-ps-surface.c b/src/cairo-ps-surface.c
index 5f43e98..612865d 100644
--- a/src/cairo-ps-surface.c
+++ b/src/cairo-ps-surface.c
@@ -1588,20 +1588,21 @@ _cairo_ps_surface_emit_image (cairo_ps_surface_t    *surface,
 
 	_cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-	_cairo_surface_fill_rectangle (opaque,
+	status = _cairo_surface_fill_rectangle (opaque,
 				       CAIRO_OPERATOR_SOURCE,
 				       CAIRO_COLOR_WHITE,
 				       0, 0, image->width, image->height);
 
-	_cairo_surface_composite (CAIRO_OPERATOR_OVER,
-				  &pattern.base,
-				  NULL,
-				  opaque,
-				  0, 0,
-				  0, 0,
-				  0, 0,
-				  image->width,
-				  image->height);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+				      &pattern.base,
+				      NULL,
+				      opaque,
+				      0, 0,
+				      0, 0,
+				      0, 0,
+				      image->width,
+				      image->height);
 
 	_cairo_pattern_fini (&pattern.base);
 	opaque_image = (cairo_image_surface_t *) opaque;
@@ -1930,6 +1931,7 @@ _cairo_ps_surface_paint (void			*abstract_surface,
     cairo_ps_surface_t *surface = abstract_surface;
     cairo_output_stream_t *stream = surface->stream;
     cairo_rectangle_int16_t extents, pattern_extents;
+    cairo_status_t status;
 
     if (surface->paginated_mode == CAIRO_PAGINATED_MODE_ANALYZE)
 	return _cairo_ps_surface_analyze_operation (surface, op, source);
@@ -1947,8 +1949,12 @@ _cairo_ps_surface_paint (void			*abstract_surface,
     _cairo_output_stream_printf (stream,
 				 "%% _cairo_ps_surface_paint\n");
 
-    _cairo_surface_get_extents (&surface->base, &extents);
-    _cairo_pattern_get_extents (source, &pattern_extents);
+    status = _cairo_surface_get_extents (&surface->base, &extents);
+    if (status)
+	return status;
+    status = _cairo_pattern_get_extents (source, &pattern_extents);
+    if (status)
+	return status;
     _cairo_rectangle_intersect (&extents, &pattern_extents);
 
     _cairo_ps_surface_emit_pattern (surface, source);
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 3497323..870ca9c 100755
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -403,15 +403,18 @@ _cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font)
 					       max_glyphs_cached_per_font);
 }
 
-void
+cairo_status_t
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics)
 {
     double  font_scale_x, font_scale_y;
+    cairo_status_t status;
 
-    _cairo_matrix_compute_scale_factors (&scaled_font->font_matrix,
+    status = _cairo_matrix_compute_scale_factors (&scaled_font->font_matrix,
 					 &font_scale_x, &font_scale_y,
 					 /* XXX */ 1);
+    if (status)
+	return status;
 
     /*
      * The font responded in unscaled units, scale by the font
@@ -423,6 +426,8 @@ _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
     scaled_font->extents.height = fs_metrics->height * font_scale_y;
     scaled_font->extents.max_x_advance = fs_metrics->max_x_advance * font_scale_x;
     scaled_font->extents.max_y_advance = fs_metrics->max_y_advance * font_scale_y;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 void
@@ -1207,6 +1212,7 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
     int rows, cols, bytes_per_row;
     int x, y, bit;
     double xoff, yoff;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
 
     if (mask->format == CAIRO_FORMAT_A1)
 	a1_mask = mask;
@@ -1224,28 +1230,39 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
 	    byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte_ptr);
 	    for (bit = 7; bit >= 0 && x < a1_mask->width; bit--, x++) {
 		if (byte & (1 << bit)) {
-		    _cairo_path_fixed_move_to (path,
+		    status = _cairo_path_fixed_move_to (path,
 					       _cairo_fixed_from_int (x + xoff),
 					       _cairo_fixed_from_int (y + yoff));
-		    _cairo_path_fixed_rel_line_to (path,
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
 						   _cairo_fixed_from_int (1),
 						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_rel_line_to (path,
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
 						   _cairo_fixed_from_int (0),
 						   _cairo_fixed_from_int (1));
-		    _cairo_path_fixed_rel_line_to (path,
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
 						   _cairo_fixed_from_int (-1),
 						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_close_path (path);
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_close_path (path);
+		    if (status)
+			goto BAIL;
 		}
 	    }
 	}
     }
 
+BAIL:
     if (a1_mask != mask)
 	cairo_surface_destroy (&a1_mask->base);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..581c3ad 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -453,7 +453,7 @@ _composite_trap_region (cairo_clip_t            *clip,
 
     /* Restore the original clip if we modified it temporarily. */
     if (num_rects >1)
-	_cairo_surface_set_clip (dst, clip);
+	status = _cairo_surface_set_clip (dst, clip);
 
     if (clip_surface)
       _cairo_pattern_fini (&mask.base);
@@ -979,7 +979,7 @@ _cairo_surface_fallback_snapshot (cairo_surface_t *surface)
 
     _cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
+    status = _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
 			      &pattern.base,
 			      NULL,
 			      snapshot,
@@ -993,6 +993,11 @@ _cairo_surface_fallback_snapshot (cairo_surface_t *surface)
 
     _cairo_surface_release_source_image (surface,
 					 image, &image_extra);
+    if (status != CAIRO_STATUS_SUCCESS) {
+	cairo_surface_destroy (snapshot);
+	return (cairo_surface_t *) &_cairo_surface_nil;
+    }
+
 
     snapshot->device_transform = surface->device_transform;
     snapshot->device_transform_inverse = surface->device_transform_inverse;
@@ -1158,7 +1163,7 @@ _cairo_surface_fallback_composite_trapezoids (cairo_operator_t		op,
 	traps = offset_traps;
     }
 
-    _cairo_surface_composite_trapezoids (op, pattern,
+    status = _cairo_surface_composite_trapezoids (op, pattern,
 					 &state.image->base,
 					 antialias,
 					 src_x, src_y,
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index 740d7fd..9552c20 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -81,7 +81,7 @@ DEFINE_NIL_SURFACE(CAIRO_STATUS_FILE_NOT_FOUND, _cairo_surface_nil_file_not_foun
 DEFINE_NIL_SURFACE(CAIRO_STATUS_READ_ERROR, _cairo_surface_nil_read_error);
 DEFINE_NIL_SURFACE(CAIRO_STATUS_WRITE_ERROR, _cairo_surface_nil_write_error);
 
-static void
+static cairo_status_t
 _cairo_surface_copy_pattern_for_destination (const cairo_pattern_t *pattern,
 					     cairo_surface_t *destination,
 					     cairo_pattern_t *pattern_out);
@@ -2069,16 +2069,18 @@ _cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
  * Copies the given pattern, taking into account device scale and offsets
  * of the destination surface.
  */
-void
+static cairo_status_t
 _cairo_surface_copy_pattern_for_destination (const cairo_pattern_t *pattern,
                                              cairo_surface_t *destination,
                                              cairo_pattern_t *pattern_out)
 {
-    _cairo_pattern_init_copy (pattern_out, pattern);
+    cairo_status_t status;
+    status = _cairo_pattern_init_copy (pattern_out, pattern);
+    if (status)
+	return status;
 
     if (_cairo_surface_has_device_transform (destination)) {
 	cairo_matrix_t device_to_surface = destination->device_transform;
-	cairo_status_t status;
 
 	status = cairo_matrix_invert (&device_to_surface);
 	/* We only ever allow for scaling (under the implementation's
@@ -2088,6 +2090,8 @@ _cairo_surface_copy_pattern_for_destination (const cairo_pattern_t *pattern,
 
 	_cairo_pattern_transform (pattern_out, &device_to_surface);
     }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /*  LocalWords:  rasterized
diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index 5cb9ce0..a58c8cb 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -435,6 +435,7 @@ _cairo_svg_surface_store_page (cairo_svg_surface_t *surface)
 {
     unsigned int i;
     cairo_svg_page_t page;
+    cairo_status_t status;
 
     page.surface_id = surface->id;
     page.clip_id = surface->base_clip;
@@ -447,7 +448,9 @@ _cairo_svg_surface_store_page (cairo_svg_surface_t *surface)
     for (i = 0; i < page.clip_level; i++)
 	_cairo_output_stream_printf (page.xml_node, "</g>\n");
 
-    _cairo_array_append (&surface->page_set, &page);
+    status = _cairo_array_append (&surface->page_set, &page);
+    if (status)
+	return NULL;
 
     return _cairo_array_index (&surface->page_set, surface->page_set.num_elements - 1);
 }
@@ -459,6 +462,8 @@ _cairo_svg_surface_copy_page (void *abstract_surface)
     cairo_svg_page_t *page;
 
     page = _cairo_svg_surface_store_page (surface);
+    if (page == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
 
     _cairo_memory_stream_copy (page->xml_node, surface->xml_node);
     surface->clip_level = page->clip_level;
@@ -471,7 +476,8 @@ _cairo_svg_surface_show_page (void *abstract_surface)
 {
     cairo_svg_surface_t *surface = abstract_surface;
 
-    _cairo_svg_surface_store_page (surface);
+    if (_cairo_svg_surface_store_page (surface) == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
 
     return CAIRO_STATUS_SUCCESS;
 }
diff --git a/src/cairo.c b/src/cairo.c
index 21303de..2f720c7 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -189,6 +189,7 @@ cairo_t *
 cairo_create (cairo_surface_t *target)
 {
     cairo_t *cr;
+    cairo_status_t status;
 
     cr = malloc (sizeof (cairo_t));
     if (cr == NULL)
@@ -201,7 +202,10 @@ cairo_create (cairo_surface_t *target)
     _cairo_user_data_array_init (&cr->user_data);
 
     cr->gstate = cr->gstate_tail;
-    _cairo_gstate_init (cr->gstate, target);
+    status = _cairo_gstate_init (cr->gstate, target);
+    if (status) {
+	_cairo_set_error (cr, status);
+    }
 
     _cairo_path_fixed_init (cr->path);
 
@@ -491,9 +495,12 @@ cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
     cairo_surface_t *group_surface = NULL;
 
     /* Get the extents that we'll use in creating our new group surface */
-    _cairo_surface_get_extents (_cairo_gstate_get_target (cr->gstate), &extents);
+    status = _cairo_surface_get_extents (_cairo_gstate_get_target (cr->gstate), &extents);
+    if (status)
+	goto bail;
+
     status = _cairo_clip_intersect_to_rectangle (_cairo_gstate_get_clip (cr->gstate), &extents);
-    if (status != CAIRO_STATUS_SUCCESS)
+    if (status)
 	goto bail;
 
     group_surface = cairo_surface_create_similar (_cairo_gstate_get_target (cr->gstate),
@@ -518,7 +525,7 @@ cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
     if (cr->status)
 	goto bail;
 
-    _cairo_gstate_redirect_target (cr->gstate, group_surface);
+    status = _cairo_gstate_redirect_target (cr->gstate, group_surface);
 
 bail:
     cairo_surface_destroy (group_surface);
@@ -1623,18 +1630,21 @@ cairo_arc_to (cairo_t *cr,
 void
 cairo_rel_move_to (cairo_t *cr, double dx, double dy)
 {
+    cairo_status_t status;
     cairo_fixed_t dx_fixed, dy_fixed;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 
 /**
@@ -1659,17 +1669,20 @@ void
 cairo_rel_line_to (cairo_t *cr, double dx, double dy)
 {
     cairo_fixed_t dx_fixed, dy_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 slim_hidden_def(cairo_rel_line_to);
 
@@ -1708,13 +1721,26 @@ cairo_rel_curve_to (cairo_t *cr,
     cairo_fixed_t dx1_fixed, dy1_fixed;
     cairo_fixed_t dx2_fixed, dy2_fixed;
     cairo_fixed_t dx3_fixed, dy3_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
+    if (status) {
+	_cairo_set_error (cr, status);
+	return;
+    }
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
+    if (status) {
+	_cairo_set_error (cr, status);
+	return;
+    }
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    if (status) {
+	_cairo_set_error (cr, status);
+	return;
+    }
 
     dx1_fixed = _cairo_fixed_from_double (dx1);
     dy1_fixed = _cairo_fixed_from_double (dy1);
@@ -1725,12 +1751,12 @@ cairo_rel_curve_to (cairo_t *cr,
     dx3_fixed = _cairo_fixed_from_double (dx3);
     dy3_fixed = _cairo_fixed_from_double (dy3);
 
-    cr->status = _cairo_path_fixed_rel_curve_to (cr->path,
+    status = _cairo_path_fixed_rel_curve_to (cr->path,
 						 dx1_fixed, dy1_fixed,
 						 dx2_fixed, dy2_fixed,
 						 dx3_fixed, dy3_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+    if (status)
+	_cairo_set_error (cr, status);
 }
 
 /**
diff --git a/src/cairoint.h b/src/cairoint.h
index d67ea93..f9889d2 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -1336,7 +1336,7 @@ _cairo_gstate_destroy (cairo_gstate_t *gstate);
 cairo_private cairo_bool_t
 _cairo_gstate_is_redirected (cairo_gstate_t *gstate);
 
-cairo_private void
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child);
 
 cairo_private cairo_surface_t *
@@ -1814,7 +1814,7 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			 const cairo_font_options_t	   *options,
 			 const cairo_scaled_font_backend_t *backend);
 
-cairo_private void
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics);
 
@@ -2256,7 +2256,7 @@ _cairo_pen_init_empty (cairo_pen_t *pen);
 cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_init_copy (cairo_pen_t *pen, cairo_pen_t *other);
 
-cairo_private void
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_fini (cairo_pen_t *pen);
 
 cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
-- 
1.4.4.2

-------------- next part --------------
>From 6e6d0b0d1cbcb79547f00c6c7161832cb25d5bd0 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sun, 18 Mar 2007 22:55:22 +0000
Subject: [PATCH] Add warn-unused-result to *private.h

---
 src/cairo-cache-private.h               |    2 +-
 src/cairo-hash-private.h                |    2 +-
 src/cairo-meta-surface-private.h        |    2 +-
 src/cairo-output-stream-private.h       |    8 ++++----
 src/cairo-path-private.h                |    2 +-
 src/cairo-ps-surface.c                  |    5 ++++-
 src/cairo-scaled-font-subsets-private.h |   18 +++++++++---------
 src/cairo-surface-fallback-private.h    |   16 ++++++++--------
 8 files changed, 29 insertions(+), 26 deletions(-)

diff --git a/src/cairo-cache-private.h b/src/cairo-cache-private.h
index 566dbe2..89adf1e 100644
--- a/src/cairo-cache-private.h
+++ b/src/cairo-cache-private.h
@@ -113,7 +113,7 @@ _cairo_cache_lookup (cairo_cache_t	  *cache,
 		     cairo_cache_entry_t  *key,
 		     cairo_cache_entry_t **entry_return);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_cache_insert (cairo_cache_t	 *cache,
 		     cairo_cache_entry_t *entry);
 
diff --git a/src/cairo-hash-private.h b/src/cairo-hash-private.h
index 617b841..92ce6f8 100644
--- a/src/cairo-hash-private.h
+++ b/src/cairo-hash-private.h
@@ -109,7 +109,7 @@ cairo_private void *
 _cairo_hash_table_random_entry (cairo_hash_table_t	   *hash_table,
 				cairo_hash_predicate_func_t predicate);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_hash_table_insert (cairo_hash_table_t *hash_table,
 			  cairo_hash_entry_t *entry);
 
diff --git a/src/cairo-meta-surface-private.h b/src/cairo-meta-surface-private.h
index 3f2d390..0f827c1 100644
--- a/src/cairo-meta-surface-private.h
+++ b/src/cairo-meta-surface-private.h
@@ -147,7 +147,7 @@ _cairo_meta_surface_create (cairo_content_t	content,
 			    int			width_pixels,
 			    int			height_pixels);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_meta_surface_replay (cairo_surface_t *surface,
 			    cairo_surface_t *target);
 
diff --git a/src/cairo-output-stream-private.h b/src/cairo-output-stream-private.h
index d68fbb4..5629c45 100644
--- a/src/cairo-output-stream-private.h
+++ b/src/cairo-output-stream-private.h
@@ -60,7 +60,7 @@ _cairo_output_stream_init (cairo_output_stream_t            *stream,
 			   cairo_output_stream_write_func_t  write_func,
 			   cairo_output_stream_close_func_t  close_func);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_output_stream_fini (cairo_output_stream_t *stream);
 
 
@@ -89,13 +89,13 @@ _cairo_output_stream_create (cairo_write_func_t		write_func,
 /* Returns the final status value associated with this object, just
  * before its last gasp. This final status value will capture any
  * status failure returned by the stream's close_func as well. */
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_output_stream_close (cairo_output_stream_t *stream);
 
 /* Returns the final status value associated with this object, just
  * before its last gasp. This final status value will capture any
  * status failure returned by the stream's close_func as well. */
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_output_stream_destroy (cairo_output_stream_t *stream);
 
 cairo_private void
@@ -121,7 +121,7 @@ _cairo_output_stream_printf (cairo_output_stream_t *stream,
 cairo_private long
 _cairo_output_stream_get_position (cairo_output_stream_t *stream);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_output_stream_get_status (cairo_output_stream_t *stream);
 
 /* This function never returns NULL. If an error occurs (NO_MEMORY or
diff --git a/src/cairo-path-private.h b/src/cairo-path-private.h
index d855c19..e6e1d6c 100644
--- a/src/cairo-path-private.h
+++ b/src/cairo-path-private.h
@@ -52,7 +52,7 @@ _cairo_path_create_flat (cairo_path_fixed_t *path,
 cairo_private cairo_path_t *
 _cairo_path_create_in_error (cairo_status_t status);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_append_to_context (const cairo_path_t	*path,
 			       cairo_t			*cr);
 
diff --git a/src/cairo-ps-surface.c b/src/cairo-ps-surface.c
index 612865d..a5dfd8e 100644
--- a/src/cairo-ps-surface.c
+++ b/src/cairo-ps-surface.c
@@ -298,6 +298,7 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 {
     cairo_output_stream_t *word_wrap;
     cairo_status_t status;
+    cairo_status_t status2;
     ps_path_info_t path_info;
 
     word_wrap = _word_wrap_stream_create (stream, 79);
@@ -315,7 +316,9 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 
     if (status == CAIRO_STATUS_SUCCESS)
 	status = _cairo_output_stream_get_status (word_wrap);
-    _cairo_output_stream_destroy (word_wrap);
+    status2 = _cairo_output_stream_destroy (word_wrap);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
diff --git a/src/cairo-scaled-font-subsets-private.h b/src/cairo-scaled-font-subsets-private.h
index 5104340..ae40e4c 100644
--- a/src/cairo-scaled-font-subsets-private.h
+++ b/src/cairo-scaled-font-subsets-private.h
@@ -130,7 +130,7 @@ _cairo_scaled_font_subsets_destroy (cairo_scaled_font_subsets_t *font_subsets);
  * value indicating an error. Possible errors include
  * CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_subsets_map_glyph (cairo_scaled_font_subsets_t	*font_subsets,
 				      cairo_scaled_font_t		*scaled_font,
 				      unsigned long			 scaled_font_glyph_index,
@@ -172,7 +172,7 @@ typedef void
  * value indicating an error. Possible errors include
  * CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_subsets_foreach_scaled (cairo_scaled_font_subsets_t		    *font_subsets,
 				           cairo_scaled_font_subset_callback_func_t  font_subset_callback,
 				           void					    *closure);
@@ -207,7 +207,7 @@ _cairo_scaled_font_subsets_foreach_scaled (cairo_scaled_font_subsets_t		    *fon
  * value indicating an error. Possible errors include
  * CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_subsets_foreach_unscaled (cairo_scaled_font_subsets_t              *font_subsets,
                                              cairo_scaled_font_subset_callback_func_t  font_subset_callback,
 				             void				      *closure);
@@ -237,7 +237,7 @@ typedef struct _cairo_cff_subset {
  * cff file, or an non-zero value indicating an error.  Possible
  * errors include CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_cff_subset_init (cairo_cff_subset_t          *cff_subset,
                         const char                  *name,
                         cairo_scaled_font_subset_t  *font_subset);
@@ -280,7 +280,7 @@ typedef struct _cairo_truetype_subset {
  * truetype file, or an non-zero value indicating an error.  Possible
  * errors include CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_truetype_subset_init (cairo_truetype_subset_t    *truetype_subset,
 			     cairo_scaled_font_subset_t	*font_subset);
 
@@ -324,7 +324,7 @@ typedef struct _cairo_type1_subset {
  * file, or an non-zero value indicating an error.  Possible errors
  * include CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_type1_subset_init (cairo_type1_subset_t		*type_subset,
 			  const char			*name,
 			  cairo_scaled_font_subset_t	*font_subset,
@@ -357,7 +357,7 @@ _cairo_type1_subset_fini (cairo_type1_subset_t *subset);
  * file, or an non-zero value indicating an error.  Possible errors
  * include CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_type1_fallback_init_binary (cairo_type1_subset_t	      *type_subset,
                                    const char		      *name,
                                    cairo_scaled_font_subset_t *font_subset);
@@ -378,7 +378,7 @@ _cairo_type1_fallback_init_binary (cairo_type1_subset_t	      *type_subset,
  * file, or an non-zero value indicating an error.  Possible errors
  * include CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_type1_fallback_init_hex (cairo_type1_subset_t	   *type_subset,
                                 const char		   *name,
                                 cairo_scaled_font_subset_t *font_subset);
@@ -408,7 +408,7 @@ _cairo_type1_fallback_fini (cairo_type1_subset_t *subset);
  * the glyphs is not available.  Possible  errors include
  * CAIRO_STATUS_NO_MEMORY.
  **/
-cairo_private cairo_int_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_truetype_create_glyph_to_unicode_map (cairo_scaled_font_subset_t	*font_subset);
 
 #endif /* CAIRO_SCALED_FONT_SUBSETS_PRIVATE_H */
diff --git a/src/cairo-surface-fallback-private.h b/src/cairo-surface-fallback-private.h
index e0f83c4..e3a379c 100644
--- a/src/cairo-surface-fallback-private.h
+++ b/src/cairo-surface-fallback-private.h
@@ -40,17 +40,17 @@
 
 #include "cairoint.h"
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_paint (cairo_surface_t	*surface,
 			       cairo_operator_t	 op,
 			       cairo_pattern_t	*source);
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_mask (cairo_surface_t		*surface,
 			      cairo_operator_t		 op,
 			      cairo_pattern_t		*source,
 			      cairo_pattern_t		*mask);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_stroke (cairo_surface_t		*surface,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*source,
@@ -61,7 +61,7 @@ _cairo_surface_fallback_stroke (cairo_surface_t		*surface,
 				double			 tolerance,
 				cairo_antialias_t	 antialias);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_fill (cairo_surface_t		*surface,
 			      cairo_operator_t		 op,
 			      cairo_pattern_t		*source,
@@ -70,7 +70,7 @@ _cairo_surface_fallback_fill (cairo_surface_t		*surface,
 			      double		 	 tolerance,
 			      cairo_antialias_t		 antialias);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_show_glyphs (cairo_surface_t		*surface,
 				     cairo_operator_t		 op,
 				     cairo_pattern_t		*source,
@@ -81,7 +81,7 @@ _cairo_surface_fallback_show_glyphs (cairo_surface_t		*surface,
 cairo_private cairo_surface_t *
 _cairo_surface_fallback_snapshot (cairo_surface_t *surface);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_composite (cairo_operator_t	op,
 				   cairo_pattern_t	*src,
 				   cairo_pattern_t	*mask,
@@ -95,14 +95,14 @@ _cairo_surface_fallback_composite (cairo_operator_t	op,
 				   unsigned int		width,
 				   unsigned int		height);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_fill_rectangles (cairo_surface_t         *surface,
 					 cairo_operator_t	 op,
 					 const cairo_color_t	 *color,
 					 cairo_rectangle_int16_t *rects,
 					 int			 num_rects);
 
-cairo_private cairo_status_t
+cairo_private CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_fallback_composite_trapezoids (cairo_operator_t		op,
 					      cairo_pattern_t	       *pattern,
 					      cairo_surface_t	       *dst,
-- 
1.4.4.2

-------------- next part --------------
>From c8ef752398cd948efc79d46ed9e58ce71ecf1448 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sun, 18 Mar 2007 23:23:44 +0000
Subject: [PATCH] Add warn-if-unused to static functions.

And propagate the status for the simple cases.
---
 src/cairo-analysis-surface.c    |   12 +++---
 src/cairo-atsui-font.c          |   16 ++++----
 src/cairo-base85-stream.c       |    4 +-
 src/cairo-bentley-ottmann.c     |   16 ++++---
 src/cairo-cache.c               |    4 +-
 src/cairo-cff-subset.c          |   83 ++++++++++++++++++++-------------------
 src/cairo-clip.c                |   40 ++++++++++++-------
 src/cairo-deflate-stream.c      |    4 +-
 src/cairo-directfb-surface.c    |   32 +++++++-------
 src/cairo-font.c                |    4 +-
 src/cairo-ft-font.c             |   22 +++++-----
 src/cairo-glitz-surface.c       |   42 ++++++++++----------
 src/cairo-gstate.c              |   20 +++++-----
 src/cairo-hash.c                |    2 +-
 src/cairo-hull.c                |   14 ++++--
 src/cairo-image-surface.c       |   22 +++++-----
 src/cairo-lzw.c                 |    2 +-
 src/cairo-meta-surface.c        |   20 +++++-----
 src/cairo-os2-surface.c         |    2 +-
 src/cairo-output-stream.c       |   14 +++---
 src/cairo-paginated-surface.c   |   42 ++++++++++++--------
 src/cairo-path-bounds.c         |   43 +++++++++++---------
 src/cairo-path-fill.c           |   20 +++++-----
 src/cairo-path-fixed.c          |    4 +-
 src/cairo-path-stroke.c         |   67 ++++++++++++++++---------------
 src/cairo-path.c                |   34 +++++++++-------
 src/cairo-pattern.c             |    8 ++--
 src/cairo-pdf-surface.c         |   76 ++++++++++++++++++------------------
 src/cairo-pen.c                 |    4 +-
 src/cairo-png.c                 |    2 +-
 src/cairo-polygon.c             |    4 +-
 src/cairo-ps-surface.c          |   60 ++++++++++++++--------------
 src/cairo-quartz-surface.c      |   46 +++++++++++-----------
 src/cairo-scaled-font-subsets.c |    6 +-
 src/cairo-scaled-font.c         |   10 ++--
 src/cairo-spline.c              |   12 +++---
 src/cairo-surface-fallback.c    |   30 +++++++-------
 src/cairo-surface.c             |   35 +++++++++++-----
 src/cairo-svg-surface.c         |   56 +++++++++++++-------------
 src/cairo-traps.c               |    8 ++--
 src/cairo-truetype-subset.c     |   12 +++---
 src/cairo-type1-fallback.c      |   28 +++++++-------
 src/cairo-type1-subset.c        |   18 ++++----
 src/cairo-win32-font.c          |   38 +++++++++---------
 src/cairo-win32-surface.c       |   26 ++++++------
 src/cairo-xcb-surface.c         |   44 ++++++++++----------
 src/cairo-xlib-surface.c        |   67 ++++++++++++++++++-------------
 src/test-fallback-surface.c     |    8 ++--
 src/test-meta-surface.c         |   22 +++++-----
 src/test-paginated-surface.c    |   16 ++++----
 50 files changed, 643 insertions(+), 578 deletions(-)

diff --git a/src/cairo-analysis-surface.c b/src/cairo-analysis-surface.c
index a89636e..2f44836 100644
--- a/src/cairo-analysis-surface.c
+++ b/src/cairo-analysis-surface.c
@@ -47,7 +47,7 @@ typedef struct {
     cairo_bool_t fallback;
 } cairo_analysis_surface_t;
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_analysis_surface_get_extents (void	 		*abstract_surface,
 				     cairo_rectangle_int16_t	*rectangle)
 {
@@ -56,7 +56,7 @@ _cairo_analysis_surface_get_extents (void	 		*abstract_surface,
     return _cairo_surface_get_extents (surface->target, rectangle);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_analysis_surface_paint (void			*abstract_surface,
 			      cairo_operator_t		op,
 			      cairo_pattern_t		*source)
@@ -76,7 +76,7 @@ _cairo_analysis_surface_paint (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_analysis_surface_mask (void		*abstract_surface,
 			      cairo_operator_t	 op,
 			      cairo_pattern_t	*source,
@@ -97,7 +97,7 @@ _cairo_analysis_surface_mask (void		*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_analysis_surface_stroke (void			*abstract_surface,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*source,
@@ -125,7 +125,7 @@ _cairo_analysis_surface_stroke (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_analysis_surface_fill (void			*abstract_surface,
 			      cairo_operator_t		 op,
 			      cairo_pattern_t		*source,
@@ -150,7 +150,7 @@ _cairo_analysis_surface_fill (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_analysis_surface_show_glyphs (void		  *abstract_surface,
 				     cairo_operator_t	   op,
 				     cairo_pattern_t	  *source,
diff --git a/src/cairo-atsui-font.c b/src/cairo-atsui-font.c
index d9fbde3..3182351 100644
--- a/src/cairo-atsui-font.c
+++ b/src/cairo-atsui-font.c
@@ -68,7 +68,7 @@ typedef struct _cairo_atsui_font_face cairo_atsui_font_face_t;
 typedef struct _cairo_atsui_font cairo_atsui_font_t;
 typedef struct _cairo_atsui_scaled_path cairo_atsui_scaled_path_t;
 
-static cairo_status_t _cairo_atsui_font_create_scaled (cairo_font_face_t *font_face,
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t _cairo_atsui_font_create_scaled (cairo_font_face_t *font_face,
 						       ATSUFontID font_id,
 						       ATSUStyle style,
 						       const cairo_matrix_t *font_matrix,
@@ -99,7 +99,7 @@ _cairo_atsui_font_face_destroy (void *abstract_face)
 {
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_atsui_font_face_scaled_font_create (void	*abstract_face,
 					   const cairo_matrix_t	*font_matrix,
 					   const cairo_matrix_t	*ctm,
@@ -225,7 +225,7 @@ CreateSizedCopyOfStyle(ATSUStyle inStyle, const cairo_matrix_t *scale)
     return style;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_atsui_font_set_metrics (cairo_atsui_font_t *font)
 {
     ATSFontRef atsFont;
@@ -257,7 +257,7 @@ _cairo_atsui_font_set_metrics (cairo_atsui_font_t *font)
     return CAIRO_STATUS_NULL_POINTER;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_atsui_font_create_scaled (cairo_font_face_t *font_face,
 				 ATSUFontID font_id,
 				 ATSUStyle style,
@@ -311,7 +311,7 @@ _cairo_atsui_font_create_scaled (cairo_font_face_t *font_face,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_atsui_font_create_toy(cairo_toy_font_face_t *toy_face,
 			     const cairo_matrix_t *font_matrix,
 			     const cairo_matrix_t *ctm,
@@ -484,7 +484,7 @@ _cairo_atsui_scaled_glyph_index (cairo_scaled_glyph_t *scaled_glyph) {
     return index;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_atsui_font_init_glyph_metrics (cairo_atsui_font_t *scaled_font,
 				      cairo_scaled_glyph_t *scaled_glyph)
 {
@@ -636,7 +636,7 @@ _close_path (void *callback_data)
     return noErr;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_atsui_scaled_font_init_glyph_path (cairo_atsui_font_t *scaled_font,
 					  cairo_scaled_glyph_t *scaled_glyph)
 {
@@ -694,7 +694,7 @@ _cairo_atsui_scaled_font_init_glyph_path (cairo_atsui_font_t *scaled_font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_atsui_scaled_font_init_glyph_surface (cairo_atsui_font_t *scaled_font,
 					     cairo_scaled_glyph_t *scaled_glyph)
 {
diff --git a/src/cairo-base85-stream.c b/src/cairo-base85-stream.c
index 7163d00..216e824 100644
--- a/src/cairo-base85-stream.c
+++ b/src/cairo-base85-stream.c
@@ -64,7 +64,7 @@ _expand_four_tuple_to_five (unsigned char four_tuple[4],
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_base85_stream_write (cairo_output_stream_t *base,
 			    const unsigned char	  *data,
 			    unsigned int	   length)
@@ -90,7 +90,7 @@ _cairo_base85_stream_write (cairo_output_stream_t *base,
     return _cairo_output_stream_get_status (stream->output);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_base85_stream_close (cairo_output_stream_t *base)
 {
     cairo_base85_stream_t *stream = (cairo_base85_stream_t *) base;
diff --git a/src/cairo-bentley-ottmann.c b/src/cairo-bentley-ottmann.c
index e0dac0e..52711a4 100644
--- a/src/cairo-bentley-ottmann.c
+++ b/src/cairo-bentley-ottmann.c
@@ -729,7 +729,7 @@ _cairo_bo_event_dequeue (cairo_bo_event_queue_t *event_queue)
     return intersection;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_bo_event_queue_init (cairo_bo_event_queue_t	*event_queue,
 			    cairo_bo_edge_t	*edges,
 			    int				 num_edges)
@@ -848,7 +848,7 @@ _cairo_bo_sweep_line_fini (cairo_bo_sweep_line_t *sweep_line)
     _cairo_skip_list_fini (&sweep_line->active_edges);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
 			     cairo_bo_edge_t		*edge)
 {
@@ -1054,7 +1054,7 @@ print_state (const char			*msg,
 
 /* Adds the trapezoid, if any, of the left edge to the cairo_traps_t
  * of bo_traps. */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_bo_edge_end_trap (cairo_bo_edge_t	*left,
 			 int32_t		bot,
 			 cairo_bo_traps_t	*bo_traps)
@@ -1128,7 +1128,7 @@ _cairo_bo_edge_end_trap (cairo_bo_edge_t	*left,
  * then either add it to the traps in `bo_traps', if the trapezoid's
  * right edge differs from `edge->next', or do nothing if the new
  * trapezoid would be a continuation of the existing one. */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_bo_edge_start_or_continue_trap (cairo_bo_edge_t	*edge,
 				       int32_t		top,
 				       cairo_bo_traps_t	*bo_traps)
@@ -1203,7 +1203,7 @@ _cairo_bo_sweep_line_validate (cairo_bo_sweep_line_t *sweep_line)
 }
 
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _active_edges_to_traps (cairo_bo_edge_t		*head,
 			int32_t			 top,
 			cairo_fill_rule_t	 fill_rule,
@@ -1246,7 +1246,7 @@ _active_edges_to_traps (cairo_bo_edge_t		*head,
 /* Execute a single pass of the Bentley-Ottmann algorithm on edges,
  * generating trapezoids according to the fill_rule and appending them
  * to traps. */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 					    int			 num_edges,
 					    cairo_fill_rule_t	 fill_rule,
@@ -1267,7 +1267,9 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
     cairo_bo_edge_t *left, *right;
     cairo_bo_edge_t *edge1, *edge2;
 
-    _cairo_bo_event_queue_init (&event_queue, edges, num_edges);
+    status = _cairo_bo_event_queue_init (&event_queue, edges, num_edges);
+		if (status)
+			return status;
     _cairo_bo_sweep_line_init (&sweep_line);
     _cairo_bo_traps_init (&bo_traps, traps, xmin, ymin, xmax, ymax);
 
diff --git a/src/cairo-cache.c b/src/cairo-cache.c
index fa1f003..6bca3c3 100644
--- a/src/cairo-cache.c
+++ b/src/cairo-cache.c
@@ -57,7 +57,7 @@ static void
 _cairo_cache_shrink_to_accommodate (cairo_cache_t *cache,
 				   unsigned long  additional);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_cache_init (cairo_cache_t		*cache,
 		   cairo_cache_keys_equal_func_t keys_equal,
 		   cairo_destroy_func_t		 entry_destroy,
@@ -252,7 +252,7 @@ _cairo_cache_lookup (cairo_cache_t	  *cache,
  * removed. CAIRO_INT_STATUS_CACHE_EMPTY if there are no entries that
  * can be removed.
  **/
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_cache_remove_random (cairo_cache_t *cache)
 {
     cairo_cache_entry_t *entry;
diff --git a/src/cairo-cff-subset.c b/src/cairo-cff-subset.c
index b354989..1788a8c 100644
--- a/src/cairo-cff-subset.c
+++ b/src/cairo-cff-subset.c
@@ -252,7 +252,7 @@ cff_index_init (cairo_array_t *index)
     _cairo_array_init (index, sizeof (cff_index_element_t));
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cff_index_read (cairo_array_t *index, unsigned char **ptr, unsigned char *end_ptr)
 {
     cff_index_element_t element;
@@ -293,7 +293,7 @@ cff_index_read (cairo_array_t *index, unsigned char **ptr, unsigned char *end_pt
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cff_index_write (cairo_array_t *index, cairo_array_t *output)
 {
     int offset_size;
@@ -361,7 +361,7 @@ cff_index_write (cairo_array_t *index, cairo_array_t *output)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cff_index_append (cairo_array_t *index, unsigned char *object , int length)
 {
     cff_index_element_t element;
@@ -373,7 +373,7 @@ cff_index_append (cairo_array_t *index, unsigned char *object , int length)
     return _cairo_array_append (index, &element);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cff_index_append_copy (cairo_array_t *index, unsigned char *object , int length)
 {
     cff_index_element_t element;
@@ -447,7 +447,7 @@ cff_dict_create_operator (int            operator,
     return op;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cff_dict_read (cairo_hash_table_t *dict, unsigned char *p, int dict_size)
 {
     unsigned char *end;
@@ -506,7 +506,7 @@ cff_dict_get_operands (cairo_hash_table_t *dict,
     return NULL;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cff_dict_set_operands (cairo_hash_table_t *dict,
                        unsigned short      operator,
                        unsigned char      *operand,
@@ -589,7 +589,7 @@ _cairo_dict_collect (void *entry, void *closure)
     write_info->status = _cairo_array_append (write_info->output, &data);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cff_dict_write (cairo_hash_table_t *dict, cairo_array_t *output)
 {
     dict_write_info_t write_info;
@@ -617,7 +617,7 @@ cff_dict_fini (cairo_hash_table_t *dict)
     _cairo_hash_table_destroy (dict);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_header (cairo_cff_font_t *font)
 {
     if (font->data_length < sizeof (cff_header_t))
@@ -629,7 +629,7 @@ cairo_cff_font_read_header (cairo_cff_font_t *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_name (cairo_cff_font_t *font)
 {
     cairo_array_t index;
@@ -644,11 +644,12 @@ cairo_cff_font_read_name (cairo_cff_font_t *font)
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_private_dict (cairo_cff_font_t   *font,
                                   unsigned char      *ptr,
                                   int                 size)
 {
+    cairo_status_t status;
     unsigned char buf[10];
     unsigned char *end_buf;
     int offset;
@@ -656,7 +657,9 @@ cairo_cff_font_read_private_dict (cairo_cff_font_t   *font,
     unsigned char *operand;
     unsigned char *p;
 
-    cff_dict_read (font->private_dict, ptr, size);
+    status = cff_dict_read (font->private_dict, ptr, size);
+    if (status)
+	return status;
     operand = cff_dict_get_operands (font->private_dict, LOCAL_SUB_OP, &i);
     if (operand) {
         decode_integer (operand, &offset);
@@ -671,7 +674,7 @@ cairo_cff_font_read_private_dict (cairo_cff_font_t   *font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_top_dict (cairo_cff_font_t *font)
 {
     cairo_array_t index;
@@ -690,7 +693,9 @@ cairo_cff_font_read_top_dict (cairo_cff_font_t *font)
         goto fail;
 
     element = _cairo_array_index (&index, 0);
-    cff_dict_read (font->top_dict, element->data, element->length);
+    status = cff_dict_read (font->top_dict, element->data, element->length);
+		if (status)
+			goto fail;
 
     /* CID fonts are NYI */
     if (cff_dict_get_operands (font->top_dict, ROS_OP, &size) != NULL) {
@@ -734,19 +739,19 @@ fail:
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_strings (cairo_cff_font_t *font)
 {
     return cff_index_read (&font->strings_index, &font->current_ptr, font->data_end);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_global_subroutines (cairo_cff_font_t *font)
 {
     return cff_index_read (&font->global_sub_index, &font->current_ptr, font->data_end);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cff_charset_read_data (cff_charset_t *charset, const unsigned char *data,
 	const unsigned char *data_end, int num_glyphs)
 {
@@ -849,7 +854,7 @@ static const uint16_t ExpertSubset_charset[] = {
     341, 342, 343, 344, 345, 346,
 };
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_charset (cairo_cff_font_t *font)
 {
     switch (font->charset_offset) {
@@ -891,7 +896,7 @@ static const font_read_t font_read_funcs[] = {
     cairo_cff_font_read_charset,
 };
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_read_font (cairo_cff_font_t *font)
 {
     cairo_int_status_t status;
@@ -906,7 +911,7 @@ cairo_cff_font_read_font (cairo_cff_font_t *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_subset_dict_string(cairo_cff_font_t   *font,
                                   cairo_hash_table_t *dict,
                                   int                 operator)
@@ -933,9 +938,7 @@ cairo_cff_font_subset_dict_string(cairo_cff_font_t   *font,
         return status;
 
     p = encode_integer (buf, sid);
-    cff_dict_set_operands (dict, operator, buf, p - buf);
-
-    return CAIRO_STATUS_SUCCESS;
+    return cff_dict_set_operands (dict, operator, buf, p - buf);
 }
 
 static const int dict_strings[] = {
@@ -950,7 +953,7 @@ static const int dict_strings[] = {
     FONTNAME_OP,
 };
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_subset_dict_strings (cairo_cff_font_t   *font,
                                     cairo_hash_table_t *dict)
 {
@@ -966,7 +969,7 @@ cairo_cff_font_subset_dict_strings (cairo_cff_font_t   *font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_subset_strings (cairo_cff_font_t *font)
 {
     cairo_status_t status;
@@ -980,7 +983,7 @@ cairo_cff_font_subset_strings (cairo_cff_font_t *font)
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_subset_charstrings (cairo_cff_font_t  *font)
 {
     cff_index_element_t *element;
@@ -1053,7 +1056,7 @@ cff_sid_from_gid (const cff_charset_t *charset, int gid)
     return 0;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_subset_charset (cairo_cff_font_t  *font)
 {
     unsigned int i;
@@ -1082,7 +1085,7 @@ cairo_cff_font_subset_charset (cairo_cff_font_t  *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_subset_font (cairo_cff_font_t  *font)
 {
     cairo_status_t status;
@@ -1125,7 +1128,7 @@ cairo_cff_font_set_topdict_operator_to_cur_pos (cairo_cff_font_t  *font,
     memcpy (op_ptr, buf, buf_end - buf);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_header (cairo_cff_font_t *font)
 {
     return _cairo_array_append_multiple (&font->output,
@@ -1133,7 +1136,7 @@ cairo_cff_font_write_header (cairo_cff_font_t *font)
                                          font->header->header_size);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_name (cairo_cff_font_t *font)
 {
     cairo_array_t index;
@@ -1153,7 +1156,7 @@ cairo_cff_font_write_name (cairo_cff_font_t *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_top_dict (cairo_cff_font_t *font)
 {
     uint16_t count;
@@ -1199,19 +1202,19 @@ cairo_cff_font_write_top_dict (cairo_cff_font_t *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_strings (cairo_cff_font_t  *font)
 {
     return cff_index_write (&font->strings_subset_index, &font->output);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_global_subrs (cairo_cff_font_t  *font)
 {
     return cff_index_write (&font->global_sub_index, &font->output);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_encoding (cairo_cff_font_t  *font)
 {
     unsigned char buf[10];
@@ -1226,7 +1229,7 @@ cairo_cff_font_write_encoding (cairo_cff_font_t  *font)
     return _cairo_array_append_multiple (&font->output, buf, 4);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_charset (cairo_cff_font_t  *font)
 {
     unsigned char format = 0;
@@ -1247,7 +1250,7 @@ cairo_cff_font_write_charset (cairo_cff_font_t  *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_charstrings (cairo_cff_font_t  *font)
 {
     cairo_cff_font_set_topdict_operator_to_cur_pos (font, CHARSTRINGS_OP);
@@ -1255,7 +1258,7 @@ cairo_cff_font_write_charstrings (cairo_cff_font_t  *font)
     return cff_index_write (&font->charstrings_subset_index, &font->output);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_private_dict_and_local_sub (cairo_cff_font_t *font)
 {
     int offset, private_dict_offset;
@@ -1312,7 +1315,7 @@ static const font_write_t font_write_funcs[] = {
     cairo_cff_font_write_private_dict_and_local_sub,
 };
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_cff_font_write_subset (cairo_cff_font_t *font)
 {
     cairo_int_status_t status;
@@ -1327,7 +1330,7 @@ cairo_cff_font_write_subset (cairo_cff_font_t *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_generate (cairo_cff_font_t  *font,
                          const char       **data,
                          unsigned long     *length)
@@ -1352,7 +1355,7 @@ cairo_cff_font_generate (cairo_cff_font_t  *font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_cff_font_create_set_widths (cairo_cff_font_t *font)
 {
     unsigned long size;
@@ -1400,7 +1403,7 @@ cairo_cff_font_create_set_widths (cairo_cff_font_t *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_cff_font_create (cairo_scaled_font_subset_t  *scaled_font_subset,
                         cairo_cff_font_t           **font_return,
                         const char                  *subset_name)
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index 966cf74..46b40cc 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -121,7 +121,7 @@ _cairo_clip_reset (cairo_clip_t *clip)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_path_intersect_to_rectangle (cairo_clip_path_t       *clip_path,
    				         cairo_rectangle_int16_t *rectangle)
 {
@@ -270,7 +270,7 @@ _cairo_clip_combine_to_surface (cairo_clip_t                  *clip,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_intersect_path (cairo_clip_t       *clip,
 			    cairo_path_fixed_t *path,
 			    cairo_fill_rule_t   fill_rule,
@@ -329,7 +329,7 @@ _cairo_clip_path_destroy (cairo_clip_path_t *clip_path)
     free (clip_path);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_intersect_region (cairo_clip_t    *clip,
 			      cairo_traps_t   *traps,
 			      cairo_surface_t *target)
@@ -369,7 +369,7 @@ _cairo_clip_intersect_region (cairo_clip_t    *clip,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_intersect_mask (cairo_clip_t      *clip,
 			    cairo_traps_t     *traps,
 			    cairo_antialias_t antialias,
@@ -535,14 +535,19 @@ _cairo_clip_translate (cairo_clip_t  *clip,
     }
 }
 
-static void
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_clip_path_reapply_clip_path (cairo_clip_t      *clip,
                                     cairo_clip_path_t *clip_path)
 {
-    if (clip_path->prev)
-        _cairo_clip_path_reapply_clip_path (clip, clip_path->prev);
+    cairo_status_t status;
+
+    if (clip_path->prev) {
+        status = _cairo_clip_path_reapply_clip_path (clip, clip_path->prev);
+	if (status)
+	    return status;
+    }
 
-    _cairo_clip_intersect_path (clip,
+    return _cairo_clip_intersect_path (clip,
                                 &clip_path->path,
                                 clip_path->fill_rule,
                                 clip_path->tolerance,
@@ -575,20 +580,27 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
 					  other->surface_rect.width,
 					  other->surface_rect.height,
 					  &clip->surface);
-	    if (status) {
-		if (clip->region)
-		    pixman_region_destroy (clip->region);
-		return status;
-	    }
+	    if (status) 
+		goto CLEANUP_REGION;
             clip->surface_rect = other->surface_rect;
         }
 
         if (other->path) {
-            _cairo_clip_path_reapply_clip_path (clip, other->path);
+            status = _cairo_clip_path_reapply_clip_path (clip, other->path);
+	    if (status)
+		goto CLEANUP_SURFACE;
         }
     }
 
     return CAIRO_STATUS_SUCCESS;
+
+CLEANUP_SURFACE:
+    if (clip->surface)
+	cairo_surface_destroy (clip->surface);
+CLEANUP_REGION:
+    if (clip->region)
+	pixman_region_destroy (clip->region);
+    return status;
 }
 
 const cairo_rectangle_list_t _cairo_rectangles_nil =
diff --git a/src/cairo-deflate-stream.c b/src/cairo-deflate-stream.c
index 816f5c5..71aea0a 100644
--- a/src/cairo-deflate-stream.c
+++ b/src/cairo-deflate-stream.c
@@ -76,7 +76,7 @@ cairo_deflate_stream_deflate (cairo_deflate_stream_t *stream, cairo_bool_t flush
     stream->zlib_stream.next_in = stream->input_buf;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_deflate_stream_write (cairo_output_stream_t *base,
                              const unsigned char   *data,
                              unsigned int	    length)
@@ -101,7 +101,7 @@ _cairo_deflate_stream_write (cairo_output_stream_t *base,
     return _cairo_output_stream_get_status (stream->output);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_deflate_stream_close (cairo_output_stream_t *base)
 {
     cairo_deflate_stream_t *stream = (cairo_deflate_stream_t *) base;
diff --git a/src/cairo-directfb-surface.c b/src/cairo-directfb-surface.c
index 686510d..0aec1c0 100644
--- a/src/cairo-directfb-surface.c
+++ b/src/cairo-directfb-surface.c
@@ -213,7 +213,7 @@ directfb_to_cairo_format (DFBSurfacePixelFormat format)
 }
 
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _directfb_get_operator (cairo_operator_t         operator,
                         DFBSurfaceDrawingFlags  *ret_drawing,
                         DFBSurfaceBlittingFlags *ret_blitting,
@@ -322,7 +322,7 @@ _directfb_buffer_surface_create (IDirectFB             *dfb,
     return buffer;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _directfb_acquire_surface (cairo_directfb_surface_t *surface, 
                                               cairo_rectangle_int16_t *intrest_rec,
                                               cairo_image_surface_t **image_out,
@@ -440,7 +440,7 @@ _cairo_directfb_surface_create_similar (void            *abstract_src,
     return &surface->base;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_directfb_surface_finish (void *data)
 {
     cairo_directfb_surface_t *surface = (cairo_directfb_surface_t *)data;
@@ -472,7 +472,7 @@ _cairo_directfb_surface_finish (void *data)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_directfb_surface_acquire_source_image (void                   *abstract_surface,
                                               cairo_image_surface_t **image_out,
                                               void                  **image_extra)
@@ -501,7 +501,7 @@ _cairo_directfb_surface_release_source_image (void                  *abstract_su
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_directfb_surface_acquire_dest_image (void                   *abstract_surface,
                                             cairo_rectangle_int16_t      *interest_rect,
                                             cairo_image_surface_t **image_out,
@@ -545,7 +545,7 @@ _cairo_directfb_surface_release_dest_image (void                  *abstract_surf
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_directfb_surface_clone_similar (void             *abstract_surface,
                                        cairo_surface_t  *src,
 				       int               src_x,
@@ -620,7 +620,7 @@ _cairo_directfb_surface_clone_similar (void             *abstract_surface,
 }
 
 #if DFB_COMPOSITE || DFB_COMPOSITE_TRAPEZOIDS
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _directfb_prepare_composite (cairo_directfb_surface_t   *dst,
                              cairo_pattern_t             *src_pattern,
                              cairo_pattern_t             *mask_pattern,
@@ -748,7 +748,7 @@ _directfb_finish_composite (cairo_directfb_surface_t   *dst,
 #endif /* DFB_COMPOSITE || DFB_COMPOSITE_TRAPEZOIDS */        
 
 #if DFB_COMPOSITE
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_directfb_surface_composite (cairo_operator_t  op,
                                    cairo_pattern_t  *src_pattern,
                                    cairo_pattern_t  *mask_pattern,
@@ -911,7 +911,7 @@ _cairo_directfb_surface_composite (cairo_operator_t  op,
 #endif /* DFB_COMPOSITE */
 
 #if DFB_RECTANGLES
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_directfb_surface_fill_rectangles (void                *abstract_surface,
                                          cairo_operator_t     op,
                                          const cairo_color_t *color,
@@ -958,7 +958,7 @@ _cairo_directfb_surface_fill_rectangles (void                *abstract_surface,
 #endif
 
 #if DFB_COMPOSITE_TRAPEZOIDS
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_directfb_surface_composite_trapezoids (cairo_operator_t   op,
                                               cairo_pattern_t   *pattern,
                                               void              *abstract_dst,
@@ -1098,7 +1098,7 @@ _cairo_directfb_surface_composite_trapezoids (cairo_operator_t   op,
 }
 #endif /* DFB_COMPOSITE_TRAPEZOIDS */
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_directfb_surface_set_clip_region (void              *abstract_surface,
                                          pixman_region16_t *region)
 {
@@ -1144,7 +1144,7 @@ _cairo_directfb_surface_set_clip_region (void              *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_directfb_abstract_surface_get_extents (void              *abstract_surface,
                                               cairo_rectangle_int16_t *rectangle)
 {
@@ -1164,7 +1164,7 @@ _cairo_directfb_abstract_surface_get_extents (void              *abstract_surfac
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_directfb_surface_mark_dirty_rectangle (void *abstract_surface,
                                               int   x,
                                               int   y,
@@ -1185,7 +1185,7 @@ _cairo_directfb_surface_mark_dirty_rectangle (void *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t 
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t 
 _cairo_directfb_surface_flush (void *abstract_surface)
 {
 #if 0
@@ -1235,7 +1235,7 @@ _directfb_destroy_font_cache (cairo_directfb_font_cache_t *cache)
     free (cache);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _directfb_acquire_font_cache (cairo_directfb_surface_t     *surface,
                               cairo_scaled_font_t          *scaled_font,
                               const cairo_glyph_t          *glyphs,
@@ -1446,7 +1446,7 @@ _cairo_directfb_surface_scaled_glyph_fini (cairo_scaled_glyph_t *scaled_glyph,
 
 
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_directfb_surface_show_glyphs ( void                 *abstract_dst,
                                      cairo_operator_t      op,
                                      cairo_pattern_t      *pattern,
diff --git a/src/cairo-font.c b/src/cairo-font.c
index cacc589..ad04e04 100644
--- a/src/cairo-font.c
+++ b/src/cairo-font.c
@@ -320,7 +320,7 @@ _cairo_toy_font_face_init_key (cairo_toy_font_face_t *key,
     key->base.hash_entry.hash = hash;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_toy_font_face_init (cairo_toy_font_face_t *font_face,
 			   const char	         *family,
 			   cairo_font_slant_t	  slant,
@@ -448,7 +448,7 @@ _cairo_toy_font_face_destroy (void *abstract_face)
     _cairo_toy_font_face_fini (font_face);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_toy_font_face_scaled_font_create (void                *abstract_font_face,
 					 const cairo_matrix_t       *font_matrix,
 					 const cairo_matrix_t       *ctm,
diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index c174275..ec7a8cb 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -306,7 +306,7 @@ _cairo_ft_unscaled_font_init_key (cairo_ft_unscaled_font_t *key,
  * parallel in the from_face case, (where the calling code would have
  * to do its own mapping to ensure similar sharing).
  **/
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ft_unscaled_font_init (cairo_ft_unscaled_font_t *unscaled,
 			      const char	       *filename,
 			      int			id,
@@ -574,7 +574,7 @@ _cairo_ft_unscaled_font_unlock_face (cairo_ft_unscaled_font_t *unscaled)
 }
 slim_hidden_def (cairo_ft_scaled_font_unlock_face);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _compute_transform (cairo_ft_font_transform_t *sf,
 		    cairo_matrix_t      *scale)
 {
@@ -716,7 +716,7 @@ static const int    filters[3][3] = {
 
 /* Fills in val->image with an image surface created from @bitmap
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _get_bitmap_surface (FT_Bitmap		     *bitmap,
 		     cairo_bool_t	      own_buffer,
 		     cairo_font_options_t    *font_options,
@@ -925,7 +925,7 @@ _get_bitmap_surface (FT_Bitmap		     *bitmap,
  * when we add subpixel support. If so, we may want to eliminate
  * this version of the code path entirely.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _render_glyph_outline (FT_Face                    face,
 		       cairo_font_options_t	 *font_options,
 		       cairo_image_surface_t	**surface)
@@ -1047,7 +1047,7 @@ _render_glyph_outline (FT_Face                    face,
 }
 
 /* Converts a bitmap (or other) FT_GlyphSlot into an image */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _render_glyph_bitmap (FT_Face		      face,
 		      cairo_font_options_t   *font_options,
 		      cairo_image_surface_t **surface)
@@ -1082,7 +1082,7 @@ _render_glyph_bitmap (FT_Face		      face,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _transform_glyph_bitmap (cairo_matrix_t         * shape,
 			 cairo_image_surface_t ** surface)
 {
@@ -1523,7 +1523,7 @@ _cairo_scaled_font_is_ft (cairo_scaled_font_t *scaled_font)
     return scaled_font->backend == &cairo_ft_scaled_font_backend;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
 				  const cairo_matrix_t	      *font_matrix,
 				  const cairo_matrix_t	      *ctm,
@@ -1719,7 +1719,7 @@ _cubic_to (FT_Vector *control1, FT_Vector *control2,
     return 0;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _decompose_glyph_outline (FT_Face		  face,
 			  cairo_font_options_t	 *options,
 			  cairo_path_fixed_t	**pathp)
@@ -1782,7 +1782,7 @@ _cairo_ft_scaled_glyph_vertical_layout_bearing_fix (void        *abstract_font,
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ft_scaled_glyph_init (void			*abstract_font,
 			     cairo_scaled_glyph_t	*scaled_glyph,
 			     cairo_scaled_glyph_info_t	 info)
@@ -2025,7 +2025,7 @@ _cairo_ft_ucs4_to_index (void	    *abstract_font,
     return index;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ft_load_truetype_table (void	       *abstract_font,
                               unsigned long     tag,
                               long              offset,
@@ -2159,7 +2159,7 @@ _cairo_ft_font_face_destroy (void *abstract_face)
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ft_font_face_scaled_font_create (void                     *abstract_face,
 					const cairo_matrix_t       *font_matrix,
 					const cairo_matrix_t       *ctm,
diff --git a/src/cairo-glitz-surface.c b/src/cairo-glitz-surface.c
index b9e4f72..3d48739 100644
--- a/src/cairo-glitz-surface.c
+++ b/src/cairo-glitz-surface.c
@@ -39,7 +39,7 @@ typedef struct _cairo_glitz_surface {
 static const cairo_surface_backend_t *
 _cairo_glitz_surface_get_backend (void);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_finish (void *abstract_surface)
 {
     cairo_glitz_surface_t *surface = abstract_surface;
@@ -110,7 +110,7 @@ _cairo_glitz_surface_create_similar (void	    *abstract_src,
     return crsurface;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_get_image (cairo_glitz_surface_t   *surface,
 				cairo_rectangle_int16_t *interest,
 				cairo_image_surface_t  **image_out,
@@ -248,7 +248,7 @@ _cairo_glitz_surface_get_image (cairo_glitz_surface_t   *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_set_image (void		      *abstract_surface,
 				cairo_image_surface_t *image,
 				int                    src_x,
@@ -309,7 +309,7 @@ _cairo_glitz_surface_set_image (void		      *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_acquire_source_image (void              *abstract_surface,
 					   cairo_image_surface_t **image_out,
 					   void                  **image_extra)
@@ -329,7 +329,7 @@ _cairo_glitz_surface_release_source_image (void              *abstract_surface,
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_acquire_dest_image (void                    *abstract_surface,
 					 cairo_rectangle_int16_t *interest_rect,
 					 cairo_image_surface_t  **image_out,
@@ -367,7 +367,7 @@ _cairo_glitz_surface_release_dest_image (void                    *abstract_surfa
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_clone_similar (void	    *abstract_surface,
 				    cairo_surface_t *src,
 				    int              src_x,
@@ -569,7 +569,7 @@ typedef struct _cairo_glitz_surface_attributes {
     cairo_bool_t		acquired;
 } cairo_glitz_surface_attributes_t;
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_pattern_acquire_surface (cairo_pattern_t	              *pattern,
 				      cairo_glitz_surface_t	       *dst,
 				      int			       x,
@@ -787,7 +787,7 @@ _cairo_glitz_pattern_release_surface (cairo_pattern_t		      *pattern,
 	cairo_surface_destroy (&surface->base);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_pattern_acquire_surfaces (cairo_pattern_t	                *src,
 				       cairo_pattern_t	                *mask,
 				       cairo_glitz_surface_t	        *dst,
@@ -873,7 +873,7 @@ _cairo_glitz_surface_set_attributes (cairo_glitz_surface_t	      *surface,
 			      a->params, a->n_params);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_surface_composite (cairo_operator_t op,
 				cairo_pattern_t  *src_pattern,
 				cairo_pattern_t  *mask_pattern,
@@ -953,7 +953,7 @@ _cairo_glitz_surface_composite (cairo_operator_t op,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_surface_fill_rectangles (void		      *abstract_dst,
 				      cairo_operator_t	       op,
 				      const cairo_color_t     *color,
@@ -1031,7 +1031,7 @@ _cairo_glitz_surface_fill_rectangles (void		      *abstract_dst,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_surface_composite_trapezoids (cairo_operator_t  op,
 					   cairo_pattern_t   *pattern,
 					   void		     *abstract_dst,
@@ -1272,7 +1272,7 @@ _cairo_glitz_surface_composite_trapezoids (cairo_operator_t  op,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_surface_set_clip_region (void		*abstract_surface,
 				      pixman_region16_t *region)
 {
@@ -1308,7 +1308,7 @@ _cairo_glitz_surface_set_clip_region (void		*abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_surface_get_extents (void		          *abstract_surface,
 				  cairo_rectangle_int16_t *rectangle)
 {
@@ -1364,7 +1364,7 @@ struct _cairo_glitz_root_area {
     const cairo_glitz_area_funcs_t *funcs;
 };
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_area_move_in (cairo_glitz_area_t *area,
 			   void		      *closure)
 {
@@ -1474,7 +1474,7 @@ _cairo_glitz_area_get_top_scored_sub_area (cairo_glitz_area_t *area)
     return NULL;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_area_find (cairo_glitz_area_t *area,
 			int		   width,
 			int		   height,
@@ -1609,7 +1609,7 @@ _cairo_glitz_area_find (cairo_glitz_area_t *area,
     return CAIRO_INT_STATUS_UNSUPPORTED;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_root_area_init (cairo_glitz_root_area_t	    *root,
 			     int			    max_level,
 			     int			    width,
@@ -1643,7 +1643,7 @@ typedef struct _cairo_glitz_surface_glyph_private {
     cairo_point_double_t p1, p2;
 } cairo_glitz_surface_glyph_private_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_glyph_move_in (cairo_glitz_area_t *area,
 			    void	       *closure)
 {
@@ -1701,7 +1701,7 @@ static const cairo_glitz_area_funcs_t _cairo_glitz_area_funcs = {
     WRITE_VEC2 (ptr, _vx1, _vy2);		       \
     WRITE_VEC2 (ptr, (p1)->x, (p1)->y)
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_font_init (cairo_glitz_surface_t *surface,
 				cairo_scaled_font_t   *scaled_font,
 				cairo_format_t	      format)
@@ -1801,7 +1801,7 @@ _cairo_glitz_surface_scaled_glyph_fini (cairo_scaled_glyph_t *scaled_glyph,
 
 #define FIXED_TO_FLOAT(f) (((glitz_float_t) (f)) / 65536)
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_add_glyph (cairo_glitz_surface_t *surface,
 				cairo_scaled_font_t   *scaled_font,
 				cairo_scaled_glyph_t  *scaled_glyph)
@@ -1913,7 +1913,7 @@ _cairo_glitz_surface_add_glyph (cairo_glitz_surface_t *surface,
 
 #define N_STACK_BUF 256
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_glitz_surface_old_show_glyphs (cairo_scaled_font_t *scaled_font,
 				      cairo_operator_t     op,
 				      cairo_pattern_t     *pattern,
@@ -2162,7 +2162,7 @@ UNLOCK:
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_glitz_surface_flush (void *abstract_surface)
 {
     cairo_glitz_surface_t *surface = abstract_surface;
diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index 7a57494..a008dad 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -42,13 +42,13 @@
 #include "cairo-clip-private.h"
 #include "cairo-gstate-private.h"
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_init_copy (cairo_gstate_t *gstate, cairo_gstate_t *other);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_ensure_font_face (cairo_gstate_t *gstate);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_ensure_scaled_font (cairo_gstate_t *gstate);
 
 static void
@@ -111,7 +111,7 @@ _cairo_gstate_init (cairo_gstate_t  *gstate,
  * @other. Note that gstate->next is not copied but is set to NULL by
  * this function.
  **/
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_init_copy (cairo_gstate_t *gstate, cairo_gstate_t *other)
 {
     cairo_status_t status;
@@ -222,7 +222,7 @@ _cairo_gstate_clone (cairo_gstate_t *other)
     return gstate;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_recursive_apply_clip_path (cairo_gstate_t *gstate,
 					 cairo_clip_path_t *cpath)
 {
@@ -710,7 +710,7 @@ _cairo_gstate_stroke_to_path (cairo_gstate_t *gstate)
 }
 */
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_copy_transformed_pattern (cairo_gstate_t  *gstate,
 					cairo_pattern_t *pattern,
 					cairo_pattern_t *original,
@@ -735,7 +735,7 @@ _cairo_gstate_copy_transformed_pattern (cairo_gstate_t  *gstate,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_copy_transformed_source (cairo_gstate_t  *gstate,
 				       cairo_pattern_t *pattern)
 {
@@ -744,7 +744,7 @@ _cairo_gstate_copy_transformed_source (cairo_gstate_t  *gstate,
 					           &gstate->source_ctm_inverse);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_copy_transformed_mask (cairo_gstate_t  *gstate,
 				     cairo_pattern_t *pattern,
 				     cairo_pattern_t *mask)
@@ -1389,7 +1389,7 @@ _cairo_gstate_get_scaled_font (cairo_gstate_t       *gstate,
  *
  */
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_ensure_font_face (cairo_gstate_t *gstate)
 {
     if (!gstate->font_face) {
@@ -1407,7 +1407,7 @@ _cairo_gstate_ensure_font_face (cairo_gstate_t *gstate)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_gstate_ensure_scaled_font (cairo_gstate_t *gstate)
 {
     cairo_status_t status;
diff --git a/src/cairo-hash.c b/src/cairo-hash.c
index 948cd23..83e9f93 100644
--- a/src/cairo-hash.c
+++ b/src/cairo-hash.c
@@ -295,7 +295,7 @@ _cairo_hash_table_lookup_internal (cairo_hash_table_t *hash_table,
  * Return value: CAIRO_STATUS_SUCCESS if successful or
  * CAIRO_STATUS_NO_MEMORY if out of memory.
  **/
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_hash_table_resize  (cairo_hash_table_t *hash_table)
 {
     cairo_hash_table_t tmp;
diff --git a/src/cairo-hull.c b/src/cairo-hull.c
index e9d0a15..fe29b47 100644
--- a/src/cairo-hull.c
+++ b/src/cairo-hull.c
@@ -140,7 +140,7 @@ _cairo_hull_next_valid (cairo_hull_t *hull, int num_hull, int index)
     return index;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_hull_eliminate_concave (cairo_hull_t *hull, int num_hull)
 {
     int i, j, k;
@@ -171,7 +171,7 @@ _cairo_hull_eliminate_concave (cairo_hull_t *hull, int num_hull)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_hull_to_pen (cairo_hull_t *hull, cairo_pen_vertex_t *vertices, int *num_vertices)
 {
     int i, j = 0;
@@ -194,6 +194,7 @@ _cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices)
 {
     cairo_hull_t *hull;
     int num_hull = *num_vertices;
+    cairo_status_t status;
 
     hull = _cairo_hull_create (vertices, num_hull);
     if (hull == NULL)
@@ -202,11 +203,14 @@ _cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices)
     qsort (hull + 1, num_hull - 1,
 	   sizeof (cairo_hull_t), _cairo_hull_vertex_compare);
 
-    _cairo_hull_eliminate_concave (hull, num_hull);
+    status = _cairo_hull_eliminate_concave (hull, num_hull);
+    if (status)
+	goto BAIL;
 
-    _cairo_hull_to_pen (hull, vertices, num_vertices);
+    status = _cairo_hull_to_pen (hull, vertices, num_vertices);
 
+BAIL:
     free (hull);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
diff --git a/src/cairo-image-surface.c b/src/cairo-image-surface.c
index 6279012..fa0ca07 100644
--- a/src/cairo-image-surface.c
+++ b/src/cairo-image-surface.c
@@ -591,7 +591,7 @@ _cairo_image_surface_create_similar (void	       *abstract_src,
 						     width, height);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_image_surface_finish (void *abstract_surface)
 {
     cairo_image_surface_t *surface = abstract_surface;
@@ -615,7 +615,7 @@ _cairo_image_surface_assume_ownership_of_data (cairo_image_surface_t *surface)
     surface->owns_data = 1;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_image_surface_acquire_source_image (void                    *abstract_surface,
 					   cairo_image_surface_t  **image_out,
 					   void                   **image_extra)
@@ -633,7 +633,7 @@ _cairo_image_surface_release_source_image (void                   *abstract_surf
 {
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_image_surface_acquire_dest_image (void                    *abstract_surface,
 					 cairo_rectangle_int16_t *interest_rect,
 					 cairo_image_surface_t  **image_out,
@@ -662,7 +662,7 @@ _cairo_image_surface_release_dest_image (void                    *abstract_surfa
 {
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_image_surface_clone_similar (void		*abstract_surface,
 				    cairo_surface_t	*src,
 				    int                  src_x,
@@ -682,7 +682,7 @@ _cairo_image_surface_clone_similar (void		*abstract_surface,
     return CAIRO_INT_STATUS_UNSUPPORTED;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_image_surface_set_matrix (cairo_image_surface_t	*surface,
 				 const cairo_matrix_t	*matrix)
 {
@@ -695,7 +695,7 @@ _cairo_image_surface_set_matrix (cairo_image_surface_t	*surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_image_surface_set_filter (cairo_image_surface_t *surface, cairo_filter_t filter)
 {
     pixman_filter_t pixman_filter;
@@ -731,7 +731,7 @@ _cairo_image_surface_set_filter (cairo_image_surface_t *surface, cairo_filter_t
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_image_surface_set_attributes (cairo_image_surface_t      *surface,
 				     cairo_surface_attributes_t *attributes)
 {
@@ -806,7 +806,7 @@ _pixman_operator (cairo_operator_t op)
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_image_surface_composite (cairo_operator_t	op,
 				cairo_pattern_t		*src_pattern,
 				cairo_pattern_t		*mask_pattern,
@@ -890,7 +890,7 @@ _cairo_image_surface_composite (cairo_operator_t	op,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_image_surface_fill_rectangles (void		      *abstract_surface,
 				      cairo_operator_t	       op,
 				      const cairo_color_t     *color,
@@ -913,7 +913,7 @@ _cairo_image_surface_fill_rectangles (void		      *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
 					   cairo_pattern_t	*pattern,
 					   void			*abstract_dst,
@@ -1054,7 +1054,7 @@ _cairo_image_surface_set_clip_region (void *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_image_surface_get_extents (void			  *abstract_surface,
 				  cairo_rectangle_int16_t *rectangle)
 {
diff --git a/src/cairo-lzw.c b/src/cairo-lzw.c
index 370d258..4e4fd95 100644
--- a/src/cairo-lzw.c
+++ b/src/cairo-lzw.c
@@ -84,7 +84,7 @@ _lzw_buf_init (lzw_buf_t *buf, int size)
  *
  * Returns CAIRO_STATUS_SUCCESS or CAIRO_STATUS_NO_MEMORY
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _lzw_buf_grow (lzw_buf_t *buf)
 {
     int new_size = buf->data_size * 2;
diff --git a/src/cairo-meta-surface.c b/src/cairo-meta-surface.c
index b6665cb..cdd3e4e 100644
--- a/src/cairo-meta-surface.c
+++ b/src/cairo-meta-surface.c
@@ -106,7 +106,7 @@ _cairo_meta_surface_create_similar (void	       *abstract_surface,
     return _cairo_meta_surface_create (content, width, height);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_meta_surface_finish (void *abstract_surface)
 {
     cairo_meta_surface_t *meta = abstract_surface;
@@ -175,7 +175,7 @@ _cairo_meta_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_meta_surface_acquire_source_image (void			 *abstract_surface,
 					  cairo_image_surface_t	**image_out,
 					  void			**image_extra)
@@ -208,7 +208,7 @@ _cairo_meta_surface_release_source_image (void			*abstract_surface,
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _init_pattern_with_snapshot (cairo_pattern_t       *pattern,
 			     const cairo_pattern_t *other)
 {
@@ -233,7 +233,7 @@ _init_pattern_with_snapshot (cairo_pattern_t       *pattern,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_meta_surface_paint (void			*abstract_surface,
 			   cairo_operator_t	 op,
 			   cairo_pattern_t	*source)
@@ -272,7 +272,7 @@ _cairo_meta_surface_paint (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_meta_surface_mask (void			*abstract_surface,
 			  cairo_operator_t	 op,
 			  cairo_pattern_t	*source,
@@ -312,7 +312,7 @@ _cairo_meta_surface_mask (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_meta_surface_stroke (void			*abstract_surface,
 			    cairo_operator_t		 op,
 			    cairo_pattern_t		*source,
@@ -368,7 +368,7 @@ _cairo_meta_surface_stroke (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_meta_surface_fill (void			*abstract_surface,
 			  cairo_operator_t	 op,
 			  cairo_pattern_t	*source,
@@ -415,7 +415,7 @@ _cairo_meta_surface_fill (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_meta_surface_show_glyphs (void			*abstract_surface,
 				 cairo_operator_t	 op,
 				 cairo_pattern_t	*source,
@@ -505,7 +505,7 @@ _cairo_meta_surface_snapshot (void *abstract_other)
     return &meta->base;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_meta_surface_intersect_clip_path (void		    *dst,
 					 cairo_path_fixed_t *path,
 					 cairo_fill_rule_t   fill_rule,
@@ -553,7 +553,7 @@ _cairo_meta_surface_intersect_clip_path (void		    *dst,
  * surface size against which the meta-surface is expected to be
  * replayed, (as passed in to _cairo_meta_surface_create).
  */
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_meta_surface_get_extents (void			 *abstract_surface,
 				 cairo_rectangle_int16_t *rectangle)
 {
diff --git a/src/cairo-os2-surface.c b/src/cairo-os2-surface.c
index f6ec8f6..330dafd 100644
--- a/src/cairo-os2-surface.c
+++ b/src/cairo-os2-surface.c
@@ -663,7 +663,7 @@ _cairo_os2_surface_release_dest_image (void                    *abstract_surface
     DosReleaseMutexSem (local_os2_surface->hmtx_use_private_fields);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_os2_surface_get_extents (void                    *abstract_surface,
                                 cairo_rectangle_int16_t *rectangle)
 {
diff --git a/src/cairo-output-stream.c b/src/cairo-output-stream.c
index df3ae4d..acd5c21 100644
--- a/src/cairo-output-stream.c
+++ b/src/cairo-output-stream.c
@@ -87,7 +87,7 @@ typedef struct _cairo_output_stream_with_closure {
 } cairo_output_stream_with_closure_t;
 
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 closure_write (cairo_output_stream_t *stream,
 	       const unsigned char *data, unsigned int length)
 {
@@ -98,7 +98,7 @@ closure_write (cairo_output_stream_t *stream,
 					    data, length);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 closure_close (cairo_output_stream_t *stream)
 {
     cairo_output_stream_with_closure_t *stream_with_closure =
@@ -402,7 +402,7 @@ typedef struct _stdio_stream {
     FILE			*file;
 } stdio_stream_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 stdio_write (cairo_output_stream_t *base,
 	     const unsigned char *data, unsigned int length)
 {
@@ -414,7 +414,7 @@ stdio_write (cairo_output_stream_t *base,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 stdio_flush (cairo_output_stream_t *base)
 {
     stdio_stream_t *stream = (stdio_stream_t *) base;
@@ -427,7 +427,7 @@ stdio_flush (cairo_output_stream_t *base)
 	return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 stdio_close (cairo_output_stream_t *base)
 {
     cairo_status_t status;
@@ -486,7 +486,7 @@ typedef struct _memory_stream {
     cairo_array_t		array;
 } memory_stream_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 memory_write (cairo_output_stream_t *base,
 	      const unsigned char *data, unsigned int length)
 {
@@ -495,7 +495,7 @@ memory_write (cairo_output_stream_t *base,
     return _cairo_array_append_multiple (&stream->array, data, length);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 memory_close (cairo_output_stream_t *base)
 {
     memory_stream_t *stream = (memory_stream_t *) base;
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index 023f2a7..cb254cd 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -77,7 +77,7 @@ typedef struct _cairo_paginated_surface {
 
 const cairo_private cairo_surface_backend_t cairo_paginated_surface_backend;
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_show_page (void *abstract_surface);
 
 static cairo_surface_t *
@@ -153,7 +153,7 @@ _cairo_paginated_surface_get_target (cairo_surface_t *surface)
     return paginated_surface->target;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_paginated_surface_finish (void *abstract_surface)
 {
     cairo_paginated_surface_t *surface = abstract_surface;
@@ -194,7 +194,7 @@ _cairo_paginated_surface_create_image_surface (void	       *abstract_surface,
     return image;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_paginated_surface_acquire_source_image (void	       *abstract_surface,
 					       cairo_image_surface_t **image_out,
 					       void		   **image_extra)
@@ -212,7 +212,11 @@ _cairo_paginated_surface_acquire_source_image (void	       *abstract_surface,
 							   extents.width,
 							   extents.height);
 
-    _cairo_meta_surface_replay (surface->meta, image);
+    status = _cairo_meta_surface_replay (surface->meta, image);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     *image_out = (cairo_image_surface_t*) image;
     *image_extra = NULL;
@@ -228,7 +232,7 @@ _cairo_paginated_surface_release_source_image (void	  *abstract_surface,
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _paint_page (cairo_paginated_surface_t *surface)
 {
     cairo_surface_t *analysis;
@@ -284,7 +288,7 @@ _paint_page (cairo_paginated_surface_t *surface)
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _start_page (cairo_paginated_surface_t *surface)
 {
     if (! surface->backend->start_page)
@@ -293,7 +297,7 @@ _start_page (cairo_paginated_surface_t *surface)
     return (surface->backend->start_page) (surface->target);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_copy_page (void *abstract_surface)
 {
     cairo_status_t status;
@@ -303,7 +307,9 @@ _cairo_paginated_surface_copy_page (void *abstract_surface)
     if (status)
 	return status;
 
-    _paint_page (surface);
+    status = _paint_page (surface);
+    if (status)
+	return status;
 
     surface->page_num++;
 
@@ -318,7 +324,7 @@ _cairo_paginated_surface_copy_page (void *abstract_surface)
     return _cairo_surface_show_page (surface->target);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_show_page (void *abstract_surface)
 {
     cairo_status_t status;
@@ -328,7 +334,9 @@ _cairo_paginated_surface_show_page (void *abstract_surface)
     if (status)
 	return status;
 
-    _paint_page (surface);
+    status = _paint_page (surface);
+    if (status)
+	return status;
 
     status = _cairo_surface_show_page (surface->target);
     if (status)
@@ -347,7 +355,7 @@ _cairo_paginated_surface_show_page (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_intersect_clip_path (void	  *abstract_surface,
 					      cairo_path_fixed_t *path,
 					      cairo_fill_rule_t	  fill_rule,
@@ -361,7 +369,7 @@ _cairo_paginated_surface_intersect_clip_path (void	  *abstract_surface,
 					       tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_get_extents (void	              *abstract_surface,
 				      cairo_rectangle_int16_t *rectangle)
 {
@@ -379,7 +387,7 @@ _cairo_paginated_surface_get_font_options (void                  *abstract_surfa
     cairo_surface_get_font_options (surface->target, options);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_paint (void			*abstract_surface,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*source)
@@ -395,7 +403,7 @@ _cairo_paginated_surface_paint (void			*abstract_surface,
     return _cairo_surface_paint (surface->meta, op, source);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_mask (void		*abstract_surface,
 			       cairo_operator_t	 op,
 			       cairo_pattern_t	*source,
@@ -406,7 +414,7 @@ _cairo_paginated_surface_mask (void		*abstract_surface,
     return _cairo_surface_mask (surface->meta, op, source, mask);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_stroke (void			*abstract_surface,
 				 cairo_operator_t	 op,
 				 cairo_pattern_t	*source,
@@ -431,7 +439,7 @@ _cairo_paginated_surface_stroke (void			*abstract_surface,
 				  tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_fill (void			*abstract_surface,
 			       cairo_operator_t		 op,
 			       cairo_pattern_t		*source,
@@ -453,7 +461,7 @@ _cairo_paginated_surface_fill (void			*abstract_surface,
 				tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_paginated_surface_show_glyphs (void			*abstract_surface,
 				      cairo_operator_t		 op,
 				      cairo_pattern_t		*source,
diff --git a/src/cairo-path-bounds.c b/src/cairo-path-bounds.c
index 48b4393..24eeca9 100644
--- a/src/cairo-path-bounds.c
+++ b/src/cairo-path-bounds.c
@@ -51,22 +51,22 @@ _cairo_path_bounder_init (cairo_path_bounder_t *bounder);
 static void
 _cairo_path_bounder_fini (cairo_path_bounder_t *bounder);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_add_point (cairo_path_bounder_t *bounder, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_move_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_line_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_curve_to (void *closure,
 			      cairo_point_t *b,
 			      cairo_point_t *c,
 			      cairo_point_t *d);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_close_path (void *closure);
 
 static void
@@ -81,7 +81,7 @@ _cairo_path_bounder_fini (cairo_path_bounder_t *bounder)
     bounder->has_point = 0;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_add_point (cairo_path_bounder_t *bounder, cairo_point_t *point)
 {
     if (bounder->has_point) {
@@ -108,42 +108,45 @@ _cairo_path_bounder_add_point (cairo_path_bounder_t *bounder, cairo_point_t *poi
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_move_to (void *closure, cairo_point_t *point)
 {
     cairo_path_bounder_t *bounder = closure;
 
-    _cairo_path_bounder_add_point (bounder, point);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_path_bounder_add_point (bounder, point);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_line_to (void *closure, cairo_point_t *point)
 {
     cairo_path_bounder_t *bounder = closure;
 
-    _cairo_path_bounder_add_point (bounder, point);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_path_bounder_add_point (bounder, point);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_curve_to (void *closure,
 			      cairo_point_t *b,
 			      cairo_point_t *c,
 			      cairo_point_t *d)
 {
     cairo_path_bounder_t *bounder = closure;
-
-    _cairo_path_bounder_add_point (bounder, b);
-    _cairo_path_bounder_add_point (bounder, c);
-    _cairo_path_bounder_add_point (bounder, d);
+		cairo_status_t status;
+
+    status = _cairo_path_bounder_add_point (bounder, b);
+		if (status)
+			return status;
+    status = _cairo_path_bounder_add_point (bounder, c);
+		if (status)
+			return status;
+    status = _cairo_path_bounder_add_point (bounder, d);
+		if (status)
+			return status;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_bounder_close_path (void *closure)
 {
     return CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-path-fill.c b/src/cairo-path-fill.c
index d2a9118..f35fcd6 100644
--- a/src/cairo-path-fill.c
+++ b/src/cairo-path-fill.c
@@ -52,19 +52,19 @@ _cairo_filler_init (cairo_filler_t *filler, double tolerance, cairo_traps_t *tra
 static void
 _cairo_filler_fini (cairo_filler_t *filler);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_move_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_line_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_curve_to (void *closure,
 			cairo_point_t *b,
 			cairo_point_t *c,
 			cairo_point_t *d);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_close_path (void *closure);
 
 static void
@@ -85,7 +85,7 @@ _cairo_filler_fini (cairo_filler_t *filler)
     _cairo_polygon_fini (&filler->polygon);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_move_to (void *closure, cairo_point_t *point)
 {
     cairo_status_t status;
@@ -105,7 +105,7 @@ _cairo_filler_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_line_to (void *closure, cairo_point_t *point)
 {
     cairo_status_t status;
@@ -121,7 +121,7 @@ _cairo_filler_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_curve_to (void *closure,
 			cairo_point_t *b,
 			cairo_point_t *c,
@@ -156,7 +156,7 @@ _cairo_filler_curve_to (void *closure,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_filler_close_path (void *closure)
 {
     cairo_status_t status;
@@ -170,7 +170,7 @@ _cairo_filler_close_path (void *closure)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_path_fixed_fill_rectangle (cairo_path_fixed_t	*path,
 				  cairo_traps_t		*traps);
 
@@ -224,7 +224,7 @@ BAIL:
  * If the path described anything but a device-axis aligned rectangle,
  * this function will return CAIRO_INT_STATUS_UNSUPPORTED.
  */
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_path_fixed_fill_rectangle (cairo_path_fixed_t	*path,
 				  cairo_traps_t		*traps)
 {
diff --git a/src/cairo-path-fixed.c b/src/cairo-path-fixed.c
index 4845ada..d443777 100644
--- a/src/cairo-path-fixed.c
+++ b/src/cairo-path-fixed.c
@@ -41,7 +41,7 @@
 #include "cairo-path-fixed-private.h"
 
 /* private functions */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_add (cairo_path_fixed_t *path,
 		       cairo_path_op_t 	   op,
 		       cairo_point_t	  *points,
@@ -350,7 +350,7 @@ _cairo_path_fixed_get_current_point (cairo_path_fixed_t *path,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_fixed_add (cairo_path_fixed_t *path,
 		       cairo_path_op_t	   op,
 		       cairo_point_t	  *points,
diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index d4db605..c8fd590 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -67,7 +67,7 @@ typedef struct cairo_stroker {
 } cairo_stroker_t;
 
 /* private functions */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -75,31 +75,31 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     double			 tolerance,
 		     cairo_traps_t		*traps);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_move_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_line_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_line_to_dashed (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_curve_to (void *closure,
 			 cairo_point_t *b,
 			 cairo_point_t *c,
 			 cairo_point_t *d);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_curve_to_dashed (void *closure,
 				cairo_point_t *b,
 				cairo_point_t *c,
 				cairo_point_t *d);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_close_path (void *closure);
 
 static void
@@ -108,7 +108,7 @@ _translate_point (cairo_point_t *point, cairo_point_t *offset);
 static int
 _cairo_stroker_face_clockwise (cairo_stroke_face_t *in, cairo_stroke_face_t *out);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_stroke_face_t *out);
 
 static void
@@ -148,7 +148,7 @@ _cairo_stroker_step_dash (cairo_stroker_t *stroker, double step)
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -176,7 +176,7 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		            tolerance, ctm);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker)
 {
     return _cairo_pen_fini (&stroker->pen);
@@ -200,7 +200,7 @@ _cairo_stroker_face_clockwise (cairo_stroke_face_t *in, cairo_stroke_face_t *out
     return _cairo_slope_clockwise (&in_slope, &out_slope);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_stroke_face_t *out)
 {
     int			clockwise = _cairo_stroker_face_clockwise (out, in);
@@ -372,7 +372,7 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 {
     cairo_status_t	    status;
@@ -459,7 +459,7 @@ CLEANUP_LINE_CAP_SQUARE:
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_add_leading_cap (cairo_stroker_t     *stroker,
 				cairo_stroke_face_t *face)
 {
@@ -480,7 +480,7 @@ _cairo_stroker_add_leading_cap (cairo_stroker_t     *stroker,
     return _cairo_stroker_add_cap (stroker, &reversed);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_add_trailing_cap (cairo_stroker_t     *stroker,
 				 cairo_stroke_face_t *face)
 {
@@ -490,7 +490,7 @@ _cairo_stroker_add_trailing_cap (cairo_stroker_t     *stroker,
 static void
 _compute_face (cairo_point_t *point, cairo_slope_t *slope, cairo_stroker_t *stroker, cairo_stroke_face_t *face);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_add_caps (cairo_stroker_t *stroker)
 {
     cairo_status_t status;
@@ -600,7 +600,7 @@ _compute_face (cairo_point_t *point, cairo_slope_t *slope, cairo_stroker_t *stro
     face->dev_vector = *slope;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_add_sub_edge (cairo_stroker_t *stroker, cairo_point_t *p1, cairo_point_t *p2,
 			     cairo_slope_t *slope, cairo_stroke_face_t *start,
 			     cairo_stroke_face_t *end)
@@ -625,7 +625,7 @@ _cairo_stroker_add_sub_edge (cairo_stroker_t *stroker, cairo_point_t *p1, cairo_
     return _cairo_traps_tessellate_convex_quad (stroker->traps, rectangle);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_move_to (void *closure, cairo_point_t *point)
 {
     cairo_status_t status;
@@ -646,7 +646,7 @@ _cairo_stroker_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_move_to_dashed (void *closure, cairo_point_t *point)
 {
     /* reset the dash pattern for new sub paths */
@@ -656,7 +656,7 @@ _cairo_stroker_move_to_dashed (void *closure, cairo_point_t *point)
     return _cairo_stroker_move_to (closure, point);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_line_to (void *closure, cairo_point_t *point)
 {
     cairo_status_t status;
@@ -698,7 +698,7 @@ _cairo_stroker_line_to (void *closure, cairo_point_t *point)
 /*
  * Dashed lines.  Cap each dash end, join around turns when on
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_line_to_dashed (void *closure, cairo_point_t *point)
 {
     cairo_status_t status = CAIRO_STATUS_SUCCESS;
@@ -800,7 +800,7 @@ _cairo_stroker_line_to_dashed (void *closure, cairo_point_t *point)
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_curve_to (void *closure,
 			 cairo_point_t *b,
 			 cairo_point_t *c,
@@ -888,7 +888,7 @@ _cairo_stroker_curve_to (void *closure,
  * problem. It will also increase the importance of implementing
  * an efficient and more robust tessellator.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_curve_to_dashed (void *closure,
 				cairo_point_t *b,
 				cairo_point_t *c,
@@ -937,7 +937,7 @@ _cairo_stroker_curve_to_dashed (void *closure,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_stroker_close_path (void *closure)
 {
     cairo_status_t status;
@@ -969,7 +969,7 @@ _cairo_stroker_close_path (void *closure)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_path_fixed_stroke_rectilinear (cairo_path_fixed_t	*path,
 				      cairo_stroke_style_t	*stroke_style,
 				      cairo_matrix_t		*ctm,
@@ -984,6 +984,7 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
 				   cairo_traps_t	*traps)
 {
     cairo_status_t status;
+    cairo_status_t status2;
     cairo_stroker_t stroker;
 
     /* Before we do anything else, we attempt the rectilinear
@@ -1027,7 +1028,9 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
     status = _cairo_stroker_add_caps (&stroker);
 
 BAIL:
-    _cairo_stroker_fini (&stroker);
+    status2 = _cairo_stroker_fini (&stroker);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
@@ -1066,7 +1069,7 @@ _cairo_rectilinear_stroker_fini (cairo_rectilinear_stroker_t	*stroker)
     free (stroker->segments);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_rectilinear_stroker_add_segment (cairo_rectilinear_stroker_t	*stroker,
 					cairo_point_t			*p1,
 					cairo_point_t			*p2)
@@ -1093,7 +1096,7 @@ _cairo_rectilinear_stroker_add_segment (cairo_rectilinear_stroker_t	*stroker,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_rectilinear_stroker_emit_segments (cairo_rectilinear_stroker_t *stroker)
 {
     cairo_status_t status;
@@ -1203,7 +1206,7 @@ _cairo_rectilinear_stroker_emit_segments (cairo_rectilinear_stroker_t *stroker)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_rectilinear_stroker_move_to (void		*closure,
 				    cairo_point_t	*point)
 {
@@ -1220,7 +1223,7 @@ _cairo_rectilinear_stroker_move_to (void		*closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_rectilinear_stroker_line_to (void		*closure,
 				    cairo_point_t	*point)
 {
@@ -1246,7 +1249,7 @@ _cairo_rectilinear_stroker_line_to (void		*closure,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_rectilinear_stroker_close_path (void *closure)
 {
     cairo_rectilinear_stroker_t *stroker = closure;
@@ -1270,7 +1273,7 @@ _cairo_rectilinear_stroker_close_path (void *closure)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_path_fixed_stroke_rectilinear (cairo_path_fixed_t	*path,
 				      cairo_stroke_style_t	*stroke_style,
 				      cairo_matrix_t		*ctm,
diff --git a/src/cairo-path.c b/src/cairo-path.c
index a12db36..77ae774 100644
--- a/src/cairo-path.c
+++ b/src/cairo-path.c
@@ -47,7 +47,7 @@ typedef struct cairo_path_count {
     cairo_point_t current_point;
 } cpc_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpc_move_to (void *closure, cairo_point_t *point)
 {
     cpc_t *cpc = closure;
@@ -59,7 +59,7 @@ _cpc_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpc_line_to (void *closure, cairo_point_t *point)
 {
     cpc_t *cpc = closure;
@@ -71,7 +71,7 @@ _cpc_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpc_curve_to (void		*closure,
 	       cairo_point_t	*p1,
 	       cairo_point_t	*p2,
@@ -86,7 +86,7 @@ _cpc_curve_to (void		*closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpc_curve_to_flatten (void		*closure,
 		       cairo_point_t	*p1,
 		       cairo_point_t	*p2,
@@ -107,8 +107,11 @@ _cpc_curve_to_flatten (void		*closure,
     if (status)
       goto out;
 
-    for (i=1; i < spline.num_points; i++)
-	_cpc_line_to (cpc, &spline.points[i]);
+    for (i=1; i < spline.num_points; i++) {
+	status = _cpc_line_to (cpc, &spline.points[i]);
+	if (status)
+	    goto out;
+    }
 
     cpc->current_point = *p3;
 
@@ -119,7 +122,7 @@ _cpc_curve_to_flatten (void		*closure,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpc_close_path (void *closure)
 {
     cpc_t *cpc = closure;
@@ -165,7 +168,7 @@ typedef struct cairo_path_populate {
     cairo_point_t      current_point;
 } cpp_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpp_move_to (void *closure, cairo_point_t *point)
 {
     cpp_t *cpp = closure;
@@ -191,7 +194,7 @@ _cpp_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpp_line_to (void *closure, cairo_point_t *point)
 {
     cpp_t *cpp = closure;
@@ -217,7 +220,7 @@ _cpp_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpp_curve_to (void		*closure,
 	       cairo_point_t	*p1,
 	       cairo_point_t	*p2,
@@ -261,7 +264,7 @@ _cpp_curve_to (void		*closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpp_curve_to_flatten (void		*closure,
 		       cairo_point_t	*p1,
 		       cairo_point_t	*p2,
@@ -282,8 +285,11 @@ _cpp_curve_to_flatten (void		*closure,
     if (status)
       goto out;
 
-    for (i=1; i < spline.num_points; i++)
-	_cpp_line_to (cpp, &spline.points[i]);
+    for (i=1; i < spline.num_points; i++) {
+	status = _cpp_line_to (cpp, &spline.points[i]);
+	if (status)
+	    goto out;
+    }
 
     cpp->current_point = *p3;
 
@@ -294,7 +300,7 @@ _cpp_curve_to_flatten (void		*closure,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cpp_close_path (void *closure)
 {
     cpp_t *cpp = closure;
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index e3857ba..9d5dd8e 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -658,7 +658,7 @@ cairo_pattern_set_user_data (cairo_pattern_t		 *pattern,
 }
 
 /* make room for at least one more color stop */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pattern_gradient_grow (cairo_gradient_pattern_t *pattern)
 {
     pixman_gradient_stop_t *new_stops;
@@ -1025,7 +1025,7 @@ _cairo_linear_pattern_classify (cairo_linear_pattern_t *pattern,
     *is_horizontal = factors[2] == factors[0];
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pattern_acquire_surface_for_gradient (cairo_gradient_pattern_t *pattern,
 					     cairo_surface_t	        *dst,
 					     int			x,
@@ -1160,7 +1160,7 @@ _cairo_pattern_acquire_surface_for_gradient (cairo_gradient_pattern_t *pattern,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pattern_acquire_surface_for_solid (cairo_solid_pattern_t	     *pattern,
 					  cairo_surface_t	     *dst,
 					  int			     x,
@@ -1251,7 +1251,7 @@ _cairo_pattern_is_opaque (const cairo_pattern_t *abstract_pattern)
     return FALSE;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pattern_acquire_surface_for_surface (cairo_surface_pattern_t   *pattern,
 					    cairo_surface_t	       *dst,
 					    int			       x,
diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 25e5058..5b62d64 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -170,10 +170,10 @@ _cairo_pdf_surface_write_catalog (cairo_pdf_surface_t *surface);
 static long
 _cairo_pdf_surface_write_xref (cairo_pdf_surface_t *surface);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_write_page (cairo_pdf_surface_t *surface);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_font_subsets (cairo_pdf_surface_t *surface);
 
 static const cairo_surface_backend_t cairo_pdf_surface_backend;
@@ -400,7 +400,7 @@ _cairo_surface_is_pdf (cairo_surface_t *surface)
  * surface's target is a pdf_surface, then set pdf_surface to that
  * target. Otherwise return CAIRO_STATUS_SURFACE_TYPE_MISMATCH.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _extract_pdf_surface (cairo_surface_t		 *surface,
 		      cairo_pdf_surface_t	**pdf_surface)
 {
@@ -535,7 +535,7 @@ _cairo_pdf_surface_close_stream (cairo_pdf_surface_t *surface)
     surface->current_stream.active = FALSE;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_finish (void *abstract_surface)
 {
     cairo_status_t status;
@@ -610,7 +610,7 @@ _cairo_pdf_surface_resume_content_stream (cairo_pdf_surface_t *surface)
     _cairo_pdf_surface_add_stream (surface, stream);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_start_page (void *abstract_surface)
 {
     cairo_pdf_surface_t *surface = abstract_surface;
@@ -656,7 +656,7 @@ compress_dup (const void *data, unsigned long data_size,
  * In the case that the alpha channel happens to be all opaque, then
  * no SMask object will be emitted and *id_ret will be set to 0.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_smask (cairo_pdf_surface_t		*surface,
 	    cairo_image_surface_t	*image,
 	    cairo_pdf_resource_t	*stream_ret)
@@ -727,7 +727,7 @@ _cairo_pdf_surface_emit_smask (cairo_pdf_surface_t		*surface,
 
 /* Emit image data into the given surface, providing a resource that
  * can be used to reference the data in image_ret. */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_image (cairo_pdf_surface_t		*surface,
 	    cairo_image_surface_t	*image,
 	    cairo_pdf_resource_t	*image_ret)
@@ -840,7 +840,7 @@ _cairo_pdf_surface_emit_image (cairo_pdf_surface_t		*surface,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_solid_pattern (cairo_pdf_surface_t *surface,
 		    cairo_solid_pattern_t *pattern)
 {
@@ -865,7 +865,7 @@ _cairo_pdf_surface_emit_solid_pattern (cairo_pdf_surface_t *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	*surface,
 		      cairo_surface_pattern_t	*pattern)
 {
@@ -1186,7 +1186,7 @@ _cairo_pdf_surface_emit_pattern_stops (cairo_pdf_surface_t *surface, cairo_gradi
     return function;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_linear_pattern_t *pattern)
 {
     cairo_pdf_resource_t function, pattern_resource, alpha;
@@ -1249,7 +1249,7 @@ _cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_line
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radial_pattern_t *pattern)
 {
     cairo_pdf_resource_t function, pattern_resource, alpha;
@@ -1325,7 +1325,7 @@ _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radi
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_pattern (cairo_pdf_surface_t *surface, cairo_pattern_t *pattern)
 {
     switch (pattern->type) {
@@ -1347,7 +1347,7 @@ _cairo_pdf_surface_emit_pattern (cairo_pdf_surface_t *surface, cairo_pattern_t *
     return CAIRO_STATUS_PATTERN_TYPE_MISMATCH;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_copy_page (void *abstract_surface)
 {
     cairo_pdf_surface_t *surface = abstract_surface;
@@ -1355,7 +1355,7 @@ _cairo_pdf_surface_copy_page (void *abstract_surface)
     return _cairo_pdf_surface_write_page (surface);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_show_page (void *abstract_surface)
 {
     cairo_pdf_surface_t *surface = abstract_surface;
@@ -1370,7 +1370,7 @@ _cairo_pdf_surface_show_page (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_get_extents (void		        *abstract_surface,
 				cairo_rectangle_int16_t *rectangle)
 {
@@ -1394,7 +1394,7 @@ typedef struct _pdf_path_info {
     cairo_matrix_t	    *ctm_inverse;
 } pdf_path_info_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_path_move_to (void *closure, cairo_point_t *point)
 {
     pdf_path_info_t *info = closure;
@@ -1410,7 +1410,7 @@ _cairo_pdf_path_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_path_line_to (void *closure, cairo_point_t *point)
 {
     pdf_path_info_t *info = closure;
@@ -1425,7 +1425,7 @@ _cairo_pdf_path_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_path_curve_to (void          *closure,
 			  cairo_point_t *b,
 			  cairo_point_t *c,
@@ -1451,7 +1451,7 @@ _cairo_pdf_path_curve_to (void          *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_path_close_path (void *closure)
 {
     pdf_path_info_t *info = closure;
@@ -1462,7 +1462,7 @@ _cairo_pdf_path_close_path (void *closure)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_intersect_clip_path (void			*abstract_surface,
 					cairo_path_fixed_t	*path,
 					cairo_fill_rule_t	fill_rule,
@@ -1719,7 +1719,7 @@ _cairo_pdf_surface_emit_toUnicode_stream (cairo_pdf_surface_t		*surface,
     return stream;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_cff_font_subset (cairo_pdf_surface_t		*surface,
                                          cairo_scaled_font_subset_t	*font_subset)
 {
@@ -1831,7 +1831,7 @@ _cairo_pdf_surface_emit_cff_font_subset (cairo_pdf_surface_t		*surface,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_type1_font (cairo_pdf_surface_t		*surface,
                                     cairo_scaled_font_subset_t	*font_subset,
                                     cairo_type1_subset_t        *subset)
@@ -1937,7 +1937,7 @@ _cairo_pdf_surface_emit_type1_font (cairo_pdf_surface_t		*surface,
 }
 
 #if CAIRO_HAS_FT_FONT
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_type1_font_subset (cairo_pdf_surface_t		*surface,
 					   cairo_scaled_font_subset_t	*font_subset)
 {
@@ -1958,7 +1958,7 @@ _cairo_pdf_surface_emit_type1_font_subset (cairo_pdf_surface_t		*surface,
 }
 #endif
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_type1_fallback_font (cairo_pdf_surface_t	*surface,
                                              cairo_scaled_font_subset_t	*font_subset)
 {
@@ -1980,7 +1980,7 @@ _cairo_pdf_surface_emit_type1_fallback_font (cairo_pdf_surface_t	*surface,
 
 #define PDF_UNITS_PER_EM 1000
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_truetype_font_subset (cairo_pdf_surface_t		*surface,
 					      cairo_scaled_font_subset_t	*font_subset)
 {
@@ -2109,7 +2109,7 @@ _cairo_pdf_surface_emit_truetype_font_subset (cairo_pdf_surface_t		*surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_emit_outline_glyph (cairo_pdf_surface_t	*surface,
 				       cairo_scaled_font_t	*scaled_font,
 				       unsigned long		 glyph_index,
@@ -2155,7 +2155,7 @@ _cairo_pdf_surface_emit_outline_glyph (cairo_pdf_surface_t	*surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_emit_bitmap_glyph (cairo_pdf_surface_t	*surface,
 				      cairo_scaled_font_t	*scaled_font,
 				      unsigned long		 glyph_index,
@@ -2263,7 +2263,7 @@ _cairo_pdf_surface_emit_glyph (cairo_pdf_surface_t	*surface,
 	_cairo_surface_set_error (&surface->base, status);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_type3_font_subset (cairo_pdf_surface_t		*surface,
 					   cairo_scaled_font_subset_t	*font_subset)
 {
@@ -2428,7 +2428,7 @@ _cairo_pdf_surface_emit_scaled_font_subset (cairo_scaled_font_subset_t *font_sub
 	return;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_font_subsets (cairo_pdf_surface_t *surface)
 {
     cairo_status_t status;
@@ -2494,7 +2494,7 @@ _cairo_pdf_surface_write_xref (cairo_pdf_surface_t *surface)
     return offset;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_write_page (cairo_pdf_surface_t *surface)
 {
     cairo_status_t status;
@@ -2612,7 +2612,7 @@ _cairo_pdf_test_force_fallbacks (void)
     cairo_pdf_force_fallbacks = TRUE;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 __cairo_pdf_surface_operation_supported (cairo_pdf_surface_t *surface,
 		      cairo_operator_t op,
 		      cairo_pattern_t *pattern)
@@ -2631,7 +2631,7 @@ __cairo_pdf_surface_operation_supported (cairo_pdf_surface_t *surface,
     return FALSE;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_analyze_operation (cairo_pdf_surface_t *surface,
 		    cairo_operator_t op,
 		    cairo_pattern_t *pattern)
@@ -2642,7 +2642,7 @@ _cairo_pdf_surface_analyze_operation (cairo_pdf_surface_t *surface,
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_paint (void			*abstract_surface,
 			  cairo_operator_t	 op,
 			  cairo_pattern_t	*source)
@@ -2674,7 +2674,7 @@ _cairo_pdf_surface_paint (void			*abstract_surface,
     return _cairo_output_stream_get_status (surface->output);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_mask	(void			*abstract_surface,
 			 cairo_operator_t	 op,
 			 cairo_pattern_t	*source,
@@ -2722,7 +2722,7 @@ _cairo_pdf_line_join (cairo_line_join_t join)
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pdf_surface_emit_stroke_style (cairo_pdf_surface_t	*surface,
 				      cairo_stroke_style_t	*style)
 {
@@ -2756,7 +2756,7 @@ _cairo_pdf_surface_emit_stroke_style (cairo_pdf_surface_t	*surface,
     return _cairo_output_stream_get_status (surface->output);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_stroke (void			*abstract_surface,
 			   cairo_operator_t	 op,
 			   cairo_pattern_t	*source,
@@ -2806,7 +2806,7 @@ _cairo_pdf_surface_stroke (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_fill (void			*abstract_surface,
 			 cairo_operator_t	 op,
 			 cairo_pattern_t	*source,
@@ -2858,7 +2858,7 @@ _cairo_pdf_surface_fill (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_pdf_surface_show_glyphs (void			*abstract_surface,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*source,
diff --git a/src/cairo-pen.c b/src/cairo-pen.c
index 66984b3..cf6c704 100644
--- a/src/cairo-pen.c
+++ b/src/cairo-pen.c
@@ -42,7 +42,7 @@ _cairo_pen_vertices_needed (double tolerance, double radius, cairo_matrix_t *mat
 static void
 _cairo_pen_compute_slopes (cairo_pen_t *pen);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_stroke_spline_half (cairo_pen_t *pen, cairo_spline_t *spline, cairo_direction_t dir, cairo_polygon_t *polygon);
 
 cairo_status_t
@@ -358,7 +358,7 @@ _cairo_pen_find_active_ccw_vertex_index (cairo_pen_t *pen,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_pen_stroke_spline_half (cairo_pen_t *pen,
 			       cairo_spline_t *spline,
 			       cairo_direction_t dir,
diff --git a/src/cairo-png.c b/src/cairo-png.c
index 006cae3..9123151 100644
--- a/src/cairo-png.c
+++ b/src/cairo-png.c
@@ -82,7 +82,7 @@ convert_data_to_bytes (png_structp png, png_row_infop row_info, png_bytep data)
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 write_png (cairo_surface_t	*surface,
 	   png_rw_ptr		write_func,
 	   void			*closure)
diff --git a/src/cairo-polygon.c b/src/cairo-polygon.c
index 86191ca..059ec30 100644
--- a/src/cairo-polygon.c
+++ b/src/cairo-polygon.c
@@ -39,7 +39,7 @@
 
 /* private functions */
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_polygon_grow (cairo_polygon_t *polygon);
 
 void
@@ -67,7 +67,7 @@ _cairo_polygon_fini (cairo_polygon_t *polygon)
 }
 
 /* make room for at least one more edge */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_polygon_grow (cairo_polygon_t *polygon)
 {
     cairo_edge_t *new_edges;
diff --git a/src/cairo-ps-surface.c b/src/cairo-ps-surface.c
index a5dfd8e..ec3d8d7 100644
--- a/src/cairo-ps-surface.c
+++ b/src/cairo-ps-surface.c
@@ -122,7 +122,7 @@ _count_word_up_to (const unsigned char *s, int length)
     return word;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _word_wrap_stream_write (cairo_output_stream_t  *base,
 			 const unsigned char	*data,
 			 unsigned int		 length)
@@ -167,7 +167,7 @@ _word_wrap_stream_write (cairo_output_stream_t  *base,
     return _cairo_output_stream_get_status (stream->output);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _word_wrap_stream_close (cairo_output_stream_t *base)
 {
     word_wrap_stream_t *stream = (word_wrap_stream_t *) base;
@@ -203,7 +203,7 @@ typedef struct _ps_path_info {
     cairo_bool_t has_sub_path;
 } ps_path_info_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_path_move_to (void *closure, cairo_point_t *point)
 {
     ps_path_info_t *path_info = closure;
@@ -219,7 +219,7 @@ _cairo_ps_surface_path_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_path_line_to (void *closure, cairo_point_t *point)
 {
     ps_path_info_t *path_info = closure;
@@ -242,7 +242,7 @@ _cairo_ps_surface_path_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_path_curve_to (void          *closure,
 				 cairo_point_t *b,
 				 cairo_point_t *c,
@@ -264,7 +264,7 @@ _cairo_ps_surface_path_curve_to (void          *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_path_close_path (void *closure)
 {
     ps_path_info_t *path_info = closure;
@@ -290,7 +290,7 @@ _cairo_ps_surface_path_close_path (void *closure)
  * stroked, simply pass CAIRO_LINE_CAP_ROUND which will guarantee that
  * the stroke workaround will not modify the path being emitted.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 			     cairo_output_stream_t *stream,
 			     cairo_path_fixed_t    *path,
@@ -395,7 +395,7 @@ _cairo_ps_surface_emit_header (cairo_ps_surface_t *surface)
 }
 
 #if CAIRO_HAS_FT_FONT
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_emit_type1_font_subset (cairo_ps_surface_t		*surface,
 					  cairo_scaled_font_subset_t	*font_subset)
 
@@ -426,7 +426,7 @@ _cairo_ps_surface_emit_type1_font_subset (cairo_ps_surface_t		*surface,
 }
 #endif
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_emit_type1_font_fallback (cairo_ps_surface_t		*surface,
                                             cairo_scaled_font_subset_t	*font_subset)
 {
@@ -454,7 +454,7 @@ _cairo_ps_surface_emit_type1_font_fallback (cairo_ps_surface_t		*surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_emit_truetype_font_subset (cairo_ps_surface_t		*surface,
 					     cairo_scaled_font_subset_t	*font_subset)
 
@@ -531,7 +531,7 @@ _cairo_ps_surface_emit_truetype_font_subset (cairo_ps_surface_t		*surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_emit_outline_glyph_data (cairo_ps_surface_t	*surface,
 					   cairo_scaled_font_t	*scaled_font,
 					   unsigned long	 glyph_index)
@@ -566,7 +566,7 @@ _cairo_ps_surface_emit_outline_glyph_data (cairo_ps_surface_t	*surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_emit_bitmap_glyph_data (cairo_ps_surface_t	*surface,
 					  cairo_scaled_font_t	*scaled_font,
 					  unsigned long	 glyph_index)
@@ -663,7 +663,7 @@ _cairo_ps_surface_emit_glyph (cairo_ps_surface_t	*surface,
 	_cairo_surface_set_error (&surface->base, status);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_emit_type3_font_subset (cairo_ps_surface_t		*surface,
 					  cairo_scaled_font_subset_t	*font_subset)
 
@@ -745,7 +745,7 @@ _cairo_ps_surface_emit_scaled_font_subset (cairo_scaled_font_subset_t *font_subs
 	return;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_emit_font_subsets (cairo_ps_surface_t *surface)
 {
     cairo_status_t status;
@@ -949,7 +949,7 @@ _cairo_surface_is_ps (cairo_surface_t *surface)
  * surface's target is a ps_surface, then set ps_surface to that
  * target. Otherwise return CAIRO_STATUS_SURFACE_TYPE_MISMATCH.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _extract_ps_surface (cairo_surface_t	 *surface,
 		     cairo_ps_surface_t **ps_surface)
 {
@@ -1201,7 +1201,7 @@ cairo_ps_surface_dsc_begin_page_setup (cairo_surface_t *surface)
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_finish (void *abstract_surface)
 {
     cairo_status_t status;
@@ -1249,7 +1249,7 @@ _cairo_ps_surface_finish (void *abstract_surface)
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_start_page (void *abstract_surface)
 {
     cairo_ps_surface_t *surface = abstract_surface;
@@ -1304,7 +1304,7 @@ _cairo_ps_surface_end_page (cairo_ps_surface_t *surface)
 				 "grestore\n");
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_copy_page (void *abstract_surface)
 {
     cairo_ps_surface_t *surface = abstract_surface;
@@ -1316,7 +1316,7 @@ _cairo_ps_surface_copy_page (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_show_page (void *abstract_surface)
 {
     cairo_ps_surface_t *surface = abstract_surface;
@@ -1406,7 +1406,7 @@ _cairo_ps_test_force_fallbacks (void)
     cairo_ps_force_fallbacks = TRUE;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_operation_supported (cairo_ps_surface_t *surface,
 		      cairo_operator_t op,
 		      const cairo_pattern_t *pattern)
@@ -1426,7 +1426,7 @@ _cairo_ps_surface_operation_supported (cairo_ps_surface_t *surface,
     return _cairo_pattern_is_opaque (pattern);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_analyze_operation (cairo_ps_surface_t *surface,
 		    cairo_operator_t op,
 		    const cairo_pattern_t *pattern)
@@ -1456,7 +1456,7 @@ typedef struct _string_array_stream {
     int string_size;
 } string_array_stream_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _string_array_stream_write (cairo_output_stream_t *base,
 			    const unsigned char   *data,
 			    unsigned int	   length)
@@ -1511,7 +1511,7 @@ _string_array_stream_write (cairo_output_stream_t *base,
     return _cairo_output_stream_get_status (stream->output);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _string_array_stream_close (cairo_output_stream_t *base)
 {
     cairo_status_t status;
@@ -1560,7 +1560,7 @@ _string_array_stream_create (cairo_output_stream_t *output)
 /* PS Output - this section handles output of the parts of the meta
  * surface we can render natively in PS. */
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_ps_surface_emit_image (cairo_ps_surface_t    *surface,
 	    cairo_image_surface_t *image,
 	    const char		  *name)
@@ -1851,7 +1851,7 @@ _cairo_ps_surface_emit_pattern (cairo_ps_surface_t *surface, cairo_pattern_t *pa
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_intersect_clip_path (void		   *abstract_surface,
 				cairo_path_fixed_t *path,
 				cairo_fill_rule_t   fill_rule,
@@ -1896,7 +1896,7 @@ _cairo_ps_surface_intersect_clip_path (void		   *abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_get_extents (void		       *abstract_surface,
 			       cairo_rectangle_int16_t *rectangle)
 {
@@ -1926,7 +1926,7 @@ _cairo_ps_surface_get_font_options (void                  *abstract_surface,
     cairo_font_options_set_antialias (options, CAIRO_ANTIALIAS_GRAY);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_paint (void			*abstract_surface,
 			 cairo_operator_t	 op,
 			 cairo_pattern_t	*source)
@@ -2009,7 +2009,7 @@ _cairo_ps_line_join (cairo_line_join_t join)
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_stroke (void			*abstract_surface,
 			  cairo_operator_t	 op,
 			  cairo_pattern_t	*source,
@@ -2144,7 +2144,7 @@ _cairo_ps_surface_stroke (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_fill (void		*abstract_surface,
 		 cairo_operator_t	 op,
 		 cairo_pattern_t	*source,
@@ -2198,7 +2198,7 @@ typedef struct _cairo_ps_glyph_id {
     unsigned int glyph_id;
 } cairo_ps_glyph_id_t;
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_ps_surface_show_glyphs (void		     *abstract_surface,
 			       cairo_operator_t	      op,
 			       cairo_pattern_t	     *source,
diff --git a/src/cairo-quartz-surface.c b/src/cairo-quartz-surface.c
index 1ac4c7b..a88c2fb 100644
--- a/src/cairo-quartz-surface.c
+++ b/src/cairo-quartz-surface.c
@@ -102,7 +102,7 @@ static void quartz_image_to_png (CGImageRef, char *dest);
  */
 
 /* cairo path -> mutable path */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_path_move_to (void *closure, cairo_point_t *point)
 {
     CGPathMoveToPoint ((CGMutablePathRef) closure, NULL,
@@ -110,7 +110,7 @@ _cairo_path_to_quartz_path_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_path_line_to (void *closure, cairo_point_t *point)
 {
     CGPathAddLineToPoint ((CGMutablePathRef) closure, NULL,
@@ -118,7 +118,7 @@ _cairo_path_to_quartz_path_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_path_curve_to (void *closure, cairo_point_t *p0, cairo_point_t *p1, cairo_point_t *p2)
 {
     CGPathAddCurveToPoint ((CGMutablePathRef) closure, NULL,
@@ -128,7 +128,7 @@ _cairo_path_to_quartz_path_curve_to (void *closure, cairo_point_t *p0, cairo_poi
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_path_close_path (void *closure)
 {
     CGPathCloseSubpath ((CGMutablePathRef) closure);
@@ -136,7 +136,7 @@ _cairo_path_to_quartz_path_close_path (void *closure)
 }
 
 /* cairo path -> execute in context */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_context_move_to (void *closure, cairo_point_t *point)
 {
     //ND((stderr, "moveto: %f %f\n", _cairo_fixed_to_double(point->x), _cairo_fixed_to_double(point->y)));
@@ -145,7 +145,7 @@ _cairo_path_to_quartz_context_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_context_line_to (void *closure, cairo_point_t *point)
 {
     //ND((stderr, "lineto: %f %f\n",  _cairo_fixed_to_double(point->x), _cairo_fixed_to_double(point->y)));
@@ -158,7 +158,7 @@ _cairo_path_to_quartz_context_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_context_curve_to (void *closure, cairo_point_t *p0, cairo_point_t *p1, cairo_point_t *p2)
 {
     //ND( (stderr, "curveto: %f,%f %f,%f %f,%f\n",
@@ -173,7 +173,7 @@ _cairo_path_to_quartz_context_curve_to (void *closure, cairo_point_t *p0, cairo_
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_path_to_quartz_context_close_path (void *closure)
 {
     //ND((stderr, "closepath\n"));
@@ -181,7 +181,7 @@ _cairo_path_to_quartz_context_close_path (void *closure)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_quartz_cairo_path_to_quartz_path (cairo_path_fixed_t *path,
 					  CGMutablePathRef cgPath)
 {
@@ -194,7 +194,7 @@ _cairo_quartz_cairo_path_to_quartz_path (cairo_path_fixed_t *path,
 					cgPath);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_quartz_cairo_path_to_quartz_context (cairo_path_fixed_t *path,
 					     CGContextRef cgc)
 {
@@ -511,7 +511,7 @@ SurfacePatternDrawFunc (void *info, CGContextRef context)
 }
 
 /* Borrowed from cairo-meta-surface */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _init_pattern_with_snapshot (cairo_pattern_t *pattern,
 			     const cairo_pattern_t *other)
 {
@@ -746,7 +746,7 @@ ImageDataReleaseFunc(void *info, const void *data, size_t size)
 }
 
 /* Read the image from the surface's front buffer */
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_get_image (cairo_quartz_surface_t *surface,
 			  cairo_image_surface_t **image_out,
 			  unsigned char **data_out)
@@ -829,7 +829,7 @@ _cairo_quartz_get_image (cairo_quartz_surface_t *surface,
  * Cairo surface backend implementations
  */
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_quartz_surface_finish (void *abstract_surface)
 {
     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
@@ -851,7 +851,7 @@ _cairo_quartz_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_quartz_surface_acquire_source_image (void *abstract_surface,
 					     cairo_image_surface_t **image_out,
 					     void **image_extra)
@@ -865,7 +865,7 @@ _cairo_quartz_surface_acquire_source_image (void *abstract_surface,
     return _cairo_quartz_get_image (surface, image_out, NULL);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_quartz_surface_acquire_dest_image (void *abstract_surface,
 					   cairo_rectangle_int16_t *interest_rect,
 					   cairo_image_surface_t **image_out,
@@ -956,7 +956,7 @@ _cairo_quartz_surface_create_similar (void *abstract_surface,
     return cairo_quartz_surface_create (format, width, height);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_quartz_surface_clone_similar (void *abstract_surface,
 				      cairo_surface_t *src,
 				      int              src_x,
@@ -1050,7 +1050,7 @@ _cairo_quartz_surface_clone_similar (void *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_surface_get_extents (void *abstract_surface,
 				    cairo_rectangle_int16_t *extents)
 {
@@ -1061,7 +1061,7 @@ _cairo_quartz_surface_get_extents (void *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_surface_paint (void *abstract_surface,
 			      cairo_operator_t op,
 			      cairo_pattern_t *source)
@@ -1096,7 +1096,7 @@ _cairo_quartz_surface_paint (void *abstract_surface,
     return rv;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_surface_fill (void *abstract_surface,
 			     cairo_operator_t op,
 			     cairo_pattern_t *source,
@@ -1155,7 +1155,7 @@ _cairo_quartz_surface_fill (void *abstract_surface,
     return rv;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_surface_stroke (void *abstract_surface,
 			       cairo_operator_t op,
 			       cairo_pattern_t *source,
@@ -1235,7 +1235,7 @@ _cairo_quartz_surface_stroke (void *abstract_surface,
 }
 
 #if CAIRO_HAS_ATSUI_FONT
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_surface_show_glyphs (void *abstract_surface,
 				    cairo_operator_t op,
 				    cairo_pattern_t *source,
@@ -1349,7 +1349,7 @@ _cairo_quartz_surface_show_glyphs (void *abstract_surface,
 }
 #endif /* CAIRO_HAS_ATSUI_FONT */
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_surface_mask (void *abstract_surface,
 			     cairo_operator_t op,
 			     cairo_pattern_t *source,
@@ -1387,7 +1387,7 @@ _cairo_quartz_surface_mask (void *abstract_surface,
     return rv;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_quartz_surface_intersect_clip_path (void *abstract_surface,
 					    cairo_path_fixed_t *path,
 					    cairo_fill_rule_t fill_rule,
diff --git a/src/cairo-scaled-font-subsets.c b/src/cairo-scaled-font-subsets.c
index d98cba2..9e4371a 100644
--- a/src/cairo-scaled-font-subsets.c
+++ b/src/cairo-scaled-font-subsets.c
@@ -244,7 +244,7 @@ _cairo_sub_font_pluck (void *entry, void *closure)
     _cairo_sub_font_destroy (sub_font);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_sub_font_lookup_glyph (cairo_sub_font_t	*sub_font,
                               unsigned long	 scaled_font_glyph_index,
                               unsigned int	*subset_id,
@@ -265,7 +265,7 @@ _cairo_sub_font_lookup_glyph (cairo_sub_font_t	*sub_font,
     return CAIRO_STATUS_NULL_POINTER;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_sub_font_map_glyph (cairo_sub_font_t	*sub_font,
 			   unsigned long	 scaled_font_glyph_index,
 			   unsigned int		*subset_id,
@@ -497,7 +497,7 @@ _cairo_scaled_font_subsets_map_glyph (cairo_scaled_font_subsets_t	*subsets,
                                       subset_id, subset_glyph_index);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_scaled_font_subsets_foreach_internal (cairo_scaled_font_subsets_t              *font_subsets,
                                              cairo_scaled_font_subset_callback_func_t  font_subset_callback,
                                              void				      *closure,
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 870ca9c..e760e14 100755
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -1140,7 +1140,7 @@ typedef struct _cairo_scaled_glyph_path_closure {
     cairo_path_fixed_t	    *path;
 } cairo_scaled_glyph_path_closure_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _scaled_glyph_path_move_to (void *abstract_closure, cairo_point_t *point)
 {
     cairo_scaled_glyph_path_closure_t	*closure = abstract_closure;
@@ -1150,7 +1150,7 @@ _scaled_glyph_path_move_to (void *abstract_closure, cairo_point_t *point)
 				      point->y + closure->offset.y);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _scaled_glyph_path_line_to (void *abstract_closure, cairo_point_t *point)
 {
     cairo_scaled_glyph_path_closure_t	*closure = abstract_closure;
@@ -1160,7 +1160,7 @@ _scaled_glyph_path_line_to (void *abstract_closure, cairo_point_t *point)
 				      point->y + closure->offset.y);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _scaled_glyph_path_curve_to (void *abstract_closure,
 			     cairo_point_t *p0,
 			     cairo_point_t *p1,
@@ -1177,7 +1177,7 @@ _scaled_glyph_path_curve_to (void *abstract_closure,
 				       p2->y + closure->offset.y);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _scaled_glyph_path_close_path (void *abstract_closure)
 {
     cairo_scaled_glyph_path_closure_t	*closure = abstract_closure;
@@ -1203,7 +1203,7 @@ _scaled_glyph_path_close_path (void *abstract_closure)
  * who cares enough about getting a better result to implement
  * something more sophisticated.
  **/
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _trace_mask_to_path (cairo_image_surface_t *mask,
 		     cairo_path_fixed_t *path)
 {
diff --git a/src/cairo-spline.c b/src/cairo-spline.c
index 3624bfc..97b4036 100644
--- a/src/cairo-spline.c
+++ b/src/cairo-spline.c
@@ -36,10 +36,10 @@
 
 #include "cairoint.h"
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_spline_grow (cairo_spline_t *spline);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_spline_add_point (cairo_spline_t *spline, cairo_point_t *point);
 
 static void
@@ -51,7 +51,7 @@ _de_casteljau (cairo_spline_t *spline, cairo_spline_t *s1, cairo_spline_t *s2);
 static double
 _cairo_spline_error_squared (cairo_spline_t *spline);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_spline_decompose_into (cairo_spline_t *spline, double tolerance_squared, cairo_spline_t *result);
 
 cairo_int_status_t
@@ -99,7 +99,7 @@ _cairo_spline_fini (cairo_spline_t *spline)
 }
 
 /* make room for at least one more point */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_spline_grow (cairo_spline_t *spline)
 {
     cairo_point_t *new_points;
@@ -135,7 +135,7 @@ _cairo_spline_grow (cairo_spline_t *spline)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_spline_add_point (cairo_spline_t *spline, cairo_point_t *point)
 {
     cairo_status_t status;
@@ -256,7 +256,7 @@ _cairo_spline_error_squared (cairo_spline_t *spline)
 	return cerr;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_spline_decompose_into (cairo_spline_t *spline, double tolerance_squared, cairo_spline_t *result)
 {
     cairo_status_t status;
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 581c3ad..2be3de3 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -56,7 +56,7 @@ typedef struct {
  * visible, CAIRO_STATUS_SUCCESS if some portion is visible and all
  * went well, or some error status otherwise.
  **/
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _fallback_init (fallback_state_t *state,
 		cairo_surface_t  *dst,
 		int               x,
@@ -106,7 +106,7 @@ typedef cairo_status_t (*cairo_draw_func_t) (void                          *clos
 					     int                            dst_y,
 					     const cairo_rectangle_int16_t *extents);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _create_composite_mask_pattern (cairo_surface_pattern_t       *mask_pattern,
 				cairo_clip_t                  *clip,
 				cairo_draw_func_t             draw_func,
@@ -150,7 +150,7 @@ _create_composite_mask_pattern (cairo_surface_pattern_t       *mask_pattern,
 /* Handles compositing with a clip surface when the operator allows
  * us to combine the clip with the mask
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _clip_and_composite_with_mask (cairo_clip_t                  *clip,
 			       cairo_operator_t               op,
 			       cairo_pattern_t               *src,
@@ -184,7 +184,7 @@ _clip_and_composite_with_mask (cairo_clip_t                  *clip,
 /* Handles compositing with a clip surface when we have to do the operation
  * in two pieces and combine them together.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _clip_and_composite_combine (cairo_clip_t                  *clip,
 			     cairo_operator_t               op,
 			     cairo_pattern_t               *src,
@@ -273,7 +273,7 @@ _clip_and_composite_combine (cairo_clip_t                  *clip,
 /* Handles compositing for CAIRO_OPERATOR_SOURCE, which is special; it's
  * defined as (src IN mask IN clip) ADD (dst OUT (mask IN clip))
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _clip_and_composite_source (cairo_clip_t                  *clip,
 			    cairo_pattern_t               *src,
 			    cairo_draw_func_t              draw_func,
@@ -346,7 +346,7 @@ _cairo_rectangle_empty (const cairo_rectangle_int16_t *rect)
  *
  * Return value: %CAIRO_STATUS_SUCCESS if the drawing succeeded.
  **/
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _clip_and_composite (cairo_clip_t                  *clip,
 		     cairo_operator_t               op,
 		     cairo_pattern_t               *src,
@@ -402,7 +402,7 @@ _clip_and_composite (cairo_clip_t                  *clip,
 
 /* Composites a region representing a set of trapezoids.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _composite_trap_region (cairo_clip_t            *clip,
 			cairo_pattern_t         *src,
 			cairo_operator_t         op,
@@ -469,7 +469,7 @@ typedef struct {
     cairo_antialias_t antialias;
 } cairo_composite_traps_info_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _composite_traps_draw_func (void                          *closure,
 			    cairo_operator_t               op,
 			    cairo_pattern_t               *src,
@@ -502,7 +502,7 @@ _composite_traps_draw_func (void                          *closure,
 }
 
 /* Warning: This call modifies the coordinates of traps */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _clip_and_composite_trapezoids (cairo_pattern_t *src,
 				cairo_operator_t op,
 				cairo_surface_t *dst,
@@ -690,7 +690,7 @@ _cairo_surface_fallback_paint (cairo_surface_t	*surface,
     if (status)
 	return status;
 
-    _clip_and_composite_trapezoids (source,
+    status = _clip_and_composite_trapezoids (source,
 				    op,
 				    surface,
 				    &traps,
@@ -699,10 +699,10 @@ _cairo_surface_fallback_paint (cairo_surface_t	*surface,
 
     _cairo_traps_fini (&traps);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_mask_draw_func (void                          *closure,
 			       cairo_operator_t               op,
 			       cairo_pattern_t               *src,
@@ -798,7 +798,7 @@ _cairo_surface_fallback_stroke (cairo_surface_t		*surface,
 	return status;
     }
 
-    _clip_and_composite_trapezoids (source,
+    status = _clip_and_composite_trapezoids (source,
 				    op,
 				    surface,
 				    &traps,
@@ -807,7 +807,7 @@ _cairo_surface_fallback_stroke (cairo_surface_t		*surface,
 
     _cairo_traps_fini (&traps);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
@@ -851,7 +851,7 @@ typedef struct {
     int num_glyphs;
 } cairo_show_glyphs_info_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_old_show_glyphs_draw_func (void                          *closure,
 					  cairo_operator_t               op,
 					  cairo_pattern_t               *src,
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index 9552c20..a7cb14b 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -81,7 +81,7 @@ DEFINE_NIL_SURFACE(CAIRO_STATUS_FILE_NOT_FOUND, _cairo_surface_nil_file_not_foun
 DEFINE_NIL_SURFACE(CAIRO_STATUS_READ_ERROR, _cairo_surface_nil_read_error);
 DEFINE_NIL_SURFACE(CAIRO_STATUS_WRITE_ERROR, _cairo_surface_nil_write_error);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_copy_pattern_for_destination (const cairo_pattern_t *pattern,
 					     cairo_surface_t *destination,
 					     cairo_pattern_t *pattern_out);
@@ -1256,7 +1256,9 @@ _cairo_surface_paint (cairo_surface_t	*surface,
 
     assert (! surface->is_snapshot);
 
-    _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
+    status = _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
+    if (status)
+	return status;
 
     if (surface->backend->paint) {
 	status = surface->backend->paint (surface, op, &dev_source.base);
@@ -1284,8 +1286,12 @@ _cairo_surface_mask (cairo_surface_t	*surface,
 
     assert (! surface->is_snapshot);
 
-    _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
-    _cairo_surface_copy_pattern_for_destination (mask, surface, &dev_mask.base);
+    status = _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
+    if (status)
+	return status;
+    status = _cairo_surface_copy_pattern_for_destination (mask, surface, &dev_mask.base);
+    if (status)
+	goto CLEANUP_SOURCE;
 
     if (surface->backend->mask) {
 	status = surface->backend->mask (surface, op, &dev_source.base, &dev_mask.base);
@@ -1297,6 +1303,7 @@ _cairo_surface_mask (cairo_surface_t	*surface,
 
  FINISH:
     _cairo_pattern_fini (&dev_mask.base);
+CLEANUP_SOURCE:
     _cairo_pattern_fini (&dev_source.base);
 
     return status;
@@ -1322,7 +1329,9 @@ _cairo_surface_stroke (cairo_surface_t		*surface,
 
     assert (! surface->is_snapshot);
 
-    _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
+    status = _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
+    if (status)
+	return status;
 
     if (surface->backend->stroke) {
 	status = surface->backend->stroke (surface, op, &dev_source.base,
@@ -1361,7 +1370,9 @@ _cairo_surface_fill (cairo_surface_t	*surface,
 
     assert (! surface->is_snapshot);
 
-    _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
+    status = _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
+    if (status)
+	return status;
 
     if (surface->backend->fill) {
 	status = surface->backend->fill (surface, op, &dev_source.base,
@@ -1609,7 +1620,7 @@ _cairo_surface_intersect_clip_path (cairo_surface_t    *surface,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_set_clip_path_recursive (cairo_surface_t *surface,
 					cairo_clip_path_t *clip_path)
 {
@@ -1638,7 +1649,7 @@ _cairo_surface_set_clip_path_recursive (cairo_surface_t *surface,
  * Sets the given clipping path for the surface and assigns the
  * clipping serial to the surface.
  **/
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_set_clip_path (cairo_surface_t	*surface,
 			      cairo_clip_path_t	*clip_path,
 			      unsigned int	serial)
@@ -1765,9 +1776,11 @@ _cairo_surface_show_glyphs (cairo_surface_t	*surface,
     if (!num_glyphs)
 	return CAIRO_STATUS_SUCCESS;
 
-    _cairo_surface_copy_pattern_for_destination (source,
+    status = _cairo_surface_copy_pattern_for_destination (source,
 						 surface,
 						 &dev_source.base);
+    if (status)
+	return status;
 
     cairo_scaled_font_get_font_matrix (scaled_font, &font_matrix);
 
@@ -1855,7 +1868,7 @@ _cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
 						   cairo_rectangle_int16_t *src_rectangle,
 						   cairo_rectangle_int16_t *mask_rectangle,
@@ -2069,7 +2082,7 @@ _cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
  * Copies the given pattern, taking into account device scale and offsets
  * of the destination surface.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_surface_copy_pattern_for_destination (const cairo_pattern_t *pattern,
                                              cairo_surface_t *destination,
                                              cairo_pattern_t *pattern_out)
diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index a58c8cb..315d7c5 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -150,7 +150,7 @@ _cairo_svg_document_create (cairo_output_stream_t   *stream,
 static void
 _cairo_svg_document_destroy (cairo_svg_document_t *document);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_document_finish (cairo_svg_document_t *document);
 
 static cairo_svg_document_t *
@@ -258,7 +258,7 @@ _cairo_surface_is_svg (cairo_surface_t *surface)
  * surface's target is a svg_surface, then set svg_surface to that
  * target. Otherwise return CAIRO_STATUS_SURFACE_TYPE_MISMATCH.
  */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _extract_svg_surface (cairo_surface_t		 *surface,
 		      cairo_svg_surface_t	**svg_surface)
 {
@@ -455,7 +455,7 @@ _cairo_svg_surface_store_page (cairo_svg_surface_t *surface)
     return _cairo_array_index (&surface->page_set, surface->page_set.num_elements - 1);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_copy_page (void *abstract_surface)
 {
     cairo_svg_surface_t *surface = abstract_surface;
@@ -471,7 +471,7 @@ _cairo_svg_surface_copy_page (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_show_page (void *abstract_surface)
 {
     cairo_svg_surface_t *surface = abstract_surface;
@@ -503,7 +503,7 @@ typedef struct
     cairo_matrix_t *ctm_inverse;
 } svg_path_info_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_path_move_to (void *closure, cairo_point_t *point)
 {
     svg_path_info_t *info = closure;
@@ -518,7 +518,7 @@ _cairo_svg_path_move_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_path_line_to (void *closure, cairo_point_t *point)
 {
     svg_path_info_t *info = closure;
@@ -533,7 +533,7 @@ _cairo_svg_path_line_to (void *closure, cairo_point_t *point)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_path_curve_to (void          *closure,
 			  cairo_point_t *b,
 			  cairo_point_t *c,
@@ -560,7 +560,7 @@ _cairo_svg_path_curve_to (void          *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_path_close_path (void *closure)
 {
     svg_path_info_t *info = closure;
@@ -570,7 +570,7 @@ _cairo_svg_path_close_path (void *closure)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_surface_emit_path (cairo_output_stream_t *output,
 	   cairo_path_fixed_t    *path,
 	   cairo_matrix_t	 *ctm_inverse)
@@ -595,7 +595,7 @@ _cairo_svg_surface_emit_path (cairo_output_stream_t *output,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_document_emit_outline_glyph_data (cairo_svg_document_t	*document,
 					     cairo_scaled_font_t	*scaled_font,
 					     unsigned long		 glyph_index)
@@ -622,7 +622,7 @@ _cairo_svg_document_emit_outline_glyph_data (cairo_svg_document_t	*document,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_document_emit_bitmap_glyph_data (cairo_svg_document_t	*document,
 					    cairo_scaled_font_t		*scaled_font,
 					    unsigned long		 glyph_index)
@@ -742,7 +742,7 @@ _cairo_svg_test_force_fallbacks (void)
     cairo_svg_force_fallbacks = TRUE;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 __cairo_svg_surface_operation_supported (cairo_svg_surface_t *surface,
 		      cairo_operator_t op,
 		      const cairo_pattern_t *pattern)
@@ -759,7 +759,7 @@ __cairo_svg_surface_operation_supported (cairo_svg_surface_t *surface,
     return TRUE;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_analyze_operation (cairo_svg_surface_t *surface,
 		    cairo_operator_t op,
 		    const cairo_pattern_t *pattern)
@@ -779,7 +779,7 @@ _cairo_svg_surface_create_similar (void			*abstract_src,
     return _cairo_meta_surface_create (content, width, height);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_surface_finish (void *abstract_surface)
 {
     cairo_status_t status;
@@ -836,7 +836,7 @@ typedef struct {
 static char const *base64_table =
 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 base64_write_func (void *closure,
 		   const unsigned char *data,
 		   unsigned int length)
@@ -889,7 +889,7 @@ base64_write_func (void *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_surface_base64_encode (cairo_surface_t       *surface,
 			      cairo_output_stream_t *output)
 {
@@ -921,7 +921,7 @@ _cairo_surface_base64_encode (cairo_surface_t       *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_surface_emit_composite_image_pattern (cairo_output_stream_t     *output,
 			      cairo_svg_surface_t	*svg_surface,
 			      cairo_surface_pattern_t 	*pattern,
@@ -1071,7 +1071,7 @@ _cairo_svg_surface_emit_meta_surface (cairo_svg_document_t *document,
     return id;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_surface_emit_composite_meta_pattern (cairo_output_stream_t	*output,
 			     cairo_svg_surface_t	*surface,
 			     cairo_surface_pattern_t	*pattern,
@@ -1119,7 +1119,7 @@ _cairo_svg_surface_emit_composite_meta_pattern (cairo_output_stream_t	*output,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_surface_emit_composite_pattern (cairo_output_stream_t   *output,
 			cairo_svg_surface_t	*surface,
 			cairo_surface_pattern_t *pattern,
@@ -1602,7 +1602,7 @@ _cairo_svg_surface_emit_pattern (cairo_svg_surface_t *surface, cairo_pattern_t *
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_fill (void			*abstract_surface,
 			 cairo_operator_t	 op,
 			 cairo_pattern_t	*source,
@@ -1635,7 +1635,7 @@ _cairo_svg_surface_fill (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_get_extents (void		        *abstract_surface,
 				cairo_rectangle_int16_t *rectangle)
 {
@@ -1654,7 +1654,7 @@ _cairo_svg_surface_get_extents (void		        *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_surface_emit_paint (cairo_output_stream_t *output,
 	    cairo_svg_surface_t   *surface,
 	    cairo_operator_t	   op,
@@ -1687,7 +1687,7 @@ _cairo_svg_surface_emit_paint (cairo_output_stream_t *output,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_paint (void		    *abstract_surface,
 			  cairo_operator_t   op,
 			  cairo_pattern_t   *source)
@@ -1740,7 +1740,7 @@ _cairo_svg_surface_paint (void		    *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_mask (void		    *abstract_surface,
 			cairo_operator_t     op,
 			cairo_pattern_t	    *source,
@@ -1782,7 +1782,7 @@ _cairo_svg_surface_mask (void		    *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_stroke (void			*abstract_dst,
 			   cairo_operator_t      op,
 			   cairo_pattern_t	*source,
@@ -1871,7 +1871,7 @@ _cairo_svg_surface_stroke (void			*abstract_dst,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_show_glyphs (void			*abstract_surface,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*pattern,
@@ -1942,7 +1942,7 @@ FALLBACK:
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_svg_surface_intersect_clip_path (void			*dst,
 					cairo_path_fixed_t	*path,
 					cairo_fill_rule_t	 fill_rule,
@@ -2095,7 +2095,7 @@ _cairo_svg_document_destroy (cairo_svg_document_t *document)
     free (document);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_svg_document_finish (cairo_svg_document_t *document)
 {
     cairo_status_t status;
diff --git a/src/cairo-traps.c b/src/cairo-traps.c
index dd5837b..7b8bcd3 100644
--- a/src/cairo-traps.c
+++ b/src/cairo-traps.c
@@ -40,10 +40,10 @@
 
 /* private functions */
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_grow (cairo_traps_t *traps);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_add_trap (cairo_traps_t *traps, cairo_fixed_t top, cairo_fixed_t bottom,
 		       cairo_line_t *left, cairo_line_t *right);
 
@@ -109,7 +109,7 @@ _cairo_traps_init_box (cairo_traps_t *traps,
   return traps->status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_add_trap (cairo_traps_t *traps, cairo_fixed_t top, cairo_fixed_t bottom,
 		       cairo_line_t *left, cairo_line_t *right)
 {
@@ -182,7 +182,7 @@ _cairo_traps_add_trap_from_points (cairo_traps_t *traps, cairo_fixed_t top, cair
 }
 
 /* make room for at least one more trap */
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_traps_grow (cairo_traps_t *traps)
 {
     cairo_trapezoid_t *new_traps;
diff --git a/src/cairo-truetype-subset.c b/src/cairo-truetype-subset.c
index 7e77bb8..5b60fed 100644
--- a/src/cairo-truetype-subset.c
+++ b/src/cairo-truetype-subset.c
@@ -80,7 +80,7 @@ cairo_truetype_font_use_glyph (cairo_truetype_font_t *font, int glyph);
 #define SFNT_VERSION			0x00010000
 #define SFNT_STRING_MAX_LENGTH  65535
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_truetype_font_create (cairo_scaled_font_subset_t  *scaled_font_subset,
 			     cairo_truetype_font_t      **font_return)
 {
@@ -256,7 +256,7 @@ cairo_truetype_font_destroy (cairo_truetype_font_t *font)
     free (font);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_truetype_font_allocate_write_buffer (cairo_truetype_font_t  *font,
 					   size_t		   length,
 					   unsigned char	 **buffer)
@@ -270,7 +270,7 @@ cairo_truetype_font_allocate_write_buffer (cairo_truetype_font_t  *font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_truetype_font_write (cairo_truetype_font_t *font,
 			   const void            *data,
 			   size_t                 length)
@@ -696,7 +696,7 @@ static const table_t truetype_tables[] = {
     { TT_TAG_prep, cairo_truetype_font_write_generic_table, 11 },
 };
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_truetype_font_write_offset_table (cairo_truetype_font_t *font)
 {
     cairo_status_t status;
@@ -769,7 +769,7 @@ cairo_truetype_font_update_entry (cairo_truetype_font_t *font,
     entry[3] = cpu_to_be32 ((uint32_t)(end - start));
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_truetype_font_generate (cairo_truetype_font_t  *font,
 			      const char            **data,
 			      unsigned long          *length,
@@ -921,7 +921,7 @@ _cairo_truetype_subset_fini (cairo_truetype_subset_t *subset)
     free (subset->string_offsets);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_truetype_map_glyphs_to_unicode (cairo_scaled_font_subset_t *font_subset,
                                        unsigned long               table_offset)
 {
diff --git a/src/cairo-type1-fallback.c b/src/cairo-type1-fallback.c
index a183b28..26dee6b 100644
--- a/src/cairo-type1-fallback.c
+++ b/src/cairo-type1-fallback.c
@@ -63,7 +63,7 @@ typedef struct _cairo_type1_font {
     int hex_column;
 } cairo_type1_font_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_create (cairo_scaled_font_subset_t  *scaled_font_subset,
                          cairo_type1_font_t         **subset_return,
                          cairo_bool_t                 hex_encode)
@@ -195,7 +195,7 @@ typedef struct _ps_path_info {
     int current_x, current_y;
 } t1_path_info_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _charstring_move_to (void          *closure,
                      cairo_point_t *point)
 {
@@ -219,7 +219,7 @@ _charstring_move_to (void          *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _charstring_line_to (void          *closure,
                      cairo_point_t *point)
 {
@@ -243,7 +243,7 @@ _charstring_line_to (void          *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _charstring_curve_to (void	    *closure,
                       cairo_point_t *point1,
                       cairo_point_t *point2,
@@ -276,7 +276,7 @@ _charstring_curve_to (void	    *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _charstring_close_path (void *closure)
 {
     cairo_status_t status;
@@ -308,7 +308,7 @@ charstring_encrypt (cairo_array_t *data)
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 create_notdef_charstring (cairo_array_t *data)
 {
     cairo_status_t status;
@@ -333,7 +333,7 @@ create_notdef_charstring (cairo_array_t *data)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_type1_font_create_charstring (cairo_type1_font_t *font,
                                     int                 subset_index,
                                     int                 glyph_index,
@@ -402,7 +402,7 @@ cairo_type1_font_create_charstring (cairo_type1_font_t *font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_type1_font_write_charstrings (cairo_type1_font_t    *font,
                                     cairo_output_stream_t *encrypted_output)
 {
@@ -514,7 +514,7 @@ cairo_type1_font_write_header (cairo_type1_font_t *font,
                                  "currentfile eexec\n");
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_write_stream_encrypted (void                *closure,
                                     const unsigned char *data,
                                     unsigned int         length)
@@ -553,7 +553,7 @@ cairo_type1_write_stream_encrypted (void                *closure,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_type1_font_write_private_dict (cairo_type1_font_t *font,
                                      const char         *name)
 {
@@ -618,7 +618,7 @@ cairo_type1_font_write_trailer(cairo_type1_font_t *font)
     _cairo_output_stream_printf (font->output, "cleartomark\n");
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_write_stream (void *closure,
                          const unsigned char *data,
                          unsigned int length)
@@ -628,7 +628,7 @@ cairo_type1_write_stream (void *closure,
     return _cairo_array_append_multiple (&font->contents, data, length);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_type1_font_write (cairo_type1_font_t *font,
                         const char *name)
 {
@@ -652,7 +652,7 @@ cairo_type1_font_write (cairo_type1_font_t *font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 cairo_type1_font_generate (cairo_type1_font_t *font, const char *name)
 {
     cairo_int_status_t status;
@@ -682,7 +682,7 @@ cairo_type1_font_destroy (cairo_type1_font_t *font)
     free (font);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_type1_fallback_init_internal (cairo_type1_subset_t	*type1_subset,
                                      const char			*name,
                                      cairo_scaled_font_subset_t	*scaled_font_subset,
diff --git a/src/cairo-type1-subset.c b/src/cairo-type1-subset.c
index e4f5015..b929395 100644
--- a/src/cairo-type1-subset.c
+++ b/src/cairo-type1-subset.c
@@ -102,7 +102,7 @@ typedef struct _cairo_type1_font_subset {
 } cairo_type1_font_subset_t;
 
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_type1_font_subset_create (cairo_unscaled_font_t      *unscaled_font,
 				 cairo_type1_font_subset_t **subset_return,
                                  cairo_bool_t                hex_encode)
@@ -216,7 +216,7 @@ find_token (const char *buffer, const char *end, const char *token)
     return NULL;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_subset_find_segments (cairo_type1_font_subset_t *font)
 {
     unsigned char *p;
@@ -257,7 +257,7 @@ cairo_type1_font_subset_find_segments (cairo_type1_font_subset_t *font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_subset_write_header (cairo_type1_font_subset_t *font,
 					 const char *name)
 {
@@ -354,7 +354,7 @@ cairo_type1_font_subset_write_encrypted (cairo_type1_font_subset_t *font,
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_subset_decrypt_eexec_segment (cairo_type1_font_subset_t *font)
 {
     unsigned short r = CAIRO_TYPE1_PRIVATE_DICT_KEY;
@@ -421,7 +421,7 @@ cairo_type1_font_subset_lookup_glyph (cairo_type1_font_subset_t *font,
     return -1;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_subset_get_glyph_names_and_widths (cairo_type1_font_subset_t *font)
 {
     unsigned int i;
@@ -954,7 +954,7 @@ cairo_type1_font_subset_write_private_dict (cairo_type1_font_subset_t *font,
     return p;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_subset_write_trailer(cairo_type1_font_subset_t *font)
 {
     const char *cleartomark_token;
@@ -979,7 +979,7 @@ cairo_type1_font_subset_write_trailer(cairo_type1_font_subset_t *font)
     return font->status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 type1_font_write (void *closure, const unsigned char *data, unsigned int length)
 {
     cairo_type1_font_subset_t *font = closure;
@@ -990,7 +990,7 @@ type1_font_write (void *closure, const unsigned char *data, unsigned int length)
     return font->status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_subset_write (cairo_type1_font_subset_t *font,
 			       const char *name)
 {
@@ -1029,7 +1029,7 @@ cairo_type1_font_subset_write (cairo_type1_font_subset_t *font,
     return font->status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 cairo_type1_font_subset_generate (void       *abstract_font,
 				  const char *name)
 
diff --git a/src/cairo-win32-font.c b/src/cairo-win32-font.c
index de81c0a..dbace95 100644
--- a/src/cairo-win32-font.c
+++ b/src/cairo-win32-font.c
@@ -104,14 +104,14 @@ typedef struct {
     cairo_bool_t delete_scaled_hfont;
 } cairo_win32_scaled_font_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_set_metrics (cairo_win32_scaled_font_t *scaled_font);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_init_glyph_metrics (cairo_win32_scaled_font_t *scaled_font,
 					     cairo_scaled_glyph_t      *scaled_glyph);
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_init_glyph_path (cairo_win32_scaled_font_t *scaled_font,
 					  cairo_scaled_glyph_t      *scaled_glyph);
 
@@ -299,7 +299,7 @@ _win32_scaled_font_create (LOGFONTW                   *logfont,
     return &f->base;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _win32_scaled_font_set_world_transform (cairo_win32_scaled_font_t *scaled_font,
 					HDC                        hdc)
 {
@@ -318,7 +318,7 @@ _win32_scaled_font_set_world_transform (cairo_win32_scaled_font_t *scaled_font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _win32_scaled_font_set_identity_transform (HDC hdc)
 {
     if (!ModifyWorldTransform (hdc, NULL, MWT_IDENTITY))
@@ -425,7 +425,7 @@ _win32_scaled_font_get_unscaled_hfont (cairo_win32_scaled_font_t *scaled_font,
     return scaled_font->unscaled_hfont;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_select_unscaled_font (cairo_scaled_font_t *scaled_font,
 					       HDC                  hdc)
 {
@@ -459,7 +459,7 @@ _cairo_win32_scaled_font_done_unscaled_font (cairo_scaled_font_t *scaled_font)
 
 /* implement the font backend interface */
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_create_toy (cairo_toy_font_face_t *toy_face,
 				     const cairo_matrix_t        *font_matrix,
 				     const cairo_matrix_t        *ctm,
@@ -553,7 +553,7 @@ _cairo_win32_scaled_font_fini (void *abstract_font)
 	DeleteObject (scaled_font->unscaled_hfont);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_scaled_font_text_to_glyphs (void		*abstract_font,
 					 double		x,
 					 double		y,
@@ -680,7 +680,7 @@ _cairo_win32_scaled_font_text_to_glyphs (void		*abstract_font,
     return status;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_set_metrics (cairo_win32_scaled_font_t *scaled_font)
 {
     cairo_status_t status;
@@ -741,7 +741,7 @@ _cairo_win32_scaled_font_set_metrics (cairo_win32_scaled_font_t *scaled_font)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_init_glyph_metrics (cairo_win32_scaled_font_t *scaled_font,
 					     cairo_scaled_glyph_t      *scaled_glyph)
 {
@@ -836,7 +836,7 @@ _cairo_win32_scaled_font_init_glyph_metrics (cairo_win32_scaled_font_t *scaled_f
  * font-space metrics.
  */
 #if 0
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_glyph_bbox (void		 *abstract_font,
 				     const cairo_glyph_t *glyphs,
 				     int                  num_glyphs,
@@ -918,7 +918,7 @@ _start_glyphs (cairo_glyph_state_t        *state,
     _cairo_array_init (&state->dx, sizeof (int));
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _flush_glyphs (cairo_glyph_state_t *state)
 {
     cairo_status_t status;
@@ -954,7 +954,7 @@ _flush_glyphs (cairo_glyph_state_t *state)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _add_glyph (cairo_glyph_state_t *state,
 	    unsigned long        index,
 	    double               device_x,
@@ -1008,7 +1008,7 @@ _finish_glyphs (cairo_glyph_state_t *state)
     _cairo_array_fini (&state->dx);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _draw_glyphs_on_surface (cairo_win32_surface_t     *surface,
 			 cairo_win32_scaled_font_t *scaled_font,
 			 COLORREF                   color,
@@ -1113,7 +1113,7 @@ _compute_a8_mask (cairo_win32_surface_t *mask_surface)
     return &image8->base;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_scaled_font_glyph_init (void		       *abstract_font,
 				     cairo_scaled_glyph_t      *scaled_glyph,
 				     cairo_scaled_glyph_info_t  info)
@@ -1140,7 +1140,7 @@ _cairo_win32_scaled_font_glyph_init (void		       *abstract_font,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_scaled_font_show_glyphs (void		       *abstract_font,
 				      cairo_operator_t    	op,
 				      cairo_pattern_t          *pattern,
@@ -1254,7 +1254,7 @@ _cairo_win32_scaled_font_show_glyphs (void		       *abstract_font,
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_scaled_font_load_truetype_table (void	       *abstract_font,
                                              unsigned long      tag,
                                              long               offset,
@@ -1309,7 +1309,7 @@ _cairo_win32_transform_FIXED_to_fixed (cairo_matrix_t *matrix,
     *fy =  _cairo_fixed_from_double (y);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_scaled_font_init_glyph_path (cairo_win32_scaled_font_t *scaled_font,
 					  cairo_scaled_glyph_t      *scaled_glyph)
 {
@@ -1501,7 +1501,7 @@ _cairo_win32_font_face_destroy (void *abstract_face)
 {
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_font_face_scaled_font_create (void			*abstract_face,
 					   const cairo_matrix_t	*font_matrix,
 					   const cairo_matrix_t	*ctm,
diff --git a/src/cairo-win32-surface.c b/src/cairo-win32-surface.c
index 9123b82..5b3d5c1 100644
--- a/src/cairo-win32-surface.c
+++ b/src/cairo-win32-surface.c
@@ -140,7 +140,7 @@ _cairo_win32_flags_for_dc (HDC dc)
     return flags;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _create_dc_and_bitmap (cairo_win32_surface_t *surface,
 		       HDC                    original_dc,
 		       cairo_format_t         format,
@@ -432,7 +432,7 @@ _cairo_win32_surface_create_similar (void	    *abstract_src,
     return _cairo_win32_surface_create_similar_internal (abstract_src, content, width, height, FALSE);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_surface_finish (void *abstract_surface)
 {
     cairo_win32_surface_t *surface = abstract_surface;
@@ -453,7 +453,7 @@ _cairo_win32_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_surface_get_subimage (cairo_win32_surface_t  *surface,
 				   int                     x,
 				   int                     y,
@@ -503,7 +503,7 @@ _cairo_win32_surface_get_subimage (cairo_win32_surface_t  *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_surface_acquire_source_image (void                    *abstract_surface,
 					   cairo_image_surface_t  **image_out,
 					   void                   **image_extra)
@@ -542,7 +542,7 @@ _cairo_win32_surface_release_source_image (void                   *abstract_surf
 	cairo_surface_destroy ((cairo_surface_t *)local);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_surface_acquire_dest_image (void                    *abstract_surface,
 					 cairo_rectangle_int16_t *interest_rect,
 					 cairo_image_surface_t  **image_out,
@@ -663,7 +663,7 @@ typedef BOOL (WINAPI *cairo_alpha_blend_func_t) (HDC hdcDest,
 						 int nHeightSrc,
 						 BLENDFUNCTION blendFunction);
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _composite_alpha_blend (cairo_win32_surface_t *dst,
 			cairo_win32_surface_t *src,
 			int                    alpha,
@@ -729,7 +729,7 @@ _composite_alpha_blend (cairo_win32_surface_t *dst,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_surface_composite_inner (cairo_win32_surface_t *src,
 				      cairo_image_surface_t *src_image,
 				      cairo_win32_surface_t *dst,
@@ -815,7 +815,7 @@ _cairo_win32_surface_composite_inner (cairo_win32_surface_t *src,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_surface_composite (cairo_operator_t	op,
 				cairo_pattern_t       	*pattern,
 				cairo_pattern_t		*mask_pattern,
@@ -1305,7 +1305,7 @@ categorize_solid_dest_operator (cairo_operator_t op,
     return DO_UNSUPPORTED;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_surface_fill_rectangles (void			*abstract_surface,
 				      cairo_operator_t		op,
 				      const cairo_color_t	*color,
@@ -1370,7 +1370,7 @@ _cairo_win32_surface_fill_rectangles (void			*abstract_surface,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_surface_set_clip_region (void              *abstract_surface,
 				      pixman_region16_t *region)
 {
@@ -1460,7 +1460,7 @@ _cairo_win32_surface_set_clip_region (void              *abstract_surface,
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_surface_get_extents (void		          *abstract_surface,
 				  cairo_rectangle_int16_t *rectangle)
 {
@@ -1471,7 +1471,7 @@ _cairo_win32_surface_get_extents (void		          *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_win32_surface_flush (void *abstract_surface)
 {
     return _cairo_surface_reset_clip (abstract_surface);
@@ -1479,7 +1479,7 @@ _cairo_win32_surface_flush (void *abstract_surface)
 
 #define STACK_GLYPH_SIZE 256
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_win32_surface_show_glyphs (void			*surface,
 				  cairo_operator_t	 op,
 				  cairo_pattern_t	*source,
diff --git a/src/cairo-xcb-surface.c b/src/cairo-xcb-surface.c
index 0897961..b688caf 100644
--- a/src/cairo-xcb-surface.c
+++ b/src/cairo-xcb-surface.c
@@ -206,7 +206,7 @@ _cairo_xcb_surface_create_similar (void		       *abstract_src,
     return &surface->base;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_finish (void *abstract_surface)
 {
     cairo_xcb_surface_t *surface = abstract_surface;
@@ -295,7 +295,7 @@ _CAIRO_MASK_FORMAT (cairo_format_masks_t *masks, cairo_format_t *format)
     return FALSE;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _get_image_surface (cairo_xcb_surface_t     *surface,
 		    cairo_rectangle_int16_t *interest_rect,
 		    cairo_image_surface_t  **image_out,
@@ -541,7 +541,7 @@ _cairo_xcb_surface_ensure_gc (cairo_xcb_surface_t *surface)
     _cairo_xcb_surface_set_gc_clip_rects(surface);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _draw_image_surface (cairo_xcb_surface_t    *surface,
 		     cairo_image_surface_t  *image,
 		     int                    src_x,
@@ -613,7 +613,7 @@ _draw_image_surface (cairo_xcb_surface_t    *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_acquire_source_image (void                    *abstract_surface,
 					 cairo_image_surface_t  **image_out,
 					 void                   **image_extra)
@@ -640,7 +640,7 @@ _cairo_xcb_surface_release_source_image (void                   *abstract_surfac
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_acquire_dest_image (void                    *abstract_surface,
 				       cairo_rectangle_int16_t *interest_rect,
 				       cairo_image_surface_t  **image_out,
@@ -689,7 +689,7 @@ _cairo_xcb_surface_same_screen (cairo_xcb_surface_t *dst,
     return dst->dpy == src->dpy && dst->screen == src->screen;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_clone_similar (void			*abstract_surface,
 				  cairo_surface_t	*src,
 				  int                    src_x,
@@ -733,7 +733,7 @@ _cairo_xcb_surface_clone_similar (void			*abstract_surface,
     return CAIRO_INT_STATUS_UNSUPPORTED;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_set_matrix (cairo_xcb_surface_t *surface,
 			       cairo_matrix_t	   *matrix)
 {
@@ -773,7 +773,7 @@ _cairo_xcb_surface_set_matrix (cairo_xcb_surface_t *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_set_filter (cairo_xcb_surface_t *surface,
 			       cairo_filter_t	   filter)
 {
@@ -818,7 +818,7 @@ _cairo_xcb_surface_set_filter (cairo_xcb_surface_t *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_set_repeat (cairo_xcb_surface_t *surface, int repeat)
 {
     uint32_t mask = XCB_RENDER_CP_REPEAT;
@@ -832,7 +832,7 @@ _cairo_xcb_surface_set_repeat (cairo_xcb_surface_t *surface, int repeat)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_set_attributes (cairo_xcb_surface_t	      *surface,
 				   cairo_surface_attributes_t *attributes)
 {
@@ -1091,7 +1091,7 @@ _render_operator (cairo_operator_t op)
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_composite (cairo_operator_t		op,
 			      cairo_pattern_t		*src_pattern,
 			      cairo_pattern_t		*mask_pattern,
@@ -1242,7 +1242,7 @@ _cairo_xcb_surface_composite (cairo_operator_t		op,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_fill_rectangles (void			     *abstract_surface,
 				     cairo_operator_t	      op,
 				     const cairo_color_t	*     color,
@@ -1357,7 +1357,7 @@ _create_trapezoid_mask (cairo_xcb_surface_t *dst,
     return mask_picture;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_composite_trapezoids (cairo_operator_t	op,
 					 cairo_pattern_t	*pattern,
 					 void			*abstract_dst,
@@ -1486,7 +1486,7 @@ _cairo_xcb_surface_composite_trapezoids (cairo_operator_t	op,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_set_clip_region (void              *abstract_surface,
 				    pixman_region16_t *region)
 {
@@ -1545,7 +1545,7 @@ _cairo_xcb_surface_set_clip_region (void              *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_get_extents (void		        *abstract_surface,
 				cairo_rectangle_int16_t *rectangle)
 {
@@ -1569,7 +1569,7 @@ static void
 _cairo_xcb_surface_scaled_glyph_fini (cairo_scaled_glyph_t *scaled_glyph,
 				       cairo_scaled_font_t  *scaled_font);
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_show_glyphs (void                *abstract_dst,
 				 cairo_operator_t     op,
 				 cairo_pattern_t     *src_pattern,
@@ -1895,7 +1895,7 @@ typedef struct _cairo_xcb_surface_font_private {
     xcb_render_pictforminfo_t	*xrender_format;
 } cairo_xcb_surface_font_private_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_font_init (xcb_connection_t		    *dpy,
 			       cairo_scaled_font_t  *scaled_font,
 			       cairo_format_t	     format)
@@ -1950,7 +1950,7 @@ _native_byte_order_lsb (void)
     return *((char *) &x) == 1;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_add_glyph (xcb_connection_t *dpy,
 			       cairo_scaled_font_t  *scaled_font,
 			       cairo_scaled_glyph_t *scaled_glyph)
@@ -2128,7 +2128,7 @@ _cairo_xcb_surface_add_glyph (xcb_connection_t *dpy,
 
 #define N_STACK_BUF 1024
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_show_glyphs_8  (cairo_xcb_surface_t *dst,
                                    cairo_operator_t op,
                                    cairo_xcb_surface_t *src,
@@ -2169,7 +2169,7 @@ _cairo_xcb_surface_show_glyphs_8  (cairo_xcb_surface_t *dst,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_show_glyphs_16 (cairo_xcb_surface_t *dst,
                                    cairo_operator_t op,
                                    cairo_xcb_surface_t *src,
@@ -2210,7 +2210,7 @@ _cairo_xcb_surface_show_glyphs_16 (cairo_xcb_surface_t *dst,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xcb_surface_show_glyphs_32 (cairo_xcb_surface_t *dst,
                                    cairo_operator_t op,
                                    cairo_xcb_surface_t *src,
@@ -2255,7 +2255,7 @@ typedef cairo_status_t (*cairo_xcb_surface_show_glyphs_func_t)
     (cairo_xcb_surface_t *, cairo_operator_t, cairo_xcb_surface_t *, int, int,
      const cairo_glyph_t *, int, cairo_scaled_font_t *);
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xcb_surface_show_glyphs (void                *abstract_dst,
 				 cairo_operator_t     op,
 				 cairo_pattern_t     *src_pattern,
diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 160cb08..dfd0256 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -51,7 +51,7 @@ typedef int (*cairo_xlib_error_func_t) (Display     *display,
 
 typedef struct _cairo_xlib_surface cairo_xlib_surface_t;
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface);
 
 static void
@@ -66,7 +66,7 @@ _cairo_surface_is_xlib (cairo_surface_t *surface);
 static cairo_bool_t
 _native_byte_order_lsb (void);
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
 				 cairo_operator_t     op,
 				 cairo_pattern_t     *src_pattern,
@@ -322,7 +322,7 @@ _cairo_xlib_surface_create_similar (void	       *abstract_src,
     return &surface->base;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_finish (void *abstract_surface)
 {
     cairo_xlib_surface_t *surface = abstract_surface;
@@ -503,7 +503,7 @@ _swap_ximage_to_native (XImage *ximage)
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _get_image_surface (cairo_xlib_surface_t    *surface,
 		    cairo_rectangle_int16_t *interest_rect,
 		    cairo_image_surface_t  **image_out,
@@ -733,7 +733,7 @@ _cairo_xlib_surface_ensure_dst_picture (cairo_xlib_surface_t    *surface)
 
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface)
 {
     XGCValues gcv;
@@ -752,7 +752,7 @@ _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _draw_image_surface (cairo_xlib_surface_t   *surface,
 		     cairo_image_surface_t  *image,
 		     int                    src_x,
@@ -799,7 +799,7 @@ _draw_image_surface (cairo_xlib_surface_t   *surface,
 
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_acquire_source_image (void                    *abstract_surface,
 					  cairo_image_surface_t  **image_out,
 					  void                   **image_extra)
@@ -826,7 +826,7 @@ _cairo_xlib_surface_release_source_image (void                   *abstract_surfa
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_acquire_dest_image (void                    *abstract_surface,
 					cairo_rectangle_int16_t *interest_rect,
 					cairo_image_surface_t  **image_out,
@@ -875,7 +875,7 @@ _cairo_xlib_surface_same_screen (cairo_xlib_surface_t *dst,
     return dst->dpy == src->dpy && dst->screen == src->screen;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_clone_similar (void			*abstract_surface,
 				   cairo_surface_t	*src,
 				   int                   src_x,
@@ -886,6 +886,7 @@ _cairo_xlib_surface_clone_similar (void			*abstract_surface,
 {
     cairo_xlib_surface_t *surface = abstract_surface;
     cairo_xlib_surface_t *clone;
+    cairo_status_t status;
 
     if (src->backend == surface->base.backend ) {
 	cairo_xlib_surface_t *xlib_src = (cairo_xlib_surface_t *)src;
@@ -907,8 +908,12 @@ _cairo_xlib_surface_clone_similar (void			*abstract_surface,
 	if (clone->base.status)
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	_draw_image_surface (clone, image_src, src_x, src_y,
+	status = _draw_image_surface (clone, image_src, src_x, src_y,
 			     width, height, src_x, src_y);
+	if (status) {
+	    cairo_surface_destroy (&clone->base);
+	    return status;
+	}
 
 	*clone_out = &clone->base;
 
@@ -918,7 +923,7 @@ _cairo_xlib_surface_clone_similar (void			*abstract_surface,
     return CAIRO_INT_STATUS_UNSUPPORTED;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_set_matrix (cairo_xlib_surface_t *surface,
 				cairo_matrix_t	     *matrix)
 {
@@ -958,7 +963,7 @@ _cairo_xlib_surface_set_matrix (cairo_xlib_surface_t *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_set_filter (cairo_xlib_surface_t *surface,
 				cairo_filter_t	     filter)
 {
@@ -1008,7 +1013,7 @@ _cairo_xlib_surface_set_filter (cairo_xlib_surface_t *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_set_repeat (cairo_xlib_surface_t *surface, int repeat)
 {
     XRenderPictureAttributes pa;
@@ -1025,7 +1030,7 @@ _cairo_xlib_surface_set_repeat (cairo_xlib_surface_t *surface, int repeat)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_set_attributes (cairo_xlib_surface_t	  *surface,
 				       cairo_surface_attributes_t *attributes)
 {
@@ -1039,10 +1044,14 @@ _cairo_xlib_surface_set_attributes (cairo_xlib_surface_t	  *surface,
 
     switch (attributes->extend) {
     case CAIRO_EXTEND_NONE:
-	_cairo_xlib_surface_set_repeat (surface, 0);
+	status = _cairo_xlib_surface_set_repeat (surface, 0);
+	if (status)
+	    return status;
 	break;
     case CAIRO_EXTEND_REPEAT:
-	_cairo_xlib_surface_set_repeat (surface, 1);
+	status = _cairo_xlib_surface_set_repeat (surface, 1);
+	if (status)
+	    return status;
 	break;
     case CAIRO_EXTEND_REFLECT:
     case CAIRO_EXTEND_PAD:
@@ -1291,7 +1300,7 @@ _render_operator (cairo_operator_t op)
     }
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_composite (cairo_operator_t		op,
 			       cairo_pattern_t		*src_pattern,
 			       cairo_pattern_t		*mask_pattern,
@@ -1439,7 +1448,7 @@ _cairo_xlib_surface_composite (cairo_operator_t		op,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_fill_rectangles (void		     *abstract_surface,
 				     cairo_operator_t	      op,
 				     const cairo_color_t     *color,
@@ -1558,7 +1567,7 @@ _create_trapezoid_mask (cairo_xlib_surface_t *dst,
     return mask_picture;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_composite_trapezoids (cairo_operator_t	op,
 					  cairo_pattern_t	*pattern,
 					  void			*abstract_dst,
@@ -1684,7 +1693,7 @@ _cairo_xlib_surface_composite_trapezoids (cairo_operator_t	op,
     return status;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_set_clip_region (void              *abstract_surface,
 				     pixman_region16_t *region)
 {
@@ -1745,7 +1754,7 @@ _cairo_xlib_surface_set_clip_region (void              *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_get_extents (void		         *abstract_surface,
 				 cairo_rectangle_int16_t *rectangle)
 {
@@ -2308,7 +2317,7 @@ _cairo_xlib_surface_remove_scaled_font (Display *dpy,
     }
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_font_init (Display		    *dpy,
 			       cairo_scaled_font_t  *scaled_font,
 			       cairo_format_t	     format)
@@ -2368,7 +2377,7 @@ _native_byte_order_lsb (void)
     return *((char *) &x) == 1;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_add_glyph (Display *dpy,
 			       cairo_scaled_font_t  *scaled_font,
 			       cairo_scaled_glyph_t *scaled_glyph)
@@ -2577,7 +2586,7 @@ typedef struct {
 #define GLYPH_INDEX_SKIP ((unsigned long) -1)
 #define STACK_ELTS_LEN ((int) (CAIRO_STACK_BUFFER_SIZE / sizeof (XGlyphElt8)))
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_emit_glyphs_chunk (cairo_xlib_surface_t *dst,
 				       cairo_xlib_glyph_t *glyphs,
 				       int num_glyphs,
@@ -2692,7 +2701,7 @@ _cairo_xlib_surface_emit_glyphs_chunk (cairo_xlib_surface_t *dst,
 
 #undef STACK_ELTS_LEN
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _cairo_xlib_surface_emit_glyphs (cairo_xlib_surface_t *dst,
 				 cairo_xlib_glyph_t *glyphs,
 				 int num_glyphs,
@@ -2812,7 +2821,9 @@ _cairo_xlib_surface_emit_glyphs (cairo_xlib_surface_t *dst,
 
 	/* Send unsent glyphs to the server */
 	if (scaled_glyph->surface_private == NULL) {
-	    _cairo_xlib_surface_add_glyph (dst->dpy, scaled_font, scaled_glyph);
+	    status = _cairo_xlib_surface_add_glyph (dst->dpy, scaled_font, scaled_glyph);
+	    if (status)
+		return status;
 	    scaled_glyph->surface_private = (void *) 1;
 	}
 
@@ -2834,7 +2845,7 @@ _cairo_xlib_surface_emit_glyphs (cairo_xlib_surface_t *dst,
 
 #undef GLYPH_INDEX_SKIP
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
 				 cairo_operator_t     op,
 				 cairo_pattern_t     *src_pattern,
@@ -2947,7 +2958,7 @@ _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
     if (status)
         goto BAIL;
 
-    _cairo_xlib_surface_emit_glyphs (dst, (cairo_xlib_glyph_t *) glyphs, num_glyphs,
+    status = _cairo_xlib_surface_emit_glyphs (dst, (cairo_xlib_glyph_t *) glyphs, num_glyphs,
 				     scaled_font, op, src, &attributes);
 
   BAIL:
diff --git a/src/test-fallback-surface.c b/src/test-fallback-surface.c
index 21ee190..8275319 100644
--- a/src/test-fallback-surface.c
+++ b/src/test-fallback-surface.c
@@ -105,7 +105,7 @@ _test_fallback_surface_create_similar (void		*abstract_surface,
 					  width, height);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _test_fallback_surface_finish (void *abstract_surface)
 {
     test_fallback_surface_t *surface = abstract_surface;
@@ -115,7 +115,7 @@ _test_fallback_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _test_fallback_surface_acquire_source_image (void	     *abstract_surface,
 					     cairo_image_surface_t **image_out,
 					     void		 **image_extra)
@@ -137,7 +137,7 @@ _test_fallback_surface_release_source_image (void	     *abstract_surface,
 					 image, image_extra);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _test_fallback_surface_acquire_dest_image (void		           *abstract_surface,
 					   cairo_rectangle_int16_t *interest_rect,
 					   cairo_image_surface_t  **image_out,
@@ -169,7 +169,7 @@ _test_fallback_surface_release_dest_image (void			   *abstract_surface,
 				       image_extra);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_fallback_surface_get_extents (void		            *abstract_surface,
 				    cairo_rectangle_int16_t *rectangle)
 {
diff --git a/src/test-meta-surface.c b/src/test-meta-surface.c
index 6c58779..02ebb58 100644
--- a/src/test-meta-surface.c
+++ b/src/test-meta-surface.c
@@ -64,7 +64,7 @@ typedef struct _test_meta_surface {
 
 const cairo_private cairo_surface_backend_t test_meta_surface_backend;
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_show_page (void *abstract_surface);
 
 cairo_surface_t *
@@ -103,7 +103,7 @@ _cairo_test_meta_surface_create (cairo_content_t	content,
     return (cairo_surface_t*) &_cairo_surface_nil;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _test_meta_surface_finish (void *abstract_surface)
 {
     test_meta_surface_t *surface = abstract_surface;
@@ -114,7 +114,7 @@ _test_meta_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _test_meta_surface_acquire_source_image (void		  *abstract_surface,
 					 cairo_image_surface_t	**image_out,
 					 void			**image_extra)
@@ -139,7 +139,7 @@ _test_meta_surface_release_source_image (void			*abstract_surface,
 					 image, image_extra);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_show_page (void *abstract_surface)
 {
     test_meta_surface_t *surface = abstract_surface;
@@ -154,7 +154,7 @@ _test_meta_surface_show_page (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_intersect_clip_path (void			*abstract_surface,
 					cairo_path_fixed_t	*path,
 					cairo_fill_rule_t	 fill_rule,
@@ -168,7 +168,7 @@ _test_meta_surface_intersect_clip_path (void			*abstract_surface,
 					       tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_get_extents (void			*abstract_surface,
 				cairo_rectangle_int16_t	*rectangle)
 {
@@ -179,7 +179,7 @@ _test_meta_surface_get_extents (void			*abstract_surface,
     return _cairo_surface_get_extents (surface->image, rectangle);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_paint (void			*abstract_surface,
 			  cairo_operator_t	 op,
 			  cairo_pattern_t	*source)
@@ -191,7 +191,7 @@ _test_meta_surface_paint (void			*abstract_surface,
     return _cairo_surface_paint (surface->meta, op, source);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_mask (void			*abstract_surface,
 			 cairo_operator_t	 op,
 			 cairo_pattern_t	*source,
@@ -204,7 +204,7 @@ _test_meta_surface_mask (void			*abstract_surface,
     return _cairo_surface_mask (surface->meta, op, source, mask);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_stroke (void			*abstract_surface,
 			   cairo_operator_t	 op,
 			   cairo_pattern_t	*source,
@@ -225,7 +225,7 @@ _test_meta_surface_stroke (void			*abstract_surface,
 				  tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_fill (void			*abstract_surface,
 			 cairo_operator_t	 op,
 			 cairo_pattern_t	*source,
@@ -243,7 +243,7 @@ _test_meta_surface_fill (void			*abstract_surface,
 				tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_meta_surface_show_glyphs (void			*abstract_surface,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*source,
diff --git a/src/test-paginated-surface.c b/src/test-paginated-surface.c
index d82749f..0bf69c7 100644
--- a/src/test-paginated-surface.c
+++ b/src/test-paginated-surface.c
@@ -95,7 +95,7 @@ _cairo_test_paginated_surface_create_for_data (unsigned char		*data,
 					    &test_paginated_surface_paginated_backend);
 }
 
-static cairo_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_status_t
 _test_paginated_surface_finish (void *abstract_surface)
 {
     test_paginated_surface_t *surface = abstract_surface;
@@ -105,7 +105,7 @@ _test_paginated_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_paginated_surface_set_clip_region (void *abstract_surface,
 					 pixman_region16_t *region)
 {
@@ -147,7 +147,7 @@ _test_paginated_surface_set_clip_region (void *abstract_surface,
     return _cairo_image_surface_set_clip_region (surface->target, region);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_paginated_surface_get_extents (void			*abstract_surface,
 				     cairo_rectangle_int16_t	*rectangle)
 {
@@ -156,7 +156,7 @@ _test_paginated_surface_get_extents (void			*abstract_surface,
     return _cairo_surface_get_extents (surface->target, rectangle);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_paginated_surface_paint (void		*abstract_surface,
 			       cairo_operator_t	 op,
 			       cairo_pattern_t	*source)
@@ -169,7 +169,7 @@ _test_paginated_surface_paint (void		*abstract_surface,
     return _cairo_surface_paint (surface->target, op, source);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_paginated_surface_mask (void		*abstract_surface,
 			      cairo_operator_t	 op,
 			      cairo_pattern_t	*source,
@@ -183,7 +183,7 @@ _test_paginated_surface_mask (void		*abstract_surface,
     return _cairo_surface_mask (surface->target, op, source, mask);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_paginated_surface_stroke (void			*abstract_surface,
 				cairo_operator_t	 op,
 				cairo_pattern_t		*source,
@@ -205,7 +205,7 @@ _test_paginated_surface_stroke (void			*abstract_surface,
 				  tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_paginated_surface_fill (void			*abstract_surface,
 			      cairo_operator_t		 op,
 			      cairo_pattern_t		*source,
@@ -224,7 +224,7 @@ _test_paginated_surface_fill (void			*abstract_surface,
 				tolerance, antialias);
 }
 
-static cairo_int_status_t
+static CAIRO_WARN_UNUSED_RESULT cairo_int_status_t
 _test_paginated_surface_show_glyphs (void			*abstract_surface,
 				     cairo_operator_t		 op,
 				     cairo_pattern_t		*source,
-- 
1.4.4.2

From cworth at cworth.org  Mon Mar 19 13:29:16 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar 19 13:29:55 2007
Subject: [cairo] 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <20070316164045.GB11712@inspired.chris-wilson.co.uk>
References: <20070316164045.GB11712@inspired.chris-wilson.co.uk>
Message-ID: <87hcsh9dur.wl%cworth@cworth.org>

On Fri, 16 Mar 2007 16:40:45 +0000, Chris Wilson wrote:
> Following Behad's suggestion that Cairo really should suffer some
> malloc-failure testing, I wrote a simple valgrind skin to randomly
> return NULL.
>
> The effort was justified as it's already pinpointed a few places that
> needed some error checking.

Hi Chris,

This looks like great work, and I'm excited about getting fixes like
this into cairo. But I think we'll need a bit more work on these
specific patches before they go into cairo, (that is, I'll probably go
ahead and release 1.4.2 without these today, unless there's some
really fast turnaround on these).

> @@ -187,6 +187,8 @@ _pixman_create_source_image (void)
>      pixman_image_t *image;
>
>      image = (pixman_image_t *) malloc (sizeof (pixman_image_t));
> +    if (!image)
> +	return;

That's introducing the failure to return a value from a non-void
function.

[And as a style point, I prefer "if (image == NULL)" for testing
against NULL. If you do insist on treating a pointer as a Boolean,
(something not unheard of in the cairo source code), I prefer to see a
space character used to call attention to the !  operator. That is:
"if (!  condition)"]

> diff --git a/src/cairo-skiplist.c b/src/cairo-skiplist.c
> index 451ecb0..9f27ffa 100644
> --- a/src/cairo-skiplist.c
> +++ b/src/cairo-skiplist.c
> @@ -349,6 +349,8 @@ _cairo_skip_list_insert (cairo_skip_list_t *list, void *data, int unique)
>      }
>
>      data_and_elt = alloc_node_for_level (list, level);
> +    if (!data_and_elt)
> +	return NULL;

A fix like this doesn't actually help unless we also propagate the
checks all the way up, (the current callers of _cairo_skip_list_insert
are calling this function without checking). And the easiest time to
catch those callers is when introducing this fix. Otherwise, we're
basically just moving a bug from one location to many locations---not
actually improving cairo at all.

> Subject: [PATCH] Handle and return out-of-memory condition.
>
> ---
>  src/cairo-bentley-ottmann.c |    9 +++++++--
>  1 files changed, 7 insertions(+), 2 deletions(-)

This patch at least looks functionally complete. The patch description
should be more descriptive though, (specifically mentioning
_cairo_bo_sweep_line_insert at least), particularly since we
anticipate a whole slew of similar fixes as testing reveals similar
failures to handle out-of-memory conditions.

Also:

>      edge->sweep_line_elt = sweep_line_elt;
> +    return CAIRO_STATUS_SUCCESS;
...
> -	    _cairo_bo_sweep_line_insert (&sweep_line, edge);
> +	    status = _cairo_bo_sweep_line_insert (&sweep_line, edge);
> +	    if (status)
> +		goto unwind;
>  	    /* Cache the insert position for use in pass 2.

There are missing newlines in the above, (before the return value and
after the goto). Statements that change the control flow really need
to be visually called out somehow compared to other sequences of
statements that are always executed together as a basic block.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/08d96ad8/attachment.pgp
From cworth at cworth.org  Mon Mar 19 14:00:49 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar 19 14:03:50 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1173170822.24503.63.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
Message-ID: <87ejnl9ce6.wl%cworth@cworth.org>

Behdad asked me to take a look at this patch so we could get it in
place for the cairo 1.4.2 release happening today.

On Tue, 06 Mar 2007 09:47:01 +0100, Frederic Crozat wrote:
> I wanted git to give me a combined patch with changelog but I'm still a
> newbie for that ;)

For future reference, you could have most easily done this by not
making a second commit, but instead doing "git commit -a --amend" to
replace the first commit with the final desired state.

But even after you had made two commits, you could merge them by first
resetting the current branch pointer back to the previous commit while
leaving the working-tree content unchanged, then doing the --amend
commit. That is:

	git reset HEAD~1
	git commit -a --amend

As is, I could fabricate a commit message, ("Use union instead of cast
for __m54 conversion to allow compilation without
-fno-strict-aliasing" ? Is that accurate?).

But meanwhile:

> -		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (M64(m)), expand565(vd, 0));
> +		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (to_m64(m)), expand565(vd, 0));

So the patch only touches up one occurrence of M64 while leaving the
M64 macro and 14 other callers to it in place. That can't be right,
can it?

-Carl

$ grep M64 fbmmx.c
#define M64(x) (*(__m64*)(void*)(&x))
                __m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (M64(m)), load8888(*dst));
                dest0 = in_over(vsrc, vsrca, expand_alpha_rev (M64(m0)), expand8888(vdest, 0));
                dest1 = in_over(vsrc, vsrca, expand_alpha_rev (M64(m1)), expand8888(vdest, 1));
                vdest = in_over(vsrc, vsrca, expand_alpha_rev (M64(m)), vdest);
                  __m64 vdest = in(vsrc, expand_alpha_rev (M64(m)));
                dest0 = in(vsrc, expand_alpha_rev (M64(m0)));
                dest1 = in(vsrc, expand_alpha_rev (M64(m1)));
                vdest = in(vsrc, expand_alpha_rev (M64(m)));
                __m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (M64(m)), expand565(vd, 0));
                vm0 = M64(m0);
                vm1 = M64(m1);
                vm2 = M64(m2);
                vm3 = M64(m3);
                __m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (M64(m)), expand565(vd, 0));
    vfill = M64(fill);
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070319/bd942c74/attachment.pgp
From govindsalinas at gmail.com  Mon Mar 19 19:05:29 2007
From: govindsalinas at gmail.com (Govind Salinas)
Date: Mon Mar 19 19:05:29 2007
Subject: [cairo] Problems erasing a line.
In-Reply-To: <45FE5427.1020600@qatar.cmu.edu>
References: <1174289501.14565.22.camel@govind-desktop>
	<45FE5427.1020600@qatar.cmu.edu>
Message-ID: <1174356329.14565.25.camel@govind-desktop>

This makes some sense, I actually thought the antialiasing might have
something to do with it tried to disable it by setting the Antialias
property to None.  That didn't work but I will give this a try and see
what happens.

Thanks,
Govind.

 
On Mon, 2007-03-19 at 12:13 +0300, Justin Carlson wrote:
> Hi Gorvind.  I'm not a deep cairo hacker, but I'll try to answer your 
> questions.  I'm sure someone else will correct me when I invariably go 
> wrong.  :)
> 
> Govind Salinas wrote:
> > Hey guys,
> >
> > I am writing a small project to familiarize myself with c# and all the
> > new stuff that has come into the gnome-related world lately,
> > specifically Cairo.  One thing I was trying to do was make a
> > Gtk.DrawingArea.  When I get a left mouse click I start a rubber band
> > line to the current mouse location (mouse move events).  As the cursor
> > moves, I white out my background, erase my old line and draw a new one.
> > However I keep seeing artifacts of my previous line.
> >
> > Here is the relevant code:
> >
> >   
> ...snip
> > This more or less works other than I get artifacts of previous lines.
> >   
> Without seeing the rest of your code, it's hard to say exactly what's 
> going on.  I suspect your problem here is related what you've seen in 
> the second code snippet, which I've addressed below.  One other place 
> you can easily go wrong is not realizing that, when you invalidate a 
> section of a widget to force a redraw in GTK+, the expose event that 
> comes back automatically clips the area to be drawn to the invalidated 
> region.  So if you aren't careful in what you invalidate, you can end up 
> leaving artifacts.  To figure out exactly what to invalidate, you either 
> have to be very careful in how you draw, or you should use 
> cairo_{stroke|fill}_extents (or whatever the equivalent is in the C# 
> bindings) to figure out the precise area that's gone wrong.
> 
> > As an experiment I tried this:
> >   
> ...snip...
> > What I get from this is the outside of the line I was drawing (I
> > successfully erased the middle of the line but left two thinner lines in
> > its place).  I would expect that this leaves me with a blank canvas.  Is
> > there some fundamental thing that I am missing that will get this to
> > work?  The only way I have gotten this to draw cleanly is to invalidate
> > the whole area (QueueDraw() for example) and then draw the new line.
> > While this works its seems like an expensive way to erase a line.  Can
> > someone tell me where I am going wrong?
> >   
> This counter-intuitive result can come about whenever you have some 
> transparency, which, when drawing lines, is virtually always in cairo.  
> Whenever you have transparency, the result will be some of what you're 
> painting, and some of what was previously there.  So if you draw a white 
> line on a black background, you get white in the middle of the line, and 
> gray at the antialiased edges.  Let's say that the value of one 
> particular edge pixel is  .5 * black + .5 * white. 
> 
> So if you then draw the same line again, only in black, the pixel is 
> rendered as .5 * (.5 * black + .5 * white) + .5 * black. 
> 
> Plug in whatever values you want for black and white, and you'll see 
> that those edge pixels are not actually black.
> 
> The only situation in line drawing in cairo in which you don't get 
> antialiased pixels is (I believe) when you have a (post-scaling) 
> integral stroke width, your coordinates in device space all end in .5, 
> and your lines are completely horizontal or vertical.  e.g. (and I'm 
> guessing at the C# binding syntax here:)
> 
> gr.SetMatrix(identity);
> gr.SetStrokeWidth(1.0);
> gr.SetColor(Black);
> gr.Rectangle(10.5, 10.5, 20, 20);
> gr.Stroke();
> should give you a pure 1 pixel wide rectangle that has no transparent 
> pixels.
> 
> Hope that helps!
> 
> -J
> 

From bruce.dubbs at gmail.com  Mon Mar 19 20:18:43 2007
From: bruce.dubbs at gmail.com (Bruce Dubbs)
Date: Mon Mar 19 20:24:14 2007
Subject: [cairo] extend-reflect test hangs system
Message-ID: <45FF5293.9000001@gmail.com>

I am new to this mailing list and fairly new to cairo.

In any case, I have been running into severe problems with my build of
cairo-1.4.0.

I build the package with:

./configure --prefix=/usr && make

Then I do a make check.   When doing this remotely, extend-reflect gives me:

TESTING extend-reflect
Test CAIRO_EXTEND_REFLECT for surface patterns
extend-reflect-image-argb32 [0]:        PASS
extend-reflect-image-argb32 [25]:       PASS
extend-reflect-image-rgb24 [0]: PASS
extend-reflect-image-rgb24 [25]:        PASS
Failed to open display:
extend-reflect-xlib-argb32 [0]: UNTESTED
Failed to open display:
extend-reflect-xlib-argb32 [25]:        UNTESTED
Failed to open display:
extend-reflect-xlib-rgb24 [0]:  UNTESTED
Failed to open display:
extend-reflect-xlib-rgb24 [25]: UNTESTED
extend-reflect-ps-argb32 [0]:   PASS
extend-reflect-ps-argb32 [25]:  PASS
extend-reflect-ps-rgb24 [0]:    PASS
extend-reflect-ps-rgb24 [25]:   PASS

When doing the make check in an X window, the output of the first four
tests is the same, but then the system hangs hard.  No X cursor
movement, no response to the keyboard (even the off button), no response
to ping and an ssh connection is dead.  The only way to recover is to
disconnect all power to the system and power up again.

I can disable this test and all the others complete (but not all pass).

The only way I can figure that a crash to this level can occur is
triggered by cairo via the X generic Nvidia driver (nv) which I thought
was well tested.

Suggestions are welcome.

  -- Bruce
From jeff at infidigm.net  Mon Mar 19 21:52:02 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Mon Mar 19 21:50:16 2007
Subject: [cairo] extend-reflect test hangs system
In-Reply-To: <45FF5293.9000001@gmail.com>
References: <45FF5293.9000001@gmail.com>
Message-ID: <20070320045202.GA22028@infidigm.net>

This is a known problem. Nobody has come up with a solution yet.

-Jeff

On Mon, Mar 19, 2007 at 10:18:43PM -0500, Bruce Dubbs wrote:
> I am new to this mailing list and fairly new to cairo.
> 
> In any case, I have been running into severe problems with my build of
> cairo-1.4.0.
> 
> I build the package with:
> 
> ./configure --prefix=/usr && make
> 
> Then I do a make check.   When doing this remotely, extend-reflect gives me:
> 
> TESTING extend-reflect
> Test CAIRO_EXTEND_REFLECT for surface patterns
> extend-reflect-image-argb32 [0]:        PASS
> extend-reflect-image-argb32 [25]:       PASS
> extend-reflect-image-rgb24 [0]: PASS
> extend-reflect-image-rgb24 [25]:        PASS
> Failed to open display:
> extend-reflect-xlib-argb32 [0]: UNTESTED
> Failed to open display:
> extend-reflect-xlib-argb32 [25]:        UNTESTED
> Failed to open display:
> extend-reflect-xlib-rgb24 [0]:  UNTESTED
> Failed to open display:
> extend-reflect-xlib-rgb24 [25]: UNTESTED
> extend-reflect-ps-argb32 [0]:   PASS
> extend-reflect-ps-argb32 [25]:  PASS
> extend-reflect-ps-rgb24 [0]:    PASS
> extend-reflect-ps-rgb24 [25]:   PASS
> 
> When doing the make check in an X window, the output of the first four
> tests is the same, but then the system hangs hard.  No X cursor
> movement, no response to the keyboard (even the off button), no response
> to ping and an ssh connection is dead.  The only way to recover is to
> disconnect all power to the system and power up again.
> 
> I can disable this test and all the others complete (but not all pass).
> 
> The only way I can figure that a crash to this level can occur is
> triggered by cairo via the X generic Nvidia driver (nv) which I thought
> was well tested.
> 
> Suggestions are welcome.
> 
>   -- Bruce
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
From cworth at cworth.org  Mon Mar 19 23:57:49 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar 19 23:58:58 2007
Subject: [cairo] [cairo-announce] cairo release 1.4.2 now available
Message-ID: <87aby89zbm.wl%cworth@cworth.org>

Skipped content of type multipart/signed-------------- next part --------------
_______________________________________________
cairo-announce mailing list
cairo-announce@cairographics.org
http://cairographics.org/cgi-bin/mailman/listinfo/cairo-announce
From bruce.dubbs at gmail.com  Tue Mar 20 00:57:48 2007
From: bruce.dubbs at gmail.com (Bruce Dubbs)
Date: Tue Mar 20 00:57:51 2007
Subject: [cairo] extend-reflect test hangs system
In-Reply-To: <1174369223.6171.1.camel@localhost>
References: <45FF5293.9000001@gmail.com>	 <20070320045202.GA22028@infidigm.net>
	<1174369223.6171.1.camel@localhost>
Message-ID: <45FF93FC.6060308@gmail.com>

Mathias Hasselmann wrote:
> Am Dienstag, den 20.03.2007, 00:52 -0400 schrieb Jeff Muizelaar:
>> This is a known problem. Nobody has come up with a solution yet.
> 
> Do we have a theory about the cause of the problem? Or do we know at
> least, arround which time that bug appeared? Could investigate the
> problem, but would like to operate with some kind of plan: Endless
> reboot-debug cycles are no fun...

I just downloaded and tested 1.4.2 and it did not hang my system:

Without X: 14 of 122 tests did not behave as expected (2 XPASS)

FAIL: clip-operator
FAIL: font-matrix-translation
FAIL: glyph-cache-pressure
FAIL: operator-clear
FAIL: operator-source
FAIL: select-font-face
FAIL: show-text-current-point
FAIL: text-antialias-gray
FAIL: text-pattern
FAIL: text-rotate
FAIL: unbounded-operator
FAIL: ft-text-vertical-layout-type3

XPASS: surface-pattern-scale-down
XPASS: surface-pattern-scale-up

With X: 18 of 122 tests failed

FAIL: clip-operator
*FAIL: dash-scale
*FAIL: dash-state
FAIL: font-matrix-translation
FAIL: glyph-cache-pressure
FAIL: operator-clear
FAIL: operator-source
*FAIL: pixman-rotate
*FAIL: random-intersections
*FAIL: rotate-image-surface-paint
FAIL: select-font-face
FAIL: show-text-current-point
*FAIL: source-clip-scale
FAIL: text-antialias-gray
FAIL: text-pattern
FAIL: text-rotate
FAIL: unbounded-operator
FAIL: ft-text-vertical-layout-type3

I notice that extend-reflect is not in the test suite any more.

Is there anything I can do to help resolve some of these failures?
  -- Bruce


===============
>> On Mon, Mar 19, 2007 at 10:18:43PM -0500, Bruce Dubbs wrote:

>>> TESTING extend-reflect
>>> Test CAIRO_EXTEND_REFLECT for surface patterns
>>> extend-reflect-image-argb32 [0]:        PASS
>>> extend-reflect-image-argb32 [25]:       PASS
>>> extend-reflect-image-rgb24 [0]: PASS
>>> extend-reflect-image-rgb24 [25]:        PASS
>>> Failed to open display:
>>> extend-reflect-xlib-argb32 [0]: UNTESTED
>>> Failed to open display:
>>> extend-reflect-xlib-argb32 [25]:        UNTESTED
>>> Failed to open display:
>>> extend-reflect-xlib-rgb24 [0]:  UNTESTED
>>> Failed to open display:
>>> extend-reflect-xlib-rgb24 [25]: UNTESTED
>>> extend-reflect-ps-argb32 [0]:   PASS
>>> extend-reflect-ps-argb32 [25]:  PASS
>>> extend-reflect-ps-rgb24 [0]:    PASS
>>> extend-reflect-ps-rgb24 [25]:   PASS
>>>
>>> When doing the make check in an X window, the output of the first four
>>> tests is the same, but then the system hangs hard.  No X cursor
>>> movement, no response to the keyboard (even the off button), no response
>>> to ping and an ssh connection is dead.  The only way to recover is to
>>> disconnect all power to the system and power up again.
From klein.stephane at gmail.com  Tue Mar 20 01:56:45 2007
From: klein.stephane at gmail.com (=?ISO-8859-1?Q?KLEIN_St=E9phane?=)
Date: Tue Mar 20 01:56:49 2007
Subject: [cairo] Can I use pycairo to convert svg file to pdf ?
Message-ID: <6bcc32f20703200156o19ec06xd3d7a78d0d811683@mail.gmail.com>

Hi,

I would like convert svg file to pdf file.

I've use rsvg-convert but it are some issue with circumflex char then
I would like use last cairo version to do this conversion.

My question : can I make a python script (with pycairo) to open svg
file and convert it to pdf ?

Thanks for your help.
Stephane
From fcrozat at mandriva.com  Tue Mar 20 02:20:16 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Tue Mar 20 02:19:43 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <87ejnl9ce6.wl%cworth@cworth.org>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
	<87ejnl9ce6.wl%cworth@cworth.org>
Message-ID: <1174382416.4247.22.camel@trinidad.mandrakesoft.com>

Le lundi 19 mars 2007 ? 14:00 -0700, Carl Worth a ?crit :
> Behdad asked me to take a look at this patch so we could get it in
> place for the cairo 1.4.2 release happening today.
> 
> On Tue, 06 Mar 2007 09:47:01 +0100, Frederic Crozat wrote:
> > I wanted git to give me a combined patch with changelog but I'm still a
> > newbie for that ;)
> 
> For future reference, you could have most easily done this by not
> making a second commit, but instead doing "git commit -a --amend" to
> replace the first commit with the final desired state.
> 
> But even after you had made two commits, you could merge them by first
> resetting the current branch pointer back to the previous commit while
> leaving the working-tree content unchanged, then doing the --amend
> commit. That is:
> 
> 	git reset HEAD~1
> 	git commit -a --amend
> 
> As is, I could fabricate a commit message, ("Use union instead of cast
> for __m54 conversion to allow compilation without
> -fno-strict-aliasing" ? Is that accurate?).

Yes for commit message :)

And thanks for git tutorial.

> But meanwhile:
> 
> > -		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (M64(m)), expand565(vd, 0));
> > +		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (to_m64(m)), expand565(vd, 0));
> 
> So the patch only touches up one occurrence of M64 while leaving the
> M64 macro and 14 other callers to it in place. That can't be right,
> can it?

It is right, or at least, it is the only changes that are needed to fix
the issues we are seeing on x86 and x86_64.

I'm not a specialist in these strange (for me) casting stuff so I didn't
replace all occurrences of M64 with to_m64 since some of those cast
might be valid (according to our gcc guy who helped me debug that
initially), since I don't have the expertise in pixman and I didn't want
to break everything :)

Another thing is troubling me : 
we got hit by this bug because in our default rpm configuration, %
optflags contains -fomit-frame-pointer, so CFLAGS is exported when
running ./configure.

And after doing more checks, it seems -fno-strict-aliasing is correctly
added and used when building cairo code (src subdir) but not when
building pixman code, because CAIRO_CFLAGS (where -fno-strict-aliasing
is defined) is not used in pixman subdirectory.

I'm not sure which way is best to fix this : adding -fno-strict-aliasing
to CFLAGS in configure.in and not in CAIRO_CFLAGS (so pixman will use
it) or teach pixman to use CAIRO_CFLAGS.

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva

From basti at bastisoft.de  Tue Mar 20 03:42:58 2007
From: basti at bastisoft.de (Sebastian Koppehel)
Date: Tue Mar 20 03:49:30 2007
Subject: [cairo] Can I use pycairo to convert svg file to pdf ?
In-Reply-To: <6bcc32f20703200156o19ec06xd3d7a78d0d811683@mail.gmail.com>
References: <6bcc32f20703200156o19ec06xd3d7a78d0d811683@mail.gmail.com>
Message-ID: <1174387378.11453.3.camel@clever>

Am Dienstag, den 20.03.2007, 09:56 +0100 schrieb KLEIN St?phane:

> My question : can I make a python script (with pycairo) to open svg
> file and convert it to pdf ?

Yes.

Primitive outline:

        import cairo, rsvg
        from sys import argv
        
        WIDTH, HEIGHT = 100, 100
        
        surf = cairo.PDFSurface(argv[2], WIDTH, HEIGHT)
        cr = cairo.Context(surf)
        rsvg.Handle(argv[1]).render_cairo(cr)
        cr.show_page()

Regards,

 - Sebastian

From domlachowicz at gmail.com  Tue Mar 20 05:31:15 2007
From: domlachowicz at gmail.com (Dominic Lachowicz)
Date: Tue Mar 20 05:31:19 2007
Subject: [cairo] Can I use pycairo to convert svg file to pdf ?
In-Reply-To: <6bcc32f20703200156o19ec06xd3d7a78d0d811683@mail.gmail.com>
References: <6bcc32f20703200156o19ec06xd3d7a78d0d811683@mail.gmail.com>
Message-ID: <2672cf4d0703200531s7829d1a0s5155c67d2e9918d3@mail.gmail.com>

Hi Stephane,

You filed bug http://bugzilla.gnome.org/show_bug.cgi?id=420469 against
librsvg. Since you claim that the problem happens with PDF output and
not PNG output, could you please re-file the bug against Cairo?

Thanks,
Dom

On 3/20/07, KLEIN St?phane <klein.stephane@gmail.com> wrote:
> Hi,
>
> I would like convert svg file to pdf file.
>
> I've use rsvg-convert but it are some issue with circumflex char then
> I would like use last cairo version to do this conversion.
>
> My question : can I make a python script (with pycairo) to open svg
> file and convert it to pdf ?
>
> Thanks for your help.
> Stephane
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
>


-- 
Counting bodies like sheep to the rhythm of the war drums.
From behdad at behdad.org  Tue Mar 20 05:46:39 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Tue Mar 20 05:46:39 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1174382416.4247.22.camel@trinidad.mandrakesoft.com>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
	<87ejnl9ce6.wl%cworth@cworth.org>
	<1174382416.4247.22.camel@trinidad.mandrakesoft.com>
Message-ID: <1174394800.9050.8.camel@behdad>

On Tue, 2007-03-20 at 05:20 -0400, Frederic Crozat wrote:
> 
> I'm not a specialist in these strange (for me) casting stuff so I
> didn't
> replace all occurrences of M64 with to_m64 since some of those cast
> might be valid (according to our gcc guy who helped me debug that
> initially), since I don't have the expertise in pixman and I didn't
> want to break everything :)

I think replacing them all is what we really want.

> Another thing is troubling me : 
> we got hit by this bug because in our default rpm configuration, %
> optflags contains -fomit-frame-pointer, so CFLAGS is exported when
> running ./configure.
> 
> And after doing more checks, it seems -fno-strict-aliasing is
> correctly
> added and used when building cairo code (src subdir) but not when
> building pixman code, because CAIRO_CFLAGS (where -fno-strict-aliasing
> is defined) is not used in pixman subdirectory.
> 
> I'm not sure which way is best to fix this : adding
> -fno-strict-aliasing
> to CFLAGS in configure.in and not in CAIRO_CFLAGS (so pixman will use
> it) or teach pixman to use CAIRO_CFLAGS. 

Ok, great.  I was wondering but didn't check.  It should be fixed now.
I defined a PIXMAN_CFLAGS in configure.in...

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From fcrozat at mandriva.com  Tue Mar 20 05:52:23 2007
From: fcrozat at mandriva.com (Frederic Crozat)
Date: Tue Mar 20 05:51:50 2007
Subject: [cairo] regression in text rendering when not using Render xlib
In-Reply-To: <1174394800.9050.8.camel@behdad>
References: <1172773690.4863.93.camel@trinidad.mandrakesoft.com>
	<1172796505.19281.20.camel@behdad>
	<1172826398.4863.110.camel@trinidad.mandrakesoft.com>
	<1172834686.4863.129.camel@trinidad.mandrakesoft.com>
	<1172865665.4863.131.camel@trinidad.mandrakesoft.com>
	<1173102817.24503.7.camel@trinidad.mandrakesoft.com>
	<1173128740.18079.75.camel@behdad>
	<1173170822.24503.63.camel@trinidad.mandrakesoft.com>
	<87ejnl9ce6.wl%cworth@cworth.org>
	<1174382416.4247.22.camel@trinidad.mandrakesoft.com>
	<1174394800.9050.8.camel@behdad>
Message-ID: <1174395144.4247.46.camel@trinidad.mandrakesoft.com>

Le mardi 20 mars 2007 ? 08:46 -0400, Behdad Esfahbod a ?crit :
> On Tue, 2007-03-20 at 05:20 -0400, Frederic Crozat wrote:
> > 
> > I'm not a specialist in these strange (for me) casting stuff so I
> > didn't
> > replace all occurrences of M64 with to_m64 since some of those cast
> > might be valid (according to our gcc guy who helped me debug that
> > initially), since I don't have the expertise in pixman and I didn't
> > want to break everything :)
> 
> I think replacing them all is what we really want.

On the other hand, it might not be optimal (I can hear our gcc guy
mumbling about unoptimal code)  ;)

-- 
Frederic Crozat <fcrozat@mandriva.com>
Mandriva

From jeff at infidigm.net  Tue Mar 20 07:04:36 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Tue Mar 20 07:02:49 2007
Subject: [cairo] extend-reflect test hangs system
In-Reply-To: <1174369223.6171.1.camel@localhost>
References: <45FF5293.9000001@gmail.com> <20070320045202.GA22028@infidigm.net>
	<1174369223.6171.1.camel@localhost>
Message-ID: <20070320140436.GA24382@infidigm.net>

On Tue, Mar 20, 2007 at 06:40:23AM +0100, Mathias Hasselmann wrote:
> Am Dienstag, den 20.03.2007, 00:52 -0400 schrieb Jeff Muizelaar:
> > This is a known problem. Nobody has come up with a solution yet.
> 
> Do we have a theory about the cause of the problem? Or do we know at
> least, arround which time that bug appeared? Could investigate the
> problem, but would like to operate with some kind of plan: Endless
> reboot-debug cycles are no fun...

IIRC the xservers ends up looping in fbCompositeSrc_8888x8888mmx() when try to
composite the surface we create in the 'if (attr->extend ==
CAIRO_EXTEND_REFLECT) {' section of
_cairo_pattern_acquire_surface_for_surface(). The current hypothesis is
that the problem is caused by fbComposite() giving
fbCompositeSrc_8888x8888mmx() bad parameters or data of some sort.

Debugging it shouldn't be too bad if you have debugging symbols or can
build your own xserver and can debug using ssh. (Note: when debugging
the xserver using gdb I've found it a good idea to do 'handle SIGARLM
ignore' to keep from being interrupted).

-Jeff
From jeff at infidigm.net  Tue Mar 20 07:09:20 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Tue Mar 20 07:07:34 2007
Subject: [cairo] PDF Transparent Gradients
In-Reply-To: <45FDBB52.2000806@redneon.com>
References: <45FCC778.8010307@redneon.com> <20070318125922.GA3524@infidigm.net>
	<45FDBB52.2000806@redneon.com>
Message-ID: <20070320140920.GC24382@infidigm.net>

Yep, it looks like something is wrong here. I'll look into it when I get
the chance.

-Jeff

On Mon, Mar 19, 2007 at 08:51:06AM +1030, Adrian Johnson wrote:
> Jeff Muizelaar wrote:
> > On Sun, Mar 18, 2007 at 03:30:40PM +1030, Adrian Johnson wrote:
> >> Poppler does not appear to support SMasks. Also, enabling padding with a
> >> radial gradient did not pad out the entire rectangle I was filling.
> > 
> > Poppler should support SMasks. What isn't working?
> > 
> > -Jeff
> 
> I've attached two pdf files containing a linear gradient with a red and
> green color stop and the extend mode CAIRO_EXTEND_PAD.  The only
> difference between the two is the the green color stop in
> transparent_gradient.pdf has 0.5 alpha while in opaque_gradient.pdf it
> is 1.0. The red color stop has alpha = 1 in both files.
> 
> I've also attached screen captures of each pdf as displayed by evince
> and ghostscript. The evince output appears to be identical for both
> pdf files.
> 
> I am using evince 0.6.1, poppler 0.5.4, and ghostscript 8.54.
> 







From christophe.dehais at gmail.com  Tue Mar 20 08:04:17 2007
From: christophe.dehais at gmail.com (Christophe Dehais)
Date: Tue Mar 20 08:04:21 2007
Subject: [cairo] Projective transformations
Message-ID: <4a305d880703200804h1877f62br1a201d5f11831fec@mail.gmail.com>

Hi !

Would it be difficult to make cairo_matrix hold a full 3x3 projective
transformation matrix instead of an affine transformation (2x3 matrix)
? Such transformations (also called homography) handle perspective
transformations and can simulate a kind of poor man's 3D.

In a GUI context, many elements are planar, and the transformation
between 2 (perspective) views of a plan is a homography. So having
that in cairo could allow creating widgets that presently would
require using OpenGL.

Thoughts ?

cheers,
Christophe
From sebastian.tusk at gmx.net  Tue Mar 20 10:35:58 2007
From: sebastian.tusk at gmx.net (Sebastian Tusk)
Date: Tue Mar 20 10:36:03 2007
Subject: [cairo] CAIRO_OPERATOR_SOURCE not handled by backend
Message-ID: <20070320173558.166360@gmx.net>

I am writing a surface backend and noticed that for CAIRO_OPERATOR_SOURCE there is some special handling in _clip_and_composite. I'd like to implement this operator in my backend as all the other operators. Is it necessary to change _clip_and_composite or is there another solution?

Shouldn't most backends be able to do the SOURCE operator more efficently than the current way?

Sebastian

-- 
"Feel free" - 5 GB Mailbox, 50 FreeSMS/Monat ...
Jetzt GMX ProMail testen: www.gmx.net/de/go/mailfooter/promail-out
From jeff at infidigm.net  Tue Mar 20 10:49:37 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Tue Mar 20 10:47:48 2007
Subject: [cairo] CAIRO_OPERATOR_SOURCE not handled by backend
In-Reply-To: <20070320173558.166360@gmx.net>
References: <20070320173558.166360@gmx.net>
Message-ID: <20070320174937.GA26484@infidigm.net>

On Tue, Mar 20, 2007 at 06:35:58PM +0100, Sebastian Tusk wrote:
> I am writing a surface backend and noticed that for CAIRO_OPERATOR_SOURCE there is some special handling in _clip_and_composite. I'd like to implement this operator in my backend as all the other operators. Is it necessary to change _clip_and_composite or is there another solution?
> 

The reason for the special behaviour is that when SOURCE or CLEAR are used with
a mask in cairo that mask bounds the operation. Does your backend
support this behaviour? Either way _clip_and_composite should probably
be changed to try to do the operation and the backends that don't
support it should return STATUS_UNSUPPORTED. Only then, should cairo
fallback to trying (src IN mask IN clip) ADD (dst OUT (mask IN clip)).

> Shouldn't most backends be able to do the SOURCE operator more efficently than the current way?

XRender can not. I am not sure about the other backends, though I think
Quartz (at least newer ones) might be able to do it more efficiently.

-Jeff
From sebastian.tusk at gmx.net  Tue Mar 20 11:18:13 2007
From: sebastian.tusk at gmx.net (Sebastian Tusk)
Date: Tue Mar 20 11:18:15 2007
Subject: [cairo] CAIRO_OPERATOR_SOURCE not handled by backend
In-Reply-To: <20070320174937.GA26484@infidigm.net>
References: <20070320173558.166360@gmx.net>
	<20070320174937.GA26484@infidigm.net>
Message-ID: <20070320181813.311520@gmx.net>

> The reason for the special behaviour is that when SOURCE or CLEAR are used
> with
> a mask in cairo that mask bounds the operation. Does your backend
> support this behaviour?

The special behaviour is triggered even without a mask. For my backend I would handle both cases myself.

> Either way _clip_and_composite should probably
> be changed to try to do the operation and the backends that don't
> support it should return STATUS_UNSUPPORTED. Only then, should cairo
> fallback to trying (src IN mask IN clip) ADD (dst OUT (mask IN clip)).

This means a change to all of the existing backends too? I will do that if there is no easier way.

> 
> > Shouldn't most backends be able to do the SOURCE operator more
> efficently than the current way?
> 
> XRender can not. I am not sure about the other backends, though I think
> Quartz (at least newer ones) might be able to do it more efficiently.

Is this an API limitation?

Sebastian

-- 
"Feel free" - 5 GB Mailbox, 50 FreeSMS/Monat ...
Jetzt GMX ProMail testen: www.gmx.net/de/go/mailfooter/promail-out
From jeff at infidigm.net  Tue Mar 20 11:55:14 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Tue Mar 20 11:54:01 2007
Subject: [cairo] CAIRO_OPERATOR_SOURCE not handled by backend
In-Reply-To: <20070320181813.311520@gmx.net>
References: <20070320173558.166360@gmx.net>
	<20070320174937.GA26484@infidigm.net>
	<20070320181813.311520@gmx.net>
Message-ID: <20070320185514.GA26912@infidigm.net>

On Tue, Mar 20, 2007 at 07:18:13PM +0100, Sebastian Tusk wrote:
> > The reason for the special behaviour is that when SOURCE or CLEAR are used
> > with
> > a mask in cairo that mask bounds the operation. Does your backend
> > support this behaviour?
> 
> The special behaviour is triggered even without a mask. For my backend I would handle both cases myself.

This isn't true. Without a mask (clip_surface) the special case in
clip_and_composite_trapezoids will send the operation through to
_composite_trap_region which passes the SOURCE operation on to the
backend composite function through _cairo_surface_composite.

> > Either way _clip_and_composite should probably
> > be changed to try to do the operation and the backends that don't
> > support it should return STATUS_UNSUPPORTED. Only then, should cairo
> > fallback to trying (src IN mask IN clip) ADD (dst OUT (mask IN clip)).
> 
> This means a change to all of the existing backends too? I will do that if there is no easier way.

Yes, that's probably what you'll have to do.

> > 
> > > Shouldn't most backends be able to do the SOURCE operator more
> > efficently than the current way?
> > 
> > XRender can not. I am not sure about the other backends, though I think
> > Quartz (at least newer ones) might be able to do it more efficiently.
> 
> Is this an API limitation?

Of XRender? Not really an API limitation, it's just a semantic mismatch.
The SOURCE operator is not bounded by the mask in XRender.

-Jeff
From jeff at infidigm.net  Tue Mar 20 11:58:43 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Tue Mar 20 11:56:55 2007
Subject: [cairo] CAIRO_OPERATOR_SOURCE not handled by backend
In-Reply-To: <20070320185514.GA26912@infidigm.net>
References: <20070320173558.166360@gmx.net>
	<20070320174937.GA26484@infidigm.net>
	<20070320181813.311520@gmx.net>
	<20070320185514.GA26912@infidigm.net>
Message-ID: <20070320185843.GB26912@infidigm.net>

On Tue, Mar 20, 2007 at 02:55:14PM -0400, Jeff Muizelaar wrote:
> > > Either way _clip_and_composite should probably
> > > be changed to try to do the operation and the backends that don't
> > > support it should return STATUS_UNSUPPORTED. Only then, should cairo
> > > fallback to trying (src IN mask IN clip) ADD (dst OUT (mask IN clip)).
> > 
> > This means a change to all of the existing backends too? I will do that if there is no easier way.
> 
> Yes, that's probably what you'll have to do.

Out of curiosity, what is your cairo backend targeting?

-Jeff
From cworth at cworth.org  Tue Mar 20 13:49:11 2007
From: cworth at cworth.org (Carl Worth)
Date: Tue Mar 20 13:51:02 2007
Subject: [cairo] Projective transformations
In-Reply-To: <4a305d880703200804h1877f62br1a201d5f11831fec@mail.gmail.com>
References: <4a305d880703200804h1877f62br1a201d5f11831fec@mail.gmail.com>
Message-ID: <877itbabeg.wl%cworth@cworth.org>

On Tue, 20 Mar 2007 16:04:17 +0100, "Christophe Dehais" wrote:
> Would it be difficult to make cairo_matrix hold a full 3x3 projective
> transformation matrix instead of an affine transformation (2x3 matrix)
> ? Such transformations (also called homography) handle perspective
> transformations and can simulate a kind of poor man's 3D.

It's been discussed before...

It seems like it would be quite appealing for doing image
transformation at least, (particularly since many of the graphics
systems underlying cairo have support for projective transformation).

One problematic aspect is that a projective transformation would
destroy the current algorithm implementing path stroking, (which
currently pre-computes a pen that is assumed to be stable throughout
the stroke). So there's at least one unsolved problem there.

A compromise position that has also been floated would be to allow a
projective matrix for pattern transformation and stick to an
affine-only matrix for the transformation matrix within the cairo
context.

That idea has been around for a long time, but no code has ever
appeared for it.

I imagine that in the meantime people that have really wanted 3D
effects have used 3D APIs for them, (often with cairo-rendered
textures: see http://cairographics.org/OpenGL).

I hope that helps explain where things stand on this issue,

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070320/44e988ab/attachment.pgp
From sebastian.tusk at gmx.net  Tue Mar 20 14:09:52 2007
From: sebastian.tusk at gmx.net (Sebastian Tusk)
Date: Tue Mar 20 14:09:56 2007
Subject: [cairo] CAIRO_OPERATOR_SOURCE not handled by backend
In-Reply-To: <20070320185843.GB26912@infidigm.net>
References: <20070320173558.166360@gmx.net>
	<20070320174937.GA26484@infidigm.net> <20070320181813.311520@gmx.net>
	<20070320185514.GA26912@infidigm.net>
	<20070320185843.GB26912@infidigm.net>
Message-ID: <20070320210952.171280@gmx.net>


> > > The reason for the special behaviour is that when SOURCE or CLEAR are
> used
> > > with
> > > a mask in cairo that mask bounds the operation. Does your backend
> > > support this behaviour?
> > 
> > The special behaviour is triggered even without a mask. For my backend I
> would handle both cases myself.
> 
> This isn't true. Without a mask (clip_surface) the special case in
> clip_and_composite_trapezoids will send the operation through to
> _composite_trap_region which passes the SOURCE operation on to the
> backend composite function through _cairo_surface_composite.

You are right.

> Out of curiosity, what is your cairo backend targeting?

DirectX 9. Unfortunately I think it is impossible to do transparently to a client application. The reason for this is that a surface in video memory can go away at any moment without a chance to safe the content. Additionally render commands can fail silently. A client application has to be aware of these issues.

Sebastian

-- 
"Feel free" - 10 GB Mailbox, 100 FreeSMS/Monat ...
Jetzt GMX TopMail testen: www.gmx.net/de/go/mailfooter/topmail-out
From cairo-2007a at ryandesign.com  Tue Mar 20 14:15:26 2007
From: cairo-2007a at ryandesign.com (Ryan Schmidt)
Date: Tue Mar 20 14:15:35 2007
Subject: [cairo] cairo-path-fixed.c: warning: comparison between signed and
	unsigned
Message-ID: <D9BA6C2C-C6A0-4982-B5F8-382A2E9AAF13@ryandesign.com>

Hello everybody. Compiling cairo 1.4.2 on Mac OS X 10.4.9, I get this  
output:

cairo-path-fixed.c: In function '_cairo_path_fixed_add':
cairo-path-fixed.c:359: warning: comparison between signed and unsigned
cairo-path-fixed.c:360: warning: comparison between signed and unsigned

Version 1.4.0 didn't do that.


From behdad at behdad.org  Tue Mar 20 14:30:52 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Tue Mar 20 14:31:15 2007
Subject: [cairo] Projective transformations
In-Reply-To: <877itbabeg.wl%cworth@cworth.org>
References: <4a305d880703200804h1877f62br1a201d5f11831fec@mail.gmail.com>
	<877itbabeg.wl%cworth@cworth.org>
Message-ID: <1174426252.14263.1.camel@behdad>

On Tue, 2007-03-20 at 16:49 -0400, Carl Worth wrote:
> 
> It seems like it would be quite appealing for doing image
> transformation at least, (particularly since many of the graphics
> systems underlying cairo have support for projective transformation).

Do they?  Ok, let's start!  Do Render, win32, and Quartz support them?

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From cworth at cworth.org  Tue Mar 20 14:52:45 2007
From: cworth at cworth.org (Carl Worth)
Date: Tue Mar 20 14:53:24 2007
Subject: [cairo] CAIRO_OPERATOR_SOURCE not handled by backend
In-Reply-To: <20070320181813.311520@gmx.net>
References: <20070320173558.166360@gmx.net>
	<20070320174937.GA26484@infidigm.net>
	<20070320181813.311520@gmx.net>
Message-ID: <87648va8gi.wl%cworth@cworth.org>

On Tue, 20 Mar 2007 19:18:13 +0100, "Sebastian Tusk" wrote:
> > XRender can not. I am not sure about the other backends, though I think
> > Quartz (at least newer ones) might be able to do it more efficiently.
>
> Is this an API limitation?

The Render interface was defined with the following compositing
equation:

	destination' = (source IN mask) OP destination

and also defined to act only within a rectangle, (either explicit in
the case of Composite or implicitly in the case of CompositeTrapezoids
where Render uses the bounding box of the trapezoids).

If you plug SOURCE in as OP in the above equation, the result is
effectively copying the source to the destination "inside" the mask,
and zeroing out the destination everywhere "outside" the mask, but
inside the appropriate rectangle.

That turns out to be a rather unuseful result, particularly in the
case of CompositeTrapezoids. If cairo sets up a list of trapezoids
representing some filled path, and passes those directly to Render's
CompositeTrapezoids call, the result is a big, ugly black box that
appears around the bounds of the trapezoid.

When developing cairo, we wrote code that did exactly that, and saw
that big, ugly box. It's obviously not useful for anything,
(basically, no cairo rendering of a path should have any effect that
makes the bounding box appear). So we went through the effort to
decide what would be useful instead.

One option would have been to allow the zeroing out of the destination
to occur everywhere "outside" of the mask.

But even that wasn't satisfying as a useful thing for cairo to
provide. We asked the question: If a user specifies the SOURCE
operator and asks to fill a path, what should the user expect to get?
The answer we came up with is that the user should get the result of
doing (source SOURCE dest) but restricted to operate within the mask.

For all the gory details that led to this, we can thank Owen Taylor
for providing a lot of insight, a bunch of careful math and
experimentation and some useful writeups (this all took place just
before the cairo 1.0 release which froze the currently implemented
semantics):

	Details of revised rendering equation
	http://lists.freedesktop.org/archives/cairo/2005-August/004718.html

	Redoing SOURCE and CLEAR
	http://article.gmane.org/gmane.comp.lib.cairo/4791

The first details how we took Render's equation above and extended it
to handle cairo's notion of clipping. The second details the change we
made to SOURCE and CLEAR so that they operate only within the mask and
not outside of it.

So the messages above, (along with others in the threads), contain
most the information that really needs to be extracted out to form the
introductory chapter of a document describing cairo's imaging model.

Meanwhile, a lot of the internals of cairo, (including the surface
backend interface), still retain a lot of the original Render heritage
from which they were originally based. So the complex code you see in
_clip_and_composite is the strategy for implementing the "new" cairo
semantics on top of the "old" Render semantics.

And as Jeff described, what would be much nicer to have internally
would be something that tried to execute cairo's semantics through the
backend, and only fell back to the current workarounds if the backend
couldn't deal with it. This might allow your backend, (what is it, by
the way?), to be implemented more efficiently. It might also allow for
a future revision of the Render specification which would allow cairo
to use a more efficient implementation.

I hope that helps explain things,

-Carl

PS. For reference, here are the final equations that Owen proposed in
the second message linked to above, (and I believe these are the final
semantics adopted into cairo 1.0 and all subsequent releases and
codified in cairo's test suite):

On 2005-08-17, at 15:45:19 GMT Owen Taylor wrote:
>
> So, the proposal here is to logically divide the operators into
> 4 groups by what definition we use:
>
>  OVER, ATOP, DEST, DEST_OVER, DEST_OUT, XOR, ADD
>
>    All definitions equivalent
>
>  SOURCE, CLEAR
>
>    (mask IN clip) ? src OP dest : dest
>
>  IN, OUT, DEST_IN, DEST_ATOP
>
>    clip ? (src IN mask) OP dest : dest
>
>  SATURATE
>
>    (src IN mask IN clip) OP dest
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070320/2ce2921e/attachment.pgp
From behdad at behdad.org  Tue Mar 20 15:08:28 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Tue Mar 20 15:08:45 2007
Subject: [cairo] cairo-path-fixed.c: warning: comparison between signed
	and unsigned
In-Reply-To: <D9BA6C2C-C6A0-4982-B5F8-382A2E9AAF13@ryandesign.com>
References: <D9BA6C2C-C6A0-4982-B5F8-382A2E9AAF13@ryandesign.com>
Message-ID: <1174428508.14263.5.camel@behdad>

On Tue, 2007-03-20 at 17:15 -0400, Ryan Schmidt wrote:
> Hello everybody. Compiling cairo 1.4.2 on Mac OS X 10.4.9, I get this  
> output:
> 
> cairo-path-fixed.c: In function '_cairo_path_fixed_add':
> cairo-path-fixed.c:359: warning: comparison between signed and unsigned
> cairo-path-fixed.c:360: warning: comparison between signed and unsigned
> 
> Version 1.4.0 didn't do that.

Fixed.  Thanks.

I cannot seem to fix this warning though:

cairo-output-stream.c:309: warning: ignoring return value of 'strtol',
declared with attribute warn_unused_result

I thought casting to void will fix it, but it doesn't.  Assigning the
return value to a variable causes an unused-variable warning.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From whydoubt at yahoo.com  Tue Mar 20 21:02:45 2007
From: whydoubt at yahoo.com (Jeff Smith)
Date: Tue Mar 20 21:02:48 2007
Subject: [cairo] cairo-path-fixed.c: warning: comparison between signed
	and unsigned
Message-ID: <229565.27102.qm@web54302.mail.yahoo.com>

> cairo-output-stream.c:309: warning: ignoring return value of 'strtol',
> declared with attribute warn_unused_result

> I thought casting to void will fix it, but it doesn't.  Assigning the
> return value to a variable causes an unused-variable warning.

Since it's just eating characters (more specifically digits), the attached
patch should take care of it

 -- Jeff Smith




 
____________________________________________________________________________________
Bored stiff? Loosen up... 
Download and play hundreds of games for free on Yahoo! Games.
http://games.yahoo.com/games/front
-------------- next part --------------
A non-text attachment was scrubbed...
Name: =?utf-8?q?remove=5Fstrtol.patch?=
Type: application/octet-stream
Size: 632 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070320/2cf16c20/utf-8qremove5Fstrtol.obj
From spitzak at d2.com  Wed Mar 21 04:00:46 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Wed Mar 21 04:01:03 2007
Subject: [cairo] Projective transformations
In-Reply-To: <877itbabeg.wl%cworth@cworth.org>
References: <4a305d880703200804h1877f62br1a201d5f11831fec@mail.gmail.com>
	<877itbabeg.wl%cworth@cworth.org>
Message-ID: <4601105E.5090200@d2.com>

Carl Worth wrote:

> One problematic aspect is that a projective transformation would
> destroy the current algorithm implementing path stroking, (which
> currently pre-computes a pen that is assumed to be stable throughout
> the stroke). So there's at least one unsolved problem there.

It would not be a problem if the pen and font were fixed to the ctm at 
the moment they were specified, rather than changing with the ctm. This 
is in fact one of the primary reasons I want this change.

The result you are suggesting is not very useful, as it can be 
duplicated by drawing on a flat surface and then perspective 
transforming that image, and in fact that is probably the only practical 
way to implement it. Far more interesting is to be able to draw with a 
pen and font that does not change size with distance and remains 
parallel to the screen, which has the added benefit that it is quite 
easy to make the existing Cairo do this.

PS: Choosing a font or line width when a perspective transform is in 
effect should choose the affine transform that would happen for x==y==0.
From lots.of.mailing.lists at gmail.com  Wed Mar 21 05:19:00 2007
From: lots.of.mailing.lists at gmail.com (Alex Mac)
Date: Wed Mar 21 05:25:07 2007
Subject: [cairo] svg surface problems
Message-ID: <1b420d380703210519j3cf26fb2sfcc7fa2fcb71ef71@mail.gmail.com>

when I use pango to render some text to an svg surface cairo generates
a path for each glyph and then references them to achieve the result.
I know this will solve problems of people not having the right fonts
installed but it makes the svg files massive and unusable if you
actually need to extract the text content, is there anyway I can tell
cairo to just generate <svg:text> elements?

Also cairo adds a rectangular clipping path to the svg file which is
pointless as the outer <svg:svg> element has an implicit clipping
path. How do I disable this?

thanks,
Alex
From emmanuel.pacaud at lapp.in2p3.fr  Wed Mar 21 05:49:12 2007
From: emmanuel.pacaud at lapp.in2p3.fr (Emmanuel Pacaud)
Date: Wed Mar 21 05:49:19 2007
Subject: [cairo] svg surface problems
In-Reply-To: <1b420d380703210519j3cf26fb2sfcc7fa2fcb71ef71@mail.gmail.com>
References: <1b420d380703210519j3cf26fb2sfcc7fa2fcb71ef71@mail.gmail.com>
Message-ID: <1174481352.6758.9.camel@lappc-p087.in2p3.fr>

Le mercredi 21 mars 2007 ? 12:19 +0000, Alex Mac a ?crit :
> when I use pango to render some text to an svg surface cairo generates
> a path for each glyph and then references them to achieve the result.
> I know this will solve problems of people not having the right fonts
> installed but it makes the svg files massive and unusable if you
> actually need to extract the text content, is there anyway I can tell
> cairo to just generate <svg:text> elements?

The current SVG backend behaviour is due to the fact it is given only a
list on glyphs to display, without the original utf8 string. So emitting
a <text> element is not straightforward. We could probably do something
similar to what's done in the PDF backend, but that's not implemented
yet.

> Also cairo adds a rectangular clipping path to the svg file which is
> pointless as the outer <svg:svg> element has an implicit clipping
> path. How do I disable this?

I don't remember exactly why I've added this clipping rectangle. I'll
try to have a look at this issue soon.

	Emmanuel.
> 
> thanks,
> Alex
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
-- 
Emmanuel PACAUD
Groupe Virgo
LAPP - Laboratoire d'Annecy-le-Vieux de physique des particules
9, chemin de Bellevue - BP 110
74941 Annecy-le-Vieux CEDEX
France
T?l: (+33)4 50 09 17 89 - Fax: (+33)4 50 27 94 95

From behdad at behdad.org  Wed Mar 21 06:42:59 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 21 06:43:02 2007
Subject: [cairo] Projective transformations
In-Reply-To: <4601105E.5090200@d2.com>
References: <4a305d880703200804h1877f62br1a201d5f11831fec@mail.gmail.com>
	<877itbabeg.wl%cworth@cworth.org>  <4601105E.5090200@d2.com>
Message-ID: <1174484579.32053.5.camel@behdad>

On Wed, 2007-03-21 at 07:00 -0400, Bill Spitzak wrote:
> Carl Worth wrote:
> 
> > One problematic aspect is that a projective transformation would
> > destroy the current algorithm implementing path stroking, (which
> > currently pre-computes a pen that is assumed to be stable throughout
> > the stroke). So there's at least one unsolved problem there.
> 
> It would not be a problem if the pen and font were fixed to the ctm at 
> the moment they were specified, rather than changing with the ctm. This 
> is in fact one of the primary reasons I want this change.
> 
> The result you are suggesting is not very useful, as it can be 
> duplicated by drawing on a flat surface and then perspective 
> transforming that image, and in fact that is probably the only practical 
> way to implement it. Far more interesting is to be able to draw with a 
> pen and font that does not change size with distance and remains 
> parallel to the screen, which has the added benefit that it is quite 
> easy to make the existing Cairo do this.
> 
> PS: Choosing a font or line width when a perspective transform is in 
> effect should choose the affine transform that would happen for x==y==0.

Good points.  Maybe we can start up the lock-pen-width thread again.
Anyone volunteering to update the patch to current master?

Speaking of projective transformations, they make
cairo_transform_distance() obsolete.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From johannes.schmid at openismus.com  Wed Mar 21 06:28:29 2007
From: johannes.schmid at openismus.com (Johannes Schmid)
Date: Wed Mar 21 06:50:59 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <1173895459.14946.4.camel@behdad>
References: <1173884708.5780.19.camel@murrayc-desktop>	
	<87k5xjycox.wl%cworth@cworth.org> <1173895376.14946.2.camel@behdad>
	<1173895459.14946.4.camel@behdad>
Message-ID: <460132FD.6060407@openismus.com>

Hi Behded!

Behdad Esfahbod schrieb:
>> Create an image surface and render something in the default language and
>> default font ("Sans"?) to it using pangocairo.
> 
> For extra, do it for all font-descriptions that your UI uses (all
> "default" font face+size combinations).

I am not very familiar to cairo but I tried this without any speed-up:

context = pango_cairo_font_map_create_context (
	PANGO_CAIRO_FONT_MAP(pango_cairo_font_map_get_default()));
pango_context_load_font (context, 	
	pango_font_description_from_string("Sans"));

Maybe someone could point me to the methods I should use to render
something to the pango image surface because I could not figure out yet
with the reference documentation.

Thanks and regards,
Johannes
From otaylor at redhat.com  Wed Mar 21 07:07:39 2007
From: otaylor at redhat.com (Owen Taylor)
Date: Wed Mar 21 07:07:51 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <460132FD.6060407@openismus.com>
References: <1173884708.5780.19.camel@murrayc-desktop>
	<87k5xjycox.wl%cworth@cworth.org> <1173895376.14946.2.camel@behdad>
	<1173895459.14946.4.camel@behdad>  <460132FD.6060407@openismus.com>
Message-ID: <1174486059.19078.151.camel@localhost.localdomain>

On Wed, 2007-03-21 at 14:28 +0100, Johannes Schmid wrote:
> Hi Behded!
> 
> Behdad Esfahbod schrieb:
> >> Create an image surface and render something in the default language and
> >> default font ("Sans"?) to it using pangocairo.
> > 
> > For extra, do it for all font-descriptions that your UI uses (all
> > "default" font face+size combinations).
> 
> I am not very familiar to cairo but I tried this without any speed-up:
> 
> context = pango_cairo_font_map_create_context (
> 	PANGO_CAIRO_FONT_MAP(pango_cairo_font_map_get_default()));
> pango_context_load_font (context, 	
> 	pango_font_description_from_string("Sans"));

Hmm, I would have actually thought that this would work, but I'd 
certainly trust Behdad's suggestion - "render something" - more.

> Maybe someone could point me to the methods I should use to render
> something to the pango image surface because I could not figure out yet
> with the reference documentation.

http://svn.gnome.org/viewcvs/pango/trunk/examples/cairosimple.c?view=markup

may help. (Obviously, it can get a lot simpler than that, but it shows
the basics of rendering to an image surface)

It could just be that the fontconfig memmap'ed cache stuff has dropped
startup overhead low enough that the advantage of pre-initializing
things is small.
						- Owen


From behdad at behdad.org  Wed Mar 21 07:21:09 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 21 07:21:18 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <460132FD.6060407@openismus.com>
References: <1173884708.5780.19.camel@murrayc-desktop>
	<87k5xjycox.wl%cworth@cworth.org>  <1173895376.14946.2.camel@behdad>
	<1173895459.14946.4.camel@behdad>  <460132FD.6060407@openismus.com>
Message-ID: <1174486869.32053.12.camel@behdad>

On Wed, 2007-03-21 at 14:28 +0100, Johannes Schmid wrote:
> Hi Behded!
> 
> Behdad Esfahbod schrieb:
> >> Create an image surface and render something in the default language and
> >> default font ("Sans"?) to it using pangocairo.
> > 
> > For extra, do it for all font-descriptions that your UI uses (all
> > "default" font face+size combinations).
> 
> I am not very familiar to cairo but I tried this without any speed-up:
> 
> context = pango_cairo_font_map_create_context (
> 	PANGO_CAIRO_FONT_MAP(pango_cairo_font_map_get_default()));
> pango_context_load_font (context, 	
> 	pango_font_description_from_string("Sans"));

Probably because as Owen says, fontconfig doesn't have that much of a
startup overhead anymore.  So what we can aim for is to populate pango's
cache of fontsets.  For that to work, you need to use the exact font
description that is going to be used later...  So, just "Sans" may not
be enough.  I suggest you create a context from a Gtk+ widget for
example (gtk_widget_create_context).  That ensures that you get the font
from the style right.


> Maybe someone could point me to the methods I should use to render
> something to the pango image surface because I could not figure out yet
> with the reference documentation.

pango_cairo_show_layout() works.

> Thanks and regards,
> Johannes

Cheers,
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Wed Mar 21 07:22:25 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 21 07:22:29 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <460132FD.6060407@openismus.com>
References: <1173884708.5780.19.camel@murrayc-desktop>
	<87k5xjycox.wl%cworth@cworth.org>  <1173895376.14946.2.camel@behdad>
	<1173895459.14946.4.camel@behdad>  <460132FD.6060407@openismus.com>
Message-ID: <1174486945.32053.15.camel@behdad>

On Wed, 2007-03-21 at 14:28 +0100, Johannes Schmid wrote:
> 
> I am not very familiar to cairo but I tried this without any speed-up:

So, another answer is: maybe there's not much to gain by early
initializing pango...  You should do some measurements first.  Try to
measure private memory too...

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Wed Mar 21 07:42:13 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 21 07:42:19 2007
Subject: [cairo] cairo-path-fixed.c: warning: comparison between signed
	and unsigned
In-Reply-To: <229565.27102.qm@web54302.mail.yahoo.com>
References: <229565.27102.qm@web54302.mail.yahoo.com>
Message-ID: <1174488133.1028.1.camel@behdad>

On Wed, 2007-03-21 at 00:02 -0400, Jeff Smith wrote:
> > cairo-output-stream.c:309: warning: ignoring return value of 'strtol',
> > declared with attribute warn_unused_result
> 
> > I thought casting to void will fix it, but it doesn't.  Assigning the
> > return value to a variable causes an unused-variable warning.
> 
> Since it's just eating characters (more specifically digits), the attached
> patch should take care of it

Thanks.  Committed.

>  -- Jeff Smith

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From chris at chris-wilson.co.uk  Wed Mar 21 09:51:34 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar 21 09:51:47 2007
Subject: [cairo] Add attribute(warn_unused_result)
Message-ID: <20070321165133.GA10524@inspired.chris-wilson.co.uk>

By adding the gcc warn_unused_result attribute to the function
definitions, we can catch the a common mistake of forgetting to check
for an error returned from a function at compile time.

As could be expected from the coverage and testing pattern this method
found far more mistakes than the random malloc-failure method, but it
also failed to detect some of logic errors that the failure mode testing
revealed.
-------------- next part --------------
>From 1947a07fed338d723eaf5c258dbacb4aa1a838ba Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 21 Mar 2007 13:04:53 +0000
Subject: [PATCH] Add attribute(warn_unused_result)

This adds a compiler check that the function result is used by the caller
and enables it by default for all cairo_private functions and for public
API that returns a cairo_status_t.

Unfortunately, I have found no way to disable the spurious warnings from
gcc when applying the attribute to variables or functions returning void.
To placate gcc, new function types have been introduced to manually avoid
the warning.  So we now have cairo_public_warn/cairo_public and
cairo_private/cairo_private_no_warn - choosen as the majority of internal
functions should be checking for errors!, whereas only a minority of the
public API requires an immediate error check.

To extend the warning to all functions, a new function type has been
introduced to cover static functions: cairo_static/cairo_static_no_warn.
---
 configure.in                            |   10 ++
 src/cairo-arc-private.h                 |    4 +-
 src/cairo-cache-private.h               |    8 +-
 src/cairo-clip-private.h                |   12 +-
 src/cairo-freelist-private.h            |    6 +-
 src/cairo-ft-private.h                  |    2 +-
 src/cairo-hash-private.h                |    6 +-
 src/cairo-output-stream-private.h       |   14 +-
 src/cairo-output-stream.c               |    4 +-
 src/cairo-paginated-surface.c           |    4 +-
 src/cairo-path-private.h                |    2 +-
 src/cairo-scaled-font-subsets-private.h |   10 +-
 src/cairo-skiplist-private.h            |    8 +-
 src/cairo.h                             |   40 +++---
 src/cairoint.h                          |  205 ++++++++++++++++---------------
 src/check-headers.sh                    |    2 +-
 16 files changed, 178 insertions(+), 159 deletions(-)

diff --git a/configure.in b/configure.in
index 0b3e9fa..500f121 100644
--- a/configure.in
+++ b/configure.in
@@ -823,9 +823,19 @@ AC_CONFIG_COMMANDS([src/cairo-features.h],
 # define CAIRO_END_DECLS
 #endif
 
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#define CAIRO_WARN_UNUSED_RESULT 		\
+  __attribute__((__warn_unused_result__))
+#else
+#define CAIRO_WARN_UNUSED_RESULT
+#endif /* __GNUC__ */
+
 #ifndef cairo_public
 # define cairo_public
 #endif
+#ifndef cairo_public_warn
+# define cairo_public_warn CAIRO_WARN_UNUSED_RESULT
+#endif
 
 #define CAIRO_VERSION_MAJOR $CAIRO_VERSION_MAJOR
 #define CAIRO_VERSION_MINOR $CAIRO_VERSION_MINOR
diff --git a/src/cairo-arc-private.h b/src/cairo-arc-private.h
index 633fbfa..6885103 100644
--- a/src/cairo-arc-private.h
+++ b/src/cairo-arc-private.h
@@ -38,7 +38,7 @@
 
 #include "cairoint.h"
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_arc_path (cairo_t *cr,
 		 double	  xc,
 		 double	  yc,
@@ -46,7 +46,7 @@ _cairo_arc_path (cairo_t *cr,
 		 double	  angle1,
 		 double	  angle2);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_arc_path_negative (cairo_t *cr,
 			  double   xc,
 			  double   yc,
diff --git a/src/cairo-cache-private.h b/src/cairo-cache-private.h
index 566dbe2..836963f 100644
--- a/src/cairo-cache-private.h
+++ b/src/cairo-cache-private.h
@@ -99,13 +99,13 @@ _cairo_cache_create (cairo_cache_keys_equal_func_t keys_equal,
 		     cairo_destroy_func_t	   entry_destroy,
 		     unsigned long		   max_size);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_cache_destroy (cairo_cache_t *cache);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_cache_freeze (cairo_cache_t *cache);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_cache_thaw (cairo_cache_t *cache);
 
 cairo_private cairo_bool_t
@@ -117,7 +117,7 @@ cairo_private cairo_status_t
 _cairo_cache_insert (cairo_cache_t	 *cache,
 		     cairo_cache_entry_t *entry);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_cache_foreach (cairo_cache_t 	      	 *cache,
 		      cairo_cache_callback_func_t cache_callback,
 		      void			 *closure);
diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index 3c4ff0d..c2d2036 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -38,7 +38,7 @@
 
 #include "cairo-path-fixed-private.h"
 
-extern cairo_private const cairo_rectangle_list_t _cairo_rectangles_nil;
+extern const cairo_private_no_warn cairo_rectangle_list_t _cairo_rectangles_nil;
 
 struct _cairo_clip_path {
     unsigned int	ref_count;
@@ -80,16 +80,16 @@ struct _cairo_clip {
     cairo_clip_path_t *path;
 };
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_clip_fini (cairo_clip_t *clip);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target);
@@ -121,7 +121,7 @@ _cairo_clip_combine_to_surface (cairo_clip_t                  *clip,
 				int                            dst_y,
 				const cairo_rectangle_int16_t *extents);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_clip_translate (cairo_clip_t  *clip,
                        cairo_fixed_t  tx,
                        cairo_fixed_t  ty);
diff --git a/src/cairo-freelist-private.h b/src/cairo-freelist-private.h
index 41855f7..0631c9c 100644
--- a/src/cairo-freelist-private.h
+++ b/src/cairo-freelist-private.h
@@ -43,11 +43,11 @@ struct _cairo_freelist {
 
 /* Initialise a freelist that will be responsible for allocating
  * nodes of size nodesize. */
-cairo_private void
+cairo_private_no_warn void
 _cairo_freelist_init (cairo_freelist_t *freelist, unsigned nodesize);
 
 /* Deallocate any nodes in the freelist. */
-cairo_private void
+cairo_private_no_warn void
 _cairo_freelist_fini (cairo_freelist_t *freelist);
 
 /* Allocate a new node from the freelist.  If the freelist contains no
@@ -67,7 +67,7 @@ _cairo_freelist_calloc (cairo_freelist_t *freelist);
 /* Return a node to the freelist. This does not deallocate the memory,
  * but makes it available for later reuse by
  * _cairo_freelist_alloc(). */
-cairo_private void
+cairo_private_no_warn void
 _cairo_freelist_free (cairo_freelist_t *freelist, void *node);
 
 #endif /* CAIRO_FREELIST_H */
diff --git a/src/cairo-ft-private.h b/src/cairo-ft-private.h
index 3e28f5e..53b03b9 100644
--- a/src/cairo-ft-private.h
+++ b/src/cairo-ft-private.h
@@ -61,7 +61,7 @@ _cairo_ft_scaled_font_get_unscaled_font (cairo_scaled_font_t *scaled_font);
 cairo_private FT_Face
 _cairo_ft_unscaled_font_lock_face (cairo_ft_unscaled_font_t *unscaled);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_ft_unscaled_font_unlock_face (cairo_ft_unscaled_font_t *unscaled);
 
 cairo_private cairo_bool_t
diff --git a/src/cairo-hash-private.h b/src/cairo-hash-private.h
index 617b841..68b4cff 100644
--- a/src/cairo-hash-private.h
+++ b/src/cairo-hash-private.h
@@ -97,7 +97,7 @@ typedef void
 cairo_private cairo_hash_table_t *
 _cairo_hash_table_create (cairo_hash_keys_equal_func_t keys_equal);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_hash_table_destroy (cairo_hash_table_t *hash_table);
 
 cairo_private cairo_bool_t
@@ -113,11 +113,11 @@ cairo_private cairo_status_t
 _cairo_hash_table_insert (cairo_hash_table_t *hash_table,
 			  cairo_hash_entry_t *entry);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_hash_table_remove (cairo_hash_table_t *hash_table,
 			  cairo_hash_entry_t *key);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_hash_table_foreach (cairo_hash_table_t 	      *hash_table,
 			   cairo_hash_callback_func_t  hash_callback,
 			   void			      *closure);
diff --git a/src/cairo-output-stream-private.h b/src/cairo-output-stream-private.h
index d68fbb4..7ed5cf4 100644
--- a/src/cairo-output-stream-private.h
+++ b/src/cairo-output-stream-private.h
@@ -53,9 +53,9 @@ struct _cairo_output_stream {
     cairo_bool_t		     closed;
 };
 
-extern const cairo_private cairo_output_stream_t cairo_output_stream_nil;
+extern const cairo_private_no_warn cairo_output_stream_t cairo_output_stream_nil;
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_output_stream_init (cairo_output_stream_t            *stream,
 			   cairo_output_stream_write_func_t  write_func,
 			   cairo_output_stream_close_func_t  close_func);
@@ -98,11 +98,11 @@ _cairo_output_stream_close (cairo_output_stream_t *stream);
 cairo_private cairo_status_t
 _cairo_output_stream_destroy (cairo_output_stream_t *stream);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_output_stream_write (cairo_output_stream_t *stream,
 			    const void *data, size_t length);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_output_stream_write_hex_string (cairo_output_stream_t *stream,
 				       const char *data,
 				       size_t length);
@@ -110,11 +110,11 @@ _cairo_output_stream_write_hex_string (cairo_output_stream_t *stream,
 cairo_private int
 _cairo_dtostr (char *buffer, size_t size, double d);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_output_stream_vprintf (cairo_output_stream_t *stream,
 			      const char *fmt, va_list ap);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_output_stream_printf (cairo_output_stream_t *stream,
 			     const char *fmt, ...);
 
@@ -148,7 +148,7 @@ _cairo_output_stream_create_for_file (FILE *file);
 cairo_private cairo_output_stream_t *
 _cairo_memory_stream_create (void);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_memory_stream_copy (cairo_output_stream_t *base,
 			   cairo_output_stream_t *dest);
 
diff --git a/src/cairo-output-stream.c b/src/cairo-output-stream.c
index df3ae4d..8a6cacf 100644
--- a/src/cairo-output-stream.c
+++ b/src/cairo-output-stream.c
@@ -45,7 +45,7 @@
 #endif /* _MSC_VER */
 
 
-cairo_private void
+void
 _cairo_output_stream_init (cairo_output_stream_t            *stream,
 			   cairo_output_stream_write_func_t  write_func,
 			   cairo_output_stream_close_func_t  close_func)
@@ -57,7 +57,7 @@ _cairo_output_stream_init (cairo_output_stream_t            *stream,
     stream->closed = FALSE;
 }
 
-cairo_private cairo_status_t
+cairo_status_t
 _cairo_output_stream_fini (cairo_output_stream_t *stream)
 {
     return _cairo_output_stream_close (stream);
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index c8e4612..64a9cbf 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -75,7 +75,7 @@ typedef struct _cairo_paginated_surface {
 
 } cairo_paginated_surface_t;
 
-const cairo_private cairo_surface_backend_t cairo_paginated_surface_backend;
+static const cairo_surface_backend_t cairo_paginated_surface_backend;
 
 static cairo_int_status_t
 _cairo_paginated_surface_show_page (void *abstract_surface);
@@ -517,7 +517,7 @@ _cairo_paginated_surface_snapshot (void *abstract_other)
 #endif
 }
 
-const cairo_surface_backend_t cairo_paginated_surface_backend = {
+static const cairo_surface_backend_t cairo_paginated_surface_backend = {
     CAIRO_INTERNAL_SURFACE_TYPE_PAGINATED,
     _cairo_paginated_surface_create_similar,
     _cairo_paginated_surface_finish,
diff --git a/src/cairo-path-private.h b/src/cairo-path-private.h
index d855c19..9e505c0 100644
--- a/src/cairo-path-private.h
+++ b/src/cairo-path-private.h
@@ -39,7 +39,7 @@
 
 #include "cairoint.h"
 
-extern const cairo_private cairo_path_t _cairo_path_nil;
+extern const cairo_private_no_warn cairo_path_t _cairo_path_nil;
 
 cairo_private cairo_path_t *
 _cairo_path_create (cairo_path_fixed_t *path,
diff --git a/src/cairo-scaled-font-subsets-private.h b/src/cairo-scaled-font-subsets-private.h
index 5104340..ba70875 100644
--- a/src/cairo-scaled-font-subsets-private.h
+++ b/src/cairo-scaled-font-subsets-private.h
@@ -77,7 +77,7 @@ _cairo_scaled_font_subsets_create (int max_glyphs_unscaled_per_subset,
  *
  * Destroys @font_subsets and all resources associated with it.
  **/
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_font_subsets_destroy (cairo_scaled_font_subsets_t *font_subsets);
 
 /**
@@ -250,7 +250,7 @@ _cairo_cff_subset_init (cairo_cff_subset_t          *cff_subset,
  * call, @cff_subset should not be used again without a
  * subsequent call to _cairo_cff_subset_init() again first.
  **/
-cairo_private void
+cairo_private_no_warn void
 _cairo_cff_subset_fini (cairo_cff_subset_t *cff_subset);
 
 typedef struct _cairo_truetype_subset {
@@ -292,7 +292,7 @@ _cairo_truetype_subset_init (cairo_truetype_subset_t    *truetype_subset,
  * call, @truetype_subset should not be used again without a
  * subsequent call to _cairo_truetype_subset_init() again first.
  **/
-cairo_private void
+cairo_private_no_warn void
 _cairo_truetype_subset_fini (cairo_truetype_subset_t *truetype_subset);
 
 
@@ -338,7 +338,7 @@ _cairo_type1_subset_init (cairo_type1_subset_t		*type_subset,
  * @type1_subset should not be used again without a subsequent call to
  * _cairo_truetype_type1_init() again first.
  **/
-cairo_private void
+cairo_private_no_warn void
 _cairo_type1_subset_fini (cairo_type1_subset_t *subset);
 
 /**
@@ -391,7 +391,7 @@ _cairo_type1_fallback_init_hex (cairo_type1_subset_t	   *type_subset,
  * @type1_subset should not be used again without a subsequent call to
  * _cairo_truetype_type1_init() again first.
  **/
-cairo_private void
+cairo_private_no_warn void
 _cairo_type1_fallback_fini (cairo_type1_subset_t *subset);
 
 /**
diff --git a/src/cairo-skiplist-private.h b/src/cairo-skiplist-private.h
index b152f4b..505f7fe 100644
--- a/src/cairo-skiplist-private.h
+++ b/src/cairo-skiplist-private.h
@@ -64,7 +64,7 @@ typedef struct _skip_list {
  * sizeof) is passed for elt_size. Note that the structure used for
  * list elements must have as its final member a skip_elt_t
  */
-cairo_private void
+cairo_private_no_warn void
 _cairo_skip_list_init (cairo_skip_list_t		*list,
 		cairo_skip_list_compare_t	 compare,
 		size_t			 elt_size);
@@ -73,7 +73,7 @@ _cairo_skip_list_init (cairo_skip_list_t		*list,
 /* Deallocate resources associated with a skip list and all elements
  * in it. (XXX: currently this simply deletes all elements.)
  */
-cairo_private void
+cairo_private_no_warn void
 _cairo_skip_list_fini (cairo_skip_list_t		*list);
 
 /* Insert a new element into the list at the correct sort order as
@@ -89,11 +89,11 @@ cairo_private void *
 _cairo_skip_list_find (cairo_skip_list_t *list, void *data);
 
 /* Delete an element which compare considers equal to <data> */
-cairo_private void
+cairo_private_no_warn void
 _cairo_skip_list_delete (cairo_skip_list_t *list, void *data);
 
 /* Delete the given element from the list. */
-cairo_private void
+cairo_private_no_warn void
 _cairo_skip_list_delete_given (cairo_skip_list_t *list, skip_elt_t *given);
 
 #endif
diff --git a/src/cairo.h b/src/cairo.h
index a80efde..5fc05e3 100644
--- a/src/cairo.h
+++ b/src/cairo.h
@@ -313,7 +313,7 @@ cairo_public void *
 cairo_get_user_data (cairo_t			 *cr,
 		     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_set_user_data (cairo_t			 *cr,
 		     const cairo_user_data_key_t *key,
 		     void			 *user_data,
@@ -972,7 +972,7 @@ cairo_font_options_copy (const cairo_font_options_t *original);
 cairo_public void
 cairo_font_options_destroy (cairo_font_options_t *options);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_options_status (cairo_font_options_t *options);
 
 cairo_public void
@@ -1088,7 +1088,7 @@ cairo_font_face_destroy (cairo_font_face_t *font_face);
 cairo_public unsigned int
 cairo_font_face_get_reference_count (cairo_font_face_t *font_face);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_face_status (cairo_font_face_t *font_face);
 
 /**
@@ -1141,7 +1141,7 @@ cairo_public void *
 cairo_font_face_get_user_data (cairo_font_face_t	   *font_face,
 			       const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_face_set_user_data (cairo_font_face_t	   *font_face,
 			       const cairo_user_data_key_t *key,
 			       void			   *user_data,
@@ -1164,7 +1164,7 @@ cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font);
 cairo_public unsigned int
 cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_scaled_font_status (cairo_scaled_font_t *scaled_font);
 
 cairo_public cairo_font_type_t
@@ -1174,7 +1174,7 @@ cairo_public void *
 cairo_scaled_font_get_user_data (cairo_scaled_font_t         *scaled_font,
 				 const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_scaled_font_set_user_data (cairo_scaled_font_t         *scaled_font,
 				 const cairo_user_data_key_t *key,
 				 void                        *user_data,
@@ -1392,7 +1392,7 @@ cairo_path_destroy (cairo_path_t *path);
 
 /* Error status queries */
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_status (cairo_t *cr);
 
 cairo_public const char *
@@ -1418,7 +1418,7 @@ cairo_surface_destroy (cairo_surface_t *surface);
 cairo_public unsigned int
 cairo_surface_get_reference_count (cairo_surface_t *surface);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_status (cairo_surface_t *surface);
 
 /**
@@ -1482,11 +1482,11 @@ cairo_surface_get_content (cairo_surface_t *surface);
 
 #if CAIRO_HAS_PNG_FUNCTIONS
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_write_to_png (cairo_surface_t	*surface,
 			    const char		*filename);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_write_to_png_stream (cairo_surface_t	*surface,
 				   cairo_write_func_t	write_func,
 				   void			*closure);
@@ -1497,7 +1497,7 @@ cairo_public void *
 cairo_surface_get_user_data (cairo_surface_t		 *surface,
 			     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_set_user_data (cairo_surface_t		 *surface,
 			     const cairo_user_data_key_t *key,
 			     void			 *user_data,
@@ -1642,14 +1642,14 @@ cairo_pattern_destroy (cairo_pattern_t *pattern);
 cairo_public unsigned int
 cairo_pattern_get_reference_count (cairo_pattern_t *pattern);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_status (cairo_pattern_t *pattern);
 
 cairo_public void *
 cairo_pattern_get_user_data (cairo_pattern_t		 *pattern,
 			     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_set_user_data (cairo_pattern_t		 *pattern,
 			     const cairo_user_data_key_t *key,
 			     void			 *user_data,
@@ -1758,32 +1758,32 @@ cairo_pattern_set_filter (cairo_pattern_t *pattern, cairo_filter_t filter);
 cairo_public cairo_filter_t
 cairo_pattern_get_filter (cairo_pattern_t *pattern);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_rgba (cairo_pattern_t *pattern,
 			double *red, double *green,
 			double *blue, double *alpha);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_surface (cairo_pattern_t *pattern,
 			   cairo_surface_t **surface);
 
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_color_stop_rgba (cairo_pattern_t *pattern,
 				   int index, double *offset,
 				   double *red, double *green,
 				   double *blue, double *alpha);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_color_stop_count (cairo_pattern_t *pattern,
 				    int *count);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_linear_points (cairo_pattern_t *pattern,
 				 double *x0, double *y0,
 				 double *x1, double *y1);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_radial_circles (cairo_pattern_t *pattern,
 				  double *x0, double *y0, double *r0,
 				  double *x1, double *y1, double *r1);
@@ -1820,7 +1820,7 @@ cairo_matrix_scale (cairo_matrix_t *matrix, double sx, double sy);
 cairo_public void
 cairo_matrix_rotate (cairo_matrix_t *matrix, double radians);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_matrix_invert (cairo_matrix_t *matrix);
 
 cairo_public void
diff --git a/src/cairoint.h b/src/cairoint.h
index c31f1dc..3f25eca 100755
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -80,7 +80,7 @@ CAIRO_BEGIN_DECLS
 # define slim_hidden_proto1(name, internal)				\
   extern __typeof (name) name						\
 	__asm__ (slim_hidden_asmname (internal))			\
-	cairo_private
+	cairo_private_no_warn
 # define slim_hidden_def1(name, internal)				\
   extern __typeof (name) EXT_##name __asm__(slim_hidden_asmname(name))	\
 	__attribute__((__alias__(slim_hidden_asmname(internal))))
@@ -103,13 +103,22 @@ CAIRO_BEGIN_DECLS
 
 /* slim_internal.h */
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__)
-#define cairo_private		__attribute__((__visibility__("hidden")))
+#define cairo_private						__attribute__((__visibility__("hidden"),__warn_unused_result__))
+#define cairo_private_no_warn		__attribute__((__visibility__("hidden")))
 #elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
-#define cairo_private		__hidden
+#define cairo_private						__hidden CAIRO_WARN_UNUSED_RESULT
+#define cairo_private_no_warn		__hidden
 #else /* not gcc >= 3.3 and not Sun Studio >= 8 */
-#define cairo_private
+#define cairo_private CAIRO_WARN_UNUSED_RESULT
+#define cairo_private_no_warn
 #endif
 
+/* This allows us to conditionally expose internals during debugging,
+   and forces propagation of return values.
+*/
+#define cairo_static static CAIRO_WARN_UNUSED_RESULT
+#define cairo_static_no_warn static
+
 /* This macro allow us to deprecate a function by providing an alias
    for the old function name to the new function name. With this
    macro, binary compatibility is preserved. The macro only works on
@@ -188,8 +197,8 @@ typedef HMTX cairo_mutex_t;
 #endif
 
 #if !defined(CAIRO_MUTEX_DECLARE) && defined CAIRO_HAS_BEOS_SURFACE
-cairo_private void _cairo_beos_lock(void*);
-cairo_private void _cairo_beos_unlock(void*);
+cairo_private_no_warn void _cairo_beos_lock(void*);
+cairo_private_no_warn void _cairo_beos_unlock(void*);
   /* the real initialization takes place in a global constructor */
 # define CAIRO_MUTEX_DECLARE(name) extern void* name;
 # define CAIRO_MUTEX_DECLARE_GLOBAL(name) extern void* name;
@@ -463,10 +472,10 @@ typedef struct _cairo_image_surface cairo_image_surface_t;
 
 typedef struct _cairo_surface_backend cairo_surface_backend_t;
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_box_round_to_rectangle (cairo_box_t *box, cairo_rectangle_int16_t *rectangle);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_rectangle_intersect (cairo_rectangle_int16_t *dest, cairo_rectangle_int16_t *src);
 
 /* cairo_array.c structures and functions */
@@ -481,20 +490,20 @@ struct _cairo_array {
     cairo_bool_t is_snapshot;
 };
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_array_init (cairo_array_t *array, int element_size);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_array_init_snapshot (cairo_array_t	*array,
 			    const cairo_array_t *other);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_array_fini (cairo_array_t *array);
 
 cairo_private cairo_status_t
 _cairo_array_grow_by (cairo_array_t *array, int additional);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_array_truncate (cairo_array_t *array, unsigned int num_elements);
 
 cairo_private cairo_status_t
@@ -513,7 +522,7 @@ _cairo_array_allocate (cairo_array_t	 *array,
 cairo_private void *
 _cairo_array_index (cairo_array_t *array, unsigned int index);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_array_copy_element (cairo_array_t *array, int index, void *dst);
 
 cairo_private int
@@ -524,10 +533,10 @@ _cairo_array_size (cairo_array_t *array);
 
 typedef cairo_array_t cairo_user_data_array_t;
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_user_data_array_init (cairo_user_data_array_t *array);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_user_data_array_fini (cairo_user_data_array_t *array);
 
 cairo_private void *
@@ -654,16 +663,16 @@ struct _cairo_font_face {
     const cairo_font_face_backend_t *backend;
 };
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_font_reset_static_data (void);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_ft_font_reset_static_data (void);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_xlib_surface_reset_static_data (void);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_xlib_screen_reset_static_data (void);
 
 /* the font backend interface */
@@ -783,19 +792,19 @@ struct _cairo_font_face_backend {
 /* concrete font backends */
 #if CAIRO_HAS_FT_FONT
 
-extern const cairo_private struct _cairo_scaled_font_backend cairo_ft_scaled_font_backend;
+extern const cairo_private_no_warn struct _cairo_scaled_font_backend cairo_ft_scaled_font_backend;
 
 #endif
 
 #if CAIRO_HAS_WIN32_FONT
 
-extern const cairo_private struct _cairo_scaled_font_backend cairo_win32_scaled_font_backend;
+extern const cairo_private_no_warn struct _cairo_scaled_font_backend cairo_win32_scaled_font_backend;
 
 #endif
 
 #if CAIRO_HAS_ATSUI_FONT
 
-extern const cairo_private struct _cairo_scaled_font_backend cairo_atsui_scaled_font_backend;
+extern const cairo_private_no_warn struct _cairo_scaled_font_backend cairo_atsui_scaled_font_backend;
 
 #endif
 
@@ -1121,7 +1130,7 @@ struct _cairo_image_surface {
     pixman_image_t *pixman_image;
 };
 
-extern const cairo_private cairo_surface_backend_t cairo_image_surface_backend;
+extern const cairo_private_no_warn cairo_surface_backend_t cairo_image_surface_backend;
 
 /* XXX: Right now, the cairo_color structure puts unpremultiplied
    color in the doubles and premultiplied color in the shorts. Yes,
@@ -1167,7 +1176,7 @@ typedef struct _cairo_solid_pattern {
     cairo_color_t color;
 } cairo_solid_pattern_t;
 
-extern const cairo_private cairo_solid_pattern_t cairo_pattern_nil;
+extern const cairo_private_no_warn cairo_solid_pattern_t cairo_pattern_nil;
 
 typedef struct _cairo_surface_pattern {
     cairo_pattern_t base;
@@ -1276,7 +1285,7 @@ typedef struct _cairo_stroke_face {
 } cairo_stroke_face_t;
 
 /* cairo.c */
-cairo_private void
+cairo_private_no_warn void
 _cairo_restrict_value (double *value, double min, double max);
 
 cairo_private int
@@ -1314,19 +1323,19 @@ cairo_private cairo_status_t
 _cairo_gstate_init (cairo_gstate_t  *gstate,
 		    cairo_surface_t *target);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_fini (cairo_gstate_t *gstate);
 
 cairo_private cairo_gstate_t *
 _cairo_gstate_clone (cairo_gstate_t *gstate);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_destroy (cairo_gstate_t *gstate);
 
 cairo_private cairo_bool_t
 _cairo_gstate_is_redirected (cairo_gstate_t *gstate);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child);
 
 cairo_private cairo_surface_t *
@@ -1392,7 +1401,7 @@ _cairo_gstate_set_miter_limit (cairo_gstate_t *gstate, double limit);
 cairo_private double
 _cairo_gstate_get_miter_limit (cairo_gstate_t *gstate);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_get_matrix (cairo_gstate_t *gstate, cairo_matrix_t *matrix);
 
 cairo_private cairo_status_t
@@ -1427,13 +1436,13 @@ _cairo_gstate_device_to_user (cairo_gstate_t *gstate, double *x, double *y);
 cairo_private cairo_status_t
 _cairo_gstate_device_to_user_distance (cairo_gstate_t *gstate, double *dx, double *dy);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_user_to_backend (cairo_gstate_t *gstate, double *x, double *y);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_backend_to_user (cairo_gstate_t *gstate, double *x, double *y);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_backend_to_user_rectangle (cairo_gstate_t *gstate,
                                          double *x1, double *y1,
                                          double *x2, double *y2,
@@ -1518,7 +1527,7 @@ cairo_private cairo_status_t
 _cairo_gstate_set_font_size (cairo_gstate_t *gstate,
 			     double          size);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_get_font_matrix (cairo_gstate_t *gstate,
 			       cairo_matrix_t *matrix);
 
@@ -1526,7 +1535,7 @@ cairo_private cairo_status_t
 _cairo_gstate_set_font_matrix (cairo_gstate_t	    *gstate,
 			       const cairo_matrix_t *matrix);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_gstate_get_font_options (cairo_gstate_t       *gstate,
 				cairo_font_options_t *options);
 
@@ -1592,30 +1601,30 @@ _cairo_stock_color (cairo_stock_t stock);
 cairo_private uint16_t
 _cairo_color_double_to_short (double d);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_color_init (cairo_color_t *color);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_color_init_rgb (cairo_color_t *color,
 		       double red, double green, double blue);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_color_init_rgba (cairo_color_t *color,
 			double red, double green, double blue,
 			double alpha);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_color_multiply_alpha (cairo_color_t *color,
 			     double	    alpha);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_color_get_rgba (cairo_color_t *color,
 		       double	     *red,
 		       double	     *green,
 		       double	     *blue,
 		       double	     *alpha);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_color_get_rgba_premultiplied (cairo_color_t *color,
 				     double	   *red,
 				     double	   *green,
@@ -1624,20 +1633,20 @@ _cairo_color_get_rgba_premultiplied (cairo_color_t *color,
 
 /* cairo-font.c */
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_font_freeze_cache (cairo_scaled_font_t *scaled_font);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_font_thaw_cache (cairo_scaled_font_t *scaled_font);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_font_set_error (cairo_scaled_font_t *scaled_font,
 			      cairo_status_t status);
 
-extern const cairo_private cairo_font_face_t _cairo_font_face_nil;
-extern const cairo_private cairo_scaled_font_t _cairo_scaled_font_nil;
+extern const cairo_private_no_warn cairo_font_face_t _cairo_font_face_nil;
+extern const cairo_private_no_warn cairo_scaled_font_t _cairo_scaled_font_nil;
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_font_face_init (cairo_font_face_t               *font_face,
 		       const cairo_font_face_backend_t *backend);
 
@@ -1646,22 +1655,22 @@ _cairo_toy_font_face_create (const char           *family,
 			     cairo_font_slant_t    slant,
 			     cairo_font_weight_t   weight);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_unscaled_font_init (cairo_unscaled_font_t               *font,
 			   const cairo_unscaled_font_backend_t *backend);
 
 cairo_private cairo_unscaled_font_t *
 _cairo_unscaled_font_reference (cairo_unscaled_font_t *font);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_unscaled_font_destroy (cairo_unscaled_font_t *font);
 
 /* cairo-font-options.c */
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_font_options_init_default (cairo_font_options_t *options);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_font_options_init_copy (cairo_font_options_t		*options,
 			       const cairo_font_options_t	*other);
 
@@ -1681,7 +1690,7 @@ cairo_private cairo_bool_t
 _cairo_operator_always_translucent (cairo_operator_t op);
 
 /* cairo_path.c */
-cairo_private void
+cairo_private_no_warn void
 _cairo_path_fixed_init (cairo_path_fixed_t *path);
 
 cairo_private cairo_status_t
@@ -1691,10 +1700,10 @@ _cairo_path_fixed_init_copy (cairo_path_fixed_t *path,
 cairo_private cairo_path_fixed_t *
 _cairo_path_fixed_create (void);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_path_fixed_fini (cairo_path_fixed_t *path);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_path_fixed_destroy (cairo_path_fixed_t *path);
 
 cairo_private cairo_status_t
@@ -1702,7 +1711,7 @@ _cairo_path_fixed_move_to (cairo_path_fixed_t  *path,
 			   cairo_fixed_t	x,
 			   cairo_fixed_t	y);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_path_fixed_new_sub_path (cairo_path_fixed_t *path);
 
 cairo_private cairo_status_t
@@ -1771,7 +1780,7 @@ _cairo_path_fixed_bounds (cairo_path_fixed_t *path,
 			  double *x1, double *y1,
 			  double *x2, double *y2);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_path_fixed_device_transform (cairo_path_fixed_t	*path,
 				    cairo_matrix_t	*device_transform);
 
@@ -1801,11 +1810,11 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			 const cairo_font_options_t	   *options,
 			 const cairo_scaled_font_backend_t *backend);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_font_fini (cairo_scaled_font_t *scaled_font);
 
 cairo_private cairo_status_t
@@ -1846,17 +1855,17 @@ _cairo_scaled_font_glyph_path (cairo_scaled_font_t *scaled_font,
 			       int                  num_glyphs,
 			       cairo_path_fixed_t  *path);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_glyph_set_metrics (cairo_scaled_glyph_t *scaled_glyph,
 				 cairo_scaled_font_t *scaled_font,
 				 cairo_text_extents_t *fs_metrics);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_glyph_set_surface (cairo_scaled_glyph_t *scaled_glyph,
 				 cairo_scaled_font_t *scaled_font,
 				 cairo_image_surface_t *surface);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_glyph_set_path (cairo_scaled_glyph_t *scaled_glyph,
 			      cairo_scaled_font_t *scaled_font,
 			      cairo_path_fixed_t *path);
@@ -1867,29 +1876,29 @@ _cairo_scaled_glyph_lookup (cairo_scaled_font_t *scaled_font,
 			    cairo_scaled_glyph_info_t info,
 			    cairo_scaled_glyph_t **scaled_glyph_ret);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_scaled_font_map_destroy (void);
 
 /* cairo-stroke-style.c */
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_stroke_style_init (cairo_stroke_style_t *style);
 
 cairo_private cairo_status_t
 _cairo_stroke_style_init_copy (cairo_stroke_style_t *style,
 			       cairo_stroke_style_t *other);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_stroke_style_fini (cairo_stroke_style_t *style);
 
 /* cairo-surface.c */
 
-extern const cairo_private cairo_surface_t _cairo_surface_nil;
-extern const cairo_private cairo_surface_t _cairo_surface_nil_read_error;
-extern const cairo_private cairo_surface_t _cairo_surface_nil_write_error;
-extern const cairo_private cairo_surface_t _cairo_surface_nil_file_not_found;
+extern const cairo_private_no_warn cairo_surface_t _cairo_surface_nil;
+extern const cairo_private_no_warn cairo_surface_t _cairo_surface_nil_read_error;
+extern const cairo_private_no_warn cairo_surface_t _cairo_surface_nil_write_error;
+extern const cairo_private_no_warn cairo_surface_t _cairo_surface_nil_file_not_found;
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_surface_set_error (cairo_surface_t	*surface,
 			  cairo_status_t	 status);
 
@@ -1906,12 +1915,12 @@ _cairo_surface_create_similar_solid (cairo_surface_t	 *other,
 				     int		  height,
 				     const cairo_color_t *color);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_surface_init (cairo_surface_t			*surface,
 		     const cairo_surface_backend_t	*backend,
 		     cairo_content_t			 content);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_surface_set_font_options (cairo_surface_t       *surface,
 				 cairo_font_options_t  *options);
 
@@ -2018,7 +2027,7 @@ _cairo_surface_acquire_source_image (cairo_surface_t         *surface,
 				     cairo_image_surface_t  **image_out,
 				     void                   **image_extra);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_surface_release_source_image (cairo_surface_t        *surface,
 				     cairo_image_surface_t  *image,
 				     void                   *image_extra);
@@ -2030,7 +2039,7 @@ _cairo_surface_acquire_dest_image (cairo_surface_t         *surface,
 				   cairo_rectangle_int16_t *image_rect,
 				   void                   **image_extra);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_surface_release_dest_image (cairo_surface_t        *surface,
 				   cairo_rectangle_int16_t      *interest_rect,
 				   cairo_image_surface_t  *image,
@@ -2127,7 +2136,7 @@ _cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
 cairo_private cairo_bool_t
 _cairo_surface_is_opaque (const cairo_surface_t *surface);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_surface_set_device_scale (cairo_surface_t *surface,
 				 double		  sx,
 				 double		  sy);
@@ -2204,7 +2213,7 @@ _cairo_image_surface_create_for_data_with_content (unsigned char	*data,
 						   int			 height,
 						   int			 stride);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_image_surface_assume_ownership_of_data (cairo_image_surface_t *surface);
 
 /* XXX: It's a nasty kludge that this appears here. Backend functions
@@ -2243,7 +2252,7 @@ _cairo_pen_init_empty (cairo_pen_t *pen);
 cairo_private cairo_status_t
 _cairo_pen_init_copy (cairo_pen_t *pen, cairo_pen_t *other);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pen_fini (cairo_pen_t *pen);
 
 cairo_private cairo_status_t
@@ -2273,10 +2282,10 @@ _cairo_pen_stroke_spline (cairo_pen_t *pen,
 			  cairo_traps_t *traps);
 
 /* cairo_polygon.c */
-cairo_private void
+cairo_private_no_warn void
 _cairo_polygon_init (cairo_polygon_t *polygon);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_polygon_fini (cairo_polygon_t *polygon);
 
 cairo_private cairo_status_t
@@ -2302,23 +2311,23 @@ _cairo_spline_init (cairo_spline_t *spline,
 cairo_private cairo_status_t
 _cairo_spline_decompose (cairo_spline_t *spline, double tolerance);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_spline_fini (cairo_spline_t *spline);
 
 /* cairo_matrix.c */
-cairo_private void
+cairo_private_no_warn void
 _cairo_matrix_get_affine (const cairo_matrix_t *matrix,
 			  double *xx, double *yx,
 			  double *xy, double *yy,
 			  double *x0, double *y0);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_matrix_transform_bounding_box (const cairo_matrix_t *matrix,
 				      double *x1, double *y1,
 				      double *x2, double *y2,
 				      cairo_bool_t *is_tight);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_matrix_compute_determinant (const cairo_matrix_t *matrix, double *det);
 
 cairo_private cairo_status_t
@@ -2338,22 +2347,22 @@ _cairo_matrix_is_integer_translation(const cairo_matrix_t *matrix,
 cairo_private double
 _cairo_matrix_transformed_circle_major_axis(cairo_matrix_t *matrix, double radius);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_matrix_to_pixman_matrix (const cairo_matrix_t	*matrix,
 				pixman_transform_t	*pixman_transform);
 
 /* cairo_traps.c */
-cairo_private void
+cairo_private_no_warn void
 _cairo_traps_init (cairo_traps_t *traps);
 
 cairo_private cairo_status_t
 _cairo_traps_init_box (cairo_traps_t *traps,
 		       cairo_box_t   *box);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_traps_fini (cairo_traps_t *traps);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_traps_translate (cairo_traps_t *traps, int x, int y);
 
 cairo_private cairo_status_t
@@ -2380,14 +2389,14 @@ _cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t      *traps,
 cairo_private int
 _cairo_traps_contain (cairo_traps_t *traps, double x, double y);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_traps_extents (cairo_traps_t *traps, cairo_box_t *extents);
 
 cairo_private cairo_status_t
 _cairo_traps_extract_region (cairo_traps_t      *tr,
 			     pixman_region16_t **region);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
 					    cairo_trapezoid_t *src_traps,
 					    int num_traps,
@@ -2395,7 +2404,7 @@ _cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
 					    double sx, double sy);
 
 /* cairo_slope.c */
-cairo_private void
+cairo_private_no_warn void
 _cairo_slope_init (cairo_slope_t *slope, cairo_point_t *a, cairo_point_t *b);
 
 cairo_private int
@@ -2409,34 +2418,34 @@ _cairo_slope_counter_clockwise (cairo_slope_t *a, cairo_slope_t *b);
 
 /* cairo_pattern.c */
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_init_copy (cairo_pattern_t	*pattern,
 			  const cairo_pattern_t *other);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_init_solid (cairo_solid_pattern_t *pattern,
 			   const cairo_color_t *color);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_init_for_surface (cairo_surface_pattern_t *pattern,
 				 cairo_surface_t *surface);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_init_linear (cairo_linear_pattern_t *pattern,
 			    double x0, double y0, double x1, double y1);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_init_radial (cairo_radial_pattern_t *pattern,
 			    double cx0, double cy0, double radius0,
 			    double cx1, double cy1, double radius1);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_fini (cairo_pattern_t *pattern);
 
 cairo_private cairo_pattern_t *
 _cairo_pattern_create_solid (const cairo_color_t *color);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_transform (cairo_pattern_t      *pattern,
 			  const cairo_matrix_t *ctm_inverse);
 
@@ -2456,7 +2465,7 @@ _cairo_pattern_acquire_surface (cairo_pattern_t		   *pattern,
 				cairo_surface_t		   **surface_out,
 				cairo_surface_attributes_t *attributes);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_pattern_release_surface (cairo_pattern_t		   *pattern,
 				cairo_surface_t		   *surface,
 				cairo_surface_attributes_t *attributes);
@@ -2492,7 +2501,7 @@ _cairo_gstate_get_antialias (cairo_gstate_t *gstate);
 cairo_private pixman_region16_t *
 _cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_region_extents_rectangle (pixman_region16_t       *region,
 				 cairo_rectangle_int16_t *rect);
 
@@ -2510,7 +2519,7 @@ _cairo_utf8_to_utf16 (const unsigned char *str,
 		      uint16_t		 **result,
 		      int		  *items_written);
 
-cairo_private void
+cairo_private_no_warn void
 _cairo_error (cairo_status_t status);
 
 cairo_private int
diff --git a/src/check-headers.sh b/src/check-headers.sh
index 91a52a0..a17d666 100755
--- a/src/check-headers.sh
+++ b/src/check-headers.sh
@@ -12,7 +12,7 @@ xargs grep -B 1 '^cairo_.*[ 	]\+(' |
 awk '
 /^--$/ { context=""; public=0; next; }
 /:cairo_.*[ 	]+\(/ { if (!public) {print context; print; print "--";} next; }
-/-cairo_public[ 	]/ {public=1;}
+/-cairo_public.*[ 	]/ {public=1;}
 { context=$0; }
 ' |
 sed 's/[.]h-/.h:/' |
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Wed Mar 21 09:58:50 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar 21 09:59:03 2007
Subject: [cairo] Fix up the simple warnings
In-Reply-To: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
Message-ID: <20070321165850.GB10524@inspired.chris-wilson.co.uk>

For the majority of warning we can simply propagate the error status.
This leaves some checks that were explicity deferred and others that
appeared more complicated and needed to be dealt with outside of this
mammoth, preferably by people who knew the code better ;-)
-------------- next part --------------
>From fe6572d22374d9309076e5ee7bff7bdfaa30859c Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 21 Mar 2007 16:38:43 +0000
Subject: [PATCH] Fix up the simple cases of warn-unused-result.

For the majority of cases of unchecked status returns the most appropiate
action is to propagate the status back up the chain, after performing
all local cleanups. Sometimes this involves changing the prototype to
include the status return and repeating on the process for its callers.
---
 boilerplate/cairo-boilerplate.c |    7 ++-
 src/cairo-bentley-ottmann.c     |   48 +++++++++++-----
 src/cairo-clip-private.h        |    4 +-
 src/cairo-clip.c                |   67 ++++++++++++++++------
 src/cairo-ft-font.c             |  107 +++++++++++++++++++++++++----------
 src/cairo-gstate.c              |   32 ++++++++--
 src/cairo-meta-surface.c        |    4 +-
 src/cairo-paginated-surface.c   |   33 ++++++++---
 src/cairo-path-fill.c           |    2 +-
 src/cairo-path-stroke.c         |  119 ++++++++++++++++++++++++++------------
 src/cairo-path.c                |   50 +++++++++--------
 src/cairo-pattern.c             |    4 +-
 src/cairo-pdf-surface.c         |   34 +++++++-----
 src/cairo-pen.c                 |   28 ++++++---
 src/cairo-polygon.c             |    8 +-
 src/cairo-ps-surface.c          |   73 +++++++++++++++---------
 src/cairo-scaled-font.c         |   53 +++++++++++------
 src/cairo-surface-fallback.c    |   28 ++++++---
 src/cairo-svg-surface.c         |   47 ++++++++++++----
 src/cairo-traps.c               |    1 +
 src/cairo-truetype-subset.c     |   15 ++++-
 src/cairo-type1-fallback.c      |   28 +++++++---
 src/cairo-xlib-private.h        |    2 +-
 src/cairo.c                     |   69 +++++++++++++++--------
 src/cairoint.h                  |   10 ++--
 test/buffer-diff.c              |    6 +-
 26 files changed, 595 insertions(+), 284 deletions(-)

diff --git a/boilerplate/cairo-boilerplate.c b/boilerplate/cairo-boilerplate.c
index f726d42..6ea5e52 100644
--- a/boilerplate/cairo-boilerplate.c
+++ b/boilerplate/cairo-boilerplate.c
@@ -1095,7 +1095,12 @@ create_ps_surface (const char			 *name,
 	ptc->target = NULL;
     }
 
-    cairo_surface_set_user_data (surface, &ps_closure_key, ptc, NULL);
+    if (cairo_surface_set_user_data (surface, &ps_closure_key, ptc, NULL)) {
+	cairo_surface_destroy (surface);
+	free (ptc->filename);
+	free (ptc);
+	return NULL;
+    }
 
     return surface;
 }
diff --git a/src/cairo-bentley-ottmann.c b/src/cairo-bentley-ottmann.c
index 873bfd6..0248a38 100644
--- a/src/cairo-bentley-ottmann.c
+++ b/src/cairo-bentley-ottmann.c
@@ -692,13 +692,15 @@ _cairo_bo_event_init (cairo_bo_event_t		*event,
     event->point = point;
 }
 
-static void
+cairo_static cairo_status_t
 _cairo_bo_event_queue_insert (cairo_bo_event_queue_t *queue,
 			      cairo_bo_event_t	     *event)
 {
     /* Don't insert if there's already an equivalent intersection event in the queue. */
-    _cairo_skip_list_insert (&queue->intersection_queue, event,
-		      event->type == CAIRO_BO_EVENT_TYPE_INTERSECTION);
+    if (_cairo_skip_list_insert (&queue->intersection_queue, event,
+		      event->type == CAIRO_BO_EVENT_TYPE_INTERSECTION) == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static void
@@ -796,7 +798,7 @@ _cairo_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue)
 	free (event_queue->sorted_startstop_event_ptrs);
 }
 
-static void
+cairo_static cairo_status_t
 _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t	*event_queue,
 							   cairo_bo_edge_t	*left,
 							   cairo_bo_edge_t	*right)
@@ -806,7 +808,7 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
     cairo_bo_event_t event;
 
     if (left == NULL || right == NULL)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     /* The names "left" and "right" here are correct descriptions of
      * the order of the two edges within the active edge list. So if a
@@ -814,13 +816,13 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
      * that the intersection of these two segments has oalready
      * occurred before the current sweep line position. */
     if (_slope_compare (left, right) < 0)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     status = _cairo_bo_edge_intersect (left, right, &intersection);
     if (status == CAIRO_BO_STATUS_PARALLEL ||
 	status == CAIRO_BO_STATUS_NO_INTERSECTION)
     {
-	return;
+	return CAIRO_STATUS_SUCCESS;
     }
 
     _cairo_bo_event_init (&event,
@@ -828,7 +830,7 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
 			  left, right,
 			  intersection);
 
-    _cairo_bo_event_queue_insert (event_queue, &event);
+    return _cairo_bo_event_queue_insert (event_queue, &event);
 }
 
 static void
@@ -848,7 +850,7 @@ _cairo_bo_sweep_line_fini (cairo_bo_sweep_line_t *sweep_line)
     _cairo_skip_list_fini (&sweep_line->active_edges);
 }
 
-static void
+static cairo_status_t
 _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
 			     cairo_bo_edge_t		*edge)
 {
@@ -858,6 +860,8 @@ _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
 
     sweep_line_elt = _cairo_skip_list_insert (&sweep_line->active_edges, &edge,
 				       1 /* unique inserts*/);
+    if (sweep_line_elt == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
 
     next_elt = sweep_line_elt->elt.next[0];
     if (next_elt)
@@ -876,6 +880,8 @@ _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
     *next_of_prev = edge;
 
     edge->sweep_line_elt = sweep_line_elt;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static void
@@ -1296,7 +1302,9 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 	case CAIRO_BO_EVENT_TYPE_START:
 	    edge = event->e1;
 
-	    _cairo_bo_sweep_line_insert (&sweep_line, edge);
+	    status = _cairo_bo_sweep_line_insert (&sweep_line, edge);
+	    if (status)
+		goto unwind;
 	    /* Cache the insert position for use in pass 2.
 	    event->e2 = Sortlist::prev (sweep_line, edge);
 	    */
@@ -1304,9 +1312,13 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 	    left = edge->prev;
 	    right = edge->next;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, edge);
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, edge);
+	    if (status)
+		goto unwind;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, edge, right);
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, edge, right);
+	    if (status)
+		goto unwind;
 
 #if DEBUG_PRINT_STATE
 	    print_state ("After processing start", &event_queue, &sweep_line);
@@ -1326,7 +1338,9 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 	    if (status)
 		goto unwind;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, right);
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, right);
+	    if (status)
+		goto unwind;
 
 #if DEBUG_PRINT_STATE
 	    print_state ("After processing stop", &event_queue, &sweep_line);
@@ -1354,11 +1368,15 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 
 	    /* after the swap e2 is left of e1 */
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
 								       left, edge2);
+	    if (status)
+		goto unwind;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
 								       edge1, right);
+	    if (status)
+		goto unwind;
 
 #if DEBUG_PRINT_STATE
 	    print_state ("After processing intersection", &event_queue, &sweep_line);
diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index c2d2036..12f4194 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -86,10 +86,10 @@ _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target);
 cairo_private_no_warn void
 _cairo_clip_fini (cairo_clip_t *clip);
 
-cairo_private_no_warn void
+cairo_private cairo_status_t
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other);
 
-cairo_private_no_warn void
+cairo_private cairo_status_t
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target);
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index efecd89..0e7d2a8 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -82,7 +82,7 @@ _cairo_clip_fini (cairo_clip_t *clip)
     clip->path = NULL;
 }
 
-void
+cairo_status_t
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 {
     clip->mode = other->mode;
@@ -96,10 +96,15 @@ _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 	clip->region = other->region;
     } else {
 	clip->region = pixman_region_create ();
+	if (clip->region == NULL) {
+	    cairo_surface_destroy (clip->surface);
+	    return CAIRO_STATUS_NO_MEMORY;
+	}
 	pixman_region_copy (clip->region, other->region);
     }
 
     clip->path = _cairo_clip_path_reference (other->path);
+    return CAIRO_STATUS_SUCCESS;
 }
 
 cairo_status_t
@@ -270,7 +275,7 @@ _cairo_clip_combine_to_surface (cairo_clip_t                  *clip,
     return status;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_clip_intersect_path (cairo_clip_t       *clip,
 			    cairo_path_fixed_t *path,
 			    cairo_fill_rule_t   fill_rule,
@@ -535,25 +540,30 @@ _cairo_clip_translate (cairo_clip_t  *clip,
     }
 }
 
-static void
+cairo_static cairo_status_t
 _cairo_clip_path_reapply_clip_path (cairo_clip_t      *clip,
                                     cairo_clip_path_t *clip_path)
 {
-    if (clip_path->prev)
-        _cairo_clip_path_reapply_clip_path (clip, clip_path->prev);
+    if (clip_path->prev) {
+	cairo_status_t status;
+        status = _cairo_clip_path_reapply_clip_path (clip, clip_path->prev);
+	if (status)
+	    return status;
+    }
 
-    _cairo_clip_intersect_path (clip,
+    return _cairo_clip_intersect_path (clip,
                                 &clip_path->path,
                                 clip_path->fill_rule,
                                 clip_path->tolerance,
                                 clip_path->antialias);
 }
 
-void
+cairo_status_t
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target)
 {
+    cairo_status_t status;
     _cairo_clip_init (clip, target);
 
     if (other->mode != clip->mode) {
@@ -562,23 +572,42 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
     } else {
         if (other->region) {
             clip->region = pixman_region_create ();
+	    if (clip->region == NULL)
+		return CAIRO_STATUS_NO_MEMORY;
             pixman_region_copy (clip->region, other->region);
         }
 
         if (other->surface) {
-            _cairo_surface_clone_similar (target, other->surface,
-					  other->surface_rect.x,
-					  other->surface_rect.y,
-					  other->surface_rect.width,
-					  other->surface_rect.height,
-					  &clip->surface);
+            status = _cairo_surface_clone_similar (target, other->surface,
+					           other->surface_rect.x,
+						   other->surface_rect.y,
+						   other->surface_rect.width,
+						   other->surface_rect.height,
+						   &clip->surface);
+	    if (status)
+		goto BAIL;
             clip->surface_rect = other->surface_rect;
         }
 
         if (other->path) {
-            _cairo_clip_path_reapply_clip_path (clip, other->path);
+            status = _cairo_clip_path_reapply_clip_path (clip, other->path);
+	    if (status)
+		goto BAIL;
         }
     }
+
+    return CAIRO_STATUS_SUCCESS;
+
+BAIL:
+    if (clip->region) {
+	pixman_region_destroy (clip->region);
+	clip->region = NULL;
+    }
+    if (clip->surface) {
+	cairo_surface_destroy (clip->surface);
+	clip->surface = NULL;
+    }
+    return status;
 }
 
 const cairo_rectangle_list_t _cairo_rectangles_nil =
@@ -635,10 +664,12 @@ _cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate)
         }
     } else {
         cairo_rectangle_int16_t extents;
-        _cairo_surface_get_extents (_cairo_gstate_get_target (gstate), &extents);
-        if (!_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
-                                      extents.width, extents.height,
-                                      rectangles)) {
+	cairo_status_t status;
+        status = _cairo_surface_get_extents (_cairo_gstate_get_target (gstate), &extents);
+        if (status != CAIRO_STATUS_SUCCESS ||
+		!_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
+                                          extents.width, extents.height,
+                                          rectangles)) {
             free (rectangles);
             return (cairo_rectangle_list_t*)
                 &_cairo_rectangles_not_representable;
diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index 7f10fd7..08677d2 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -572,10 +572,11 @@ _cairo_ft_unscaled_font_unlock_face (cairo_ft_unscaled_font_t *unscaled)
 }
 slim_hidden_def (cairo_ft_scaled_font_unlock_face);
 
-static void
+cairo_static cairo_status_t
 _compute_transform (cairo_ft_font_transform_t *sf,
 		    cairo_matrix_t      *scale)
 {
+    cairo_status_t status;
     cairo_matrix_t normalized = *scale;
     double tx, ty;
 
@@ -586,9 +587,11 @@ _compute_transform (cairo_ft_font_transform_t *sf,
      * freetype's transformation.
      */
 
-    _cairo_matrix_compute_scale_factors (&normalized,
-					 &sf->x_scale, &sf->y_scale,
-					 /* XXX */ 1);
+    status = _cairo_matrix_compute_scale_factors (&normalized,
+					          &sf->x_scale, &sf->y_scale,
+					          /* XXX */ 1);
+    if (status)
+	return status;
 
     if (sf->x_scale != 0 && sf->y_scale != 0) {
 	cairo_matrix_scale (&normalized, 1.0 / sf->x_scale, 1.0 / sf->y_scale);
@@ -601,15 +604,18 @@ _compute_transform (cairo_ft_font_transform_t *sf,
 	sf->shape[0][0] = sf->shape[1][1] = 1.0;
 	sf->shape[0][1] = sf->shape[1][0] = 0.0;
     }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /* Temporarily scales an unscaled font to the give scale. We catch
  * scaling to the same size, since changing a FT_Face is expensive.
  */
-static void
+cairo_static cairo_status_t
 _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 				   cairo_matrix_t	      *scale)
 {
+    cairo_status_t status;
     cairo_ft_font_transform_t sf;
     FT_Matrix mat;
     FT_Error error;
@@ -621,12 +627,12 @@ _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 	scale->yx == unscaled->current_scale.yx &&
 	scale->xy == unscaled->current_scale.xy &&
 	scale->yy == unscaled->current_scale.yy)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     unscaled->have_scale = TRUE;
     unscaled->current_scale = *scale;
 
-    _compute_transform (&sf, scale);
+    status = _compute_transform (&sf, scale);
 
     unscaled->x_scale = sf.x_scale;
     unscaled->y_scale = sf.y_scale;
@@ -685,6 +691,8 @@ _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 					unscaled->face->available_sizes[best_i].height);
 	assert (error == 0);
     }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /* Empirically-derived subpixel filtering values thanks to Keith
@@ -1154,23 +1162,31 @@ _transform_glyph_bitmap (cairo_matrix_t         * shape,
 
     /* Initialize it to empty
      */
-    _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
-				   CAIRO_COLOR_TRANSPARENT,
-				   0, 0,
-				   width, height);
+    status = _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
+				            CAIRO_COLOR_TRANSPARENT,
+				            0, 0,
+				            width, height);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     /* Draw the original bitmap transformed into the new bitmap
      */
     _cairo_pattern_init_for_surface (&pattern, &(*surface)->base);
     cairo_pattern_set_matrix (&pattern.base, &transformed_to_original);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_OVER,
-			      &pattern.base, NULL, image,
-			      0, 0, 0, 0, 0, 0,
-			      width,
-			      height);
+    status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+			               &pattern.base, NULL, image,
+			               0, 0, 0, 0, 0, 0,
+			               width, height);
 
     _cairo_pattern_fini (&pattern.base);
+    
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     /* Now update the cache entry for the new bitmap, recomputing
      * the origin based on the final transform.
@@ -1417,6 +1433,7 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
 			      const cairo_font_options_t *options,
 			      cairo_ft_options_t	  ft_options)
 {
+    cairo_status_t status;
     cairo_ft_scaled_font_t *scaled_font = NULL;
     FT_Face face;
     FT_Size_Metrics *metrics;
@@ -1441,13 +1458,19 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
     _cairo_font_options_init_copy (&scaled_font->ft_options.base, options);
     _cairo_ft_options_merge (&scaled_font->ft_options, &ft_options);
 
-    _cairo_scaled_font_init (&scaled_font->base,
-			     font_face,
-			     font_matrix, ctm, options,
-			     &cairo_ft_scaled_font_backend);
+    status = _cairo_scaled_font_init (&scaled_font->base,
+			              font_face,
+			              font_matrix, ctm, options,
+			              &cairo_ft_scaled_font_backend);
+    if (status) {
+	goto UNLOCK;
+    }
 
-    _cairo_ft_unscaled_font_set_scale (unscaled,
-				       &scaled_font->base.scale);
+    status = _cairo_ft_unscaled_font_set_scale (unscaled,
+				                &scaled_font->base.scale);
+    if (status) {
+	goto UNLOCK;
+    }
 
     metrics = &face->size->metrics;
 
@@ -1498,6 +1521,11 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
     _cairo_ft_unscaled_font_unlock_face (unscaled);
 
     return &scaled_font->base;
+
+UNLOCK:
+    free (scaled_font);
+    _cairo_ft_unscaled_font_unlock_face (unscaled);
+    return NULL;
 }
 
 cairo_bool_t
@@ -1514,6 +1542,7 @@ _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
 				  cairo_scaled_font_t	     **font)
 {
     FcPattern *pattern, *resolved;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
     cairo_ft_unscaled_font_t *unscaled;
     cairo_scaled_font_t *new_font = NULL;
     FcResult result;
@@ -1561,7 +1590,7 @@ _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
 	goto FREE_PATTERN;
 
     cairo_matrix_multiply (&scale, font_matrix, ctm);
-    _compute_transform (&sf, &scale);
+    status = _compute_transform (&sf, &scale);
 
     FcPatternAddInteger (pattern, FC_PIXEL_SIZE, sf.y_scale);
 
@@ -1594,10 +1623,11 @@ _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
 
     if (new_font) {
 	*font = new_font;
-	return CAIRO_STATUS_SUCCESS;
     } else {
-	return CAIRO_STATUS_NO_MEMORY;
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = CAIRO_STATUS_NO_MEMORY;
     }
+    return status;
 }
 
 static void
@@ -1719,6 +1749,7 @@ _decompose_glyph_outline (FT_Face		  face,
 
     FT_GlyphSlot glyph;
     cairo_path_fixed_t *path;
+    cairo_status_t status;
 
     path = _cairo_path_fixed_create ();
     if (!path)
@@ -1728,9 +1759,16 @@ _decompose_glyph_outline (FT_Face		  face,
 
     /* Font glyphs have an inverted Y axis compared to cairo. */
     FT_Outline_Transform (&glyph->outline, &invert_y);
-    FT_Outline_Decompose (&glyph->outline, &outline_funcs, path);
+    if (FT_Outline_Decompose (&glyph->outline, &outline_funcs, path) != 0) {
+	_cairo_path_fixed_destroy (path);
+	return CAIRO_STATUS_NO_MEMORY;
+    }
 
-    _cairo_path_fixed_close_path (path);
+    status = _cairo_path_fixed_close_path (path);
+    if (status != CAIRO_STATUS_SUCCESS) {
+	_cairo_path_fixed_destroy (path);
+	return status;
+    }
 
     *pathp = path;
 
@@ -1774,14 +1812,16 @@ _cairo_ft_scaled_glyph_init (void			*abstract_font,
     FT_Glyph_Metrics *metrics;
     double x_factor, y_factor;
     cairo_bool_t vertical_layout = FALSE;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
 
     face = _cairo_ft_unscaled_font_lock_face (unscaled);
     if (!face)
 	return CAIRO_STATUS_NO_MEMORY;
 
-    _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
-				       &scaled_font->base.scale);
+    status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
+				                &scaled_font->base.scale);
+    if (status)
+	return status;
 
     /* Ignore global advance unconditionally */
     load_flags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
@@ -2447,6 +2487,7 @@ FT_Face
 cairo_ft_scaled_font_lock_face (cairo_scaled_font_t *abstract_font)
 {
     cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
+    cairo_status_t status;
     FT_Face face;
 
     if (scaled_font->base.status)
@@ -2458,8 +2499,12 @@ cairo_ft_scaled_font_lock_face (cairo_scaled_font_t *abstract_font)
 	return NULL;
     }
 
-    _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
+    status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
 				       &scaled_font->base.scale);
+    if (status) {
+	_cairo_scaled_font_set_error (&scaled_font->base, status);
+	return NULL;
+    }
 
     /* NOTE: We deliberately release the unscaled font's mutex here,
      * so that we are not holding a lock across two separate calls to
diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index b75a90b..155ee9c 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -64,6 +64,8 @@ cairo_status_t
 _cairo_gstate_init (cairo_gstate_t  *gstate,
 		    cairo_surface_t *target)
 {
+    cairo_status_t status;
+
     gstate->op = CAIRO_GSTATE_OPERATOR_DEFAULT;
 
     gstate->tolerance = CAIRO_GSTATE_TOLERANCE_DEFAULT;
@@ -88,7 +90,9 @@ _cairo_gstate_init (cairo_gstate_t  *gstate,
     gstate->parent_target = NULL;
     gstate->original_target = cairo_surface_reference (target);
 
-    _cairo_gstate_identity_matrix (gstate);
+    status = _cairo_gstate_identity_matrix (gstate);
+    if (status != CAIRO_STATUS_SUCCESS)
+	return status;
     gstate->source_ctm_inverse = gstate->ctm_inverse;
 
     gstate->source = _cairo_pattern_create_solid (CAIRO_COLOR_BLACK);
@@ -122,6 +126,12 @@ _cairo_gstate_init_copy (cairo_gstate_t *gstate, cairo_gstate_t *other)
     if (status)
 	return status;
 
+    status = _cairo_clip_init_copy (&gstate->clip, &other->clip);
+    if (status) {
+	_cairo_stroke_style_fini (&gstate->stroke_style);
+	return status;
+    }
+
     gstate->fill_rule = other->fill_rule;
 
     gstate->font_face = cairo_font_face_reference (other->font_face);
@@ -131,7 +141,6 @@ _cairo_gstate_init_copy (cairo_gstate_t *gstate, cairo_gstate_t *other)
 
     _cairo_font_options_init_copy (&gstate->font_options , &other->font_options);
 
-    _cairo_clip_init_copy (&gstate->clip, &other->clip);
 
     gstate->target = cairo_surface_reference (other->target);
     /* parent_target is always set to NULL; it's only ever set by redirect_target */
@@ -252,9 +261,10 @@ _cairo_gstate_recursive_apply_clip_path (cairo_gstate_t *gstate,
  * original #cairo_t target, the clip will be INVALID after this call,
  * and the caller should either recreate or reset the clip.
  **/
-void
+cairo_status_t
 _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child)
 {
+    cairo_status_t status;
     /* If this gstate is already redirected, this is an error; we need a
      * new gstate to be able to redirect */
     assert (gstate->parent_target == NULL);
@@ -270,13 +280,17 @@ _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child)
     gstate->target = cairo_surface_reference (child);
 
     _cairo_clip_fini (&gstate->clip);
-    _cairo_clip_init_deep_copy (&gstate->clip, &gstate->next->clip, child);
+    status = _cairo_clip_init_deep_copy (&gstate->clip, &gstate->next->clip, child);
+    if (status)
+	return status;
 
     /* The clip is in surface backend coordinates for the previous target;
      * translate it into the child's backend coordinates. */
     _cairo_clip_translate (&gstate->clip,
                            _cairo_fixed_from_double (child->device_transform.x0 - gstate->parent_target->device_transform.x0),
                            _cairo_fixed_from_double (child->device_transform.y0 - gstate->parent_target->device_transform.y0));
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /**
@@ -583,13 +597,16 @@ _cairo_gstate_transform (cairo_gstate_t	      *gstate,
 			 const cairo_matrix_t *matrix)
 {
     cairo_matrix_t tmp;
+    cairo_status_t status;
 
     _cairo_gstate_unset_scaled_font (gstate);
 
     tmp = *matrix;
     cairo_matrix_multiply (&gstate->ctm, &tmp, &gstate->ctm);
 
-    cairo_matrix_invert (&tmp);
+    status = cairo_matrix_invert (&tmp);
+    if (status)
+	return status;
     cairo_matrix_multiply (&gstate->ctm_inverse, &gstate->ctm_inverse, &tmp);
 
     return CAIRO_STATUS_SUCCESS;
@@ -1190,15 +1207,16 @@ _cairo_gstate_select_font_face (cairo_gstate_t       *gstate,
 				cairo_font_weight_t   weight)
 {
     cairo_font_face_t *font_face;
+    cairo_status_t status;
 
     font_face = _cairo_toy_font_face_create (family, slant, weight);
     if (font_face->status)
 	return font_face->status;
 
-    _cairo_gstate_set_font_face (gstate, font_face);
+    status = _cairo_gstate_set_font_face (gstate, font_face);
     cairo_font_face_destroy (font_face);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
diff --git a/src/cairo-meta-surface.c b/src/cairo-meta-surface.c
index e196df2..7bbdc39 100644
--- a/src/cairo-meta-surface.c
+++ b/src/cairo-meta-surface.c
@@ -668,7 +668,9 @@ _cairo_meta_surface_replay (cairo_surface_t *surface,
 
 	dev_path = _cairo_command_get_path (command);
 	if (dev_path && has_device_transform) {
-	    _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    status = _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    if (status)
+		break;
 	    _cairo_path_fixed_device_transform (&path_copy, device_transform);
 	    dev_path = &path_copy;
 	}
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index 64a9cbf..b8e87ac 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -201,15 +201,22 @@ _cairo_paginated_surface_acquire_source_image (void	       *abstract_surface,
 {
     cairo_paginated_surface_t *surface = abstract_surface;
     cairo_surface_t *image;
+    cairo_status_t status;
     cairo_rectangle_int16_t extents;
 
-    _cairo_surface_get_extents (surface->target, &extents);
+    status = _cairo_surface_get_extents (surface->target, &extents);
+    if (status)
+	return status;
 
     image = _cairo_paginated_surface_create_image_surface (surface,
 							   extents.width,
 							   extents.height);
 
-    _cairo_meta_surface_replay (surface->meta, image);
+    status = _cairo_meta_surface_replay (surface->meta, image);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     *image_out = (cairo_image_surface_t*) image;
     *image_extra = NULL;
@@ -257,7 +264,7 @@ _paint_page (cairo_paginated_surface_t *surface)
 							       surface->height * y_scale);
 	_cairo_surface_set_device_scale (image, x_scale, y_scale);
 
-	_cairo_meta_surface_replay (surface->meta, image);
+	status = _cairo_meta_surface_replay (surface->meta, image);
 
 	pattern = cairo_pattern_create_for_surface (image);
 	cairo_matrix_init_scale (&matrix, x_scale, y_scale);
@@ -271,12 +278,12 @@ _paint_page (cairo_paginated_surface_t *surface)
     }
     else
     {
-	_cairo_meta_surface_replay (surface->meta, surface->target);
+	status = _cairo_meta_surface_replay (surface->meta, surface->target);
     }
 
     cairo_surface_destroy (analysis);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
@@ -325,7 +332,9 @@ _cairo_paginated_surface_show_page (void *abstract_surface)
 
     _paint_page (surface);
 
-    _cairo_surface_show_page (surface->target);
+    status = _cairo_surface_show_page (surface->target);
+    if (status)
+	return status;
 
     cairo_surface_destroy (surface->meta);
 
@@ -503,15 +512,23 @@ _cairo_paginated_surface_snapshot (void *abstract_other)
     return _cairo_surface_snapshot (other->meta);
 #else
     cairo_rectangle_int16_t extents;
+    cairo_status_t status;
     cairo_surface_t *surface;
 
-    _cairo_surface_get_extents (other->target, &extents);
+    status = _cairo_surface_get_extents (other->target, &extents);
+    if (status) {
+	return (cairo_surface_t *) &_cairo_surface_nil;
+    }
 
     surface = _cairo_paginated_surface_create_image_surface (other,
 							     extents.width,
 							     extents.height);
 
-    _cairo_meta_surface_replay (other->meta, surface);
+    status = _cairo_meta_surface_replay (other->meta, surface);
+    if (status) {
+	cairo_surface_destroy (surface);
+	return (cairo_surface_t *) &_cairo_surface_nil;
+    }
 
     return surface;
 #endif
diff --git a/src/cairo-path-fill.c b/src/cairo-path-fill.c
index b1b7a12..d2a9118 100644
--- a/src/cairo-path-fill.c
+++ b/src/cairo-path-fill.c
@@ -138,7 +138,7 @@ _cairo_filler_curve_to (void *closure,
     if (status == CAIRO_INT_STATUS_DEGENERATE)
 	return CAIRO_STATUS_SUCCESS;
 
-    _cairo_spline_decompose (&spline, filler->tolerance);
+    status = _cairo_spline_decompose (&spline, filler->tolerance);
     if (status)
 	goto CLEANUP_SPLINE;
 
diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index 09bafbf..61d008f 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -67,7 +67,7 @@ typedef struct cairo_stroker {
 } cairo_stroker_t;
 
 /* private functions */
-static void
+cairo_static cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -75,43 +75,44 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     double			 tolerance,
 		     cairo_traps_t		*traps);
 
-static void
+cairo_static cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_move_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_line_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_line_to_dashed (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_curve_to (void *closure,
 			 cairo_point_t *b,
 			 cairo_point_t *c,
 			 cairo_point_t *d);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_curve_to_dashed (void *closure,
 				cairo_point_t *b,
 				cairo_point_t *c,
 				cairo_point_t *d);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_close_path (void *closure);
 
-static void
-_translate_point (cairo_point_t *point, cairo_point_t *offset);
-
-static int
+cairo_static int
 _cairo_stroker_face_clockwise (cairo_stroke_face_t *in, cairo_stroke_face_t *out);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_stroke_face_t *out);
 
 static void
+_translate_point (cairo_point_t *point, cairo_point_t *offset);
+
+
+static void
 _cairo_stroker_start_dash (cairo_stroker_t *stroker)
 {
     double offset;
@@ -148,7 +149,7 @@ _cairo_stroker_step_dash (cairo_stroker_t *stroker, double step)
     }
 }
 
-static void
+static cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -156,15 +157,19 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     double			 tolerance,
 		     cairo_traps_t		*traps)
 {
+    cairo_status_t status;
+
     stroker->style = stroke_style;
     stroker->ctm = ctm;
     stroker->ctm_inverse = ctm_inverse;
     stroker->tolerance = tolerance;
     stroker->traps = traps;
 
-    _cairo_pen_init (&stroker->pen,
-		     stroke_style->line_width / 2.0,
-		     tolerance, ctm);
+    status = _cairo_pen_init (&stroker->pen,
+		              stroke_style->line_width / 2.0,
+		              tolerance, ctm);
+    if (status)
+	return status;
 
     stroker->has_current_face = FALSE;
     stroker->has_first_face = FALSE;
@@ -174,12 +179,14 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 	_cairo_stroker_start_dash (stroker);
     else
 	stroker->dashed = FALSE;
+
+    return status;
 }
 
-static void
+static cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker)
 {
-    _cairo_pen_fini (&stroker->pen);
+    return _cairo_pen_fini (&stroker->pen);
 }
 
 static void
@@ -205,6 +212,7 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 {
     int			clockwise = _cairo_stroker_face_clockwise (out, in);
     cairo_point_t	*inpt, *outpt;
+    cairo_status_t       status;
 
     if (in->cw.x == out->cw.x
 	&& in->cw.y == out->cw.y
@@ -231,13 +239,21 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 
 	tri[0] = in->point;
 	if (clockwise) {
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = -1;
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	} else {
-	    _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = +1;
-	    _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	}
 
 	i = start;
@@ -245,7 +261,9 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 	while (i != stop) {
 	    tri[2] = in->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	    i += step;
 	    if (i < 0)
@@ -378,17 +396,23 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	cairo_pen_t *pen = &stroker->pen;
 
 	slope = f->dev_vector;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	if (status)
+	    return status;
 	slope.dx = -slope.dx;
 	slope.dy = -slope.dy;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	if (status)
+	    return status;
 
 	tri[0] = f->point;
 	tri[1] = f->cw;
 	for (i=start; i != stop; i = (i+1) % pen->num_vertices) {
 	    tri[2] = f->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	}
 	tri[2] = f->ccw;
@@ -414,13 +438,24 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	ocw.y = f->cw.y + fvector.dy;
 
 	_cairo_polygon_init (&polygon);
-	_cairo_polygon_move_to (&polygon, &f->cw);
-	_cairo_polygon_line_to (&polygon, &ocw);
-	_cairo_polygon_line_to (&polygon, &occw);
-	_cairo_polygon_line_to (&polygon, &f->ccw);
-	_cairo_polygon_close (&polygon);
+	status = _cairo_polygon_move_to (&polygon, &f->cw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &ocw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &occw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &f->ccw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_close (&polygon);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
 
 	status = _cairo_bentley_ottmann_tessellate_polygon (stroker->traps, &polygon, CAIRO_FILL_RULE_WINDING);
+CLEANUP_LINE_CAP_SQUARE:
 	_cairo_polygon_fini (&polygon);
 
 	return status;
@@ -778,7 +813,8 @@ _cairo_stroker_curve_to (void *closure,
 			 cairo_point_t *c,
 			 cairo_point_t *d)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
+    cairo_status_t status2;
     cairo_stroker_t *stroker = closure;
     cairo_spline_t spline;
     cairo_pen_t pen;
@@ -830,7 +866,9 @@ _cairo_stroker_curve_to (void *closure,
 	goto CLEANUP_PEN;
 
   CLEANUP_PEN:
-    _cairo_pen_fini (&pen);
+    status2 = _cairo_pen_fini (&pen);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
   CLEANUP_SPLINE:
     _cairo_spline_fini (&spline);
 
@@ -953,6 +991,7 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
 				   cairo_traps_t	*traps)
 {
     cairo_status_t status;
+    cairo_status_t status2;
     cairo_stroker_t stroker;
 
     /* Before we do anything else, we attempt the rectilinear
@@ -967,9 +1006,11 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
     if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 	return status;
 
-    _cairo_stroker_init (&stroker, stroke_style,
-			 ctm, ctm_inverse, tolerance,
-			 traps);
+    status = _cairo_stroker_init (&stroker, stroke_style,
+			          ctm, ctm_inverse, tolerance,
+			          traps);
+    if (status)
+	return status;
 
     if (stroker.style->dash)
 	status = _cairo_path_fixed_interpret (path,
@@ -994,7 +1035,9 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
     status = _cairo_stroker_add_caps (&stroker);
 
 BAIL:
-    _cairo_stroker_fini (&stroker);
+    status2 = _cairo_stroker_fini (&stroker);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
diff --git a/src/cairo-path.c b/src/cairo-path.c
index 7c2374c..1219f83 100644
--- a/src/cairo-path.c
+++ b/src/cairo-path.c
@@ -136,21 +136,24 @@ _cairo_path_count (cairo_path_t		*path,
 		   cairo_bool_t		 flatten)
 {
     cpc_t cpc;
+    cairo_status_t status;
 
     cpc.count = 0;
     cpc.tolerance = tolerance;
     cpc.current_point.x = 0;
     cpc.current_point.y = 0;
 
-    _cairo_path_fixed_interpret (path_fixed,
-				 CAIRO_DIRECTION_FORWARD,
-				 _cpc_move_to,
-				 _cpc_line_to,
-				 flatten ?
-				 _cpc_curve_to_flatten :
-				 _cpc_curve_to,
-				 _cpc_close_path,
-				 &cpc);
+    status = _cairo_path_fixed_interpret (path_fixed,
+				          CAIRO_DIRECTION_FORWARD,
+				          _cpc_move_to,
+				          _cpc_line_to,
+				          flatten ?
+				          _cpc_curve_to_flatten :
+				          _cpc_curve_to,
+				          _cpc_close_path,
+				          &cpc);
+    if (status)
+	return 0;
 
     return cpc.count;
 }
@@ -305,31 +308,34 @@ _cpp_close_path (void *closure)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+static cairo_status_t
 _cairo_path_populate (cairo_path_t		*path,
 		      cairo_path_fixed_t	*path_fixed,
 		      cairo_gstate_t		*gstate,
 		      cairo_bool_t		 flatten)
 {
     cpp_t cpp;
+    cairo_status_t status;
 
     cpp.data = path->data;
     cpp.gstate = gstate;
     cpp.current_point.x = 0;
     cpp.current_point.y = 0;
 
-    _cairo_path_fixed_interpret (path_fixed,
-				 CAIRO_DIRECTION_FORWARD,
-				 _cpp_move_to,
-				 _cpp_line_to,
-				 flatten ?
-				 _cpp_curve_to_flatten :
-				 _cpp_curve_to,
-				 _cpp_close_path,
-				 &cpp);
+    status = _cairo_path_fixed_interpret (path_fixed,
+				          CAIRO_DIRECTION_FORWARD,
+				          _cpp_move_to,
+		         		  _cpp_line_to,
+			         	  flatten ?
+				          _cpp_curve_to_flatten :
+		         		  _cpp_curve_to,
+			         	  _cpp_close_path,
+			         	  &cpp);
 
     /* Sanity check the count */
     assert (cpp.data - path->data == path->num_data);
+
+    return status;
 }
 
 cairo_path_t *
@@ -368,10 +374,8 @@ _cairo_path_create_internal (cairo_path_fixed_t *path_fixed,
 	return (cairo_path_t*) &_cairo_path_nil;
     }
 
-    path->status = CAIRO_STATUS_SUCCESS;
-
-    _cairo_path_populate (path, path_fixed,
-			  gstate, flatten);
+    path->status = _cairo_path_populate (path, path_fixed,
+			                 gstate, flatten);
 
     return path;
 }
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index beb95e8..bfd119a 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -1738,7 +1738,9 @@ _cairo_pattern_get_extents (cairo_pattern_t         *pattern,
 	    return status;
 
 	imatrix = pattern->matrix;
-	cairo_matrix_invert (&imatrix);
+	status = cairo_matrix_invert (&imatrix);
+	if (status)
+	    return status;
 
 	/* XXX Use _cairo_matrix_transform_bounding_box here */
 	for (sy = 0; sy <= 1; sy++) {
diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 924b80c..cdf3d2b 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -900,7 +900,9 @@ _cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	*surface,
     if (status)
 	goto BAIL;
 
-    _cairo_surface_get_extents (&surface->base, &surface_extents);
+    status = _cairo_surface_get_extents (&surface->base, &surface_extents);
+    if (status)
+	goto BAIL;
 
     switch (extend) {
     /* We implement EXTEND_PAD like EXTEND_NONE for now */
@@ -974,7 +976,9 @@ _cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	*surface,
      * pattern cell.
      */
     cairo_p2d = pattern->base.matrix;
-    cairo_matrix_invert (&cairo_p2d);
+    status = cairo_matrix_invert (&cairo_p2d);
+    if (status)
+	goto BAIL;
 
     cairo_matrix_init_identity (&pdf_p2d);
     cairo_matrix_translate (&pdf_p2d, 0.0, surface_extents.height);
@@ -1187,6 +1191,7 @@ _cairo_pdf_surface_emit_pattern_stops (cairo_pdf_surface_t *surface, cairo_gradi
 static cairo_status_t
 _cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_linear_pattern_t *pattern)
 {
+    cairo_status_t status;
     cairo_pdf_resource_t function, pattern_resource, alpha;
     double x0, y0, x1, y1;
     cairo_matrix_t p2u;
@@ -1198,7 +1203,9 @@ _cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_line
 	return CAIRO_STATUS_NO_MEMORY;
 
     p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     x0 = _cairo_fixed_to_double (pattern->gradient.p1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.p1.y);
@@ -1250,6 +1257,7 @@ _cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_line
 static cairo_status_t
 _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radial_pattern_t *pattern)
 {
+    cairo_status_t status;
     cairo_pdf_resource_t function, pattern_resource, alpha;
     double x0, y0, x1, y1, r0, r1;
     cairo_matrix_t p2u;
@@ -1261,7 +1269,9 @@ _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radi
 	return CAIRO_STATUS_NO_MEMORY;
 
     p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     x0 = _cairo_fixed_to_double (pattern->gradient.c1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.c1.y);
@@ -1822,11 +1832,11 @@ _cairo_pdf_surface_emit_cff_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_cff_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
@@ -1931,9 +1941,7 @@ _cairo_pdf_surface_emit_type1_font (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 #if CAIRO_HAS_FT_FONT
@@ -2102,11 +2110,11 @@ _cairo_pdf_surface_emit_truetype_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_truetype_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_int_status_t
@@ -2387,9 +2395,7 @@ _cairo_pdf_surface_emit_type3_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 static void
diff --git a/src/cairo-pen.c b/src/cairo-pen.c
index 1af8c36..55f74d4 100644
--- a/src/cairo-pen.c
+++ b/src/cairo-pen.c
@@ -106,13 +106,13 @@ _cairo_pen_init (cairo_pen_t	*pen,
     return CAIRO_STATUS_SUCCESS;
 }
 
-void
+cairo_status_t
 _cairo_pen_fini (cairo_pen_t *pen)
 {
     free (pen->vertices);
     pen->vertices = NULL;
 
-    _cairo_pen_init_empty (pen);
+    return _cairo_pen_init_empty (pen);
 }
 
 cairo_status_t
@@ -135,6 +135,7 @@ cairo_status_t
 _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
 {
     cairo_pen_vertex_t *vertices;
+    cairo_status_t status;
     int num_vertices;
     int i;
 
@@ -150,7 +151,9 @@ _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
     for (i=0; i < num_points; i++)
 	pen->vertices[pen->num_vertices-num_points+i].point = point[i];
 
-    _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    status = _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    if (status)
+	return status;
 
     _cairo_pen_compute_slopes (pen);
 
@@ -388,7 +391,9 @@ _cairo_pen_stroke_spline_half (cairo_pen_t *pen,
 	final_slope.dy = -final_slope.dy;
     }
 
-    _cairo_pen_find_active_cw_vertex_index (pen, &initial_slope, &active);
+    status = _cairo_pen_find_active_cw_vertex_index (pen, &initial_slope, &active);
+    if (status)
+	return status;
 
     i = start;
     while (i != stop) {
@@ -437,19 +442,22 @@ _cairo_pen_stroke_spline (cairo_pen_t		*pen,
 
     status = _cairo_spline_decompose (spline, tolerance);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_FORWARD, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_REVERSE, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
-    _cairo_polygon_close (&polygon);
-    _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
+    status = _cairo_polygon_close (&polygon);
+    if (status)
+	goto BAIL;
+    status = _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
     _cairo_polygon_fini (&polygon);
 
-    return CAIRO_STATUS_SUCCESS;
+BAIL:
+    return status;
 }
diff --git a/src/cairo-polygon.c b/src/cairo-polygon.c
index f36bc71..80c89a0 100644
--- a/src/cairo-polygon.c
+++ b/src/cairo-polygon.c
@@ -135,9 +135,9 @@ _cairo_polygon_add_edge (cairo_polygon_t *polygon, cairo_point_t *p1, cairo_poin
     polygon->num_edges++;
 
   DONE:
-    _cairo_polygon_move_to (polygon, p2);
+    status = _cairo_polygon_move_to (polygon, p2);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
@@ -154,12 +154,12 @@ _cairo_polygon_move_to (cairo_polygon_t *polygon, cairo_point_t *point)
 cairo_status_t
 _cairo_polygon_line_to (cairo_polygon_t *polygon, cairo_point_t *point)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
 
     if (polygon->has_current_point) {
 	status = _cairo_polygon_add_edge (polygon, &polygon->current_point, point);
     } else {
-	_cairo_polygon_move_to (polygon, point);
+	status = _cairo_polygon_move_to (polygon, point);
     }
 
     return status;
diff --git a/src/cairo-ps-surface.c b/src/cairo-ps-surface.c
index 5f43e98..01c5003 100644
--- a/src/cairo-ps-surface.c
+++ b/src/cairo-ps-surface.c
@@ -298,6 +298,7 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 {
     cairo_output_stream_t *word_wrap;
     cairo_status_t status;
+    cairo_status_t status2;
     ps_path_info_t path_info;
 
     word_wrap = _word_wrap_stream_create (stream, 79);
@@ -315,7 +316,9 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 
     if (status == CAIRO_STATUS_SUCCESS)
 	status = _cairo_output_stream_get_status (word_wrap);
-    _cairo_output_stream_destroy (word_wrap);
+    status2 = _cairo_output_stream_destroy (word_wrap);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
@@ -834,6 +837,7 @@ _cairo_ps_surface_create_for_stream_internal (cairo_output_stream_t *stream,
 					    &cairo_ps_surface_paginated_backend);
 
  CLEANUP_OUTPUT_STREAM:
+    /* ignore further errors, as we are already on an error path */
     _cairo_output_stream_destroy (surface->stream);
  CLEANUP_TMPFILE:
     fclose (surface->tmpfile);
@@ -1202,6 +1206,7 @@ static cairo_status_t
 _cairo_ps_surface_finish (void *abstract_surface)
 {
     cairo_status_t status;
+    cairo_status_t status2;
     cairo_ps_surface_t *surface = abstract_surface;
     int i, num_comments;
     char **comments;
@@ -1214,16 +1219,13 @@ _cairo_ps_surface_finish (void *abstract_surface)
 
     _cairo_ps_surface_emit_footer (surface);
 
-    _cairo_output_stream_close (surface->stream);
-    status = _cairo_output_stream_get_status (surface->stream);
-    _cairo_output_stream_destroy (surface->stream);
+    status = _cairo_output_stream_destroy (surface->stream);
 
     fclose (surface->tmpfile);
 
-    _cairo_output_stream_close (surface->final_stream);
+    status2 = _cairo_output_stream_destroy (surface->final_stream);
     if (status == CAIRO_STATUS_SUCCESS)
-	status = _cairo_output_stream_get_status (surface->final_stream);
-    _cairo_output_stream_destroy (surface->final_stream);
+	status = status2;
 
     num_comments = _cairo_array_num_elements (&surface->dsc_header_comments);
     comments = _cairo_array_index (&surface->dsc_header_comments, 0);
@@ -1588,23 +1590,26 @@ _cairo_ps_surface_emit_image (cairo_ps_surface_t    *surface,
 
 	_cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-	_cairo_surface_fill_rectangle (opaque,
+	status = _cairo_surface_fill_rectangle (opaque,
 				       CAIRO_OPERATOR_SOURCE,
 				       CAIRO_COLOR_WHITE,
 				       0, 0, image->width, image->height);
 
-	_cairo_surface_composite (CAIRO_OPERATOR_OVER,
-				  &pattern.base,
-				  NULL,
-				  opaque,
-				  0, 0,
-				  0, 0,
-				  0, 0,
-				  image->width,
-				  image->height);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+				               &pattern.base,
+				               NULL,
+				               opaque,
+				               0, 0,
+				               0, 0,
+				               0, 0,
+				               image->width,
+				               image->height);
 
 	_cairo_pattern_fini (&pattern.base);
 	opaque_image = (cairo_image_surface_t *) opaque;
+	if (status)
+	    goto bail1;
     } else {
 	opaque = &image->base;
 	opaque_image = image;
@@ -1705,19 +1710,24 @@ _cairo_ps_surface_emit_solid_pattern (cairo_ps_surface_t *surface,
 				     pattern->color.blue);
 }
 
-static void
+static cairo_status_t
 _cairo_ps_surface_emit_surface_pattern (cairo_ps_surface_t *surface,
 		      cairo_surface_pattern_t *pattern)
 {
     double bbox_width, bbox_height;
     double xstep, ystep;
     cairo_matrix_t inverse = pattern->base.matrix;
+    cairo_status_t status;
 
-    cairo_matrix_invert (&inverse);
+    status = cairo_matrix_invert (&inverse);
+    if (status)
+	return status;
 
     if (_cairo_surface_is_meta (pattern->surface)) {
 	_cairo_output_stream_printf (surface->stream, "/MyPattern {\n");
-	_cairo_meta_surface_replay (pattern->surface, &surface->base);
+	status = _cairo_meta_surface_replay (pattern->surface, &surface->base);
+	if (status)
+	    return status;
 	bbox_width = surface->width;
 	bbox_height = surface->height;
 	xstep = surface->width;
@@ -1805,6 +1815,8 @@ _cairo_ps_surface_emit_surface_pattern (cairo_ps_surface_t *surface,
 				 inverse.x0, inverse.y0);
     _cairo_output_stream_printf (surface->stream,
 				 "makepattern setpattern\n");
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static void
@@ -1821,9 +1833,10 @@ _cairo_ps_surface_emit_radial_pattern (cairo_ps_surface_t *surface,
     /* XXX: NYI */
 }
 
-static void
+static cairo_status_t
 _cairo_ps_surface_emit_pattern (cairo_ps_surface_t *surface, cairo_pattern_t *pattern)
 {
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
     /* FIXME: We should keep track of what pattern is currently set in
      * the postscript file and only emit code if we're setting a
      * different pattern. */
@@ -1834,7 +1847,7 @@ _cairo_ps_surface_emit_pattern (cairo_ps_surface_t *surface, cairo_pattern_t *pa
 	break;
 
     case CAIRO_PATTERN_TYPE_SURFACE:
-	_cairo_ps_surface_emit_surface_pattern (surface, (cairo_surface_pattern_t *) pattern);
+	status = _cairo_ps_surface_emit_surface_pattern (surface, (cairo_surface_pattern_t *) pattern);
 	break;
 
     case CAIRO_PATTERN_TYPE_LINEAR:
@@ -1845,6 +1858,7 @@ _cairo_ps_surface_emit_pattern (cairo_ps_surface_t *surface, cairo_pattern_t *pa
 	_cairo_ps_surface_emit_radial_pattern (surface, (cairo_radial_pattern_t *) pattern);
 	break;
     }
+    return status;
 }
 
 static cairo_int_status_t
@@ -1930,6 +1944,7 @@ _cairo_ps_surface_paint (void			*abstract_surface,
     cairo_ps_surface_t *surface = abstract_surface;
     cairo_output_stream_t *stream = surface->stream;
     cairo_rectangle_int16_t extents, pattern_extents;
+    cairo_status_t status;
 
     if (surface->paginated_mode == CAIRO_PAGINATED_MODE_ANALYZE)
 	return _cairo_ps_surface_analyze_operation (surface, op, source);
@@ -1947,8 +1962,12 @@ _cairo_ps_surface_paint (void			*abstract_surface,
     _cairo_output_stream_printf (stream,
 				 "%% _cairo_ps_surface_paint\n");
 
-    _cairo_surface_get_extents (&surface->base, &extents);
-    _cairo_pattern_get_extents (source, &pattern_extents);
+    status = _cairo_surface_get_extents (&surface->base, &extents);
+    if (status)
+	return status;
+    status = _cairo_pattern_get_extents (source, &pattern_extents);
+    if (status)
+	return status;
     _cairo_rectangle_intersect (&extents, &pattern_extents);
 
     _cairo_ps_surface_emit_pattern (surface, source);
@@ -2197,12 +2216,12 @@ _cairo_ps_surface_show_glyphs (void		     *abstract_surface,
 			       int		      num_glyphs,
 			       cairo_scaled_font_t   *scaled_font)
 {
+    cairo_status_t status;
     cairo_ps_surface_t *surface = abstract_surface;
     cairo_output_stream_t *stream = surface->stream;
     unsigned int current_subset_id = -1;
     unsigned int font_id;
     cairo_ps_glyph_id_t *glyph_ids;
-    cairo_status_t status;
     unsigned int num_glyphs_unsigned, i, j, last, end;
     cairo_bool_t vertical, horizontal;
     cairo_output_stream_t *word_wrap;
@@ -2220,7 +2239,9 @@ _cairo_ps_surface_show_glyphs (void		     *abstract_surface,
 
     num_glyphs_unsigned = num_glyphs;
 
-    _cairo_ps_surface_emit_pattern (surface, source);
+    status = _cairo_ps_surface_emit_pattern (surface, source);
+    if (status)
+	return status;
     glyph_ids = malloc (num_glyphs_unsigned*sizeof (cairo_ps_glyph_id_t));
     if (glyph_ids == NULL)
         return CAIRO_STATUS_NO_MEMORY;
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 963c060..407008d 100644
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -397,15 +397,18 @@ _cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font)
 					       max_glyphs_cached_per_font);
 }
 
-void
+cairo_status_t
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics)
 {
     double  font_scale_x, font_scale_y;
+    cairo_status_t status;
 
-    _cairo_matrix_compute_scale_factors (&scaled_font->font_matrix,
-					 &font_scale_x, &font_scale_y,
-					 /* XXX */ 1);
+    status = _cairo_matrix_compute_scale_factors (&scaled_font->font_matrix,
+					          &font_scale_x, &font_scale_y,
+					          /* XXX */ 1);
+    if (status)
+	return status;
 
     /*
      * The font responded in unscaled units, scale by the font
@@ -417,6 +420,8 @@ _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
     scaled_font->extents.height = fs_metrics->height * font_scale_y;
     scaled_font->extents.max_x_advance = fs_metrics->max_x_advance * font_scale_x;
     scaled_font->extents.max_y_advance = fs_metrics->max_y_advance * font_scale_y;
+
+    return status;
 }
 
 void
@@ -1197,6 +1202,7 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
 		     cairo_path_fixed_t *path)
 {
     cairo_image_surface_t *a1_mask;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
     unsigned char *row, *byte_ptr, byte;
     int rows, cols, bytes_per_row;
     int x, y, bit;
@@ -1218,28 +1224,39 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
 	    byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte_ptr);
 	    for (bit = 7; bit >= 0 && x < a1_mask->width; bit--, x++) {
 		if (byte & (1 << bit)) {
-		    _cairo_path_fixed_move_to (path,
-					       _cairo_fixed_from_int (x + xoff),
-					       _cairo_fixed_from_int (y + yoff));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (1),
-						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (0),
-						   _cairo_fixed_from_int (1));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (-1),
-						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_close_path (path);
+		    status = _cairo_path_fixed_move_to (path,
+					      _cairo_fixed_from_int (x + xoff),
+					      _cairo_fixed_from_int (y + yoff));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (1),
+						     _cairo_fixed_from_int (0));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (0),
+						     _cairo_fixed_from_int (1));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (-1),
+						     _cairo_fixed_from_int (0));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_close_path (path);
+		    if (status)
+			goto BAIL;
 		}
 	    }
 	}
     }
 
+BAIL:
     if (a1_mask != mask)
 	cairo_surface_destroy (&a1_mask->base);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..6a9fd1e 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -452,8 +452,11 @@ _composite_trap_region (cairo_clip_t            *clip,
 				       extents->width, extents->height);
 
     /* Restore the original clip if we modified it temporarily. */
-    if (num_rects >1)
-	_cairo_surface_set_clip (dst, clip);
+    if (num_rects >1) {
+	cairo_status_t status2 = _cairo_surface_set_clip (dst, clip);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = status2;
+    }
 
     if (clip_surface)
       _cairo_pattern_fini (&mask.base);
@@ -979,7 +982,7 @@ _cairo_surface_fallback_snapshot (cairo_surface_t *surface)
 
     _cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
+    status = _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
 			      &pattern.base,
 			      NULL,
 			      snapshot,
@@ -993,6 +996,10 @@ _cairo_surface_fallback_snapshot (cairo_surface_t *surface)
 
     _cairo_surface_release_source_image (surface,
 					 image, &image_extra);
+    if (status != CAIRO_STATUS_SUCCESS) {
+	cairo_surface_destroy (snapshot);
+	return (cairo_surface_t *) &_cairo_surface_nil;
+    }
 
     snapshot->device_transform = surface->device_transform;
     snapshot->device_transform_inverse = surface->device_transform_inverse;
@@ -1158,13 +1165,14 @@ _cairo_surface_fallback_composite_trapezoids (cairo_operator_t		op,
 	traps = offset_traps;
     }
 
-    _cairo_surface_composite_trapezoids (op, pattern,
-					 &state.image->base,
-					 antialias,
-					 src_x, src_y,
-					 dst_x - state.image_rect.x,
-					 dst_y - state.image_rect.y,
-					 width, height, traps, num_traps);
+    status = _cairo_surface_composite_trapezoids (op, pattern,
+					          &state.image->base,
+						  antialias,
+						  src_x, src_y,
+						  dst_x - state.image_rect.x,
+						  dst_y - state.image_rect.y,
+						  width, height,
+						  traps, num_traps);
     if (offset_traps)
 	free (offset_traps);
 
diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index 0da1557..d6cfcff 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -435,6 +435,7 @@ _cairo_svg_surface_store_page (cairo_svg_surface_t *surface)
 {
     unsigned int i;
     cairo_svg_page_t page;
+    cairo_status_t status;
 
     page.surface_id = surface->id;
     page.clip_id = surface->base_clip;
@@ -447,7 +448,9 @@ _cairo_svg_surface_store_page (cairo_svg_surface_t *surface)
     for (i = 0; i < page.clip_level; i++)
 	_cairo_output_stream_printf (page.xml_node, "</g>\n");
 
-    _cairo_array_append (&surface->page_set, &page);
+    status = _cairo_array_append (&surface->page_set, &page);
+    if (status)
+	return NULL;
 
     return _cairo_array_index (&surface->page_set, surface->page_set.num_elements - 1);
 }
@@ -459,6 +462,8 @@ _cairo_svg_surface_copy_page (void *abstract_surface)
     cairo_svg_page_t *page;
 
     page = _cairo_svg_surface_store_page (surface);
+    if (page == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
 
     _cairo_memory_stream_copy (page->xml_node, surface->xml_node);
     surface->clip_level = page->clip_level;
@@ -471,7 +476,8 @@ _cairo_svg_surface_show_page (void *abstract_surface)
 {
     cairo_svg_surface_t *surface = abstract_surface;
 
-    _cairo_svg_surface_store_page (surface);
+    if (_cairo_svg_surface_store_page (surface) == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -777,6 +783,7 @@ static cairo_status_t
 _cairo_svg_surface_finish (void *abstract_surface)
 {
     cairo_status_t status;
+    cairo_status_t status2;
     cairo_svg_surface_t *surface = abstract_surface;
     cairo_svg_document_t *document = surface->document;
     cairo_svg_page_t *page;
@@ -787,11 +794,15 @@ _cairo_svg_surface_finish (void *abstract_surface)
     else
 	status = CAIRO_STATUS_SUCCESS;
 
-    _cairo_output_stream_destroy (surface->xml_node);
+    status2 = _cairo_output_stream_destroy (surface->xml_node);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     for (i = 0; i < surface->page_set.num_elements; i++) {
 	page = _cairo_array_index (&surface->page_set, i);
-	_cairo_output_stream_destroy (page->xml_node);
+	status2 = _cairo_output_stream_destroy (page->xml_node);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = status2;
     }
     _cairo_array_fini (&surface->page_set);
 
@@ -941,7 +952,9 @@ _cairo_svg_surface_emit_composite_image_pattern (cairo_output_stream_t     *outp
 	return status;
 
     p2u = pattern->base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     if (pattern_id != invalid_pattern_id) {
 	_cairo_output_stream_printf (output,
@@ -1074,6 +1087,7 @@ _cairo_svg_surface_emit_composite_meta_pattern (cairo_output_stream_t	*output,
 {
     cairo_svg_document_t *document = surface->document;
     cairo_meta_surface_t *meta_surface;
+    cairo_status_t status;
     cairo_matrix_t p2u;
     int id;
 
@@ -1082,7 +1096,9 @@ _cairo_svg_surface_emit_composite_meta_pattern (cairo_output_stream_t	*output,
     id = _cairo_svg_surface_emit_meta_surface (document, meta_surface);
 
     p2u = pattern->base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     if (pattern_id != invalid_pattern_id) {
 	_cairo_output_stream_printf (output,
@@ -1406,13 +1422,14 @@ _cairo_svg_surface_emit_linear_pattern (cairo_svg_surface_t    *surface,
     document->linear_pattern_id++;
 }
 
-static void
+static cairo_status_t
 _cairo_svg_surface_emit_radial_pattern (cairo_svg_surface_t    *surface,
 		     cairo_radial_pattern_t *pattern,
 		     cairo_output_stream_t  *style,
 		     cairo_bool_t            is_stroke)
 {
     cairo_svg_document_t *document = surface->document;
+    cairo_status_t status;
     cairo_matrix_t p2u;
     cairo_extend_t extend;
     double x0, y0, x1, y1, r0, r1;
@@ -1440,7 +1457,9 @@ _cairo_svg_surface_emit_radial_pattern (cairo_svg_surface_t    *surface,
     r1 = _cairo_fixed_to_double (c1->radius);
 
     p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     if (pattern->gradient.c1.radius == pattern->gradient.c2.radius) {
 	_cairo_output_stream_printf (document->xml_node_defs,
@@ -1571,12 +1590,15 @@ _cairo_svg_surface_emit_radial_pattern (cairo_svg_surface_t    *surface,
 				 document->radial_pattern_id);
 
     document->radial_pattern_id++;
+
+    return status;
 }
 
-static void
+cairo_static cairo_status_t
 _cairo_svg_surface_emit_pattern (cairo_svg_surface_t *surface, cairo_pattern_t *pattern,
 	      cairo_output_stream_t *output, cairo_bool_t is_stroke)
 {
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
     switch (pattern->type) {
     case CAIRO_PATTERN_TYPE_SOLID:
 	_cairo_svg_surface_emit_solid_pattern (surface, (cairo_solid_pattern_t *) pattern, output, is_stroke);
@@ -1591,9 +1613,10 @@ _cairo_svg_surface_emit_pattern (cairo_svg_surface_t *surface, cairo_pattern_t *
 	break;
 
     case CAIRO_PATTERN_TYPE_RADIAL:
-	_cairo_svg_surface_emit_radial_pattern (surface, (cairo_radial_pattern_t *) pattern, output, is_stroke);
+	status = _cairo_svg_surface_emit_radial_pattern (surface, (cairo_radial_pattern_t *) pattern, output, is_stroke);
 	break;
     }
+    return status;
 }
 
 static cairo_int_status_t
@@ -1619,7 +1642,9 @@ _cairo_svg_surface_fill (void			*abstract_surface,
  				 fill_rule == CAIRO_FILL_RULE_EVEN_ODD ?
  				 "evenodd" : "nonzero");
     _cairo_svg_surface_emit_operator (surface->xml_node, surface, op);
-    _cairo_svg_surface_emit_pattern (surface, source, surface->xml_node, FALSE);
+    status = _cairo_svg_surface_emit_pattern (surface, source, surface->xml_node, FALSE);
+    if (status)
+	return status;
     _cairo_output_stream_printf (surface->xml_node, "\" ");
 
     status = _cairo_svg_surface_emit_path (surface->xml_node, path, NULL);
diff --git a/src/cairo-traps.c b/src/cairo-traps.c
index 65075c2..ec1d78d 100644
--- a/src/cairo-traps.c
+++ b/src/cairo-traps.c
@@ -385,6 +385,7 @@ _cairo_traps_tessellate_convex_quad (cairo_traps_t *traps, cairo_point_t q[4])
 
     b_left_of_d = (_cairo_slope_compare (&ab, &ad) > 0);
 
+    /* ignore the status returns until the end */
     if (q[c].y <= q[d].y) {
 	if (b_left_of_d) {
 	    /* Y-sort is abcd and b is left of d, (slope(ab) > slope (ad))
diff --git a/src/cairo-truetype-subset.c b/src/cairo-truetype-subset.c
index a99aed7..a013396 100644
--- a/src/cairo-truetype-subset.c
+++ b/src/cairo-truetype-subset.c
@@ -320,16 +320,20 @@ cairo_truetype_font_align_output (cairo_truetype_font_t *font)
     return aligned;
 }
 
-static void
+static cairo_status_t
 cairo_truetype_font_check_boundary (cairo_truetype_font_t *font,
 				    unsigned long          boundary)
 {
     if (boundary - font->last_offset > SFNT_STRING_MAX_LENGTH)
     {
-        _cairo_array_append(&font->string_offsets, &font->last_boundary);
+	cairo_status_t status;
+        status = _cairo_array_append(&font->string_offsets, &font->last_boundary);
+	if (status)
+	    return status;
         font->last_offset = font->last_boundary;
     }
     font->last_boundary = boundary;
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static int
@@ -487,7 +491,9 @@ cairo_truetype_font_write_glyf_table (cairo_truetype_font_t *font,
 	size = end - begin;
 
         next = cairo_truetype_font_align_output (font);
-        cairo_truetype_font_check_boundary (font, next);
+        status = cairo_truetype_font_check_boundary (font, next);
+	if (status)
+	    break;
         font->glyphs[i].location = next - start_offset;
 
 	status = cairo_truetype_font_allocate_write_buffer (font, size, &buffer);
@@ -793,7 +799,8 @@ cairo_truetype_font_generate (cairo_truetype_font_t  *font,
 	next = cairo_truetype_font_align_output (font);
 	cairo_truetype_font_update_entry (font, truetype_tables[i].pos, truetype_tables[i].tag,
 					start, end);
-        cairo_truetype_font_check_boundary (font, next);
+        if (cairo_truetype_font_check_boundary (font, next))
+	    goto fail;
 	start = next;
     }
 
diff --git a/src/cairo-type1-fallback.c b/src/cairo-type1-fallback.c
index a183b28..5502787 100644
--- a/src/cairo-type1-fallback.c
+++ b/src/cairo-type1-fallback.c
@@ -464,10 +464,11 @@ fail:
     return status;
 }
 
-static void
+static cairo_status_t
 cairo_type1_font_write_header (cairo_type1_font_t *font,
                                const char         *name)
 {
+    cairo_status_t status;
     cairo_matrix_t matrix;
     unsigned int i;
     const char spaces[50] = "                                                  ";
@@ -475,7 +476,9 @@ cairo_type1_font_write_header (cairo_type1_font_t *font,
     matrix = font->type1_scaled_font->scale;
     matrix.xy = -matrix.xy;
     matrix.yy = -matrix.yy;
-    cairo_matrix_invert (&matrix);
+    status = cairo_matrix_invert (&matrix);
+    if (status)
+	return status;
 
     _cairo_output_stream_printf (font->output,
                                  "%%!FontType1-1.1 %s 1.0\n"
@@ -512,6 +515,8 @@ cairo_type1_font_write_header (cairo_type1_font_t *font,
                                  "readonly def\n"
                                  "currentdict end\n"
                                  "currentfile eexec\n");
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
@@ -558,6 +563,7 @@ cairo_type1_font_write_private_dict (cairo_type1_font_t *font,
                                      const char         *name)
 {
     cairo_int_status_t status;
+    cairo_status_t status2;
     cairo_output_stream_t *encrypted_output;
 
     font->eexec_key = CAIRO_TYPE1_PRIVATE_DICT_KEY;
@@ -600,7 +606,9 @@ cairo_type1_font_write_private_dict (cairo_type1_font_t *font,
     if (status == CAIRO_STATUS_SUCCESS)
 	status = _cairo_output_stream_get_status (encrypted_output);
   fail:
-    _cairo_output_stream_destroy (encrypted_output);
+    status2 = _cairo_output_stream_destroy (encrypted_output);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
@@ -634,7 +642,9 @@ cairo_type1_font_write (cairo_type1_font_t *font,
 {
     cairo_int_status_t status;
 
-    cairo_type1_font_write_header (font, name);
+    status = cairo_type1_font_write_header (font, name);
+    if (status)
+	return status;
     font->header_size = _cairo_output_stream_get_position (font->output);
 
     status = cairo_type1_font_write_private_dict (font, name);
@@ -672,14 +682,16 @@ cairo_type1_font_generate (cairo_type1_font_t *font, const char *name)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+cairo_static cairo_status_t
 cairo_type1_font_destroy (cairo_type1_font_t *font)
 {
+    cairo_status_t status;
     free (font->widths);
     cairo_scaled_font_destroy (font->type1_scaled_font);
     _cairo_array_fini (&font->contents);
-    _cairo_output_stream_destroy (font->output);
+    status = _cairo_output_stream_destroy (font->output);
     free (font);
+    return status;
 }
 
 static cairo_status_t
@@ -745,9 +757,9 @@ _cairo_type1_fallback_init_internal (cairo_type1_subset_t	*type1_subset,
     type1_subset->data_length = font->data_size;
     type1_subset->trailer_length = font->trailer_size;
 
-    cairo_type1_font_destroy (font);
-    return CAIRO_STATUS_SUCCESS;
+    return cairo_type1_font_destroy (font);
 
+    /* error path, ignore further errors */
  fail3:
     free (type1_subset->widths);
  fail2:
diff --git a/src/cairo-xlib-private.h b/src/cairo-xlib-private.h
index 8ba46a2..9ecf5fe 100644
--- a/src/cairo-xlib-private.h
+++ b/src/cairo-xlib-private.h
@@ -63,7 +63,7 @@ _cairo_xlib_screen_info_get (Display *display, Screen *screen);
 
 cairo_private cairo_bool_t
 _cairo_xlib_add_close_display_hook (Display *display, void (*func) (Display *, void *), void *data, void *key);
-cairo_private void
+cairo_private_no_warn void
 _cairo_xlib_remove_close_display_hook (Display *display, void *key);
 
 #if CAIRO_HAS_XLIB_XRENDER_SURFACE
diff --git a/src/cairo.c b/src/cairo.c
index 21303de..1c5eafc 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -189,6 +189,7 @@ cairo_t *
 cairo_create (cairo_surface_t *target)
 {
     cairo_t *cr;
+    cairo_status_t status;
 
     cr = malloc (sizeof (cairo_t));
     if (cr == NULL)
@@ -201,12 +202,16 @@ cairo_create (cairo_surface_t *target)
     _cairo_user_data_array_init (&cr->user_data);
 
     cr->gstate = cr->gstate_tail;
-    _cairo_gstate_init (cr->gstate, target);
+    status = _cairo_gstate_init (cr->gstate, target);
 
     _cairo_path_fixed_init (cr->path);
 
     if (target == NULL) {
-	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
+	/* override internal errors */
+	status = CAIRO_STATUS_NULL_POINTER;
+    }
+    if (status) {
+	_cairo_set_error (cr, status);
     }
 
     return cr;
@@ -491,7 +496,9 @@ cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
     cairo_surface_t *group_surface = NULL;
 
     /* Get the extents that we'll use in creating our new group surface */
-    _cairo_surface_get_extents (_cairo_gstate_get_target (cr->gstate), &extents);
+    status = _cairo_surface_get_extents (_cairo_gstate_get_target (cr->gstate), &extents);
+    if (status != CAIRO_STATUS_SUCCESS)
+	goto bail;
     status = _cairo_clip_intersect_to_rectangle (_cairo_gstate_get_clip (cr->gstate), &extents);
     if (status != CAIRO_STATUS_SUCCESS)
 	goto bail;
@@ -518,7 +525,7 @@ cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
     if (cr->status)
 	goto bail;
 
-    _cairo_gstate_redirect_target (cr->gstate, group_surface);
+    status = _cairo_gstate_redirect_target (cr->gstate, group_surface);
 
 bail:
     cairo_surface_destroy (group_surface);
@@ -1624,17 +1631,20 @@ void
 cairo_rel_move_to (cairo_t *cr, double dx, double dy)
 {
     cairo_fixed_t dx_fixed, dy_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 
 /**
@@ -1659,17 +1669,20 @@ void
 cairo_rel_line_to (cairo_t *cr, double dx, double dy)
 {
     cairo_fixed_t dx_fixed, dy_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 slim_hidden_def(cairo_rel_line_to);
 
@@ -1708,13 +1721,20 @@ cairo_rel_curve_to (cairo_t *cr,
     cairo_fixed_t dx1_fixed, dy1_fixed;
     cairo_fixed_t dx2_fixed, dy2_fixed;
     cairo_fixed_t dx3_fixed, dy3_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
+    if (status)
+	goto BAIL;
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
+    if (status)
+	goto BAIL;
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    if (status)
+	goto BAIL;
 
     dx1_fixed = _cairo_fixed_from_double (dx1);
     dy1_fixed = _cairo_fixed_from_double (dy1);
@@ -1725,11 +1745,12 @@ cairo_rel_curve_to (cairo_t *cr,
     dx3_fixed = _cairo_fixed_from_double (dx3);
     dy3_fixed = _cairo_fixed_from_double (dy3);
 
-    cr->status = _cairo_path_fixed_rel_curve_to (cr->path,
-						 dx1_fixed, dy1_fixed,
-						 dx2_fixed, dy2_fixed,
-						 dx3_fixed, dy3_fixed);
-    if (cr->status)
+    status = _cairo_path_fixed_rel_curve_to (cr->path,
+				             dx1_fixed, dy1_fixed,
+					     dx2_fixed, dy2_fixed,
+					     dx3_fixed, dy3_fixed);
+BAIL:
+    if (status)
 	_cairo_set_error (cr, cr->status);
 }
 
diff --git a/src/cairoint.h b/src/cairoint.h
index 579f021..9c0c939 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -1262,7 +1262,7 @@ _cairo_gstate_destroy (cairo_gstate_t *gstate);
 cairo_private cairo_bool_t
 _cairo_gstate_is_redirected (cairo_gstate_t *gstate);
 
-cairo_private_no_warn void
+cairo_private cairo_status_t
 _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child);
 
 cairo_private cairo_surface_t *
@@ -1744,7 +1744,7 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			 const cairo_font_options_t	   *options,
 			 const cairo_scaled_font_backend_t *backend);
 
-cairo_private_no_warn void
+cairo_private cairo_status_t
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics);
 
@@ -2186,7 +2186,7 @@ _cairo_pen_init_empty (cairo_pen_t *pen);
 cairo_private cairo_status_t
 _cairo_pen_init_copy (cairo_pen_t *pen, cairo_pen_t *other);
 
-cairo_private_no_warn void
+cairo_private cairo_status_t
 _cairo_pen_fini (cairo_pen_t *pen);
 
 cairo_private cairo_status_t
diff --git a/test/buffer-diff.c b/test/buffer-diff.c
index d111b23..a77a145 100644
--- a/test/buffer-diff.c
+++ b/test/buffer-diff.c
@@ -275,7 +275,7 @@ image_diff_core (const char *filename_a,
 		 buffer_diff_result_t *result,
 		 cairo_bool_t	flatten)
 {
-    cairo_status_t status;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
     unsigned int width_a, height_a, stride_a;
     unsigned int width_b, height_b, stride_b;
     cairo_surface_t *surface_a, *surface_b, *surface_diff;
@@ -347,7 +347,7 @@ image_diff_core (const char *filename_a,
 	else
 	    png_file = stdout;
 
-	cairo_surface_write_to_png_stream (surface_diff, stdio_write_func, png_file);
+	status = cairo_surface_write_to_png_stream (surface_diff, stdio_write_func, png_file);
 
 	if (png_file != stdout)
 	    fclose (png_file);
@@ -360,7 +360,7 @@ image_diff_core (const char *filename_a,
     cairo_surface_destroy (surface_b);
     cairo_surface_destroy (surface_diff);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Wed Mar 21 10:51:07 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar 21 10:51:14 2007
Subject: [cairo] Mark cairo_fixed_t conversion functions with
	attribute(const)
Message-ID: <20070321175107.GC10524@inspired.chris-wilson.co.uk>

The cairo_fixed_t conversion functions look apt for the const attribute
as they only operate on their parameters and do not touch memory. They
also look suitable for inlining should anyone have any profile data
suggesting it would be a win...
--
Chris Wilson
-------------- next part --------------
>From 1283c0c6630f52c2af710cd241e0b0f1088c2fac Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 21 Mar 2007 17:43:33 +0000
Subject: [PATCH] Mark cairo_fixed_t conversion functions as const.

Introduce the gcc attribute(const), which implies that function only
operates on its parameters and has no effects other than the return
value. And use the attribute for the cairo_fixed.c functions which
meet this strict specification.
---
 src/cairoint.h |   22 ++++++++++++++--------
 1 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/src/cairoint.h b/src/cairoint.h
index 6e171e5..cd5f2aa 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -101,6 +101,12 @@ CAIRO_BEGIN_DECLS
 #define CAIRO_PRINTF_FORMAT(fmt_index, va_index)
 #endif
 
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+#define CAIRO_PURE __attribute__((__pure__))
+#else
+#define CAIRO_PURE
+#endif
+
 /* slim_internal.h */
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
 #define cairo_private		__attribute__((__visibility__("hidden")))
@@ -1211,30 +1217,30 @@ _cairo_lround (double d);
 
 /* cairo_fixed.c */
 cairo_private cairo_fixed_t
-_cairo_fixed_from_int (int i);
+_cairo_fixed_from_int (int i) CAIRO_PURE;
 
 #define CAIRO_FIXED_ONE _cairo_fixed_from_int (1)
 
 cairo_private cairo_fixed_t
-_cairo_fixed_from_double (double d);
+_cairo_fixed_from_double (double d) CAIRO_PURE;
 
 cairo_private cairo_fixed_t
-_cairo_fixed_from_26_6 (uint32_t i);
+_cairo_fixed_from_26_6 (uint32_t i) CAIRO_PURE;
 
 cairo_private double
-_cairo_fixed_to_double (cairo_fixed_t f);
+_cairo_fixed_to_double (cairo_fixed_t f) CAIRO_PURE;
 
 cairo_private int
-_cairo_fixed_is_integer (cairo_fixed_t f);
+_cairo_fixed_is_integer (cairo_fixed_t f) CAIRO_PURE;
 
 cairo_private int
-_cairo_fixed_integer_part (cairo_fixed_t f);
+_cairo_fixed_integer_part (cairo_fixed_t f) CAIRO_PURE;
 
 cairo_private int
-_cairo_fixed_integer_floor (cairo_fixed_t f);
+_cairo_fixed_integer_floor (cairo_fixed_t f) CAIRO_PURE;
 
 cairo_private int
-_cairo_fixed_integer_ceil (cairo_fixed_t f);
+_cairo_fixed_integer_ceil (cairo_fixed_t f) CAIRO_PURE;
 
 /* cairo_gstate.c */
 cairo_private cairo_status_t
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Wed Mar 21 10:57:20 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar 21 10:57:28 2007
Subject: [cairo] Mark cairo_fixed_t conversion functions with
	attribute(const)
In-Reply-To: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
References: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
Message-ID: <20070321175720.GD10524@inspired.chris-wilson.co.uk>

Actually attach the right patch this time - I tried outsmarting git and
lost.
--
Chris Wilson
-------------- next part --------------
>From 4fba15f347169e69b22744018593c6f52cf6af5c Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 21 Mar 2007 17:43:33 +0000
Subject: [PATCH] Mark cairo_fixed_t conversion functions as const.

Introduce the gcc attribute(const), which implies that function only
operates on its parameters and has no effects other than the return
value. And use the attribute for the cairo_fixed.c functions which
meet this strict specification.
---
 src/cairoint.h |   22 ++++++++++++++--------
 1 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/src/cairoint.h b/src/cairoint.h
index 6e171e5..090f5a4 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -101,6 +101,12 @@ CAIRO_BEGIN_DECLS
 #define CAIRO_PRINTF_FORMAT(fmt_index, va_index)
 #endif
 
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define CAIRO_CONST __attribute__((__const__))
+#else
+#define CAIRO_CONST
+#endif
+
 /* slim_internal.h */
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
 #define cairo_private		__attribute__((__visibility__("hidden")))
@@ -1211,30 +1217,30 @@ _cairo_lround (double d);
 
 /* cairo_fixed.c */
 cairo_private cairo_fixed_t
-_cairo_fixed_from_int (int i);
+_cairo_fixed_from_int (int i) CAIRO_CONST;
 
 #define CAIRO_FIXED_ONE _cairo_fixed_from_int (1)
 
 cairo_private cairo_fixed_t
-_cairo_fixed_from_double (double d);
+_cairo_fixed_from_double (double d) CAIRO_CONST;
 
 cairo_private cairo_fixed_t
-_cairo_fixed_from_26_6 (uint32_t i);
+_cairo_fixed_from_26_6 (uint32_t i) CAIRO_CONST;
 
 cairo_private double
-_cairo_fixed_to_double (cairo_fixed_t f);
+_cairo_fixed_to_double (cairo_fixed_t f) CAIRO_CONST;
 
 cairo_private int
-_cairo_fixed_is_integer (cairo_fixed_t f);
+_cairo_fixed_is_integer (cairo_fixed_t f) CAIRO_CONST;
 
 cairo_private int
-_cairo_fixed_integer_part (cairo_fixed_t f);
+_cairo_fixed_integer_part (cairo_fixed_t f) CAIRO_CONST;
 
 cairo_private int
-_cairo_fixed_integer_floor (cairo_fixed_t f);
+_cairo_fixed_integer_floor (cairo_fixed_t f) CAIRO_CONST;
 
 cairo_private int
-_cairo_fixed_integer_ceil (cairo_fixed_t f);
+_cairo_fixed_integer_ceil (cairo_fixed_t f) CAIRO_CONST;
 
 /* cairo_gstate.c */
 cairo_private cairo_status_t
-- 
1.4.4.2

From ross at burtonini.com  Wed Mar 21 11:12:04 2007
From: ross at burtonini.com (Ross Burton)
Date: Wed Mar 21 11:12:24 2007
Subject: [cairo] Re: Mark cairo_fixed_t conversion functions with
	attribute(const)
In-Reply-To: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
References: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
Message-ID: <1174500724.30169.3.camel@blackadder>

On Wed, 2007-03-21 at 17:51 +0000, Chris Wilson wrote:
> The cairo_fixed_t conversion functions look apt for the const attribute
> as they only operate on their parameters and do not touch memory. They
> also look suitable for inlining should anyone have any profile data
> suggesting it would be a win...

You're producing some really interesting looking patches, but I don't
see any proof that there are performance improvements.  I believe there
are, but I like to see hard numbers!  Can you run cairo-perf-diff?

Ross
-- 
Ross Burton                                 mail: ross@burtonini.com
                                          jabber: ross@burtonini.com
                                     www: http://www.burtonini.com./
 PGP Fingerprint: 1A21 F5B0 D8D0 CFE3 81D4 E25A 2D09 E447 D0B4 33DF



From behdad at behdad.org  Wed Mar 21 11:26:35 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 21 11:26:37 2007
Subject: [cairo] Re: Mark cairo_fixed_t conversion functions with
	attribute(const)
In-Reply-To: <1174500724.30169.3.camel@blackadder>
References: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
	<1174500724.30169.3.camel@blackadder>
Message-ID: <1174501595.1028.10.camel@behdad>

On Wed, 2007-03-21 at 14:12 -0400, Ross Burton wrote:
> On Wed, 2007-03-21 at 17:51 +0000, Chris Wilson wrote:
> > The cairo_fixed_t conversion functions look apt for the const attribute
> > as they only operate on their parameters and do not touch memory. They
> > also look suitable for inlining should anyone have any profile data
> > suggesting it would be a win...
> 
> You're producing some really interesting looking patches, but I don't
> see any proof that there are performance improvements.  I believe there
> are, but I like to see hard numbers!  Can you run cairo-perf-diff?

Well, meet Chris Wilson :).

He's amazing at janitorial work.  This kind of work typically improves
code quality without necessarily having measurable effects right now.
For example, for past few days, he's been working on improving cairo's
error handling.  That's a very valuable work since people typically
don't like doing this kind of mud work, and normally we would have to
find and plug those holes one at a time when enough bug reports come in
to let us find out where there is one...

Maybe I'm just too purist myself...  (which I am)

> Ross

Cheers,
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Wed Mar 21 11:41:31 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 21 11:41:31 2007
Subject: [cairo] Add attribute(warn_unused_result)
In-Reply-To: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
Message-ID: <1174502491.1028.20.camel@behdad>

On Wed, 2007-03-21 at 12:51 -0400, Chris Wilson wrote:
> This adds a compiler check that the function result is used by the
> caller and enables it by default for all cairo_private functions and
> for public API that returns a cairo_status_t.
> 
> Unfortunately, I have found no way to disable the spurious warnings
> from gcc when applying the attribute to variables or functions
> returning void. To placate gcc, new function types have been
> introduced to manually avoid the warning.  So we now have
> cairo_public_warn/cairo_public and cairo_private/cairo_private_no_warn
> - choosen as the majority of internal functions should be checking for
> errors!, whereas only a minority of the public API requires an
> immediate error check.
> 
> To extend the warning to all functions, a new function type has been
> introduced to cover static functions:
> cairo_static/cairo_static_no_warn. 

This is very neat stuff...  I like the idea of marking every function
with a variant of cairo_public, cairo_private, and cairo_static.  The
part I don't like is where those markings are placed.  cairo_static
comes at function declaration site, while the others come at the
prototype, and for cairo_public, a slim_hidden should follow the
definition...  May not be easy to improve these.  In an ideal world, we
won't have to mark them at all:

  - Symbols starting with cairo_ are public
  - Symbols starting with _cairo_ are private
  - All other symbols are static

But go get that in C...

The only part I really displike is the "cairo_private_no_warn void".
While cairo_private_no_warn is useful for other places too, can we have
a cairo_private_void instead?


Also note that we already #define __attribute__() if not using gcc, so
some of the checks may be relaxed, but that's not a big deal.

Anyway, I really hope Carl gets to throwing in his wisdom and get your
stuff polished and committed before they rot.

Cheers,
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From ross at burtonini.com  Wed Mar 21 12:05:36 2007
From: ross at burtonini.com (Ross Burton)
Date: Wed Mar 21 12:06:10 2007
Subject: [cairo] Re: Re: Mark cairo_fixed_t conversion functions with
	attribute(const)
In-Reply-To: <1174501595.1028.10.camel@behdad>
References: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
	<1174500724.30169.3.camel@blackadder> <1174501595.1028.10.camel@behdad>
Message-ID: <1174503936.30169.8.camel@blackadder>

On Wed, 2007-03-21 at 14:26 -0400, Behdad Esfahbod wrote:
> Well, meet Chris Wilson :).
> 
> He's amazing at janitorial work.  This kind of work typically improves
> code quality without necessarily having measurable effects right now.
> For example, for past few days, he's been working on improving cairo's
> error handling.  That's a very valuable work since people typically
> don't like doing this kind of mud work, and normally we would have to
> find and plug those holes one at a time when enough bug reports come in
> to let us find out where there is one...

I totally agree, the error handling patches are wonderful pieces of work
that should be committed without a doubt.  I'm interested in seeing if
there are any visible differences in (say) adding the const attribute to
the fixed conversions (which will micro-optimise code and probably not
make a visible difference in the general case), or the heapless
allocation code (which I'm pretty sure will be noticable in the GTK+
theme torturer).

Ross
-- 
Ross Burton                                 mail: ross@burtonini.com
                                          jabber: ross@burtonini.com
                                     www: http://www.burtonini.com./
 PGP Fingerprint: 1A21 F5B0 D8D0 CFE3 81D4 E25A 2D09 E447 D0B4 33DF



From behdad at behdad.org  Wed Mar 21 12:11:37 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Wed Mar 21 12:11:36 2007
Subject: [cairo] On cairo_get_dash and cairo_get_dash_count
Message-ID: <1174504297.1028.25.camel@behdad>

Hi,

I was cleaning up cairo.c to not access gstate members directly, and
stumbled upon cairo_get_dash and cairo_get_dash_count.  Those two access
gstate directly.  So I thought Ok, I move the meat to gstate and make
cairo.c call it.  But instead of adding two functions, I just added one.
So the cairo.c interface looks like:

cairo_public void
cairo_set_dash (cairo_t      *cr,
                const double *dashes,
                int           num_dashes,
                double        offset);

cairo_public int
cairo_get_dash_count (cairo_t *cr);

cairo_public void
cairo_get_dash (cairo_t *cr, double *dashes, double *offset);


While my gstate interface looks like:

cairo_private cairo_status_t
_cairo_gstate_set_dash (cairo_gstate_t *gstate, const double *dash, int
num_dashes, double offset);

cairo_private void
_cairo_gstate_get_dash (cairo_gstate_t *gstate, double *dash, int
*num_dashes, double *offset);


Immediate benefits in this interface:

  - exactly same arguments and order in setter and getter

  - One fewer call to remember

  - It's a common idiom: call it first with NULL buffer to get the
length, call again to feel the buffers.


I cannot remember, why did we turn that down?

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From behdad at behdad.org  Thu Mar 22 02:25:07 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar 22 02:25:08 2007
Subject: [cairo] On #if vs #ifdef
Message-ID: <1174555507.4857.9.camel@behdad>

The following message from FreeType list may be helpful deciding between
#if vs #ifdef...  Again, "#if FOO+0" is a third option that doesn't have
most problems of those two.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759


-------------- next part --------------
An embedded message was scrubbed...
From: "David Turner" <david@freetype.org>
Subject: Re: [ft-devel] Minor misc patches to freetype cvs, from custom    
	changes in vtk
Date: Thu, 22 Mar 2007 04:35:56 -0400
Size: 6339
Url: http://lists.freedesktop.org/archives/cairo/attachments/20070322/bf147a19/attachment.mht
From chris at chris-wilson.co.uk  Thu Mar 22 04:28:41 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Thu Mar 22 04:28:50 2007
Subject: [cairo] Unreliable cairo-perf results;
	was Re: Mark cairo_fixed_t conversion functions with
	attribute(const)
In-Reply-To: <1174500724.30169.3.camel@blackadder>
References: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
	<1174500724.30169.3.camel@blackadder>
Message-ID: <20070322112840.GE10524@inspired.chris-wilson.co.uk>

Ross Burton (ross@burtonini.com) said: 
> You're producing some really interesting looking patches, but I don't
> see any proof that there are performance improvements.  I believe there
> are, but I like to see hard numbers!  Can you run cairo-perf-diff?

Hmm, would love to provide conclusive evidence showing that this change
improves gcc's output. However I've not found any machine where
cairo-perf gives reliable results,  e.g.

ickle@cube:~/src/cairo/perf$ git diff HEAD^ HEAD
diff --git a/src/cairo.h b/src/cairo.h
index a80efde..7701ec4 100644
--- a/src/cairo.h
+++ b/src/cairo.h
@@ -43,6 +43,8 @@
 
 CAIRO_BEGIN_DECLS
  
 +/* force a recompilation */
 +
  #define CAIRO_VERSION_ENCODE(major, minor, micro) (     \
			          ((major) * 10000)                             \
			        + ((minor) *   100)                             \
ickle@cube:~/src/cairo/perf$ ./cairo-perf-diff HEAD^ HEAD -- -i 100
Speedups
========
image-rgb     paint_image_rgba_source-256  174.08?s 0.25% -> 146.91?s 0.32%:  1.18x speedup
?
image-rgb        paint_image_rgb_over-256  162.36?s 1.22% -> 140.51?s 0.84%:  1.16x speedup
?
image-rgb   paint_similar_rgba_source-256  169.44?s 0.53% -> 147.17?s 0.39%:  1.15x speedup
?
image-rgb      paint_image_rgb_source-256  160.88?s 0.79% -> 140.12?s 0.72%:  1.15x speedup
?
...
For the record, that machine is an idle, single processor AMD64 with
1GiB of RAM.

Sorry for the whine - this has been driving me crazy.
--
Chris Wilson
From ross at burtonini.com  Thu Mar 22 06:00:30 2007
From: ross at burtonini.com (Ross Burton)
Date: Thu Mar 22 06:00:55 2007
Subject: [cairo] Re: Unreliable cairo-perf results;
	was Re: Mark cairo_fixed_t
	conversion functions with attribute(const)
In-Reply-To: <20070322112840.GE10524@inspired.chris-wilson.co.uk>
References: <20070321175107.GC10524@inspired.chris-wilson.co.uk>
	<1174500724.30169.3.camel@blackadder>
	<20070322112840.GE10524@inspired.chris-wilson.co.uk>
Message-ID: <1174568430.14821.4.camel@blackadder>

On Thu, 2007-03-22 at 11:28 +0000, Chris Wilson wrote:
> Hmm, would love to provide conclusive evidence showing that this change
> improves gcc's output. However I've not found any machine where
> cairo-perf gives reliable results,  e.g.

Wow, let's add that comment to all of the source files!  :)

Hm, that sucks.  I used to see chronic benchmark failure like this on a
P4, which was due to the processor speed being throttled down when the
benchmark started.  Could this be the problem?

Ross
-- 
Ross Burton                                 mail: ross@burtonini.com
                                          jabber: ross@burtonini.com
                                     www: http://www.burtonini.com./
 PGP Fingerprint: 1A21 F5B0 D8D0 CFE3 81D4 E25A 2D09 E447 D0B4 33DF



From spitzak at d2.com  Thu Mar 22 07:26:28 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Thu Mar 22 08:12:18 2007
Subject: [cairo] On #if vs #ifdef
In-Reply-To: <1174555507.4857.9.camel@behdad>
References: <1174555507.4857.9.camel@behdad>
Message-ID: <46029214.7060406@d2.com>

Behdad Esfahbod wrote:
> The following message from FreeType list may be helpful deciding between
> #if vs #ifdef...  Again, "#if FOO+0" is a third option that doesn't have
> most problems of those two.

> So "#if FOO, where FOO is undefined" is ok with GNU cpp [2] but not with Visual C++ [3]
> I haven't looked at other compilers, but I wouldn't be surprised to see that this is
> a GNU-specific extension, or it may come from a tradition of various Unix pre-processors,
> but certainly can't be generalized...

I'm pretty certain this works in Visual C++, or I would have noticed a 
long time ago, as our code is full of these. It also works in the Irix 
and Intel compilers.
From tml at iki.fi  Thu Mar 22 08:47:45 2007
From: tml at iki.fi (Tor Lillqvist)
Date: Thu Mar 22 08:47:51 2007
Subject: [cairo] On #if vs #ifdef
In-Reply-To: <46029214.7060406@d2.com>
References: <1174555507.4857.9.camel@behdad>
	<46029214.7060406@d2.com>
Message-ID: <17922.42273.859000.288399@gargle.gargle.HOWL>


 > > So "#if FOO, where FOO is undefined" is ok with GNU cpp [2] but
 > > not with Visual C++ [3]

 > I'm pretty certain this works in Visual C++,

It does, but by default MSVC7.1, at least, spits out warnings about
FOO being undefined.

--tml

From chris at chris-wilson.co.uk  Thu Mar 22 10:21:41 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Thu Mar 22 10:21:49 2007
Subject: [cairo] Returning cached erroneous patterns
Message-ID: <20070322172140.GF10524@inspired.chris-wilson.co.uk>

Behdad's already fixed the primary case where we created a pattern
and explicity put it into an error state. However, it also possible for
a user to set an error status on a solid pattern, for example by using
it as an argument where a gradient was expected. That has some rather
unfortunate side-effects on a widely shared pattern...

This patch endeavours not to return a cached pattern that is in an error
state. Along the way, it also tidies up a return without dropping the
pattern cache mutex.
--
Chris Wilson
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0006-Do-not-return-any-cached-pattern-that-is-in-an-error.patch
Type: text/x-diff
Size: 2450 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070322/5f3c572c/0006-Do-not-return-any-cached-pattern-that-is-in-an-error-0001.bin
From brian.ewins at gmail.com  Thu Mar 22 11:12:40 2007
From: brian.ewins at gmail.com (Baz)
Date: Thu Mar 22 11:12:45 2007
Subject: [cairo] Returning cached erroneous patterns
In-Reply-To: <20070322172140.GF10524@inspired.chris-wilson.co.uk>
References: <20070322172140.GF10524@inspired.chris-wilson.co.uk>
Message-ID: <2faad3050703221112g4559d01bj1ea0c3f4cbed349a@mail.gmail.com>

On 22/03/07, Chris Wilson <chris@chris-wilson.co.uk> wrote:
> Behdad's already fixed the primary case where we created a pattern
> and explicity put it into an error state. However, it also possible for
> a user to set an error status on a solid pattern, for example by using
> it as an argument where a gradient was expected. That has some rather
> unfortunate side-effects on a widely shared pattern...

Doesn't this mean it's possible for two threads to have already
fetched the pattern from the cache, before one of them manages to set
it to an error state? Even after this patch, I think you can do this
by calling cairo_pattern_add_color_stop_rgba on a solid pattern
fetched from the cache twice.

You can get similar behaviour in user applications by sharing
gradients then adding color stops. Both threads will see the colour
stops, and eventually both will see a pattern with an out of memory
status.

All of this comes from patterns being mutable, for adding color stops,
and setting user data. Should those operations should even be possible
on patterns with more than one reference?

(waits to be shot down)
-Baz
From murrayc at murrayc.com  Thu Mar 22 13:54:35 2007
From: murrayc at murrayc.com (Murray Cumming)
Date: Thu Mar 22 13:54:45 2007
Subject: [cairo] Is cairo_clip_extents() a getter?
Message-ID: <1174596875.5969.39.camel@murrayc-desktop>

cairo_clip_extents() was added in cairo 1.4. Is it just a getter that
doesn't affect the cairo context?
http://cairographics.org/manual/cairo-cairo-t.html#cairo-clip-extents

It's suspiciously similar to the existing cairo_clip() and
cairo_clip_preserve() functions. 

-- 
Murray Cumming
murrayc@murrayc.com
www.murrayc.com
www.openismus.com

From jeremiah at jeremiahfoster.com  Thu Mar 22 14:58:13 2007
From: jeremiah at jeremiahfoster.com (Jeremiah Foster)
Date: Thu Mar 22 16:07:17 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
Message-ID: <20070322215813.GA12132@jeremiahfoster.com>

Hello,

In trying to install Cairo on Mac OS X 10.3.9 I am running across some problems with 
pkg-config files (i.e. cairo.pc) not being found. 

I cloned cairo with git and read the README and INSTALL files. (The install file looks
to be standard boilerplate stating that one use the traditional recipe of ./configure
make and make install to install cairo but there is no configure script and the README
tells me to use autogen.sh instead. Using authgen.sh produces this error:

./autogen.sh: Error: Could not find pkg-config macros.
        (Looked in /usr/local/share/aclocal/pkg.m4)
        If pkg.m4 is available in /another/directory, please set
        ACLOCAL_FLAGS="-I /another/directory"
        Otherwise, please install pkg-config.

pkg-config is installed but in a different directory than normal (/sw/bin/pkg-config)

How do I alert the autogen.sh script to the presence of pkg-config and will that 
solve my building Cairo problems?

Thanks,
	
	Jeremiah
From chris at chris-wilson.co.uk  Thu Mar 22 18:17:02 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Thu Mar 22 18:17:12 2007
Subject: [cairo] Multithreaded cairo-perf
Message-ID: <20070323011702.GG10524@inspired.chris-wilson.co.uk>

The recently introduced solid pattern cache has triggered a fresh set of
bad reference assertion failures, which are probably due to the lack of
atomic reference counting and highlight a lack of concurrency testing
performed by the Cairo test suite. This patch allows cairo-perf to be
run across multiple threads. It introduces a -t <int> cmdline option which
causes the creation of <int> threads where each thread runs all the perf
cases sequentially. The patch is a WIP as it makes no attempt to manage
the output from multiple threads nor provide a portable threading
interface, but it does enable concurrency testing.

Comments?
--
Chris Wilson
-------------- next part --------------
diff --git a/perf/box-outline.c b/perf/box-outline.c
index 74dd19a..7eadce8 100644
--- a/perf/box-outline.c
+++ b/perf/box-outline.c
@@ -41,7 +41,7 @@
  */
 
 static cairo_perf_ticks_t
-box_outline_stroke (cairo_t *cr, int width, int height)
+box_outline_stroke (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     cairo_set_source_rgb (cr, 0, 0, 1); /* blue */
     cairo_paint (cr);
@@ -52,17 +52,17 @@ box_outline_stroke (cairo_t *cr, int width, int height)
     cairo_set_line_width (cr, 1.0);
     cairo_set_source_rgb (cr, 1, 0, 0); /* red */
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_stroke (cr);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 static cairo_perf_ticks_t
-box_outline_fill (cairo_t *cr, int width, int height)
+box_outline_fill (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     cairo_set_source_rgb (cr, 0, 0, 1); /* blue */
     cairo_paint (cr);
@@ -76,18 +76,18 @@ box_outline_fill (cairo_t *cr, int width, int height)
     cairo_set_fill_rule (cr, CAIRO_FILL_RULE_EVEN_ODD);
     cairo_set_source_rgb (cr, 0, 1, 0); /* green */
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_fill (cr);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 box_outline (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "box-outline-stroke", box_outline_stroke);
-    cairo_perf_run (perf, "box-outline-fill", box_outline_fill);
+    cairo_perf_run (perf, cr, "box-outline-stroke", box_outline_stroke);
+    cairo_perf_run (perf, cr, "box-outline-fill", box_outline_fill);
 }
diff --git a/perf/cairo-perf-cover.c b/perf/cairo-perf-cover.c
index 53dc7b7..426f872 100644
--- a/perf/cairo-perf-cover.c
+++ b/perf/cairo-perf-cover.c
@@ -197,6 +197,7 @@ typedef void (*set_source_func_t) (cairo_t *cr, int width, int height);
 
 void
 cairo_perf_cover_sources_and_operators (cairo_perf_t		*perf,
+					cairo_t			*cr,
 					const char		*name,
 					cairo_perf_func_t	 perf_func)
 {
@@ -222,14 +223,14 @@ cairo_perf_cover_sources_and_operators (cairo_perf_t		*perf,
     };
 
     for (i = 0; i < ARRAY_SIZE (sources); i++) {
-	(sources[i].set_source) (perf->cr, perf->size, perf->size);
+	(sources[i].set_source) (cr, perf->size, perf->size);
 
 	for (j = 0; j < ARRAY_SIZE (operators); j++) {
-	    cairo_set_operator (perf->cr, operators[j].op);
+	    cairo_set_operator (cr, operators[j].op);
 
 	    xasprintf (&expanded_name, "%s_%s_%s",
 		       name, sources[i].name, operators[j].name);
-	    cairo_perf_run (perf, expanded_name, perf_func);
+	    cairo_perf_run (perf, cr, expanded_name, perf_func);
 	    free (expanded_name);
 	}
     }
diff --git a/perf/cairo-perf-posix.c b/perf/cairo-perf-posix.c
index 68637ef..b313606 100644
--- a/perf/cairo-perf-posix.c
+++ b/perf/cairo-perf-posix.c
@@ -65,11 +65,11 @@
 /* timers */
 
 #if defined(__i386__) || defined(__amd64__)
-static inline unsigned long
+static inline cairo_perf_ticks_t
 oil_profile_stamp_rdtsc (void)
 {
     unsigned long ts;
-    __asm__ __volatile__("rdtsc\n" : "=a" (ts) : : "edx");
+    __asm__ __volatile__("rdtsc\n" : "=a" (ts), :: "edx");
     return ts;
 }
 #define OIL_STAMP oil_profile_stamp_rdtsc
@@ -98,7 +98,7 @@ oil_profile_stamp_alpha(void)
 #endif
 
 #if defined(__s390__)
-static cairo_perf_ticks_t
+static inline cairo_perf_ticks_t
 oil_profile_stamp_s390(void)
 {
     uint64_t ts;
@@ -108,7 +108,7 @@ oil_profile_stamp_s390(void)
 #define OIL_STAMP oil_profile_stamp_s390
 #endif
 
-typedef struct _cairo_perf_timer
+struct _cairo_perf_timer
 {
 #ifdef OIL_STAMP
     cairo_perf_ticks_t start;
@@ -117,77 +117,98 @@ typedef struct _cairo_perf_timer
     struct timeval tv_start;
     struct timeval tv_stop;
 #endif
-} cairo_perf_timer_t;
 
-static cairo_perf_timer_t timer;
+    cairo_perf_timer_synchronize_t synchronize;
+    void *synchronize_closure;
+
+    cairo_perf_ticks_t tps;
+};
+
+
+cairo_perf_timer_t *
+cairo_perf_timer_create (void)
+{
+    cairo_perf_timer_t *timer = xmalloc (sizeof (cairo_perf_timer_t));
+
+    timer->synchronize = NULL;
+    timer->synchronize_closure = NULL;
+
+    timer->tps = 0;
+
+    return timer;
+}
+
+void
+cairo_perf_timer_destroy (cairo_perf_timer_t *timer)
+{
+    free (timer);
+}
 
-static cairo_perf_timer_synchronize_t cairo_perf_timer_synchronize = NULL;
-static void *cairo_perf_timer_synchronize_closure = NULL;
 void
-cairo_perf_timer_set_synchronize (cairo_perf_timer_synchronize_t	 synchronize,
+cairo_perf_timer_set_synchronize (cairo_perf_timer_t			*timer,
+	                          cairo_perf_timer_synchronize_t	 synchronize,
 				  void					*closure)
 {
-    cairo_perf_timer_synchronize = synchronize;
-    cairo_perf_timer_synchronize_closure = closure;
+    timer->synchronize = synchronize;
+    timer->synchronize_closure = closure;
 }
 
 void
-cairo_perf_timer_start (void) {
-    if (cairo_perf_timer_synchronize)
-	cairo_perf_timer_synchronize (cairo_perf_timer_synchronize_closure);
+cairo_perf_timer_start (cairo_perf_timer_t *timer) {
+    if (timer->synchronize)
+	timer->synchronize (timer->synchronize_closure);
 #ifdef OIL_STAMP
-    timer.start = OIL_STAMP ();
+    timer->start = OIL_STAMP ();
 #else
-    gettimeofday (&timer.tv_start, NULL);
+    gettimeofday (&timer->tv_start, NULL);
 #endif
 }
 
 void
-cairo_perf_timer_stop (void) {
-    if (cairo_perf_timer_synchronize)
-	cairo_perf_timer_synchronize (cairo_perf_timer_synchronize_closure);
+cairo_perf_timer_stop (cairo_perf_timer_t *timer) {
+    if (timer->synchronize)
+	timer->synchronize (timer->synchronize_closure);
 #ifdef OIL_STAMP
-    timer.stop = OIL_STAMP ();
+    timer->stop = OIL_STAMP ();
 #else
-    gettimeofday (&timer.tv_stop, NULL);
+    gettimeofday (&timer->tv_stop, NULL);
 #endif
 }
 
 cairo_perf_ticks_t
-cairo_perf_timer_elapsed (void) {
+cairo_perf_timer_elapsed (cairo_perf_timer_t *timer) {
     cairo_perf_ticks_t ticks;
 
 #ifdef OIL_STAMP
     /* Handle 32-bit wraparound of timer value */
-    if (timer.stop < timer.start)
-	timer.stop += 0x100000000ll;
-    ticks = (timer.stop - timer.start);
+    if (timer->stop < timer->start)
+	timer->stop += 0x100000000ll;
+    ticks = (timer->stop - timer->start);
 #else
-    ticks = (timer.tv_stop.tv_sec - timer.tv_start.tv_sec) * 1000000;
-    ticks += (timer.tv_stop.tv_usec - timer.tv_start.tv_usec);
+    ticks = (timer->tv_stop.tv_sec - timer->tv_start.tv_sec) * 1000000;
+    ticks += (timer->tv_stop.tv_usec - timer->tv_start.tv_usec);
 #endif
 
     return ticks;
 }
 
 cairo_perf_ticks_t
-cairo_perf_ticks_per_second (void) {
+cairo_perf_ticks_per_second (cairo_perf_timer_t *timer) {
 #ifdef OIL_STAMP
-    static cairo_perf_ticks_t tps = 0;
     /* XXX: This is obviously not stable in light of changing CPU speed. */
-    if (tps == 0) {
+    if (timer->tps == 0) {
 	struct timeval tv_start, tv_stop;
 	double tv_elapsed;
-	cairo_perf_timer_start ();
+	cairo_perf_timer_start (timer);
 	gettimeofday (&tv_start, NULL);
 	usleep (20000);
-	cairo_perf_timer_stop ();
+	cairo_perf_timer_stop (timer);
 	gettimeofday (&tv_stop, NULL);
 	tv_elapsed = ((tv_stop.tv_sec - tv_start.tv_sec) +
 		      + (tv_stop.tv_usec - tv_start.tv_usec) / 1000000.0);
-	tps = round (cairo_perf_timer_elapsed () / tv_elapsed);
+	timer->tps = round (cairo_perf_timer_elapsed (timer) / tv_elapsed);
     }
-    return tps;
+    return timer->tps;
 #else
     /* For gettimeofday the units are micro-seconds */
     return 1000000;
diff --git a/perf/cairo-perf.c b/perf/cairo-perf.c
index 44e842b..176e346 100644
--- a/perf/cairo-perf.c
+++ b/perf/cairo-perf.c
@@ -33,6 +33,9 @@
 #include <unistd.h>
 /* For basename */
 #include <libgen.h>
+/* For threading */
+#include <pthread.h>
+#include <errno.h>
 
 #ifdef HAVE_SCHED_H
 #include <sched.h>
@@ -42,13 +45,11 @@
 #define CAIRO_PERF_LOW_STD_DEV		0.03
 #define CAIRO_PERF_STABLE_STD_DEV_COUNT	5
 
-typedef struct _cairo_perf_case {
+static struct _cairo_perf_case {
     CAIRO_PERF_DECL (*run);
     unsigned int min_size;
     unsigned int max_size;
-} cairo_perf_case_t;
-
-cairo_perf_case_t perf_cases[];
+} perf_cases[];
 
 /* Some targets just aren't that interesting for performance testing,
  * (not least because many of these surface types use a meta-surface
@@ -105,6 +106,7 @@ _content_to_string (cairo_content_t content)
 
 void
 cairo_perf_run (cairo_perf_t		*perf,
+		cairo_t			*cr,
 		const char		*name,
 		cairo_perf_func_t	 perf_func)
 {
@@ -142,12 +144,12 @@ cairo_perf_run (cairo_perf_t		*perf,
 
     /* We run one iteration in advance to warm caches, etc. */
     cairo_perf_yield ();
-    (perf_func) (perf->cr, perf->size, perf->size);
+    (perf_func) (perf->timer, cr, perf->size, perf->size);
 
     low_std_dev_count = 0;
     for (i =0; i < perf->iterations; i++) {
 	cairo_perf_yield ();
-	times[i] = (perf_func) (perf->cr, perf->size, perf->size);
+	times[i] = (perf_func) (perf->timer, cr, perf->size, perf->size);
 
 	if (perf->raw) {
 	    if (i == 0)
@@ -155,7 +157,7 @@ cairo_perf_run (cairo_perf_t		*perf,
 			perf->target->name,
 			_content_to_string (perf->target->content),
 			name, perf->size,
-			cairo_perf_ticks_per_second () / 1000.0);
+			cairo_perf_ticks_per_second (perf->timer) / 1000.0);
 	    printf (" %lld", times[i]);
 	} else {
 	    if (i > 0) {
@@ -184,8 +186,8 @@ cairo_perf_run (cairo_perf_t		*perf,
 
 	printf ("%10lld %#8.3f %#8.3f %#5.2f%% %3d\n",
 		stats.min_ticks,
-		(stats.min_ticks * 1000.0) / cairo_perf_ticks_per_second (),
-		(stats.median_ticks * 1000.0) / cairo_perf_ticks_per_second (),
+		(stats.min_ticks * 1000.0) / cairo_perf_ticks_per_second (perf->timer),
+		(stats.median_ticks * 1000.0) / cairo_perf_ticks_per_second (perf->timer),
 		stats.std_dev * 100.0, stats.iterations);
     }
 
@@ -228,9 +230,10 @@ parse_options (cairo_perf_t *perf, int argc, char *argv[])
     perf->list_only = FALSE;
     perf->names = NULL;
     perf->num_names = 0;
+    perf->threads = 0;
 
     while (1) {
-	c = getopt (argc, argv, "i:lr");
+	c = getopt (argc, argv, "it:lr");
 	if (c == -1)
 	    break;
 
@@ -244,6 +247,14 @@ parse_options (cairo_perf_t *perf, int argc, char *argv[])
 		exit (1);
 	    }
 	    break;
+	case 't':
+	    perf->threads = strtoul (optarg, &end, 10);
+	    if (*end != '\0') {
+		fprintf (stderr, "Invalid argument for -t (not an integer): %s\n",
+			 optarg);
+		exit (1);
+	    }
+	    break;
 	case 'l':
 	    perf->list_only = TRUE;
 	    break;
@@ -298,79 +309,129 @@ check_cpu_affinity(void)
 #endif
 }
 
-int
-main (int argc, char *argv[])
+static void *
+run_perf_case (void *arg)
 {
-    int i, j;
-    cairo_perf_case_t *perf_case;
-    cairo_perf_t perf;
-    const char *cairo_test_target = getenv ("CAIRO_TEST_TARGET");
-    cairo_boilerplate_target_t *target;
+    cairo_perf_t *perf = arg;
+    const cairo_boilerplate_target_t *target = perf->target;
     cairo_surface_t *surface;
+    cairo_t *cr;
+    void *closure = NULL;
+    void *result = NULL;
+
+    surface = (target->create_surface) (NULL,
+					target->content,
+					perf->size, perf->size,
+					CAIRO_BOILERPLATE_MODE_PERF,
+					&closure);
+    cairo_perf_timer_set_synchronize (perf->timer,
+	                              target->synchronize,
+				      closure);
+
+    cr = cairo_create (surface);
+
+    perf->kase->run (perf, cr, perf->size, perf->size);
+
+    if (cairo_status (cr)) {
+	fprintf (stderr, "Error: Test left cairo in an error state: %s\n",
+		 cairo_status_to_string (cairo_status (cr)));
+	result = (void *)0x1;
+    }
 
-    parse_options (&perf, argc, argv);
+    cairo_destroy (cr);
+    cairo_surface_destroy (surface);
 
-    if (check_cpu_affinity()) {
-        fputs(
-            "NOTICE: cairo-perf and the X server should be bound to CPUs (either the same\n"
-            "or separate) on SMP systems. Not doing so causes random results when the X\n"
-            "server is moved to or from cairo-perf's CPU during the benchmarks:\n"
-            "\n"
-            "    $ sudo taskset -cp 0 $(pidof X)\n"
-            "    $ taskset -cp 1 $$\n"
-            "\n"
-            "See taskset(1) for information about changing CPU affinity.\n",
-            stderr);
-    }
+    if (target->cleanup)
+	target->cleanup (closure);
+
+    return result;
+}
+
+static void *
+run_perf_cases (void *arg)
+{
+    const cairo_perf_t *options = arg;
+    cairo_perf_t perf = *options;
+    const char *cairo_test_target = getenv ("CAIRO_TEST_TARGET");
+    int i, j;
+    long err = 0;
+
+    perf.timer = cairo_perf_timer_create ();
 
     for (i = 0; targets[i].name; i++) {
-	perf.target = target = &targets[i];
+	perf.target = &targets[i];
 	perf.test_number = 0;
 
-	if (! target_is_measurable (target))
+	if (! target_is_measurable (perf.target))
 	    continue;
-	if (cairo_test_target && ! strstr (cairo_test_target, target->name))
+	if (cairo_test_target &&
+	       	! strstr (cairo_test_target, perf.target->name))
 	    continue;
 
 	for (j = 0; perf_cases[j].run; j++) {
+	    perf.kase = &perf_cases[j];
 
-	    perf_case = &perf_cases[j];
-
-	    for (perf.size = perf_case->min_size;
-		 perf.size <= perf_case->max_size;
+	    for (perf.size = perf.kase->min_size;
+		 perf.size <= perf.kase->max_size;
 		 perf.size *= 2)
 	    {
-		surface = (target->create_surface) (NULL,
-						    target->content,
-						    perf.size, perf.size,
-						    CAIRO_BOILERPLATE_MODE_PERF,
-						    &target->closure);
-		cairo_perf_timer_set_synchronize (target->synchronize,
-						  target->closure);
-
-		perf.cr = cairo_create (surface);
-
-		perf_case->run (&perf, perf.cr, perf.size, perf.size);
-
-		if (cairo_status (perf.cr)) {
-		    fprintf (stderr, "Error: Test left cairo in an error state: %s\n",
-			     cairo_status_to_string (cairo_status (perf.cr)));
-		    exit (1);
-		}
+		err += !! run_perf_case (&perf);
+	    }
+	}
+    }
 
-		cairo_destroy (perf.cr);
-		cairo_surface_destroy (surface);
+    cairo_perf_timer_destroy (perf.timer);
 
-		if (target->cleanup)
-		    target->cleanup (target->closure);
+    return (void *) err;
+}
+
+int
+main (int argc, char *argv[])
+{
+    cairo_perf_t perf;
+    long err;
+
+    parse_options (&perf, argc, argv);
+
+    if (perf.threads) {
+	unsigned int i;
+	pthread_t *threads = xmalloc (sizeof (pthread_t) * perf.threads);
+	void *result;
+	for (i = 0; i < perf.threads; i++) {
+	    if (pthread_create (&threads[i], NULL,
+				run_perf_cases, &perf) < 0) {
+		fprintf (stderr, "Unable to create thread: %s\n",
+			strerror (errno));
+		exit (1);
 	    }
 	}
+	err = 0;
+	for (i = 0; i < perf.threads; i++) {
+	    pthread_join (threads[i], &result);
+	    err += !! result;
+	}
+	free (threads);
+    } else {
+	if (check_cpu_affinity()) {
+	    fputs(
+		    "NOTICE: cairo-perf and the X server should be bound to CPUs (either the same\n"
+		    "or separate) on SMP systems. Not doing so causes random results when the X\n"
+		    "server is moved to or from cairo-perf's CPU during the benchmarks:\n"
+		    "\n"
+		    "    $ sudo taskset -cp 0 $(pidof X)\n"
+		    "    $ taskset -cp 1 $$\n"
+		    "\n"
+		    "See taskset(1) for information about changing CPU affinity.\n",
+		    stderr);
+	}
+
+	err = (long) run_perf_cases (&perf);
     }
 
-    return 0;
+    return !! err;
 }
 
-cairo_perf_case_t perf_cases[] = {
+static cairo_perf_case_t perf_cases[] = {
     { paint,  256, 512},
     { fill,   64, 256},
     { stroke, 64, 256},
diff --git a/perf/cairo-perf.h b/perf/cairo-perf.h
index 1fef997..9240e81 100644
--- a/perf/cairo-perf.h
+++ b/perf/cairo-perf.h
@@ -35,34 +35,43 @@ typedef uint64_t cairo_perf_ticks_t;
 #include "cairo-stats.h"
 
 /* timers */
+typedef struct _cairo_perf_timer cairo_perf_timer_t;
 
+cairo_perf_timer_t *
+cairo_perf_timer_create (void);
 void
-cairo_perf_timer_start (void);
+cairo_perf_timer_destroy (cairo_perf_timer_t *timer);
+void
+cairo_perf_timer_start (cairo_perf_timer_t *timer);
 
 void
-cairo_perf_timer_stop (void);
+cairo_perf_timer_stop (cairo_perf_timer_t *timer);
 
 typedef void
 (*cairo_perf_timer_synchronize_t) (void *closure);
 
 void
-cairo_perf_timer_set_synchronize (cairo_perf_timer_synchronize_t	 synchronize,
+cairo_perf_timer_set_synchronize (cairo_perf_timer_t			*timer,
+	                          cairo_perf_timer_synchronize_t	 synchronize,
 				  void					*closure);
 
 cairo_perf_ticks_t
-cairo_perf_timer_elapsed (void);
+cairo_perf_timer_elapsed (cairo_perf_timer_t *timer);
 
 cairo_perf_ticks_t
-cairo_perf_ticks_per_second (void);
+cairo_perf_ticks_per_second (cairo_perf_timer_t *timer);
 
 /* yield */
 
 void
 cairo_perf_yield (void);
 
+typedef struct _cairo_perf_case cairo_perf_case_t;
+
 /* running a test case */
 typedef struct _cairo_perf {
     /* Options from command-line */
+    unsigned int threads;
     unsigned int iterations;
     cairo_bool_t exact_iterations;
     cairo_bool_t raw;
@@ -71,22 +80,25 @@ typedef struct _cairo_perf {
     unsigned int num_names;
 
     /* Stuff used internally */
+    cairo_perf_case_t *kase;
     cairo_boilerplate_target_t *target;
+    cairo_perf_timer_t *timer;
     unsigned int test_number;
     unsigned int size;
-    cairo_t *cr;
 } cairo_perf_t;
 
 typedef cairo_perf_ticks_t
-(*cairo_perf_func_t) (cairo_t *cr, int width, int height);
+(*cairo_perf_func_t) (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height);
 
 void
 cairo_perf_run (cairo_perf_t		*perf,
+		cairo_t			*cr,
 		const char		*name,
 		cairo_perf_func_t	 perf_func);
 
 void
 cairo_perf_cover_sources_and_operators (cairo_perf_t		*perf,
+					cairo_t			*cr,
 					const char		*name,
 					cairo_perf_func_t	 perf_func);
 
diff --git a/perf/fill.c b/perf/fill.c
index 2a41355..32e0765 100644
--- a/perf/fill.c
+++ b/perf/fill.c
@@ -26,24 +26,24 @@
 #include "cairo-perf.h"
 
 static cairo_perf_ticks_t
-do_fill (cairo_t *cr, int width, int height)
+do_fill (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     cairo_arc (cr,
 	       width/2.0, height/2.0,
 	       width/3.0,
 	       0, 2 * M_PI);
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_fill (cr);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 fill (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_cover_sources_and_operators (perf, "fill", do_fill);
+    cairo_perf_cover_sources_and_operators (perf, cr, "fill", do_fill);
 }
diff --git a/perf/long-lines.c b/perf/long-lines.c
index 62e8e16..85d1d80 100644
--- a/perf/long-lines.c
+++ b/perf/long-lines.c
@@ -40,7 +40,7 @@ typedef enum { LONG_LINES_UNCROPPED, LONG_LINES_CROPPED } long_lines_crop_t;
 #define LONG_FACTOR  50.0
 
 static cairo_perf_ticks_t
-do_long_lines (cairo_t *cr, int width, int height, long_lines_crop_t crop)
+do_long_lines (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height, long_lines_crop_t crop)
 {
     int i;
     double x, y, dx, dy, min_x, min_y, max_x, max_y;
@@ -67,7 +67,7 @@ do_long_lines (cairo_t *cr, int width, int height, long_lines_crop_t crop)
     dx = outer_width / NUM_LINES;
     dy = outer_height / NUM_LINES;
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     for (i = 0; i < NUM_LINES; i++) {
 	cairo_move_to (cr, 0, 0);
@@ -90,28 +90,28 @@ do_long_lines (cairo_t *cr, int width, int height, long_lines_crop_t crop)
 	y += dy;
     }
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
     cairo_restore (cr);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 static cairo_perf_ticks_t
-long_lines_uncropped (cairo_t *cr, int width, int height)
+long_lines_uncropped (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return do_long_lines (cr, width, height, LONG_LINES_UNCROPPED);
+    return do_long_lines (timer, cr, width, height, LONG_LINES_UNCROPPED);
 }
 
 static cairo_perf_ticks_t
-long_lines_cropped (cairo_t *cr, int width, int height)
+long_lines_cropped (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return do_long_lines (cr, width, height, LONG_LINES_CROPPED);
+    return do_long_lines (timer, cr, width, height, LONG_LINES_CROPPED);
 }
 
 void
 long_lines (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "long-lines-uncropped", long_lines_uncropped);
-    cairo_perf_run (perf, "long-lines-cropped", long_lines_cropped);
+    cairo_perf_run (perf, cr, "long-lines-uncropped", long_lines_uncropped);
+    cairo_perf_run (perf, cr, "long-lines-cropped", long_lines_cropped);
 }
diff --git a/perf/mosaic.c b/perf/mosaic.c
index 7172a9d..ad6b148 100644
--- a/perf/mosaic.c
+++ b/perf/mosaic.c
@@ -93,7 +93,7 @@ mosaic_next_path (cairo_t *cr, struct mosaic_region_iter *iter)
 }
 
 static cairo_perf_ticks_t
-mosaic_perform(cairo_t *cr, unsigned flags, int width, int height)
+mosaic_perform(cairo_perf_timer_t *timer, cairo_t *cr, unsigned flags, int width, int height)
 {
     struct mosaic_region_iter iter;
 
@@ -118,7 +118,7 @@ mosaic_perform(cairo_t *cr, unsigned flags, int width, int height)
      * tessellating them as dictated by the flags.  */
     mosaic_region_iter_init (&iter, flags & MOSAIC_CURVE_TO);
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
     while (mosaic_next_path (cr, &iter)) {
 	if (flags & MOSAIC_FILL) {
 	    cairo_fill (cr);
@@ -129,40 +129,40 @@ mosaic_perform(cairo_t *cr, unsigned flags, int width, int height)
 	    cairo_in_fill (cr, x, y);
 	}
     }
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 static cairo_perf_ticks_t
-mosaic_fill_curves (cairo_t *cr, int width, int height)
+mosaic_fill_curves (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return mosaic_perform (cr, MOSAIC_FILL | MOSAIC_CURVE_TO, width, height);
+    return mosaic_perform (timer, cr, MOSAIC_FILL | MOSAIC_CURVE_TO, width, height);
 }
 
 static cairo_perf_ticks_t
-mosaic_fill_lines (cairo_t *cr, int width, int height)
+mosaic_fill_lines (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return mosaic_perform (cr, MOSAIC_FILL | MOSAIC_LINE_TO, width, height);
+    return mosaic_perform (timer, cr, MOSAIC_FILL | MOSAIC_LINE_TO, width, height);
 }
 
 static cairo_perf_ticks_t
-mosaic_tessellate_lines (cairo_t *cr, int width, int height)
+mosaic_tessellate_lines (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return mosaic_perform (cr, MOSAIC_TESSELLATE | MOSAIC_LINE_TO, width, height);
+    return mosaic_perform (timer, cr, MOSAIC_TESSELLATE | MOSAIC_LINE_TO, width, height);
 }
 
 static cairo_perf_ticks_t
-mosaic_tessellate_curves (cairo_t *cr, int width, int height)
+mosaic_tessellate_curves (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return mosaic_perform (cr, MOSAIC_TESSELLATE | MOSAIC_CURVE_TO, width, height);
+    return mosaic_perform (timer, cr, MOSAIC_TESSELLATE | MOSAIC_CURVE_TO, width, height);
 }
 
 void
 mosaic (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "mosaic_fill_curves", mosaic_fill_curves);
-    cairo_perf_run (perf, "mosaic_fill_lines", mosaic_fill_lines);
-    cairo_perf_run (perf, "mosaic_tessellate_curves", mosaic_tessellate_curves);
-    cairo_perf_run (perf, "mosaic_tessellate_lines", mosaic_tessellate_lines);
+    cairo_perf_run (perf, cr, "mosaic_fill_curves", mosaic_fill_curves);
+    cairo_perf_run (perf, cr, "mosaic_fill_lines", mosaic_fill_lines);
+    cairo_perf_run (perf, cr, "mosaic_tessellate_curves", mosaic_tessellate_curves);
+    cairo_perf_run (perf, cr, "mosaic_tessellate_lines", mosaic_tessellate_lines);
 }
diff --git a/perf/paint.c b/perf/paint.c
index 6f75016..fad1743 100644
--- a/perf/paint.c
+++ b/perf/paint.c
@@ -26,19 +26,19 @@
 #include "cairo-perf.h"
 
 static cairo_perf_ticks_t
-do_paint (cairo_t *cr, int width, int height)
+do_paint (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_paint (cr);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 paint (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_cover_sources_and_operators (perf, "paint", do_paint);
+    cairo_perf_cover_sources_and_operators (perf, cr, "paint", do_paint);
 }
diff --git a/perf/pattern_create_radial.c b/perf/pattern_create_radial.c
index 09f15a8..bc37175 100644
--- a/perf/pattern_create_radial.c
+++ b/perf/pattern_create_radial.c
@@ -56,12 +56,12 @@ generate_double_in_range (double min, double max)
 }
 
 static cairo_perf_ticks_t
-do_pattern_create_radial (cairo_t *cr, int width, int height)
+do_pattern_create_radial (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     int i;
     cairo_pattern_t *pattern;
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     for (i = 0; i < RADIALS_COUNT; i++)
     {
@@ -72,9 +72,9 @@ do_pattern_create_radial (cairo_t *cr, int width, int height)
         cairo_pattern_destroy (pattern);
     }
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
@@ -93,6 +93,7 @@ pattern_create_radial (cairo_perf_t *perf, cairo_t *cr, int width, int height)
         radials[i].radius1 = generate_double_in_range (0.0, 1000.0);
     }
 
-    cairo_perf_run (perf, "pattern_create_radial",
-                          do_pattern_create_radial);
+    cairo_perf_run (perf, cr,
+	            "pattern_create_radial",
+		    do_pattern_create_radial);
 }
diff --git a/perf/rectangles.c b/perf/rectangles.c
index 9fa89f5..1933e57 100644
--- a/perf/rectangles.c
+++ b/perf/rectangles.c
@@ -35,11 +35,11 @@ static struct
 } rects[RECTANGLE_COUNT];
 
 static cairo_perf_ticks_t
-do_rectangles (cairo_t *cr, int width, int height)
+do_rectangles (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     int i;
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     for (i = 0; i < RECTANGLE_COUNT; i++)
     {
@@ -48,9 +48,9 @@ do_rectangles (cairo_t *cr, int width, int height)
         cairo_fill (cr);
     }
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
@@ -67,5 +67,5 @@ rectangles (cairo_perf_t *perf, cairo_t *cr, int width, int height)
         rects[i].height = (rand () % (height / 10)) + 1;
     }
 
-    cairo_perf_run (perf, "rectangles", do_rectangles);
+    cairo_perf_run (perf, cr, "rectangles", do_rectangles);
 }
diff --git a/perf/stroke.c b/perf/stroke.c
index 0b4ea8e..bf8b98b 100644
--- a/perf/stroke.c
+++ b/perf/stroke.c
@@ -26,7 +26,7 @@
 #include "cairo-perf.h"
 
 static cairo_perf_ticks_t
-do_stroke (cairo_t *cr, int width, int height)
+do_stroke (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     cairo_arc (cr,
 	       width/2.0, height/2.0,
@@ -34,18 +34,18 @@ do_stroke (cairo_t *cr, int width, int height)
 	       0, 2 * M_PI);
     cairo_close_path (cr);
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_set_line_width (cr, width/5.0);
     cairo_stroke (cr);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 stroke (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_cover_sources_and_operators (perf, "stroke", do_stroke);
+    cairo_perf_cover_sources_and_operators (perf, cr, "stroke", do_stroke);
 }
diff --git a/perf/subimage_copy.c b/perf/subimage_copy.c
index 54f596f..44d2bb3 100644
--- a/perf/subimage_copy.c
+++ b/perf/subimage_copy.c
@@ -35,18 +35,18 @@
  */
 
 static cairo_perf_ticks_t
-do_subimage_copy (cairo_t *cr, int width, int height)
+do_subimage_copy (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     cairo_rectangle (cr, 2, 2, 4, 4);
     cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_fill (cr);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
@@ -67,5 +67,5 @@ subimage_copy (cairo_perf_t *perf, cairo_t *cr, int width, int height)
     cairo_set_source_surface (cr, image, 0, 0);
     cairo_surface_destroy (image);
 
-    cairo_perf_run (perf, "subimage_copy", do_subimage_copy);
+    cairo_perf_run (perf, cr, "subimage_copy", do_subimage_copy);
 }
diff --git a/perf/tessellate.c b/perf/tessellate.c
index fc97db7..1bd6d40 100644
--- a/perf/tessellate.c
+++ b/perf/tessellate.c
@@ -99,14 +99,14 @@ point_t points[300] = {
 };
 
 static cairo_perf_ticks_t
-do_tessellate (cairo_t *cr, int num_points)
+do_tessellate (cairo_perf_timer_t *timer, cairo_t *cr, int num_points)
 {
     int i;
 
     for (i=0; i < num_points; i++)
 	cairo_line_to (cr, points[i].x, points[i].y);
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     /* We'd like to measure just tessellation without
      * rasterization. For now, we can do that with cairo_in_fill. But
@@ -115,37 +115,37 @@ do_tessellate (cairo_t *cr, int num_points)
      * include tessellation. */
     cairo_in_fill (cr, 50, 50);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
     cairo_new_path (cr);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 static cairo_perf_ticks_t
-tessellate_16 (cairo_t *cr, int width, int height)
+tessellate_16 (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return do_tessellate (cr, 16);
+    return do_tessellate (timer, cr, 16);
 }
 
 static cairo_perf_ticks_t
-tessellate_64 (cairo_t *cr, int width, int height)
+tessellate_64 (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return do_tessellate (cr, 64);
+    return do_tessellate (timer, cr, 64);
 }
 
 static cairo_perf_ticks_t
-tessellate_256 (cairo_t *cr, int width, int height)
+tessellate_256 (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
-    return do_tessellate (cr, 256);
+    return do_tessellate (timer, cr, 256);
 }
 
 void
 tessellate (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "tessellate-16", tessellate_16);
-    cairo_perf_run (perf, "tessellate-64", tessellate_64);
-    cairo_perf_run (perf, "tessellate-256", tessellate_256);
+    cairo_perf_run (perf, cr, "tessellate-16", tessellate_16);
+    cairo_perf_run (perf, cr, "tessellate-64", tessellate_64);
+    cairo_perf_run (perf, cr, "tessellate-256", tessellate_256);
 }
 
 #if 0
diff --git a/perf/text.c b/perf/text.c
index de5e0cd..d547b95 100644
--- a/perf/text.c
+++ b/perf/text.c
@@ -26,14 +26,14 @@
 #include "cairo-perf.h"
 
 static cairo_perf_ticks_t
-do_text (cairo_t *cr, int width, int height)
+do_text (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     const char text[] = "the jay, pig, fox, zebra and my wolves quack";
     int len = strlen (text);
     double x, y;
     int i = 0;
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_set_font_size (cr, 9);
     do {
@@ -49,13 +49,13 @@ do_text (cairo_t *cr, int width, int height)
 	    i = 0;
     } while (y < height);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 text (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_cover_sources_and_operators (perf, "text", do_text);
+    cairo_perf_cover_sources_and_operators (perf, cr, "text", do_text);
 }
diff --git a/perf/unaligned-clip.c b/perf/unaligned-clip.c
index c7b9d21..f2a4c1d 100644
--- a/perf/unaligned-clip.c
+++ b/perf/unaligned-clip.c
@@ -29,11 +29,11 @@
 #include "cairo-perf.h"
 
 static cairo_perf_ticks_t
-do_unaligned_clip (cairo_t *cr, int width, int height)
+do_unaligned_clip (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     cairo_save (cr);
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
     /* First a triangular clip that obviously isn't along device-pixel
      * boundaries. */
     cairo_move_to (cr, 50, 50);
@@ -52,15 +52,15 @@ do_unaligned_clip (cairo_t *cr, int width, int height)
     cairo_close_path (cr);
 
     cairo_clip (cr);
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
     cairo_restore (cr);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 unaligned_clip (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "unaligned_clip", do_unaligned_clip);
+    cairo_perf_run (perf, cr, "unaligned_clip", do_unaligned_clip);
 }
diff --git a/perf/world-map.c b/perf/world-map.c
index eef3619..9509844 100644
--- a/perf/world-map.c
+++ b/perf/world-map.c
@@ -47,12 +47,12 @@ typedef struct _wm_element {
 #include "world-map.h"
 
 static cairo_perf_ticks_t
-do_world_map (cairo_t *cr, int width, int height)
+do_world_map (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     const wm_element_t *e;
     double cx, cy;
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_set_source_rgb (cr, .68, .85, .90); /* lightblue */
     cairo_rectangle (cr, 0, 0, 800, 400);
@@ -95,13 +95,13 @@ do_world_map (cairo_t *cr, int width, int height)
 	e++;
     }
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 world_map (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "world_map", do_world_map);
+    cairo_perf_run (perf, cr, "world_map", do_world_map);
 }
diff --git a/perf/zrusin.c b/perf/zrusin.c
index 6840775..a759764 100644
--- a/perf/zrusin.c
+++ b/perf/zrusin.c
@@ -45,11 +45,11 @@ zrusin_another_path (cairo_t *cr)
 }
 
 static cairo_perf_ticks_t
-zrusin_another_tessellate (cairo_t *cr, int width, int height)
+zrusin_another_tessellate (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     zrusin_another_path (cr);
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     /* We'd like to measure just tessellation without
      * rasterization. For now, we can do that with cairo_in_fill. But
@@ -58,33 +58,37 @@ zrusin_another_tessellate (cairo_t *cr, int width, int height)
      * include tessellation. */
     cairo_in_fill (cr, 50, 50);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
     cairo_new_path (cr);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 static cairo_perf_ticks_t
-zrusin_another_fill (cairo_t *cr, int width, int height)
+zrusin_another_fill (cairo_perf_timer_t *timer, cairo_t *cr, int width, int height)
 {
     zrusin_another_path (cr);
     cairo_set_source_rgb (cr, 0.0, 0.0, 0.8); /* blue */
 
-    cairo_perf_timer_start ();
+    cairo_perf_timer_start (timer);
 
     cairo_fill (cr);
 
-    cairo_perf_timer_stop ();
+    cairo_perf_timer_stop (timer);
 
     cairo_new_path (cr);
 
-    return cairo_perf_timer_elapsed ();
+    return cairo_perf_timer_elapsed (timer);
 }
 
 void
 zrusin (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "zrusin_another_tessellate", zrusin_another_tessellate);
-    cairo_perf_run (perf, "zrusin_another_fill", zrusin_another_fill);
+    cairo_perf_run (perf, cr,
+	            "zrusin_another_tessellate",
+		    zrusin_another_tessellate);
+    cairo_perf_run (perf, cr,
+	            "zrusin_another_fill",
+		    zrusin_another_fill);
 }
From behdad at behdad.org  Thu Mar 22 20:44:29 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar 22 20:44:29 2007
Subject: [cairo] Is cairo_clip_extents() a getter?
In-Reply-To: <1174596875.5969.39.camel@murrayc-desktop>
References: <1174596875.5969.39.camel@murrayc-desktop>
Message-ID: <1174621469.18229.1.camel@behdad>

On Thu, 2007-03-22 at 16:54 -0400, Murray Cumming wrote:
> cairo_clip_extents() was added in cairo 1.4. Is it just a getter that
> doesn't affect the cairo context?

Semantically, yes.  Internally, probably no.

> http://cairographics.org/manual/cairo-cairo-t.html#cairo-clip-extents
> 
> It's suspiciously similar to the existing cairo_clip() and
> cairo_clip_preserve() functions. 

Think about it like cairo_fill/stroke/font/text/glyph_extents().

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From chris at chris-wilson.co.uk  Fri Mar 23 04:45:05 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 23 04:45:14 2007
Subject: [cairo] Multithreaded cairo-test
In-Reply-To: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
Message-ID: <20070323114504.GH10524@inspired.chris-wilson.co.uk>

Similary make cairo-test run the test over multiple threads. In order to
acheive this we have to delay any printf until the test is complete and
move the globals to a per-thread context - for portability we'll
probably have to pass the context to the actual test functions. Again
WIP.

Any feedback welcome...
--
Chris Wilson
-------------- next part --------------
diff --git a/test/cairo-test.c b/test/cairo-test.c
index f3cf9e9..ed4b424 100755
--- a/test/cairo-test.c
+++ b/test/cairo-test.c
@@ -39,6 +39,7 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <pthread.h>
 #include <errno.h>
 #include <string.h>
 #if HAVE_FCFINI
@@ -75,16 +76,18 @@ static const char *fail_face = "", *normal_face = "";
 
 #define NUM_DEVICE_OFFSETS 2
 
-/* Static data is messy, but we're coding for tests here, not a
- * general-purpose library, and it keeps the tests cleaner to avoid a
- * context object there, (though not a whole lot). */
-FILE *cairo_test_log_file = NULL;
-const char *srcdir;
+static const char *srcdir;
+static cairo_bool_t print_fail_on_stdout = TRUE;
 
-/* Used to catch crashes in a test, such that we report it as such and
- * continue testing, although one crasher may already have corrupted memory in
- * an nonrecoverable fashion. */
-jmp_buf jmpbuf;
+struct _cairo_test_context {
+    FILE *log_file;
+
+    /* Used to catch crashes in a test, such that we report it as such and
+     * continue testing, although one crasher may already have corrupted
+     * memory in an nonrecoverable fashion. */
+    jmp_buf jmpbuf;
+};
+static __thread cairo_test_context_t *cairo_test_context;
 
 void
 cairo_test_init (const char *test_name)
@@ -94,31 +97,26 @@ cairo_test_init (const char *test_name)
     xasprintf (&log_name, "%s%s", test_name, CAIRO_TEST_LOG_SUFFIX);
     xunlink (log_name);
 
-    cairo_test_log_file = fopen (log_name, "a");
-    if (cairo_test_log_file == NULL) {
+    cairo_test_context->log_file = fopen (log_name, "a");
+    if (cairo_test_context->log_file == NULL) {
 	fprintf (stderr, "Error opening log file: %s\n", log_name);
-	cairo_test_log_file = stderr;
+	cairo_test_context->log_file = stderr;
     }
     free (log_name);
-
-    printf ("\nTESTING %s\n", test_name);
 }
 
 void
 cairo_test_fini (void)
 {
-    fclose (cairo_test_log_file);
-    cairo_debug_reset_static_data ();
-#if HAVE_FCFINI
-    FcFini ();
-#endif
+    if (cairo_test_context->log_file != stderr)
+	fclose (cairo_test_context->log_file);
 }
 
 void
 cairo_test_log (const char *fmt, ...)
 {
     va_list va;
-    FILE *file = cairo_test_log_file ? cairo_test_log_file : stderr;
+    FILE *file = cairo_test_context->log_file ? cairo_test_context->log_file : stderr;
 
     va_start (va, fmt);
     vfprintf (file, fmt, va);
@@ -189,8 +187,8 @@ done:
 }
 
 static cairo_test_status_t
-cairo_test_for_target (cairo_test_t			 *test,
-		       cairo_boilerplate_target_t	 *target,
+cairo_test_for_target (const cairo_test_t	         *test,
+		       const cairo_boilerplate_target_t	 *target,
 		       int				  dev_offset)
 {
     cairo_test_status_t status;
@@ -201,6 +199,8 @@ cairo_test_for_target (cairo_test_t			 *test,
     cairo_content_t expected_content;
     cairo_font_options_t *font_options;
     const char *format;
+    unsigned int width, height;
+    void *closure = NULL;
 
     /* Get the strings ready that we'll need. */
     format = _cairo_test_content_name (target->content);
@@ -222,22 +222,19 @@ cairo_test_for_target (cairo_test_t			 *test,
 	       offset_str, CAIRO_TEST_DIFF_SUFFIX);
 
     /* Run the actual drawing code. */
-    if (test->width && test->height) {
-	test->width += dev_offset;
-	test->height += dev_offset;
+    width = test->width;
+    height = test->height;
+    if (width && height) {
+	width += dev_offset;
+	height += dev_offset;
     }
 
     surface = (target->create_surface) (test->name,
 					target->content,
-					test->width,
-					test->height,
+					width,
+					height,
 					CAIRO_BOILERPLATE_MODE_TEST,
-					&target->closure);
-
-    if (test->width && test->height) {
-	test->width -= dev_offset;
-	test->height -= dev_offset;;
-    }
+					&closure);
 
     if (surface == NULL) {
 	cairo_test_log ("Error: Failed to set %s target\n", target->name);
@@ -352,7 +349,7 @@ UNWIND_SURFACE:
     cairo_debug_reset_static_data ();
 
     if (target->cleanup)
-	target->cleanup (target->closure);
+	target->cleanup (closure);
 
 UNWIND_STRINGS:
     if (png_name)
@@ -371,48 +368,29 @@ UNWIND_STRINGS:
 static void
 segfault_handler (int signal)
 {
-    longjmp (jmpbuf, signal);
+    longjmp (cairo_test_context->jmpbuf, signal);
 }
 #endif
 
 static cairo_test_status_t
-cairo_test_expecting (cairo_test_t *test,
-		      cairo_test_status_t expectation)
+cairo_test_run (const cairo_test_t *test)
 {
     /* we use volatile here to make sure values are not clobbered
      * by longjmp */
     volatile size_t i, j, num_targets;
-    volatile cairo_bool_t limited_targets = FALSE, print_fail_on_stdout = TRUE;
     const char *tname;
 #ifdef HAVE_SIGNAL_H
     void (*old_segfault_handler)(int);
 #endif
     volatile cairo_test_status_t status, ret;
     cairo_boilerplate_target_t ** volatile targets_to_test;
+    cairo_test_context_t context;
 
-#ifdef HAVE_UNISTD_H
-    if (isatty (2)) {
-	fail_face = "\033[41m\033[37m\033[1m";
-	normal_face = "\033[m";
-	if (isatty (1))
-	    print_fail_on_stdout = FALSE;
-    }
-#endif
-
-    srcdir = getenv ("srcdir");
-    if (!srcdir)
-	srcdir = ".";
-
+    cairo_test_context = &context;
     cairo_test_init (test->name);
-    printf ("%s\n", test->description);
-
-    if (expectation == CAIRO_TEST_FAILURE)
-    printf ("Expecting failure\n");
 
     if ((tname = getenv ("CAIRO_TEST_TARGET")) != NULL && *tname) {
 
-	limited_targets = TRUE;
-
 	num_targets = 0;
 	targets_to_test = NULL;
 
@@ -434,7 +412,7 @@ cairo_test_expecting (cairo_test_t *test,
 
 	    if (!found) {
 		fprintf (stderr, "Cannot test target '%.*s'\n", (int)(end - tname), tname);
-		exit(-1);
+		return CAIRO_TEST_UNTESTED;
 	    }
 
 	    if (*end)
@@ -469,18 +447,17 @@ cairo_test_expecting (cairo_test_t *test,
     ret = CAIRO_TEST_UNTESTED;
     for (i = 0; i < num_targets; i++) {
 	for (j = 0; j < NUM_DEVICE_OFFSETS; j++) {
-	    cairo_boilerplate_target_t * volatile target = targets_to_test[i];
+	    const cairo_boilerplate_target_t * volatile target = targets_to_test[i];
 	    volatile int dev_offset = j * 25;
+	    const char *result;
+	    cairo_bool_t do_printf;
 
 	    cairo_test_log ("Testing %s with %s target (dev offset %d)\n", test->name, target->name, dev_offset);
-	    printf ("%s-%s-%s [%d]:\t", test->name, target->name,
-		    _cairo_test_content_name (target->content),
-		    dev_offset);
 
 #ifdef HAVE_SIGNAL_H
 	    /* Set up a checkpoint to get back to in case of segfaults. */
 	    old_segfault_handler = signal (SIGSEGV, segfault_handler);
-	    if (0 == setjmp (jmpbuf))
+	    if (0 == setjmp (cairo_test_context->jmpbuf))
 #endif
 		status = cairo_test_for_target (test, target, dev_offset);
 #ifdef HAVE_SIGNAL_H
@@ -489,31 +466,21 @@ cairo_test_expecting (cairo_test_t *test,
 	    signal (SIGSEGV, old_segfault_handler);
 #endif
 
-	    cairo_test_log ("TEST: %s TARGET: %s FORMAT: %s OFFSET: %d RESULT: ",
-			    test->name, target->name,
-			    _cairo_test_content_name (target->content),
-			    dev_offset);
-
+	    do_printf = TRUE;
 	    switch (status) {
 	    case CAIRO_TEST_SUCCESS:
-		printf ("PASS\n");
-		cairo_test_log ("PASS\n");
+		result = "PASS";
+		do_printf = TRUE;
 		if (ret == CAIRO_TEST_UNTESTED)
 		    ret = CAIRO_TEST_SUCCESS;
 		break;
 	    case CAIRO_TEST_UNTESTED:
-		printf ("UNTESTED\n");
-		cairo_test_log ("UNTESTED\n");
+		result = "UNTESTED";
+		do_printf = TRUE;
 		break;
 	    case CAIRO_TEST_CRASHED:
-		if (print_fail_on_stdout) {
-		    printf ("!!!CRASHED!!!\n");
-		} else {
-		    /* eat the test name */
-		    printf ("\r");
-		    fflush (stdout);
-		}
-		cairo_test_log ("CRASHED\n");
+		result = "!!!CRASHED!!!";
+		do_printf = print_fail_on_stdout;
 		fprintf (stderr, "%s-%s-%s [%d]:\t%s!!!CRASHED!!!%s\n",
 			 test->name, target->name,
 			 _cairo_test_content_name (target->content), dev_offset,
@@ -522,58 +489,31 @@ cairo_test_expecting (cairo_test_t *test,
 		break;
 	    default:
 	    case CAIRO_TEST_FAILURE:
-		if (expectation == CAIRO_TEST_FAILURE) {
-		    printf ("XFAIL\n");
-		    cairo_test_log ("XFAIL\n");
+		if (test->expectation == CAIRO_TEST_FAILURE) {
+		    result = "XFAIL";
+		    do_printf = TRUE;
 		} else {
-		    if (print_fail_on_stdout) {
-			printf ("FAIL\n");
-		    } else {
-			/* eat the test name */
-			printf ("\r");
-			fflush (stdout);
-		    }
+		    result = "FAIL";
+		    do_printf = print_fail_on_stdout;
 		    fprintf (stderr, "%s-%s-%s [%d]:\t%sFAIL%s\n",
 			     test->name, target->name,
 			     _cairo_test_content_name (target->content), dev_offset,
 			     fail_face, normal_face);
-		    cairo_test_log ("FAIL\n");
 		}
 		ret = status;
 		break;
 	    }
-	}
-    }
-
-    if (ret != CAIRO_TEST_SUCCESS)
-        printf ("Check %s%s out for more information.\n", test->name, CAIRO_TEST_LOG_SUFFIX);
-
-    /* if the set of targets to test was limited using CAIRO_TEST_TARGET, we
-     * behave slightly differently, to ensure that limiting the targets does
-     * not increase the number of tests failing. */
-    if (limited_targets) {
-
-	/* if all untested, success */
-	if (ret == CAIRO_TEST_UNTESTED) {
-	    printf ("None of the tested backends passed, but tested targets are manually limited.\n"
-		    "Passing the test, to not fail the suite.\n");
-	    ret = CAIRO_TEST_SUCCESS;
-	}
+	    cairo_test_log ("TEST: %s TARGET: %s FORMAT: %s OFFSET: %d RESULT: %s\n",
+			    test->name, target->name,
+			    _cairo_test_content_name (target->content),
+			    dev_offset, result);
 
-	/* if all passed, but expecting failure, return failure to not
-	 * trigger an XPASS failure */
-	if (expectation == CAIRO_TEST_FAILURE && ret == CAIRO_TEST_SUCCESS) {
-	    printf ("All tested backends passed, but tested targets are manually limited\n"
-		    "and the test suite expects this test to fail for at least one target.\n"
-		    "Intentionally failing the test, to not fail the suite.\n");
-	    ret = CAIRO_TEST_FAILURE;
+	    if (do_printf) {
+		printf ("%s-%s-%s [%d]:\t%s\n", test->name, target->name,
+			_cairo_test_content_name (target->content),
+			dev_offset, result);
+	    }
 	}
-
-    } else {
-
-	if (ret == CAIRO_TEST_UNTESTED)
-	    ret = CAIRO_TEST_FAILURE;
-
     }
 
     cairo_test_fini ();
@@ -583,11 +523,35 @@ cairo_test_expecting (cairo_test_t *test,
     return ret;
 }
 
+static void *
+cairo_test_run_wrapper (void *arg)
+{
+    return (void *) cairo_test_run (arg);
+}
+
+
+static cairo_bool_t
+has_string (const char *str)
+{
+    return str != NULL && *str != '\0';
+}
+
 cairo_test_status_t
 cairo_test (cairo_test_t *test)
 {
+    cairo_test_status_t status = CAIRO_TEST_SUCCESS;
     cairo_test_status_t expectation = CAIRO_TEST_SUCCESS;
     const char *xfails;
+    unsigned int nthreads;
+
+#ifdef HAVE_UNISTD_H
+    if (isatty (2)) {
+	fail_face = "\033[41m\033[37m\033[1m";
+	normal_face = "\033[m";
+	if (isatty (1))
+	    print_fail_on_stdout = FALSE;
+    }
+#endif
 
 #ifdef _MSC_VER
     /* We don't want an assert dialog, we want stderr */
@@ -612,15 +576,87 @@ cairo_test (cairo_test_t *test)
 	    xfails = end;
 	}
     }
+    test->expectation = expectation;
 
-    return cairo_test_expecting (test, expectation);
+    srcdir = getenv ("srcdir");
+    if (!srcdir)
+	srcdir = ".";
+
+    printf ("\nTESTING %s\n", test->name);
+    printf ("%s\n", test->description);
+    if (expectation == CAIRO_TEST_FAILURE)
+	printf ("Expecting failure\n");
+
+    nthreads = 0;
+    if (getenv("CAIRO_TEST_THREADS"))
+	nthreads = strtoul(getenv("CAIRO_TEST_THREADS"), NULL, 0);
+    if (nthreads) {
+	unsigned int i;
+	pthread_t *threads = xmalloc (sizeof (pthread_t) * nthreads);
+
+	for (i = 0; i < nthreads; i++) {
+	    if (pthread_create (&threads[i], NULL,
+				cairo_test_run_wrapper, (void *) test) < 0) {
+		fprintf (stderr, "Unable to create thread: %s\n",
+			strerror (errno));
+		exit (1);
+	    }
+	}
+	for (i = 0; i < nthreads; i++) {
+	    void *result;
+	    pthread_join (threads[i], &result);
+	    if (status == CAIRO_TEST_SUCCESS)
+		status = (cairo_test_status_t ) result;
+	}
+	free (threads);
+
+    } else {
+	status = cairo_test_run (test);
+    }
+
+    cairo_debug_reset_static_data ();
+#if HAVE_FCFINI
+    FcFini ();
+#endif
+
+    if (status != CAIRO_TEST_SUCCESS)
+        printf ("Check %s%s out for more information.\n", test->name, CAIRO_TEST_LOG_SUFFIX);
+
+    /* if the set of targets to test was limited using CAIRO_TEST_TARGET, we
+     * behave slightly differently, to ensure that limiting the targets does
+     * not increase the number of tests failing. */
+    if (has_string (getenv ("CAIRO_TEST_TARGET"))) {
+
+	/* if all untested, success */
+	if (status == CAIRO_TEST_UNTESTED) {
+	    printf ("None of the tested backends passed, but tested targets are manually limited.\n"
+		    "Passing the test, to not fail the suite.\n");
+	    status = CAIRO_TEST_SUCCESS;
+	}
+
+	/* if all passed, but expecting failure, return failure to not
+	 * trigger an XPASS failure */
+	if (expectation == CAIRO_TEST_FAILURE && status == CAIRO_TEST_SUCCESS) {
+	    printf ("All tested backends passed, but tested targets are manually limited\n"
+		    "and the test suite expects this test to fail for at least one target.\n"
+		    "Intentionally failing the test, to not fail the suite.\n");
+	    status = CAIRO_TEST_FAILURE;
+	}
+
+    } else {
+
+	if (status == CAIRO_TEST_UNTESTED)
+	    status = CAIRO_TEST_FAILURE;
+
+    }
+
+    return status;
 }
 
 cairo_surface_t *
 cairo_test_create_surface_from_png (const char *filename)
 {
     cairo_surface_t *image;
-    char *srcdir = getenv ("srcdir");
 
     image = cairo_image_surface_create_from_png (filename);
     if (cairo_surface_status(image)) {
diff --git a/test/cairo-test.h b/test/cairo-test.h
index d3612ba..9b9625a 100755
--- a/test/cairo-test.h
+++ b/test/cairo-test.h
@@ -66,6 +66,8 @@ typedef enum cairo_test_status {
     CAIRO_TEST_CRASHED
 } cairo_test_status_t;
 
+typedef struct _cairo_test_context cairo_test_context_t;
+
 typedef cairo_test_status_t  (cairo_test_draw_function_t) (cairo_t *cr, int width, int height);
 
 typedef struct _cairo_test {
@@ -74,6 +76,7 @@ typedef struct _cairo_test {
     int width;
     int height;
     cairo_test_draw_function_t *draw;
+    cairo_test_status_t expectation;
 } cairo_test_t;
 
 /* The standard test interface which works by examining result image.
From chris at chris-wilson.co.uk  Fri Mar 23 05:29:04 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 23 05:29:12 2007
Subject: [cairo] Multithreaded cairo-test
In-Reply-To: <20070323114504.GH10524@inspired.chris-wilson.co.uk>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
	<20070323114504.GH10524@inspired.chris-wilson.co.uk>
Message-ID: <20070323122904.GI10524@inspired.chris-wilson.co.uk>

The first causality exposed by multi-threaded cairo-test is the
_cairo_xlib_screen_list which lacked reference counting of the
_cairo_xlib_screen_info_t.
--
Chris Wilson
-------------- next part --------------
diff --git a/src/cairo-xlib-private.h b/src/cairo-xlib-private.h
index 9ecf5fe..73a0466 100644
--- a/src/cairo-xlib-private.h
+++ b/src/cairo-xlib-private.h
@@ -48,6 +48,8 @@ struct _cairo_xlib_hook {
 
 struct _cairo_xlib_screen_info {
     cairo_xlib_screen_info_t *next;
+    cairo_xlib_screen_info_t *prev;
+    unsigned int ref_count;
 
     Display *display;
     Screen *screen;
@@ -61,6 +63,11 @@ struct _cairo_xlib_screen_info {
 cairo_private cairo_xlib_screen_info_t *
 _cairo_xlib_screen_info_get (Display *display, Screen *screen);
 
+cairo_private cairo_xlib_screen_info_t *
+_cairo_xlib_screen_info_reference (cairo_xlib_screen_info_t *info);
+cairo_private_no_warn void
+_cairo_xlib_screen_info_destroy (cairo_xlib_screen_info_t *info);
+
 cairo_private cairo_bool_t
 _cairo_xlib_add_close_display_hook (Display *display, void (*func) (Display *, void *), void *data, void *key);
 cairo_private_no_warn void
diff --git a/src/cairo-xlib-screen.c b/src/cairo-xlib-screen.c
index d27057e..f314aea 100644
--- a/src/cairo-xlib-screen.c
+++ b/src/cairo-xlib-screen.c
@@ -245,6 +245,50 @@ _cairo_xlib_init_screen_font_options (cairo_xlib_screen_info_t *info)
 
 static cairo_xlib_screen_info_t *_cairo_xlib_screen_list = NULL;
 
+cairo_xlib_screen_info_t *
+_cairo_xlib_screen_info_reference (cairo_xlib_screen_info_t *info)
+{
+    assert (info->ref_count > 0);
+    info->ref_count ++;
+    return info;
+}
+
+static void
+_cairo_xlib_screen_info_destroy_unlocked (cairo_xlib_screen_info_t *info)
+{
+    assert (info->ref_count > 0);
+    if (--info->ref_count)
+	return;
+
+    while (info->close_display_hooks) {
+	cairo_xlib_hook_t *hook = info->close_display_hooks;
+	info->close_display_hooks = hook->next;
+
+	hook->func (info->display, hook->data);
+
+	free (hook);
+    }
+
+    if (info->prev)
+	info->prev->next = info->next;
+    else
+	_cairo_xlib_screen_list = info->next;
+    if (info->next)
+	info->next->prev = info->prev;
+
+    free (info);
+}
+void
+_cairo_xlib_screen_info_destroy (cairo_xlib_screen_info_t *info)
+{
+    CAIRO_MUTEX_LOCK (_cairo_xlib_screen_mutex);
+
+    _cairo_xlib_screen_info_destroy_unlocked (info);
+
+    CAIRO_MUTEX_UNLOCK (_cairo_xlib_screen_mutex);
+}
+
+
 static int
 _cairo_xlib_close_display (Display *dpy, XExtCodes *codes)
 {
@@ -261,15 +305,7 @@ _cairo_xlib_close_display (Display *dpy, XExtCodes *codes)
 	if (info->display == dpy) {
 	    *prev = next;
 	    /* call all registered shutdown routines */
-	    while (info->close_display_hooks) {
-		cairo_xlib_hook_t *hook = info->close_display_hooks;
-		info->close_display_hooks = hook->next;
-
-		hook->func (dpy, hook->data);
-
-		free (hook);
-	    }
-	    free (info);
+	    _cairo_xlib_screen_info_destroy_unlocked (info);
 	} else {
 	    prev = &info->next;
 	}
@@ -294,40 +330,38 @@ _cairo_xlib_screen_info_reset (void)
 
     for (info = _cairo_xlib_screen_list; info; info = next) {
 	next = info->next;
-	while (info->close_display_hooks) {
-	    cairo_xlib_hook_t *hook = info->close_display_hooks;
-	    info->close_display_hooks = hook->next;
-	    free (hook);
-	}
-	free (info);
+	_cairo_xlib_screen_info_destroy_unlocked (info);
     }
 
     _cairo_xlib_screen_list = NULL;
 
     CAIRO_MUTEX_UNLOCK (_cairo_xlib_screen_mutex);
-
 }
 
 static cairo_xlib_screen_info_t *
 _cairo_xlib_screen_info_get_unlocked (Display *dpy, Screen *screen)
 {
     cairo_xlib_screen_info_t *info;
-    cairo_xlib_screen_info_t **prev;
     int event_base, error_base;
     XExtCodes *codes;
     cairo_bool_t seen_display = FALSE;
 
-    for (prev = &_cairo_xlib_screen_list; (info = *prev); prev = &(*prev)->next)
+    for (info = _cairo_xlib_screen_list; info; info = info->next)
     {
 	if (info->display == dpy) {
 	    seen_display = TRUE;
-	    if (info->screen == screen || screen == NULL) {
+	    if (info->screen == screen) {
 		/*
 		 * MRU the list
 		 */
-		if (prev != &_cairo_xlib_screen_list) {
-		    *prev = info->next;
+		if (info->prev) {
+		    info->prev->next = info->next;
+		    if (info->next)
+			info->next->prev = info->prev;
 		    info->next = _cairo_xlib_screen_list;
+		    info->prev = NULL;
+		    if (_cairo_xlib_screen_list)
+			_cairo_xlib_screen_list->prev = info;
 		    _cairo_xlib_screen_list = info;
 		}
 		break;
@@ -336,7 +370,7 @@ _cairo_xlib_screen_info_get_unlocked (Display *dpy, Screen *screen)
     }
 
     if (info)
-	return info;
+	return _cairo_xlib_screen_info_reference (info);
 
     info = malloc (sizeof (cairo_xlib_screen_info_t));
     if (!info)
@@ -352,6 +386,8 @@ _cairo_xlib_screen_info_get_unlocked (Display *dpy, Screen *screen)
 	XESetCloseDisplay (dpy, codes->extension, _cairo_xlib_close_display);
     }
 
+    info->ref_count = 1;
+
     info->display = dpy;
     info->screen = screen;
     info->has_render = (XRenderQueryExtension (dpy, &event_base, &error_base) &&
@@ -362,6 +398,9 @@ _cairo_xlib_screen_info_get_unlocked (Display *dpy, Screen *screen)
     _cairo_xlib_init_screen_font_options (info);
 
     info->next = _cairo_xlib_screen_list;
+    info->prev = NULL;
+    if (_cairo_xlib_screen_list)
+	_cairo_xlib_screen_list->prev = info;
     _cairo_xlib_screen_list = info;
 
     return info;
@@ -425,7 +464,9 @@ _cairo_xlib_add_close_display_hook (Display *dpy, void (*func) (Display *, void
 	hook->key = key;
 	hook->next = info->close_display_hooks;
 	info->close_display_hooks = hook;
+	info = _cairo_xlib_screen_info_reference (info);
     }
+    _cairo_xlib_screen_info_destroy_unlocked (info);
 
     success = TRUE;
  unlock:
@@ -449,11 +490,13 @@ _cairo_xlib_remove_close_display_hook (Display *dpy, void *key)
     for (prev = &info->close_display_hooks; (hook = *prev); prev = &hook->next)
     {
 	if (hook->key == key) {
+	    _cairo_xlib_screen_info_destroy_unlocked (info);
 	    *prev = hook->next;
 	    free (hook);
 	    break;
 	}
     }
+    _cairo_xlib_screen_info_destroy_unlocked (info);
 
 unlock:
     CAIRO_MUTEX_UNLOCK (_cairo_xlib_screen_mutex);
diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 7f1392d..a85e700 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -341,6 +341,9 @@ _cairo_xlib_surface_finish (void *abstract_surface)
     if (surface->clip_rects != NULL)
 	free (surface->clip_rects);
 
+    if (surface->screen_info != NULL)
+	_cairo_xlib_screen_info_destroy (surface->screen_info);
+
     surface->dpy = NULL;
 
     return CAIRO_STATUS_SUCCESS;
@@ -1825,6 +1828,7 @@ _cairo_xlib_surface_create_internal (Display		       *dpy,
     surface = malloc (sizeof (cairo_xlib_surface_t));
     if (surface == NULL) {
 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
+	_cairo_xlib_screen_info_destroy (screen_info);
 	return (cairo_surface_t*) &_cairo_surface_nil;
     }
 
From chris at chris-wilson.co.uk  Fri Mar 23 06:02:03 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 23 06:02:12 2007
Subject: [cairo] Multithreaded cairo-test
In-Reply-To: <20070323114504.GH10524@inspired.chris-wilson.co.uk>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
	<20070323114504.GH10524@inspired.chris-wilson.co.uk>
Message-ID: <20070323130203.GJ10524@inspired.chris-wilson.co.uk>

During MT cairo-test, we see short fread()s. However, this is not always
an error, so check the ferror() status before raising png_error().
--
Chris Wilson
-------------- next part --------------
diff --git a/src/cairo-png.c b/src/cairo-png.c
index 006cae3..aa3210f 100644
--- a/src/cairo-png.c
+++ b/src/cairo-png.c
@@ -206,8 +206,13 @@ stdio_write_func (png_structp png, png_bytep data, png_size_t size)
     FILE *fp;
 
     fp = png_get_io_ptr (png);
-    if (fwrite (data, 1, size, fp) != size)
-	png_error(png, "Write Error");
+    while (size) {
+	size_t ret = fwrite (data, 1, size, fp);
+	size -= ret;
+	data += ret;
+	if (size && ferror (fp))
+	    png_error(png, "Write Error");
+    }
 }
 
 /**
@@ -332,14 +337,14 @@ read_png (png_rw_ptr	read_func,
 	  void		*closure)
 {
     cairo_surface_t *surface = (cairo_surface_t*) &_cairo_surface_nil;
-    png_byte *data = NULL;
-    unsigned int i;
     png_struct *png = NULL;
     png_info *info;
+    volatile png_byte *data = NULL;
+    volatile png_byte **row_pointers = NULL;
     png_uint_32 png_width, png_height, stride;
     int depth, color_type, interlace;
+    unsigned int i;
     unsigned int pixel_size;
-    png_byte **row_pointers = NULL;
 
     /* XXX: Perhaps we'll want some other error handlers? */
     png = png_create_read_struct (PNG_LIBPNG_VER_STRING,
@@ -442,8 +447,13 @@ stdio_read_func (png_structp png, png_bytep data, png_size_t size)
     FILE *fp;
 
     fp = png_get_io_ptr (png);
-    if (fread (data, 1, size, fp) != size)
-	png_error(png, "Read Error");
+    while (size) {
+	size_t ret = fread (data, 1, size, fp);
+	size -= ret;
+	data += ret;
+	if (size && ferror (fp))
+	    png_error(png, "Read Error");
+    }
 }
 
 /**
From behdad at behdad.org  Fri Mar 23 09:12:07 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar 23 09:12:11 2007
Subject: [cairo] Returning cached erroneous patterns
In-Reply-To: <2faad3050703221112g4559d01bj1ea0c3f4cbed349a@mail.gmail.com>
References: <20070322172140.GF10524@inspired.chris-wilson.co.uk>
	<2faad3050703221112g4559d01bj1ea0c3f4cbed349a@mail.gmail.com>
Message-ID: <1174666327.18229.23.camel@behdad>

On Thu, 2007-03-22 at 14:12 -0400, Baz wrote:
> On 22/03/07, Chris Wilson <chris@chris-wilson.co.uk> wrote:
> > Behdad's already fixed the primary case where we created a pattern
> > and explicity put it into an error state. However, it also possible for
> > a user to set an error status on a solid pattern, for example by using
> > it as an argument where a gradient was expected. That has some rather
> > unfortunate side-effects on a widely shared pattern...
> 
> Doesn't this mean it's possible for two threads to have already
> fetched the pattern from the cache, before one of them manages to set
> it to an error state? Even after this patch, I think you can do this
> by calling cairo_pattern_add_color_stop_rgba on a solid pattern
> fetched from the cache twice.
> 
> You can get similar behaviour in user applications by sharing
> gradients then adding color stops. Both threads will see the colour
> stops, and eventually both will see a pattern with an out of memory
> status.
> 
> All of this comes from patterns being mutable, for adding color stops,
> and setting user data. Should those operations should even be possible
> on patterns with more than one reference?

Ok, thanks for raising the issue.  The problem is that solid patterns
are not immutable as we expected.  Giving away the same mutable object
multiple times is definitely wrong.

I wanted to say we should back out the cache, but then I found that the
fix is really easy: instead of reusing patterns from the cache, keep a
pool of freed solid patterns.  That is: when using a pattern from the
cache, remove it from the cache, and when freeing a solid pattern of
refcount 1, set its error status to SUCCESS and add it to the cache.


> (waits to be shot down)
> -Baz

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From xi.wang at gmail.com  Fri Mar 23 09:34:04 2007
From: xi.wang at gmail.com (Xi Wang)
Date: Fri Mar 23 09:34:09 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <20070322215813.GA12132@jeremiahfoster.com>
References: <20070322215813.GA12132@jeremiahfoster.com>
Message-ID: <c72f00d10703230934i4a7c49fkba7de34585fbbe85@mail.gmail.com>

I suggest to use darwinports to install cairo 1.4.2 on Mac OS X. It works
well here.

Xi

On 3/23/07, Jeremiah Foster <jeremiah@jeremiahfoster.com> wrote:
>
> Hello,
>
> In trying to install Cairo on Mac OS X 10.3.9 I am running across some
> problems with
> pkg-config files (i.e. cairo.pc) not being found.
>
> I cloned cairo with git and read the README and INSTALL files. (The
> install file looks
> to be standard boilerplate stating that one use the traditional recipe of
> ./configure
> make and make install to install cairo but there is no configure script
> and the README
> tells me to use autogen.sh instead. Using authgen.sh produces this error:
>
> ./autogen.sh: Error: Could not find pkg-config macros.
>        (Looked in /usr/local/share/aclocal/pkg.m4)
>        If pkg.m4 is available in /another/directory, please set
>        ACLOCAL_FLAGS="-I /another/directory"
>        Otherwise, please install pkg-config.
>
> pkg-config is installed but in a different directory than normal
> (/sw/bin/pkg-config)
>
> How do I alert the autogen.sh script to the presence of pkg-config and
> will that
> solve my building Cairo problems?
>
> Thanks,
>
>        Jeremiah
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070324/46410ca1/attachment.html
From johannes.schmid at openismus.com  Fri Mar 23 09:39:28 2007
From: johannes.schmid at openismus.com (Johannes Schmid)
Date: Fri Mar 23 09:39:51 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <1174486059.19078.151.camel@localhost.localdomain>
References: <1173884708.5780.19.camel@murrayc-desktop>	
	<87k5xjycox.wl%cworth@cworth.org>
	<1173895376.14946.2.camel@behdad>	
	<1173895459.14946.4.camel@behdad> <460132FD.6060407@openismus.com>
	<1174486059.19078.151.camel@localhost.localdomain>
Message-ID: <460402C0.9000809@openismus.com>

Hi Owen, Behdad!

Thanks for your help! I think I found a quite good solution now. I still
have to bother with the default font but the rest seems to give me a
nice speed-up.

See https://maemo.org/bugzilla/show_bug.cgi?id=952 for details!

Thanks,
Johannes

Owen Taylor schrieb:
> On Wed, 2007-03-21 at 14:28 +0100, Johannes Schmid wrote:
>> Hi Behded!
>>
>> Behdad Esfahbod schrieb:
>>>> Create an image surface and render something in the default language and
>>>> default font ("Sans"?) to it using pangocairo.
>>> For extra, do it for all font-descriptions that your UI uses (all
>>> "default" font face+size combinations).
>> I am not very familiar to cairo but I tried this without any speed-up:
>>
>> context = pango_cairo_font_map_create_context (
>> 	PANGO_CAIRO_FONT_MAP(pango_cairo_font_map_get_default()));
>> pango_context_load_font (context, 	
>> 	pango_font_description_from_string("Sans"));
> 
> Hmm, I would have actually thought that this would work, but I'd 
> certainly trust Behdad's suggestion - "render something" - more.
> 
>> Maybe someone could point me to the methods I should use to render
>> something to the pango image surface because I could not figure out yet
>> with the reference documentation.
> 
> http://svn.gnome.org/viewcvs/pango/trunk/examples/cairosimple.c?view=markup
> 
> may help. (Obviously, it can get a lot simpler than that, but it shows
> the basics of rendering to an image surface)
> 
> It could just be that the fontconfig memmap'ed cache stuff has dropped
> startup overhead low enough that the advantage of pre-initializing
> things is small.
> 						- Owen
> 
> 

From jeremiah at jeremiahfoster.com  Fri Mar 23 11:44:03 2007
From: jeremiah at jeremiahfoster.com (Jeremiah Foster)
Date: Fri Mar 23 11:43:55 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <c72f00d10703230934i4a7c49fkba7de34585fbbe85@mail.gmail.com>
References: <20070322215813.GA12132@jeremiahfoster.com>
	<c72f00d10703230934i4a7c49fkba7de34585fbbe85@mail.gmail.com>
Message-ID: <20070323184403.GA17577@jeremiahfoster.com>

Thanks Xi, I'll try that .

Sat, Mar 24, 2007 at 12:34:04AM +0800:  Xi Wang mangled some bits into this alignment:
> 
>    I suggest to use darwinports to install cairo 1.4.2 on Mac OS X. It
>    works well here.
 
>    Xi
> 
> 
>    On 3/23/07, Jeremiah Foster <jeremiah@jeremiahfoster.com> wrote:
> 
>      Hello,
>      In trying to install Cairo on Mac OS X 10.3.9 I am running across
>      some problems 
From cworth at cworth.org  Fri Mar 23 15:07:05 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar 23 15:12:25 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <20070322215813.GA12132@jeremiahfoster.com>
References: <20070322215813.GA12132@jeremiahfoster.com>
Message-ID: <87aby3d37a.wl%cworth@cworth.org>

On Thu, 22 Mar 2007 22:58:13 +0100, Jeremiah Foster wrote:
>         (Looked in /usr/local/share/aclocal/pkg.m4)
>         If pkg.m4 is available in /another/directory, please set
>         ACLOCAL_FLAGS="-I /another/directory"
...
> How do I alert the autogen.sh script to the presence of pkg-config and will that
> solve my building Cairo problems?

Can I point you to the above text again? It's giving you instructions
on how to alert the autogen.sh script to the correct location of
pkg.m4 on your system. Is there something we could change in the
wording of that message to make it more clear?

Thanks,

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070323/1d0e3a53/attachment.pgp
From jeremiah at jeremiahfoster.com  Fri Mar 23 15:23:06 2007
From: jeremiah at jeremiahfoster.com (Jeremiah Foster)
Date: Fri Mar 23 15:22:55 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <87aby3d37a.wl%cworth@cworth.org>
References: <20070322215813.GA12132@jeremiahfoster.com>
	<87aby3d37a.wl%cworth@cworth.org>
Message-ID: <20070323222306.GA18533@jeremiahfoster.com>

Fri, Mar 23, 2007 at 03:07:05PM -0700:  Carl Worth mangled some bits into this alignment:
> On Thu, 22 Mar 2007 22:58:13 +0100, Jeremiah Foster wrote:
> >         (Looked in /usr/local/share/aclocal/pkg.m4)
> >         If pkg.m4 is available in /another/directory, please set
> >         ACLOCAL_FLAGS="-I /another/directory"
> ...
> > How do I alert the autogen.sh script to the presence of pkg-config and will that
> > solve my building Cairo problems?
> 
> Can I point you to the above text again? It's giving you instructions
> on how to alert the autogen.sh script to the correct location of
> pkg.m4 on your system. Is there something we could change in the
> wording of that message to make it more clear?

I am sorry, I was unclear. The error message I pasted was a two part message with the
first part mentioning cairo.pc. I did read both messages carefully and tried to set the 
required variables. The question is where? I passed the variables on the command line,
and added them to the autogen.sh script, but nothing seemed to work. 

Thanks,

	Jeremiah
From chris at chris-wilson.co.uk  Fri Mar 23 15:58:19 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 23 15:58:28 2007
Subject: [cairo] Multithreaded cairo-test
In-Reply-To: <20070323122904.GI10524@inspired.chris-wilson.co.uk>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
	<20070323114504.GH10524@inspired.chris-wilson.co.uk>
	<20070323122904.GI10524@inspired.chris-wilson.co.uk>
Message-ID: <20070323225818.GK10524@inspired.chris-wilson.co.uk>

I wrote: 
> The first causality exposed by multi-threaded cairo-test is the
> _cairo_xlib_screen_list which lacked reference counting of the
> _cairo_xlib_screen_info_t.

Not only that but later, a recursive deadlock was exposed:

==25095== Deadlock[recursive] for mutex 0x409130C at:
==25095==    at 0x401F478: pthread_mutex_lock (ld_preload.c:51)
==25095==    by 0x4063ABE: _cairo_xlib_screen_info_destroy (cairo-xlib-screen.c:284)
==25095==    by 0x4062E7B: _cairo_xlib_surface_finish (cairo-xlib-surface.c:345)
==25095==    by 0x403E402: cairo_surface_finish (cairo-surface.c:471)
==25095==    by 0x403E4AF: cairo_surface_destroy (cairo-surface.c:396)
==25095==    by 0x4041C49: _cairo_pattern_release_surface (cairo-pattern.c:1630)
==25095==    by 0x4062144: _cairo_xlib_surface_composite (cairo-xlib-surface.c:1419)
==25095==    by 0x403D5FD: _cairo_surface_composite (cairo-surface.c:1092)
==25095==    by 0x403A8D4: _cairo_scaled_font_show_glyphs (cairo-scaled-font.c:1136)
==25095==    by 0x403F828: _cairo_surface_old_show_glyphs_draw_func (cairo-surface-fallback.c:901)
==25095==    by 0x403F2B2: _clip_and_composite (cairo-surface-fallback.c:391)
==25095==    by 0x403F6C5: _cairo_surface_fallback_show_glyphs (cairo-surface-fallback.c:952)
==25095==    by 0x403DE6D: _cairo_surface_show_glyphs (cairo-surface.c:1806)
==25095==    by 0x402FDAE: _cairo_gstate_show_glyphs (cairo-gstate.c:1595)
==25095==    by 0x4029AF0: cairo_show_text (cairo.c:2825)
==25095==    by 0x804A203: draw (glyph-cache-pressure.c:80)
==25095==    by 0x804B714: cairo_test_targets (cairo-test.c:293)
==25095==    by 0x426631A: start_thread (in /lib/tls/i686/cmov/libpthread-2.5.so)
==25095==    by 0x436F3ED: clone (in /lib/tls/i686/cmov/libc-2.5.so)
==25095== Mutex 0x409130C was taken by thread 9 at:
==25095==    at 0x401F4F2: pthread_mutex_lock (ld_preload.c:54)
==25095==    by 0x40639F1: _cairo_xlib_close_display (cairo-xlib-screen.c:300)
==25095==    by 0x418E995: XCloseDisplay (ClDisplay.c:71)
==25095==    by 0x804BE2B: cleanup_xlib (cairo-boilerplate.c:1038)
==25095==    by 0x804B23F: cairo_test_targets (cairo-test.c:355)
==25095==    by 0x426631A: start_thread (in /lib/tls/i686/cmov/libpthread-2.5.so)
==25095==    by 0x436F3ED: clone (in /lib/tls/i686/cmov/libc-2.5.so)
==25095== which waits on mutex 0x80F9CEC, taken by us, thread 10, at:
==25095==    at 0x401F4F2: pthread_mutex_lock (ld_preload.c:54)
==25095==    by 0x403DDD0: _cairo_surface_show_glyphs (cairo-surface.c:1796)
==25095==    by 0x402FDAE: _cairo_gstate_show_glyphs (cairo-gstate.c:1595)
==25095==    by 0x4029AF0: cairo_show_text (cairo.c:2825)
==25095==    by 0x804A203: draw (glyph-cache-pressure.c:80)
==25095==    by 0x804B714: cairo_test_targets (cairo-test.c:293)
==25095==    by 0x426631A: start_thread (in /lib/tls/i686/cmov/libpthread-2.5.so)
==25095==    by 0x436F3ED: clone (in /lib/tls/i686/cmov/libc-2.5.so)
--
Chris Wilson


-------------- next part --------------
diff --git a/src/cairo-xlib-screen.c b/src/cairo-xlib-screen.c
index 345cdbc..e96afab 100644
--- a/src/cairo-xlib-screen.c
+++ b/src/cairo-xlib-screen.c
@@ -314,9 +314,11 @@ _cairo_xlib_close_display (Display *dpy, XExtCodes *codes)
 		cairo_xlib_hook_t *hook = info->close_display_hooks;
 		info->close_display_hooks = hook->next;
 
+		/* drop the list mutex for the callback */
+		CAIRO_MUTEX_UNLOCK (_cairo_xlib_screen_mutex);
 		hook->func (info->display, hook->data);
-
 		free (hook);
+		CAIRO_MUTEX_LOCK (_cairo_xlib_screen_mutex);
 	    }
 
 	    _cairo_xlib_screen_info_destroy_unlocked (info);
diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index a85e700..401bafd 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -2280,16 +2280,19 @@ _cairo_xlib_surface_remove_scaled_font (Display *dpy,
 	                               void    *data)
 {
     cairo_scaled_font_t *scaled_font = data;
-    cairo_xlib_surface_font_private_t	*font_private = scaled_font->surface_private;
+    cairo_xlib_surface_font_private_t	*font_private;
 
+    CAIRO_MUTEX_LOCK (scaled_font->mutex);
+    font_private = scaled_font->surface_private;
+    scaled_font->surface_private = NULL;
     _cairo_scaled_font_reset_cache (scaled_font);
+    CAIRO_MUTEX_UNLOCK (scaled_font->mutex);
 
     /* separate function to avoid deadlock if we tried to remove the
      * close display hook ala _cairo_xlib_surface_scaled_font_fini() */
     if (font_private) {
 	XRenderFreeGlyphSet (font_private->dpy, font_private->glyphset);
 	free (font_private);
-	scaled_font->surface_private = NULL;
     }
 }
 
From chris at chris-wilson.co.uk  Fri Mar 23 17:42:56 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 23 17:43:06 2007
Subject: [cairo] Multithreaded cairo-perf
In-Reply-To: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
Message-ID: <20070324004256.GL10524@inspired.chris-wilson.co.uk>

This branch and it compatriots are now online and browsable at
http://gitweb.freedesktop.org/?p=users/ickle/cairo;a=shortlog;h=threaded-testcases
A big thank you to Carl Worth for setting this up.

Similary, I'm pushing the valgrind skins that I've been developing
whilst testing Cairo to
http://gitweb.freedesktop.org/?p=users/ickle/valgrind;a=summary

And now it's time for a break before reviewing the
attribute(warn_unused_result) branch again.
--
Chris Wilson
From behdad at behdad.org  Fri Mar 23 18:23:00 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Fri Mar 23 18:23:00 2007
Subject: [cairo] Multithreaded cairo-test
In-Reply-To: <20070323225818.GK10524@inspired.chris-wilson.co.uk>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
	<20070323114504.GH10524@inspired.chris-wilson.co.uk>
	<20070323122904.GI10524@inspired.chris-wilson.co.uk>
	<20070323225818.GK10524@inspired.chris-wilson.co.uk>
Message-ID: <1174699381.28605.14.camel@behdad>

On Fri, 2007-03-23 at 18:58 -0400, Chris Wilson wrote:
> I wrote: 
> > The first causality exposed by multi-threaded cairo-test is the
> > _cairo_xlib_screen_list which lacked reference counting of the
> > _cairo_xlib_screen_info_t.
> 
> Not only that but later, a recursive deadlock was exposed:
> 
> ==25095== Deadlock[recursive] for mutex 0x409130C at:
> ==25095==    at 0x401F478: pthread_mutex_lock (ld_preload.c:51)
> ==25095==    by 0x4063ABE: _cairo_xlib_screen_info_destroy (cairo-xlib-screen.c:284)
> ==25095==    by 0x4062E7B: _cairo_xlib_surface_finish (cairo-xlib-surface.c:345)
> ==25095==    by 0x403E402: cairo_surface_finish (cairo-surface.c:471)
> ==25095==    by 0x403E4AF: cairo_surface_destroy (cairo-surface.c:396)
> ==25095==    by 0x4041C49: _cairo_pattern_release_surface (cairo-pattern.c:1630)
> ==25095==    by 0x4062144: _cairo_xlib_surface_composite (cairo-xlib-surface.c:1419)
> ==25095==    by 0x403D5FD: _cairo_surface_composite (cairo-surface.c:1092)
> ==25095==    by 0x403A8D4: _cairo_scaled_font_show_glyphs (cairo-scaled-font.c:1136)
> ==25095==    by 0x403F828: _cairo_surface_old_show_glyphs_draw_func (cairo-surface-fallback.c:901)
> ==25095==    by 0x403F2B2: _clip_and_composite (cairo-surface-fallback.c:391)
> ==25095==    by 0x403F6C5: _cairo_surface_fallback_show_glyphs (cairo-surface-fallback.c:952)
> ==25095==    by 0x403DE6D: _cairo_surface_show_glyphs (cairo-surface.c:1806)
> ==25095==    by 0x402FDAE: _cairo_gstate_show_glyphs (cairo-gstate.c:1595)
> ==25095==    by 0x4029AF0: cairo_show_text (cairo.c:2825)
> ==25095==    by 0x804A203: draw (glyph-cache-pressure.c:80)
> ==25095==    by 0x804B714: cairo_test_targets (cairo-test.c:293)
> ==25095==    by 0x426631A: start_thread (in /lib/tls/i686/cmov/libpthread-2.5.so)
> ==25095==    by 0x436F3ED: clone (in /lib/tls/i686/cmov/libc-2.5.so)
> ==25095== Mutex 0x409130C was taken by thread 9 at:
> ==25095==    at 0x401F4F2: pthread_mutex_lock (ld_preload.c:54)
> ==25095==    by 0x40639F1: _cairo_xlib_close_display (cairo-xlib-screen.c:300)
> ==25095==    by 0x418E995: XCloseDisplay (ClDisplay.c:71)
> ==25095==    by 0x804BE2B: cleanup_xlib (cairo-boilerplate.c:1038)
> ==25095==    by 0x804B23F: cairo_test_targets (cairo-test.c:355)
> ==25095==    by 0x426631A: start_thread (in /lib/tls/i686/cmov/libpthread-2.5.so)
> ==25095==    by 0x436F3ED: clone (in /lib/tls/i686/cmov/libc-2.5.so)
> ==25095== which waits on mutex 0x80F9CEC, taken by us, thread 10, at:
> ==25095==    at 0x401F4F2: pthread_mutex_lock (ld_preload.c:54)
> ==25095==    by 0x403DDD0: _cairo_surface_show_glyphs (cairo-surface.c:1796)
> ==25095==    by 0x402FDAE: _cairo_gstate_show_glyphs (cairo-gstate.c:1595)
> ==25095==    by 0x4029AF0: cairo_show_text (cairo.c:2825)
> ==25095==    by 0x804A203: draw (glyph-cache-pressure.c:80)
> ==25095==    by 0x804B714: cairo_test_targets (cairo-test.c:293)
> ==25095==    by 0x426631A: start_thread (in /lib/tls/i686/cmov/libpthread-2.5.so)
> ==25095==    by 0x436F3ED: clone (in /lib/tls/i686/cmov/libc-2.5.so)

Woot.  Is this yet another valgrind skin you've wrote?


> --
> Chris Wilson

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From cworth at cworth.org  Fri Mar 23 18:39:54 2007
From: cworth at cworth.org (Carl Worth)
Date: Fri Mar 23 18:40:39 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <20070323222306.GA18533@jeremiahfoster.com>
References: <20070322215813.GA12132@jeremiahfoster.com>
	<87aby3d37a.wl%cworth@cworth.org>
	<20070323222306.GA18533@jeremiahfoster.com>
Message-ID: <87hcsb5sid.wl%cworth@cworth.org>

On Fri, 23 Mar 2007 23:23:06 +0100, Jeremiah Foster wrote:
> > >         If pkg.m4 is available in /another/directory, please set
> > >         ACLOCAL_FLAGS="-I /another/directory"
>
> I am sorry, I was unclear. The error message I pasted was a two part message with the
> first part mentioning cairo.pc. I did read both messages carefully and tried to set the
> required variables. The question is where? I passed the variables on the command line,
> and added them to the autogen.sh script, but nothing seemed to work.

Ah, OK.

This is an environment variable. Most shells allow you to set an
environment variable for a single process directly on the command-line
when executing the command. Something like this:

	ACLOCAL_FLAGS=/path/to/directory/containing/pkg.m4 ./autogen.sh

But the exact means of setting an environment variable might vary
depending on your shell.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070323/fcbed115/attachment.pgp
From chris at chris-wilson.co.uk  Fri Mar 23 19:05:49 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Fri Mar 23 19:48:45 2007
Subject: [cairo] Multithreaded cairo-test
In-Reply-To: <1174699381.28605.14.camel@behdad>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
	<20070323114504.GH10524@inspired.chris-wilson.co.uk>
	<20070323122904.GI10524@inspired.chris-wilson.co.uk>
	<20070323225818.GK10524@inspired.chris-wilson.co.uk>
	<1174699381.28605.14.camel@behdad>
Message-ID: <20070324020548.GM10524@inspired.chris-wilson.co.uk>

Behdad Esfahbod (behdad@behdad.org) said: 
> Woot.  Is this yet another valgrind skin you've wrote?
It's a little incomplete - as in I developed it far enough to debug that
deadlock and then went back to beating upon Cairo ;-)

Have a browse:
http://gitweb.freedesktop.org/?p=users/ickle/valgrind;a=shortlog;h=lockdep

It's the simplest skin to run as it doesn't take any cmdline options at
all:
$ valgrind --tool=lockdep ./cairo-perf -t 10

The future plans are for it to check the pre/post conditions for
pthread_mutex_lock() ala Ingo Molnar's kernel lockdep - but with the
restriction that no source annotations are possible. And to complete
the checking for all the simple error cases. Though I imagine
development will continue to be driven by the need to track down bugs :-|

Eeek - distraction...  glyph-cache-pressure:
==15465== Thread 3:
==15465== Invalid read of size 4
==15465==    at 0x41DE49D: process_responses (xcb_io.c:133)
==15465==    by 0x41DE9BB: _XReply (xcb_io.c:371)
==15465==    by 0x41BC7DB: XGetImage (GetImage.c:75)
==15465==    by 0x4066A6E: _get_image_surface (cairo-xlib-surface.c:564)
==15465==    by 0x4066DD9: _cairo_xlib_surface_acquire_source_image (cairo-xlib-surface.c:804)
==15465==    by 0x4040AE1: _cairo_surface_acquire_source_image (cairo-surface.c:870)
==15465==    by 0x40588EB: write_png (cairo-png.c:102)
==15465==    by 0x4058C64: cairo_surface_write_to_png (cairo-png.c:244)
==15465==    by 0x804B79A: cairo_test_targets (cairo-test.c:314)
==15465==    by 0x428AE59: start_thread (pthread_create.c:296)
==15465==    by 0x438189D: clone (in /usr/lib/debug/libc-2.5.so)
==15465==  Address 0x445D4E0 is 56 bytes inside a block of size 60 free'd
==15465==    at 0x402123A: free (vg_replace_malloc.c:233)
==15465==    by 0x41DE667: process_responses (xcb_io.c:156)
==15465==    by 0x41DE9BB: _XReply (xcb_io.c:371)
==15465==    by 0x41BC7DB: XGetImage (GetImage.c:75)
==15465==    by 0x4066A6E: _get_image_surface (cairo-xlib-surface.c:564)
==15465==    by 0x4066DD9: _cairo_xlib_surface_acquire_source_image (cairo-xlib-surface.c:804)
==15465==    by 0x4040AE1: _cairo_surface_acquire_source_image (cairo-surface.c:870)
==15465==    by 0x40588EB: write_png (cairo-png.c:102)
==15465==    by 0x4058C64: cairo_surface_write_to_png (cairo-png.c:244)
==15465==    by 0x804B79A: cairo_test_targets (cairo-test.c:314)
==15465==    by 0x428AE59: start_thread (pthread_create.c:296)
==15465==    by 0x438189D: clone (in /usr/lib/debug/libc-2.5.so)
==15465== 
==15465== Thread 4:
==15465== Invalid read of size 4
==15465==    at 0x41DE9AA: _XReply (xcb_io.c:371)
==15465==    by 0x41D2B69: XSync (Sync.c:48)
==15465==    by 0x41D2CE4: _XSyncFunction (Synchro.c:37)
==15465==    by 0x4195879: XRenderFreeGlyphs (Glyph.c:136)
==15465==    by 0x40655FD: _cairo_xlib_surface_scaled_glyph_fini (cairo-xlib-surface.c:2345)
==15465==    by 0x403CD96: _cairo_scaled_glyph_destroy (cairo-scaled-font.c:59)
==15465==    by 0x403133F: _cairo_cache_remove (cairo-cache.c:350)
==15465==    by 0x4031378: _cairo_cache_shrink_to_accommodate (cairo-cache.c:264)
==15465==    by 0x403EA27: _cairo_scaled_font_text_to_glyphs (cairo-scaled-font.c:946)
==15465==    by 0x40340A2: _cairo_gstate_text_to_glyphs (cairo-gstate.c:1514)
==15465==    by 0x402DAA5: cairo_show_text (cairo.c:2816)
==15465==    by 0x804A213: draw (glyph-cache-pressure.c:80)
==15465==  Address 0x445D4E0 is 56 bytes inside a block of size 60 free'd
==15465==    at 0x402123A: free (vg_replace_malloc.c:233)
==15465==    by 0x41DE667: process_responses (xcb_io.c:156)
==15465==    by 0x41DE9BB: _XReply (xcb_io.c:371)
==15465==    by 0x41BC7DB: XGetImage (GetImage.c:75)
==15465==    by 0x4066A6E: _get_image_surface (cairo-xlib-surface.c:564)
==15465==    by 0x4066DD9: _cairo_xlib_surface_acquire_source_image (cairo-xlib-surface.c:804)
==15465==    by 0x4040AE1: _cairo_surface_acquire_source_image (cairo-surface.c:870)
==15465==    by 0x40588EB: write_png (cairo-png.c:102)
==15465==    by 0x4058C64: cairo_surface_write_to_png (cairo-png.c:244)
==15465==    by 0x804B79A: cairo_test_targets (cairo-test.c:314)
==15465==    by 0x428AE59: start_thread (pthread_create.c:296)
==15465==    by 0x438189D: clone (in /usr/lib/debug/libc-2.5.so)
==15465== 

Now, that does look nasty.
--
Chris Wilson
From keithp at keithp.com  Fri Mar 23 22:10:56 2007
From: keithp at keithp.com (Keith Packard)
Date: Fri Mar 23 22:11:13 2007
Subject: [cairo] Early Initialization?
In-Reply-To: <1174486059.19078.151.camel@localhost.localdomain>
References: <1173884708.5780.19.camel@murrayc-desktop>
	<87k5xjycox.wl%cworth@cworth.org> <1173895376.14946.2.camel@behdad>
	<1173895459.14946.4.camel@behdad>  <460132FD.6060407@openismus.com>
	<1174486059.19078.151.camel@localhost.localdomain>
Message-ID: <1174713056.26106.22.camel@neko.keithp.com>

On Wed, 2007-03-21 at 10:07 -0400, Owen Taylor wrote:
> 
> It could just be that the fontconfig memmap'ed cache stuff has dropped
> startup overhead low enough that the advantage of pre-initializing
> things is small. 

It helped more than I had hoped:

$ /usr/bin/time -a fc-match foo > /dev/null
0.02user 0.00system 0:00.08elapsed 39%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (0major+636minor)pagefaults 0swaps

The key numbers here are 0.02 seconds of CPU time and 636 *minor* page
faults. I believe the latter indicates that all of the pages needed for
the caches were already in memory.

It is nice to no longer be responsible for huge wastage of memory and
CPU time.

-- 
keith.packard@intel.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070323/93784c6f/attachment.pgp
From jeremiah at jeremiahfoster.com  Sat Mar 24 08:43:05 2007
From: jeremiah at jeremiahfoster.com (Jeremiah Foster)
Date: Sat Mar 24 08:42:59 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <87hcsb5sid.wl%cworth@cworth.org>
References: <20070322215813.GA12132@jeremiahfoster.com>
	<87aby3d37a.wl%cworth@cworth.org>
	<20070323222306.GA18533@jeremiahfoster.com>
	<87hcsb5sid.wl%cworth@cworth.org>
Message-ID: <20070324154305.GA22024@jeremiahfoster.com>

Fri, Mar 23, 2007 at 06:39:54PM -0700:  Carl Worth mangled some bits into this alignment:
> On Fri, 23 Mar 2007 23:23:06 +0100, Jeremiah Foster wrote:
> > > >         If pkg.m4 is available in /another/directory, please set
> > > >         ACLOCAL_FLAGS="-I /another/directory"
> >
> > I am sorry, I was unclear. The error message I pasted was a two part message with the
> > first part mentioning cairo.pc. I did read both messages carefully and tried to set the
> > required variables. The question is where? I passed the variables on the command line,
> > and added them to the autogen.sh script, but nothing seemed to work.
> 
> Ah, OK.
> 
> This is an environment variable. Most shells allow you to set an
> environment variable for a single process directly on the command-line
> when executing the command. Something like this:
> 
> 	ACLOCAL_FLAGS=/path/to/directory/containing/pkg.m4 ./autogen.sh
> 
> But the exact means of setting an environment variable might vary
> depending on your shell.

Yeah, I am using bash. I set that variable there in the first place since when
I hear the words "environment variable" in regards to a shell script I assume they
mean in the shell. I set it with the traditional PATH implementation; 

ACLOCAL_FLAGS=$PATH:/dir/:/another/dir/ in my .bashrc file.

And I set it like this on the command line: ACLOCAL_FLAGS=/dir/ and neither
worked. This is why I am unclear where I should set it. I am not in front of
the Apple machine right now so I can't read the script to see if it drops one
into another shell or if the script uses ksh, csh, tcsh (which is the default
under OS X) or what. I will look a little more closely and report back.

	Jeremiah

From behdad at behdad.org  Sat Mar 24 03:13:41 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Sat Mar 24 11:24:53 2007
Subject: [cairo] Multithreaded cairo-perf
In-Reply-To: <20070324004256.GL10524@inspired.chris-wilson.co.uk>
References: <20070323011702.GG10524@inspired.chris-wilson.co.uk>
	<20070324004256.GL10524@inspired.chris-wilson.co.uk>
Message-ID: <1174731221.28605.17.camel@behdad>

On Fri, 2007-03-23 at 20:42 -0400, Chris Wilson wrote:
> This branch and it compatriots are now online and browsable at
> http://gitweb.freedesktop.org/?p=users/ickle/cairo;a=shortlog;h=threaded-testcases
> A big thank you to Carl Worth for setting this up.

This is all great stuff Chris.  I'm fine with pushing all the test/perf
suite improvements.  For the actual bug fixes, I think Carl will comment
on them.

> Similary, I'm pushing the valgrind skins that I've been developing
> whilst testing Cairo to
> http://gitweb.freedesktop.org/?p=users/ickle/valgrind;a=summary

Thanks!  /me goes blogging these...

> And now it's time for a break before reviewing the
> attribute(warn_unused_result) branch again.

Yeah, the patches for that branch need to be broken into more
comprehensible patches.

> Chris Wilson

Thanks again Chris,
-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From cairo-2007a at ryandesign.com  Sat Mar 24 14:55:25 2007
From: cairo-2007a at ryandesign.com (Ryan Schmidt)
Date: Sat Mar 24 15:02:11 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <20070324154305.GA22024@jeremiahfoster.com>
References: <20070322215813.GA12132@jeremiahfoster.com>
	<87aby3d37a.wl%cworth@cworth.org>
	<20070323222306.GA18533@jeremiahfoster.com>
	<87hcsb5sid.wl%cworth@cworth.org>
	<20070324154305.GA22024@jeremiahfoster.com>
Message-ID: <198519DF-4BD5-42E0-99E0-8E224E994DFC@ryandesign.com>

> Yeah, I am using bash. I set that variable there in the first place  
> since when
> I hear the words "environment variable" in regards to a shell  
> script I assume they
> mean in the shell. I set it with the traditional PATH implementation;
>
> ACLOCAL_FLAGS=$PATH:/dir/:/another/dir/ in my .bashrc file.
>
> And I set it like this on the command line: ACLOCAL_FLAGS=/dir/ and  
> neither
> worked. This is why I am unclear where I should set it. I am not in  
> front of
> the Apple machine right now so I can't read the script to see if it  
> drops one
> into another shell or if the script uses ksh, csh, tcsh (which is  
> the default
> under OS X) or what. I will look a little more closely and report  
> back.

The default shell on Mac OS X has been bash since 10.3.0:

http://docs.info.apple.com/article.html?artnum=86135&coll=cp

However, your user account will still use tcsh if it was originally  
created in Mac OS X 10.0 thru 10.2 and you then updated to a new OS.


I'm not having any trouble compiling cairo on Mac OS X 10.4.9, and I  
haven't needed to set ACLOCAL_FLAGS. My pkg-config is, however, in  
the same prefix where I'm building cairo. The variables I'm setting are:

MACOSX_DEPLOYMENT_TARGET=10.4 (you'll want 10.3 here) PATH="/my/ 
prefix/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/X11R6/bin"
CFLAGS="-I/my/prefix/include -I/usr/X11R6/include"
LDFLAGS="-L/my/prefix/lib -L/usr/X11R6/lib"
PGK_CONFIG_PATH="/my/prefix/lib/pkgconfig:/usr/X11R6/lib/pkgconfig"

And then I configure with --prefix=/my/prefix


I am using bash, so all I do to set the environment variables is, e.g.,

VAR1=foo VAR2=bar ./configure --prefix=baz

I don't know how it works on tcsh anymore. You may need "setenv VAR1  
foo" "setenv VAR2 bar" etc. on separate lines before you run configure.


I haven't tried compiling on 10.3.x myself, but I hope this helps get  
you on your way.


From chris at chris-wilson.co.uk  Mon Mar 26 02:43:29 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Mon Mar 26 02:43:40 2007
Subject: [cairo] Returning cached erroneous patterns
In-Reply-To: <1174666327.18229.23.camel@behdad>
References: <20070322172140.GF10524@inspired.chris-wilson.co.uk>
	<2faad3050703221112g4559d01bj1ea0c3f4cbed349a@mail.gmail.com>
	<1174666327.18229.23.camel@behdad>
Message-ID: <20070326094329.GA24027@inspired.chris-wilson.co.uk>

Behdad Esfahbod (behdad@behdad.org) said: 
> Ok, thanks for raising the issue.  The problem is that solid patterns
> are not immutable as we expected.  Giving away the same mutable object
> multiple times is definitely wrong.
> 
> I wanted to say we should back out the cache, but then I found that the
> fix is really easy: instead of reusing patterns from the cache, keep a
> pool of freed solid patterns.  That is: when using a pattern from the
> cache, remove it from the cache, and when freeing a solid pattern of
> refcount 1, set its error status to SUCCESS and add it to the cache.

So we back out the solid-pattern-cache and replace it with a recently
freed cache. We then add one further refinement Behdad suggested which
is to destroy the current pattern before creating a new solid-pattern in
the likelihood that we will immediately reuse the freed pattern.
--
Chris Wilson
-------------- next part --------------
>From d2c91b1a7289778cea9531cb9ad6ace38961a400 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 26 Mar 2007 10:12:46 +0100
Subject: [PATCH] Back out the solid-pattern-cache.

Unfortunately one cannot cache live patterns and return a fresh reference
instead of creating new ones as patterns can be modified by the user and
so cannot be transparently shared between different users. However,
solid colour allocation is still a frequent operation, so we maintain a
small cache of recently freed patterns to reduce the malloc pressure.
---
 src/cairo-pattern.c |  100 ++++++++++++++++++++++++--------------------------
 1 files changed, 48 insertions(+), 52 deletions(-)

diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index 920542c..ed535e1 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -259,73 +259,49 @@ _cairo_pattern_init_radial (cairo_radial_pattern_t *pattern,
     pattern->gradient.c2.radius = _cairo_fixed_from_double (fabs (radius1));
 }
 
-/* We use a small cache here, because we don't want to constantly
- * reallocate simple colors. */
-#define MAX_PATTERN_CACHE_SIZE 16
+/* We use a small freed pattern cache here, because we don't want to
+ * constantly reallocate simple colors. */
+#define MAX_PATTERN_CACHE_SIZE 4
 static struct {
-    struct {
-	cairo_color_t          color;
-	cairo_solid_pattern_t *pattern;
-    } cache[MAX_PATTERN_CACHE_SIZE];
+    cairo_solid_pattern_t *patterns[MAX_PATTERN_CACHE_SIZE];
     int size;
 } solid_pattern_cache;
 
 static cairo_pattern_t *
-_cairo_pattern_create_solid_not_cached (const cairo_color_t *color)
+_cairo_pattern_create_solid_from_cache (const cairo_color_t *color)
 {
-    void *pattern;
+    cairo_solid_pattern_t *pattern = NULL;
 
-    /* Not cached, need to create a new pattern. */
-    pattern = malloc (sizeof (cairo_solid_pattern_t));
+    CAIRO_MUTEX_LOCK (_cairo_pattern_solid_cache_lock);
+
+    if (solid_pattern_cache.size) {
+	int i = --solid_pattern_cache.size %
+	    ARRAY_LEN (solid_pattern_cache.patterns);
+	pattern = solid_pattern_cache.patterns[i];
+	solid_pattern_cache.patterns[i] = NULL;
+    }
+
+    CAIRO_MUTEX_UNLOCK (_cairo_pattern_solid_cache_lock);
+
+    if (pattern == NULL) {
+	/* None cached, need to create a new pattern. */
+	pattern = malloc (sizeof (cairo_solid_pattern_t));
+    }
     if (pattern != NULL)
 	_cairo_pattern_init_solid (pattern, color);
 
-    return pattern;
+    return &pattern->base;
 }
 
 cairo_pattern_t *
 _cairo_pattern_create_solid (const cairo_color_t *color)
 {
-    static int cache_index;
-    void *pattern;
-
-    CAIRO_MUTEX_LOCK (_cairo_pattern_solid_cache_lock);
-
-    /* Check cache first. */
-    if (cache_index < solid_pattern_cache.size &&
-	    _cairo_color_equal (
-		&solid_pattern_cache.cache[cache_index].color, color))
-	goto DONE;
-
-    for (cache_index = 0; cache_index < solid_pattern_cache.size; cache_index++)
-	if (_cairo_color_equal (
-		    &solid_pattern_cache.cache[cache_index].color, color))
-	    goto DONE;
+    cairo_pattern_t *pattern;
 
-    /* Not cached, need to create a new pattern. */
-    pattern = _cairo_pattern_create_solid_not_cached (color);
+    pattern = _cairo_pattern_create_solid_from_cache (color);
     if (pattern == NULL)
 	return (cairo_pattern_t *) &cairo_pattern_nil.base;
 
-    /* And insert it into the cache. */
-    if (solid_pattern_cache.size < MAX_PATTERN_CACHE_SIZE) {
-	solid_pattern_cache.size ++;
-	/* cache_index == solid_pattern_cache.size */
-    } else {
-	/* Evict an old pattern. */
-	cache_index = rand () % MAX_PATTERN_CACHE_SIZE;
-	cairo_pattern_destroy (
-		&solid_pattern_cache.cache[cache_index].pattern->base);
-    }
-
-    solid_pattern_cache.cache[cache_index].color = *color;
-    solid_pattern_cache.cache[cache_index].pattern = pattern;
-
-DONE:
-    pattern = cairo_pattern_reference (
-	    &solid_pattern_cache.cache[cache_index].pattern->base);
-    CAIRO_MUTEX_UNLOCK (_cairo_pattern_solid_cache_lock);
-
     return pattern;
 }
 
@@ -336,8 +312,10 @@ _cairo_pattern_reset_static_data (void)
 
     CAIRO_MUTEX_LOCK (_cairo_pattern_solid_cache_lock);
 
-    for (i = 0; i < solid_pattern_cache.size; i++)
-	cairo_pattern_destroy (&solid_pattern_cache.cache[i].pattern->base);
+    for (i = 0; i < MIN (ARRAY_LEN (solid_pattern_cache.patterns), solid_pattern_cache.size); i++) {
+	free (solid_pattern_cache.patterns[i]);
+	solid_pattern_cache.patterns[i] = NULL;
+    }
     solid_pattern_cache.size = 0;
 
     CAIRO_MUTEX_UNLOCK (_cairo_pattern_solid_cache_lock);
@@ -348,7 +326,7 @@ _cairo_pattern_create_in_error (cairo_status_t status)
 {
     cairo_pattern_t *pattern;
 
-    pattern = _cairo_pattern_create_solid_not_cached (_cairo_stock_color (CAIRO_STOCK_BLACK));
+    pattern = _cairo_pattern_create_solid_from_cache (_cairo_stock_color (CAIRO_STOCK_BLACK));
     if (cairo_pattern_status (pattern))
 	return pattern;
 
@@ -648,7 +626,25 @@ cairo_pattern_destroy (cairo_pattern_t *pattern)
 	return;
 
     _cairo_pattern_fini (pattern);
-    free (pattern);
+
+    /* maintain a small cache of freed patterns */
+    if (pattern->type == CAIRO_PATTERN_TYPE_SOLID) {
+	int i;
+
+	CAIRO_MUTEX_LOCK (_cairo_pattern_solid_cache_lock);
+
+	i = solid_pattern_cache.size++ %
+	    ARRAY_LEN (solid_pattern_cache.patterns);
+	/* swap an old pattern for this 'cache-hot' pattern */
+	if (solid_pattern_cache.patterns[i])
+	    free (solid_pattern_cache.patterns[i]);
+
+	solid_pattern_cache.patterns[i] = (cairo_solid_pattern_t *) pattern;
+
+	CAIRO_MUTEX_UNLOCK (_cairo_pattern_solid_cache_lock);
+    } else {
+	free (pattern);
+    }
 }
 slim_hidden_def (cairo_pattern_destroy);
 
-- 
1.4.4.2

-------------- next part --------------
>From 8b884ec31a92d912871eebe4a6563174a5d68c7c Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 26 Mar 2007 10:33:32 +0100
Subject: [PATCH] Destroy the current pattern before replacing with cairo_set_source().

Frequently cairo_set_source_rgb[a]() is used to replace the current
solid-pattern source with a new one of a different colour. The current
pattern is very likely to be unshared and unmodified and so it is likely
just to be immediately freed [or rather simply moved to recently freed
cache]. However as the last active pattern it is likely to cache-warm and
suitable to satisfy the forthcoming allocation. So by setting the current
pattern to 'none' we can move the pattern to the freed list before we
create the new pattern and hopefully immediately reuse it.
---
 src/cairo-pattern.c |   10 ++++++++++
 src/cairo.c         |    9 +++++++++
 src/cairoint.h      |    1 +
 3 files changed, 20 insertions(+), 0 deletions(-)

diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index ed535e1..2bc5580 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -50,6 +50,16 @@ static const cairo_solid_pattern_t cairo_pattern_nil_null_pointer = {
       CAIRO_EXTEND_GRADIENT_DEFAULT },	/* extend */
 };
 
+const cairo_solid_pattern_t cairo_pattern_none = {
+    { CAIRO_PATTERN_TYPE_SOLID, 	/* type */
+      CAIRO_REF_COUNT_INVALID,		/* ref_count */
+      CAIRO_STATUS_SUCCESS,		/* status */
+      { 0, 0, 0, NULL },		/* user_data */
+      { 1., 0., 0., 1., 0., 0., }, /* matrix */
+      CAIRO_FILTER_DEFAULT,	/* filter */
+      CAIRO_EXTEND_GRADIENT_DEFAULT },	/* extend */
+};
+
 /**
  * _cairo_pattern_set_error:
  * @pattern: a pattern
diff --git a/src/cairo.c b/src/cairo.c
index 22e15fd..9a96dda 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -671,6 +671,9 @@ cairo_set_source_rgb (cairo_t *cr, double red, double green, double blue)
     if (cr->status)
 	return;
 
+    /* push the current pattern to the freed lists */
+    cairo_set_source (cr, (cairo_pattern_t *) &cairo_pattern_none);
+
     pattern = cairo_pattern_create_rgb (red, green, blue);
     cairo_set_source (cr, pattern);
     cairo_pattern_destroy (pattern);
@@ -702,6 +705,9 @@ cairo_set_source_rgba (cairo_t *cr,
     if (cr->status)
 	return;
 
+    /* push the current pattern to the freed lists */
+    cairo_set_source (cr, (cairo_pattern_t *) &cairo_pattern_none);
+
     pattern = cairo_pattern_create_rgba (red, green, blue, alpha);
     cairo_set_source (cr, pattern);
     cairo_pattern_destroy (pattern);
@@ -742,6 +748,9 @@ cairo_set_source_surface (cairo_t	  *cr,
     if (cr->status)
 	return;
 
+    /* push the current pattern to the freed lists */
+    cairo_set_source (cr, (cairo_pattern_t *) &cairo_pattern_none);
+
     pattern = cairo_pattern_create_for_surface (surface);
 
     cairo_matrix_init_translate (&matrix, -x, -y);
diff --git a/src/cairoint.h b/src/cairoint.h
index 600eef5..0c0c37c 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -1099,6 +1099,7 @@ typedef struct _cairo_solid_pattern {
 } cairo_solid_pattern_t;
 
 extern const cairo_private cairo_solid_pattern_t cairo_pattern_nil;
+extern const cairo_private cairo_solid_pattern_t cairo_pattern_none;
 
 typedef struct _cairo_surface_pattern {
     cairo_pattern_t base;
-- 
1.4.4.2

From cworth at cworth.org  Mon Mar 26 03:56:04 2007
From: cworth at cworth.org (Carl Worth)
Date: Mon Mar 26 03:57:29 2007
Subject: [cairo] Cairo on Mac OS X 10.3.9
In-Reply-To: <20070324154305.GA22024@jeremiahfoster.com>
References: <20070322215813.GA12132@jeremiahfoster.com>
	<87aby3d37a.wl%cworth@cworth.org>
	<20070323222306.GA18533@jeremiahfoster.com>
	<87hcsb5sid.wl%cworth@cworth.org>
	<20070324154305.GA22024@jeremiahfoster.com>
Message-ID: <87d52wz323.wl%cworth@cworth.org>

On Sat, 24 Mar 2007 16:43:05 +0100, Jeremiah Foster wrote:
> Fri, Mar 23, 2007 at 06:39:54PM -0700:  Carl Worth mangled some bits into this alignment:
> > On Fri, 23 Mar 2007 23:23:06 +0100, Jeremiah Foster wrote:
> > > > >         If pkg.m4 is available in /another/directory, please set
> > > > >         ACLOCAL_FLAGS="-I /another/directory"
...
> > 	ACLOCAL_FLAGS=/path/to/directory/containing/pkg.m4 ./autogen.sh
...
> I set it with the traditional PATH implementation;
>
> ACLOCAL_FLAGS=$PATH:/dir/:/another/dir/ in my .bashrc file.

Oops. Looks like we both made the same mistake above.

ACLOCAL_FLAGS, (annoyingly enough), does not use anything like the
traditional path implementation. Look closer at the very first
occurrence above and notice the extra "-I " at the beginning.

-Carl

PS. And would someone out there please be kind enough to go hack
several projects so that we can eliminate a bunch of these variables?
Here's what I'd love to see, (but I'm too lazy to do the work):

	PREFIXES=/usr:/usr/local:/opt/whatever:etc.

and all software possible looking at this variable first and deriving
its own variations of the prefixes. That is:

* shells would consult PREFIXES and then look for binaries in
  $prefix/bin for each directory (/usr/bin, /usr/local/bin,
  /opt/whatever/bin, etc.)

* The linker would look in $prefix/lib

* pkg-config would look in $prefix/lib/pkgconfig

* autoconf would look in $prefix/lib/share/aclocal

* python would look in $prefix/lib/python$version/site-packages

* mozilla would look in $prefix/lib/$mozilla-project-name/plugins

etc. etc.

All of the existing variables, (PATH, LD_LIBRARY_PATH (or
DYLD_LIBRARY_PATH), PKG_CONFIG_PATH, ACLOCAL_FLAGS, PYTHONPATH,
MOZ_PLUGIN_PATH, etc.), would continue to exist and work in the
absence of PREFIXES pointing to a satisfying directory.

That would be a very convenient thing.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070326/1d80a73c/attachment.pgp
From brian.ewins at gmail.com  Mon Mar 26 15:22:48 2007
From: brian.ewins at gmail.com (Baz)
Date: Mon Mar 26 15:23:04 2007
Subject: [cairo] Re: 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>
References: <20070316222928.1FDEE9E817@gabe.freedesktop.org>
	<ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>
Message-ID: <2faad3050703261522s47300908k8e8381db9761ad0@mail.gmail.com>

On 17/03/07, Hugo Vincent <hugo.vincent@gmail.com> wrote:
> Can the patch for bug 10036 (Cairo-Quartz Line-width-scaling problem)
> be accepted for into 1.4.2 (or even 1.4.4)? Please!?
> https://bugs.freedesktop.org/show_bug.cgi?id=10036
>
> Also, I have been playing round with Rsvg on Mac OS X, rendering into
> a Cairo-Quartz context. It mostly works (except for the above
> mentioned bug), however in certain cases it crashes rather
> ungracefully when trying to do fallback operations for things that
> aren't supported natively by Cairo-Quartz (certain radial gradients
> seem to be the culprit). I'll prepare a proper test case and submit a
> bug soon after I've tried it with 1.4.2.
>
> Cheers,
> Hugo Vincent

Hugo, did you ever track down that crasher?

Cheers,
Baz
From hugo.vincent at gmail.com  Mon Mar 26 17:09:54 2007
From: hugo.vincent at gmail.com (Hugo Vincent)
Date: Mon Mar 26 17:16:49 2007
Subject: [cairo] Re: 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <2faad3050703261522s47300908k8e8381db9761ad0@mail.gmail.com>
References: <20070316222928.1FDEE9E817@gabe.freedesktop.org>
	<ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>
	<2faad3050703261522s47300908k8e8381db9761ad0@mail.gmail.com>
Message-ID: <11B4E846-7B75-467C-9D33-4F5B35D8A463@gmail.com>

Hi Baz,

The code below seems to replicate the crash; that is to say, even the  
simplest use of a radial gradient on Quartz crashes.

verbatim error: cairo.c:91: failed assertion `status >  
CAIRO_STATUS_SUCCESS && status <= CAIRO_STATUS_LAST_STATUS'

System Info:
Mac OS X 10.4.9 (on Intel Core 2 Duo), Xcode 2.4.1, Cairo 1.4.2  
[release]

Note, this code isn't exactly what I've been testing with, but I am  
100% confident the other stuff I have in my code, but not in the  
included code here, is not what is causing this crash. Like I said  
before, Rsvg renders correctly, assuming the SVG file has no radial  
gradients. Also, because both Rsvg (which uses the Cairo C api) and  
this code, which is using Cairomm, both crash in the same way, we can  
assume the problem isn't with Cairomm. Finally, if you render this  
code into a PNG file it works fine.

Cheers,
Hugo

-----------------------------------------------------------
testview.h:
-----------------------------------------------------------

#import <Cocoa/Cocoa.h>

@interface TestView : NSView
{
	// nothing needed here
}
@end

-----------------------------------------------------------
testview.m
-----------------------------------------------------------

#include <cairomm/cairomm.h>
#include <cairomm/quartz_surface.h>

#ifndef CAIRO_HAS_QUARTZ_SURFACE
#error Need to build Cairo and Cairomm with Quartz support (version  
1.4.0 or higher)
#endif

@implementation TestView

- (id)initWithFrame:(NSRect)frameRect
{
	if ((self = [super initWithFrame:frameRect]) != nil)
	{
		// nothing needed here
	}
	return self;
}

- (void)drawRect:(NSRect)rect
{
	// Get the size of this NSView
	NSRect bounds = [self bounds];
	int width = bounds.size.width;
	int height = bounds.size.height;
	
	// Get CoreGraphcis context reference
	CGContextRef ctx = (CGContextRef)[[NSGraphicsContext currentContext]  
graphicsPort];
	
	// Make the CGContext coordinate system sane, as expected by Cairo
	CGContextTranslateCTM (ctx, 0.0, height);
	CGContextScaleCTM (ctx, 1.0, -1.0);

	// Create the Cairo surface and context
	Cairo::RefPtr<Cairo::QuartzSurface> surface =  
Cairo::QuartzSurface::create(ctx, width, height);
	Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);

	// Draw a radial gradient (copied and pasted, more or less, from  
http://cairographics.org/samples/gradient.html)
	cr->scale(width,height);
	Cairo::RefPtr<Cairo::RadialGradient> grad2 =  
Cairo::RadialGradient::create(0.45, 0.4, 0.1, 0.4, 0.4, 0.5);
	grad2->add_color_stop_rgba(0, 1,0,0, 1);
	grad2->add_color_stop_rgba(1, 0,1,0, 1);
	cr->set_source(grad2);
	cairo_arc (cr, 0.5, 0.5, 0.3, 0, 2 * M_PI);
	cr->fill(); //  CRASHES!
}

@end


On 27/03/2007, at 10:22 AM, Baz wrote:

> On 17/03/07, Hugo Vincent <hugo.vincent@gmail.com> wrote:
>> Can the patch for bug 10036 (Cairo-Quartz Line-width-scaling problem)
>> be accepted for into 1.4.2 (or even 1.4.4)? Please!?
>> https://bugs.freedesktop.org/show_bug.cgi?id=10036
>>
>> Also, I have been playing round with Rsvg on Mac OS X, rendering into
>> a Cairo-Quartz context. It mostly works (except for the above
>> mentioned bug), however in certain cases it crashes rather
>> ungracefully when trying to do fallback operations for things that
>> aren't supported natively by Cairo-Quartz (certain radial gradients
>> seem to be the culprit). I'll prepare a proper test case and submit a
>> bug soon after I've tried it with 1.4.2.
>>
>> Cheers,
>> Hugo Vincent
>
> Hugo, did you ever track down that crasher?
>
> Cheers,
> Baz

From vladimir at pobox.com  Tue Mar 27 10:12:39 2007
From: vladimir at pobox.com (Vladimir Vukicevic)
Date: Tue Mar 27 10:12:46 2007
Subject: [cairo] Re: 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <11B4E846-7B75-467C-9D33-4F5B35D8A463@gmail.com>
References: <20070316222928.1FDEE9E817@gabe.freedesktop.org>
	<ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>
	<2faad3050703261522s47300908k8e8381db9761ad0@mail.gmail.com>
	<11B4E846-7B75-467C-9D33-4F5B35D8A463@gmail.com>
Message-ID: <46095087.3080507@pobox.com>


Ah, that crash.  So what's happening here is that cairo doesn't 
gracefully deal with a backend's acquire_*_image returning 
CAIRO_INT_STATUS_UNSUPPORTED -- it ends up propagating that error all 
the way up to the user level, at which point the generic "make sure it's 
a public error" assert in cairo_error triggers.

The reason why you're seeing CAIRO_INT_STATUS_UNSUPPORTED is because 
Cairo (that is, the Quartz surface) didn't create the CG context itself; 
when it does, it creates it as an image context and can then do fallback 
rendering as necessary.  Assuming we don't manage to implement 
everything natively using Quartz (I think there are a few operators that 
simply have no equivalents in Quartz, as well as some operations), an 
easy way to get around this is to wrap your rendering in between 
cairo_push_group() and cairo_pop_group_to_source()/cairo_paint(); this 
will give you a temporary Quartz surface that was created by the Quartz 
backend, so fallback rendering would be possible.

     - Vlad

Hugo Vincent wrote:
> Hi Baz,
> 
> The code below seems to replicate the crash; that is to say, even the 
> simplest use of a radial gradient on Quartz crashes.
> 
> verbatim error: cairo.c:91: failed assertion `status > 
> CAIRO_STATUS_SUCCESS && status <= CAIRO_STATUS_LAST_STATUS'
> 
> System Info:
> Mac OS X 10.4.9 (on Intel Core 2 Duo), Xcode 2.4.1, Cairo 1.4.2 [release]
> 
> Note, this code isn't exactly what I've been testing with, but I am 100% 
> confident the other stuff I have in my code, but not in the included 
> code here, is not what is causing this crash. Like I said before, Rsvg 
> renders correctly, assuming the SVG file has no radial gradients. Also, 
> because both Rsvg (which uses the Cairo C api) and this code, which is 
> using Cairomm, both crash in the same way, we can assume the problem 
> isn't with Cairomm. Finally, if you render this code into a PNG file it 
> works fine.
> 
> Cheers,
> Hugo
> 
> -----------------------------------------------------------
> testview.h:
> -----------------------------------------------------------
> 
> #import <Cocoa/Cocoa.h>
> 
> @interface TestView : NSView
> {
>     // nothing needed here
> }
> @end
> 
> -----------------------------------------------------------
> testview.m
> -----------------------------------------------------------
> 
> #include <cairomm/cairomm.h>
> #include <cairomm/quartz_surface.h>
> 
> #ifndef CAIRO_HAS_QUARTZ_SURFACE
> #error Need to build Cairo and Cairomm with Quartz support (version 
> 1.4.0 or higher)
> #endif
> 
> @implementation TestView
> 
> - (id)initWithFrame:(NSRect)frameRect
> {
>     if ((self = [super initWithFrame:frameRect]) != nil)
>     {
>         // nothing needed here
>     }
>     return self;
> }
> 
> - (void)drawRect:(NSRect)rect
> {
>     // Get the size of this NSView
>     NSRect bounds = [self bounds];
>     int width = bounds.size.width;
>     int height = bounds.size.height;
>     
>     // Get CoreGraphcis context reference
>     CGContextRef ctx = (CGContextRef)[[NSGraphicsContext currentContext] 
> graphicsPort];
>     
>     // Make the CGContext coordinate system sane, as expected by Cairo
>     CGContextTranslateCTM (ctx, 0.0, height);
>     CGContextScaleCTM (ctx, 1.0, -1.0);
> 
>     // Create the Cairo surface and context
>     Cairo::RefPtr<Cairo::QuartzSurface> surface = 
> Cairo::QuartzSurface::create(ctx, width, height);
>     Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);
> 
>     // Draw a radial gradient (copied and pasted, more or less, from 
> http://cairographics.org/samples/gradient.html)
>     cr->scale(width,height);
>     Cairo::RefPtr<Cairo::RadialGradient> grad2 = 
> Cairo::RadialGradient::create(0.45, 0.4, 0.1, 0.4, 0.4, 0.5);
>     grad2->add_color_stop_rgba(0, 1,0,0, 1);
>     grad2->add_color_stop_rgba(1, 0,1,0, 1);
>     cr->set_source(grad2);
>     cairo_arc (cr, 0.5, 0.5, 0.3, 0, 2 * M_PI);
>     cr->fill(); //  CRASHES!
> }
> 
> @end
> 
> 
> On 27/03/2007, at 10:22 AM, Baz wrote:
> 
>> On 17/03/07, Hugo Vincent <hugo.vincent@gmail.com> wrote:
>>> Can the patch for bug 10036 (Cairo-Quartz Line-width-scaling problem)
>>> be accepted for into 1.4.2 (or even 1.4.4)? Please!?
>>> https://bugs.freedesktop.org/show_bug.cgi?id=10036
>>>
>>> Also, I have been playing round with Rsvg on Mac OS X, rendering into
>>> a Cairo-Quartz context. It mostly works (except for the above
>>> mentioned bug), however in certain cases it crashes rather
>>> ungracefully when trying to do fallback operations for things that
>>> aren't supported natively by Cairo-Quartz (certain radial gradients
>>> seem to be the culprit). I'll prepare a proper test case and submit a
>>> bug soon after I've tried it with 1.4.2.
>>>
>>> Cheers,
>>> Hugo Vincent
>>
>> Hugo, did you ever track down that crasher?
>>
>> Cheers,
>> Baz
> 
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
> 

From cworth at cworth.org  Tue Mar 27 11:35:50 2007
From: cworth at cworth.org (Carl Worth)
Date: Tue Mar 27 11:36:34 2007
Subject: [cairo] Speeding up stroking of dashed rectangles (was: ideas on
	improving the performance of gtk_tree_view)
In-Reply-To: <6266FC70-3B62-4080-8D4E-0ACAA6CF8275@adacore.com>
References: <63246EC1-97E3-4530-A38D-02E8248E6991@adacore.com>
	<1174679869.3677.87.camel@cacharro.xalalinux.org>
	<1174857487.4606e70fc3602@webmail.welho.com>
	<1174957585.3677.190.camel@cacharro.xalalinux.org>
	<41E18DEB-6C44-4C89-8E2C-EA45E8674710@adacore.com>
	<177e83dd0703270757k267d3681i6107a0e039d0aee2@mail.gmail.com>
	<6266FC70-3B62-4080-8D4E-0ACAA6CF8275@adacore.com>
Message-ID: <878xdizg8p.wl%cworth@cworth.org>

On Tue, 27 Mar 2007 17:50:08 +0200, Nicolas Setton wrote:
> Interesting, the dashed stroke is exactly what's causing problems -
> thanks for the pointer!

Ah, ...

> > though I *think* it has been adressed since. But if you are running
> > 1.4, that would hint that it still is a problem.
>
> There have been great advances in cairo performance lately,
> unfortunately this one might have been overlooked. I'll investigate
> further.

It hasn't been overlooked, per se. But we know it hasn't been
addressed yet.

The mention I made of it before, (from GUADEC last year), was with
respect to a synthetic benchmark that just drew a single big, focused
button over and over again as fast as it could. And that example
showed quite clearly that post-cairo GTK+ drew that button much more
slowly than pre-cairo GTK+, (and it is definitely the dashed stroke
that is causing the problem).

What hadn't ever been made clear is if real-world applications were
seeing performance problems caused by the dashed stroking. It sounds
like maybe you're on to one of those now.

> Indeed. Just subscribed to that list. In order to avoid confusing
> everyone, I'll stay on this list for now, and might open future
> topics on performance-list (or on the cairo list, if I can make
> myself useful there).

I'm on all three of the lists, and I'd be glad to continue the
discussion wherever you see fit. Within cairo, for example, there's a
custom _cairo_path_fixed_stroke_rectilinear function that would be the
ideal place to throw in support for really fast dashing.

And I don't think it would even be a huge amount of work to fix that
to support the kinds of dashing used in the focus rectangle here.

One thing you could do that might be very useful would be to go into
that function in cairo and remove the following two lines:

	if (stroke_style->dash)
	    return CAIRO_INT_STATUS_UNSUPPORTED;

After you do that, the results won't be correct, (the focus rectangle
will come out solid instead of dashed), but it should give you a
feeling of the upper-bound of the performance benefit you could expect
from adding dash support to this function, (and also confirm if the
dashed stroking is the cause of the problems you're seeing).

And if so, then yes, the cairo list might be the best place to
continue the discussion. In fact, I just decided to pull that list in
with this reply. Please feel free to drop gtk-devel-list from future
replies if we just keep talking about cairo's dashed stroking code.

-Carl
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070327/13644f93/attachment.pgp
From jeff at infidigm.net  Tue Mar 27 12:25:36 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Tue Mar 27 12:23:39 2007
Subject: [cairo] Composite logging
Message-ID: <20070327192535.GB19686@infidigm.net>

The included patch adds support for logging the compositing operations
that cairo does. It logs pretty much all of the information except for
image data for the compositing operation to composite.log in a binary
format. An included program 'cairo-log-print' pretty prints some of the
information that is loggged. It is currently pretty simplistic but could
easily do more.

The patch is primarily meant for debugging and is pretty hackish,
however it gets the job done.

-Jeff

diff --git a/Makefile.am b/Makefile.am
index 63b47d8..0fb2606 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,5 +1,5 @@
-DIST_SUBDIRS = pixman src boilerplate test perf doc
-SUBDIRS = pixman src doc
+DIST_SUBDIRS = pixman src boilerplate test perf log doc
+SUBDIRS = pixman src doc log
 # libpng is required for our test programs
 if CAIRO_HAS_PNG_FUNCTIONS
 SUBDIRS += boilerplate test
@@ -22,6 +22,9 @@ check-valgrind: all
 perf: all
 	cd perf && $(MAKE) $(AM_MAKEFLAGS) perf
 
+log: all
+	cd log && $(MAKE) $(AM_MAKEFLAGS) log
+
 EXTRA_DIST = \
 	BUGS \
 	CODING_STYLE \
diff --git a/configure.in b/configure.in
index 8acca66..a6227b1 100644
--- a/configure.in
+++ b/configure.in
@@ -682,6 +682,10 @@ esac
 AC_SUBST(PKGCONFIG_REQUIRES)
 
 dnl ===========================================================================
+dnl Set large file
+CFLAGS="$CFLAGS -D_FILE_OFFSET_BITS=64"
+
+dnl ===========================================================================
 dnl Check for MMX
 
 MMX_CFLAGS="-mmmx -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
@@ -873,6 +877,7 @@ src/Makefile
 test/Makefile
 test/pdiff/Makefile
 perf/Makefile
+log/Makefile
 doc/Makefile
 doc/public/Makefile
 doc/public/version.xml
diff --git a/log/Makefile.am b/log/Makefile.am
new file mode 100644
index 0000000..0c67778
--- /dev/null
+++ b/log/Makefile.am
@@ -0,0 +1,28 @@
+# We're using _GNU_SOURCE to get the prototype for asprintf. This may
+# not be the most portable approach, but it is pragmatic and I'm
+# willing to do something cleaner as soon as it causes someone a
+# problem.
+INCLUDES =					\
+	-D_GNU_SOURCE				\
+	-I$(srcdir)				\
+	-I$(top_srcdir)/boilerplate		\
+	-I$(top_srcdir)/src			\
+	-I$(top_builddir)/src			\
+	-I$(top_srcdir)/pixman/src		\
+	$(CAIRO_CFLAGS)
+
+noinst_PROGRAMS = cairo-log-print
+
+cairo_log_print_SOURCES =	\
+	cairo-log-print.c
+
+LDADD = $(top_builddir)/boilerplate/libcairoboilerplate.la \
+	$(top_builddir)/src/libcairo.la
+
+$(top_builddir)/boilerplate/libcairoboilerplate.la:
+	cd $(top_builddir)/boilerplate && $(MAKE) $(AM_MAKEFLAGS) libcairoboilerplate.la
+
+$(top_builddir)/src/libcairo.la:
+	cd $(top_builddir)/src && $(MAKE) $(AM_MAKEFLAGS) libcairo.la
+
+log: cairo-log-print
diff --git a/log/cairo-log-print.c b/log/cairo-log-print.c
new file mode 100644
index 0000000..afc0107
--- /dev/null
+++ b/log/cairo-log-print.c
@@ -0,0 +1,174 @@
+#include <cairo.h>
+#include <cairoint.h>
+#include <stdio.h>
+#include <cairo-xlib.h>
+struct composite_log {
+    cairo_operator_t op;
+    cairo_pattern_union_t *src;
+    cairo_pattern_union_t *mask;
+    cairo_surface_t *dst;
+    int src_x;
+    int src_y;
+    int mask_x;
+    int mask_y;
+    int dst_x;
+    int dst_y;
+    int width;
+    int height;
+};
+#include <X11/Xlib.h>
+
+#include <X11/extensions/Xrender.h>
+#include <X11/extensions/renderproto.h>
+typedef struct _cairo_xlib_screen_info cairo_xlib_screen_info_t;
+
+struct _cairo_xlib_screen_info {
+    cairo_xlib_screen_info_t *next;
+
+    Display *display;
+    Screen *screen;
+    cairo_bool_t has_render;
+
+    cairo_font_options_t font_options;
+};
+
+
+struct _cairo_xlib_surface {
+    cairo_surface_t base;
+
+    Display *dpy;
+    cairo_xlib_screen_info_t *screen_info;
+
+    GC gc;
+    Drawable drawable;
+    Screen *screen;
+    cairo_bool_t owns_pixmap;
+    Visual *visual;
+
+    int use_pixmap;
+
+    int render_major;
+    int render_minor;
+
+    /* TRUE if the server has a bug with repeating pictures
+     *
+     *  https://bugs.freedesktop.org/show_bug.cgi?id=3566
+     *
+     * We can't test for this because it depends on whether the
+     * picture is in video memory or not.
+     *
+     * We also use this variable as a guard against a second
+     * independent bug with transformed repeating pictures:
+     *
+     * http://lists.freedesktop.org/archives/cairo/2004-September/001839.html
+     *
+     * Both are fixed in xorg >= 6.9 and hopefully in > 6.8.2, so
+     * we can reuse the test for now.
+     */
+    cairo_bool_t buggy_repeat;
+
+    int width;
+    int height;
+    int depth;
+
+    Picture dst_picture, src_picture;
+
+    cairo_bool_t have_clip_rects;
+    XRectangle *clip_rects;
+    int num_clip_rects;
+
+    XRenderPictFormat *xrender_format;
+};
+
+typedef struct _cairo_xlib_surface cairo_xlib_surface_t;
+
+
+struct composite_log *composite_log_load(void);
+extern const char *log_name;
+#define OP(a) if (op == a) return #a
+const char * op_name(cairo_operator_t op);
+const char * op_name(cairo_operator_t op)
+{
+    OP(CAIRO_OPERATOR_CLEAR);
+
+    OP(CAIRO_OPERATOR_SOURCE);
+    OP(CAIRO_OPERATOR_OVER);
+    OP(CAIRO_OPERATOR_IN);
+    OP(CAIRO_OPERATOR_OUT);
+    OP(CAIRO_OPERATOR_ATOP);
+
+    OP(CAIRO_OPERATOR_DEST);
+    OP(CAIRO_OPERATOR_DEST_OVER);
+    OP(CAIRO_OPERATOR_DEST_IN);
+    OP(CAIRO_OPERATOR_DEST_OUT);
+    OP(CAIRO_OPERATOR_DEST_ATOP);
+
+    OP(CAIRO_OPERATOR_XOR);
+    OP(CAIRO_OPERATOR_ADD);
+    OP(CAIRO_OPERATOR_SATURATE);
+    return "unknown";
+}
+#define FORMAT(a) if (op == a) return #a
+const char * format_name(cairo_format_t fmt);
+const char * format_name(cairo_format_t fmt)
+{
+    if (fmt == CAIRO_FORMAT_ARGB32)
+	return "ARGB32";
+    if (fmt == CAIRO_FORMAT_RGB24)
+	return "RGB24";
+    if (fmt == CAIRO_FORMAT_A8)
+	return "A8";
+    if (fmt == CAIRO_FORMAT_A1)
+	return "A1";
+    return "unknown";
+}
+
+void print_surface(cairo_surface_t *s);
+void print_surface(cairo_surface_t *s)
+{
+    if (s->type == CAIRO_SURFACE_TYPE_IMAGE) {
+	cairo_image_surface_t *is = (cairo_image_surface_t*)s;
+	printf("is(%s, %d, %d)", format_name(is->format), is->height, is->width);
+    } else if (s->type == CAIRO_SURFACE_TYPE_XLIB) {
+	cairo_xlib_surface_t *xs = (cairo_xlib_surface_t*)s;
+	printf("xs(%d, %d)", xs->height, xs->width);
+    } else
+	printf("%p", s);
+}
+
+void print_pattern(cairo_pattern_union_t *pat);
+void print_pattern(cairo_pattern_union_t *pat)
+{
+    if (pat) {
+	if (pat->base.type == CAIRO_PATTERN_TYPE_SURFACE)
+	    print_surface(pat->surface.surface);
+	else if (pat->base.type == CAIRO_PATTERN_TYPE_SOLID)
+	    printf("solid");
+	else if (pat->base.type == CAIRO_PATTERN_TYPE_LINEAR)
+	    printf("linear");
+	else if (pat->base.type == CAIRO_PATTERN_TYPE_RADIAL)
+	    printf("radial");
+	else
+	    printf("%d (%d %d)-%p", pat->base.type, pat->base.ref_count, pat->base.status, pat);
+    } else
+	printf("%p", pat);
+}
+
+int main(int argc, char **argv)
+{
+    log_name = "perf-log";
+    if (argc > 1)
+	log_name = argv[1];
+    struct composite_log *e;
+    while ((e = composite_log_load())) {
+	printf("op: %s(%dx%d)", op_name(e->op), e->height, e->width);
+	putchar(' ');
+	print_pattern(e->src);
+	putchar(' ');
+	print_pattern(e->mask);
+	putchar(' ');
+	print_surface(e->dst);
+	putchar('\n');
+    }
+    return 0;
+}
diff --git a/src/cairo-image-surface.c b/src/cairo-image-surface.c
index 6279012..eb3f9ed 100644
--- a/src/cairo-image-surface.c
+++ b/src/cairo-image-surface.c
@@ -912,6 +912,21 @@ _cairo_image_surface_fill_rectangles (void		      *abstract_surface,
 
     return CAIRO_STATUS_SUCCESS;
 }
+struct composite_log {
+    cairo_operator_t op;
+    cairo_pattern_union_t *src;
+    cairo_pattern_union_t *mask;
+    cairo_surface_t *dst;
+    int src_x;
+    int src_y;
+    int mask_x;
+    int mask_y;
+    int dst_x;
+    int dst_y;
+    int width;
+    int height;
+};
+void composite_log_save(struct composite_log *log);
 
 static cairo_int_status_t
 _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
@@ -933,6 +948,7 @@ _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
     cairo_int_status_t		status;
     pixman_image_t		*mask;
     pixman_format_t		*format;
+    cairo_format_t		cairo_format;
     pixman_bits_t		*mask_data;
     int				mask_stride;
     int				mask_bpp;
@@ -975,6 +991,7 @@ _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
     switch (antialias) {
     case CAIRO_ANTIALIAS_NONE:
 	format = pixman_format_create (PIXMAN_FORMAT_NAME_A1);
+	cairo_format = CAIRO_FORMAT_A1;
 	mask_stride = (width + 31)/8;
 	mask_bpp = 1;
  	break;
@@ -983,6 +1000,7 @@ _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
     case CAIRO_ANTIALIAS_DEFAULT:
     default:
 	format = pixman_format_create (PIXMAN_FORMAT_NAME_A8);
+	cairo_format = CAIRO_FORMAT_A8;
 	mask_stride = (width + 3) & ~3;
 	mask_bpp = 8;
  	break;
@@ -1012,6 +1030,24 @@ _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
      * somehow. */
     pixman_add_trapezoids (mask, - dst_x, - dst_y,
 			   (pixman_trapezoid_t *) traps, num_traps);
+    cairo_surface_t *mask_i = _cairo_image_surface_create_for_pixman_image (mask, cairo_format);
+    cairo_pattern_t *mask_p = cairo_pattern_create_for_surface(mask_i);
+    struct composite_log log = {
+            .op = op,
+            .src = (cairo_pattern_union_t*)pattern,
+            .mask = (cairo_pattern_union_t*)mask_p,
+            .dst = (cairo_surface_t*)dst,
+            .src_x = src_x + attributes.x_offset,
+            .src_y = src_y + attributes.y_offset,
+            .mask_x = 0,
+            .mask_y = 0,
+            .dst_x = dst_x,
+	    .dst_y = dst_y,
+            .width = width,
+            .height = height
+    };
+    composite_log_save(&log);
+    cairo_pattern_destroy(mask_p);
 
     pixman_composite (_pixman_operator (op),
 		      src->pixman_image,
@@ -1030,7 +1066,8 @@ _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
 								 src_x, src_y,
 								 0, 0,
 								 dst_x, dst_y, width, height);
-    pixman_image_destroy (mask);
+    //pixman_image_destroy (mask);
+    cairo_surface_destroy(mask_i);
 
  CLEANUP_IMAGE_DATA:
     free (mask_data);
diff --git a/src/cairo-mutex-list.h b/src/cairo-mutex-list.h
index c054e11..59d4f4b 100644
--- a/src/cairo-mutex-list.h
+++ b/src/cairo-mutex-list.h
@@ -39,6 +39,8 @@ CAIRO_MUTEX_DECLARE (_cairo_pattern_solid_cache_lock);
 CAIRO_MUTEX_DECLARE (_cairo_font_face_mutex);
 CAIRO_MUTEX_DECLARE (_cairo_scaled_font_map_mutex);
 
+CAIRO_MUTEX_DECLARE(_composite_log_lock);
+
 #if CAIRO_HAS_FT_FONT
 CAIRO_MUTEX_DECLARE (_cairo_ft_unscaled_font_map_mutex);
 #endif
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index aa4f3b8..570b83a 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -1057,6 +1057,194 @@ _cairo_surface_snapshot (cairo_surface_t *surface)
     return _cairo_surface_fallback_snapshot (surface);
 }
 
+struct composite_log {
+    cairo_operator_t op;
+    cairo_pattern_union_t *src;
+    cairo_pattern_union_t *mask;
+    cairo_surface_t *dst;
+    int src_x;
+    int src_y;
+    int mask_x;
+    int mask_y;
+    int dst_x;
+    int dst_y;
+    int width;
+    int height;
+};
+#include <stdio.h>
+FILE *log_fd;
+#define save(a) fwrite((a), sizeof(*(a)), 1, log_fd)
+static void *__load(size_t size)
+{
+    void *dst = malloc(size);
+    fread(dst, size, 1, log_fd);
+    return dst;
+}
+#define load(a) (typeof(a))__load(sizeof(*(a)))
+static void *__reload(void *dst, size_t orig_size, size_t size)
+{
+    void *new;
+    new = malloc(size);
+    memcpy(new, dst, orig_size);
+    fread((char*)new + orig_size, size - orig_size, 1, log_fd);
+    return new;
+}
+#define reload(a, new_type) (typeof(a))__reload(a, sizeof(*(a)), sizeof(new_type))
+#include <X11/Xlib.h>
+
+#include <X11/extensions/Xrender.h>
+#include <X11/extensions/renderproto.h>
+typedef struct _cairo_xlib_screen_info cairo_xlib_screen_info_t;
+
+struct _cairo_xlib_screen_info {
+    cairo_xlib_screen_info_t *next;
+
+    Display *display;
+    Screen *screen;
+    cairo_bool_t has_render;
+
+    cairo_font_options_t font_options;
+};
+
+
+struct _cairo_xlib_surface {
+    cairo_surface_t base;
+
+    Display *dpy;
+    cairo_xlib_screen_info_t *screen_info;
+
+    GC gc;
+    Drawable drawable;
+    Screen *screen;
+    cairo_bool_t owns_pixmap;
+    Visual *visual;
+
+    int use_pixmap;
+
+    int render_major;
+    int render_minor;
+
+    /* TRUE if the server has a bug with repeating pictures
+     *
+     *  https://bugs.freedesktop.org/show_bug.cgi?id=3566
+     *
+     * We can't test for this because it depends on whether the
+     * picture is in video memory or not.
+     *
+     * We also use this variable as a guard against a second
+     * independent bug with transformed repeating pictures:
+     *
+     * http://lists.freedesktop.org/archives/cairo/2004-September/001839.html
+     *
+     * Both are fixed in xorg >= 6.9 and hopefully in > 6.8.2, so
+     * we can reuse the test for now.
+     */
+    cairo_bool_t buggy_repeat;
+
+    int width;
+    int height;
+    int depth;
+
+    Picture dst_picture, src_picture;
+
+    cairo_bool_t have_clip_rects;
+    XRectangle *clip_rects;
+    int num_clip_rects;
+
+    XRenderPictFormat *xrender_format;
+};
+
+typedef struct _cairo_xlib_surface cairo_xlib_surface_t;
+
+static void surface_save(cairo_surface_t *s)
+{
+    if (s->type == CAIRO_SURFACE_TYPE_IMAGE)
+	save((cairo_image_surface_t*)s);
+    else if (s->type == CAIRO_SURFACE_TYPE_XLIB)
+	save((cairo_xlib_surface_t*)s);
+    else {
+	    printf("unexpected surface type: %d\n", s->type);
+	    save(s);
+    }
+}
+
+static cairo_surface_t *surface_load(void)
+{
+    cairo_surface_t *ret;
+    ret = load(ret);
+
+    if (ret->type == CAIRO_SURFACE_TYPE_IMAGE)
+	ret = reload(ret, cairo_image_surface_t);
+    else if (ret->type == CAIRO_SURFACE_TYPE_XLIB)
+	ret = reload(ret, cairo_xlib_surface_t);
+    else {
+	    printf("unexpected surface type: %d\n", ret->type);
+    }
+    return ret;
+}
+
+static void pattern_save(cairo_pattern_union_t *pat)
+{
+    save(pat);
+    if (pat->base.type == CAIRO_PATTERN_TYPE_SURFACE) {
+	surface_save(pat->surface.surface);
+    }
+}
+
+static cairo_pattern_union_t *pattern_load(void)
+{
+    cairo_pattern_union_t *pat;
+    pat = load(pat);
+    if (pat->base.type == CAIRO_PATTERN_TYPE_SURFACE) {
+	pat->surface.surface = surface_load();
+    }
+    return pat;
+}
+
+void composite_log_save(struct composite_log *log)
+{
+    CAIRO_MUTEX_LOCK(_composite_log_lock);
+    static long last_pos;
+    if (!log_fd) {
+	log_fd = fopen("composite.log", "w+");
+    }
+    unsigned int magic = 0xdeadbabe;
+    save(&magic);
+    save(log);
+    if (log->src)
+	pattern_save(log->src);
+    if (log->mask)
+	pattern_save(log->mask);
+    if (log->dst)
+	surface_save(log->dst);
+    //printf("wrote: %d bytes\n", ftell(log_fd) - last_pos);
+    last_pos = ftell(log_fd);
+    CAIRO_MUTEX_UNLOCK(_composite_log_lock);
+}
+
+char *log_name;
+
+struct composite_log *composite_log_load(void)
+{
+    if (!log_fd)
+	log_fd = fopen(log_name, "r");
+    if (feof(log_fd))
+	return NULL;
+    unsigned int *magic;
+    magic = load(magic);
+    if (*magic != 0xdeadbabe)
+	printf("missing magic: %x\n", *magic);
+    struct composite_log *log;
+    log = load(log);
+    if (log->src)
+	log->src = pattern_load();
+    if (log->mask)
+	log->mask = pattern_load();
+    if (log->dst)
+	log->dst = surface_load();
+    return log;
+}
+
 cairo_status_t
 _cairo_surface_composite (cairo_operator_t	op,
 			  cairo_pattern_t	*src,
@@ -1072,7 +1260,21 @@ _cairo_surface_composite (cairo_operator_t	op,
 			  unsigned int		height)
 {
     cairo_int_status_t status;
-
+    struct composite_log log = {
+	    .op = op,
+	    .src = (cairo_pattern_union_t*)src,
+	    .mask = (cairo_pattern_union_t*)mask,
+	    .dst = dst,
+	    .src_x = src_x,
+	    .src_y = src_y,
+	    .mask_x = mask_x,
+	    .mask_y = mask_y,
+	    .dst_x = dst_x,
+	    .dst_y = dst_y,
+	    .width = width,
+	    .height = height
+    };
+    composite_log_save(&log);
     assert (! dst->is_snapshot);
 
     if (mask) {
From chris at chris-wilson.co.uk  Tue Mar 27 14:04:51 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Tue Mar 27 14:30:30 2007
Subject: [cairo] Add attribute(warn_unused_result)
In-Reply-To: <1174502491.1028.20.camel@behdad>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
	<1174502491.1028.20.camel@behdad>
Message-ID: <20070327210451.GB24027@inspired.chris-wilson.co.uk>

Behdad Esfahbod (behdad@behdad.org) said: 
> The only part I really displike is the "cairo_private_no_warn void".
> While cairo_private_no_warn is useful for other places too, can we have
> a cairo_private_void instead?

Fortunately for readability I found the -Wno-attributes flag.
Attached are the changes for the headers and the most trivial cleanups.
The plan is to attack the rest as a series of independent patches -
however any that are not blindingly obvious I'll defer to the intrepid
reader.

I'll leave introducing cairo_static prototypes for a future janitorial
crusade.
--
Chris Wilson
-------------- next part --------------
>From b2da8b40e9cfa16f156b5a482bcadfbf75d885f5 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 27 Mar 2007 19:15:42 +0100
Subject: [PATCH] Add attribute(warn_unused_result)

This adds a compiler check that the function result is used by the caller
and enables it by default for all cairo_private functions and for public
API that returns a cairo_status_t.

To extend the warnings to all functions, a new function type has been
introduced to cover static functions: cairo_static. The preference is
for all static code to be forward declared with a cairo_static prototype.

In order to reduce the warning spew generated by gcc for invalid use of
this attribute, -Wno-attributes is added to CFLAGS. This has the
unfortunate side-effect of masking future warnings for all attributes -
be warned!
---
 configure.in           |   13 ++++++++++++-
 pixman/configure.in    |    3 ++-
 pixman/src/Makefile.am |    1 +
 pixman/src/pixman.h    |    2 +-
 src/cairo.h            |   40 ++++++++++++++++++++--------------------
 src/cairoint.h         |   11 ++++++++---
 src/check-headers.sh   |    2 +-
 7 files changed, 45 insertions(+), 27 deletions(-)

diff --git a/configure.in b/configure.in
index 8acca66..e885b5c 100644
--- a/configure.in
+++ b/configure.in
@@ -621,7 +621,8 @@ MAYBE_WARN="-Wall -Wextra \
 -Wpacked -Wswitch-enum -Wmissing-format-attribute \
 -Wstrict-aliasing=2 -Winit-self -Wunsafe-loop-optimizations \
 -Wdeclaration-after-statement -Wold-style-definition \
--Wno-missing-field-initializers -Wno-unused-parameter"
+-Wno-missing-field-initializers -Wno-unused-parameter \
+-Wno-attributes"
 
 
 # invalidate cached value if MAYBE_WARN has changed
@@ -834,9 +835,19 @@ AC_CONFIG_COMMANDS([src/cairo-features.h],
 # define CAIRO_END_DECLS
 #endif
 
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#define CAIRO_WARN_UNUSED_RESULT 		\
+  __attribute__((__warn_unused_result__))
+#else
+#define CAIRO_WARN_UNUSED_RESULT
+#endif /* __GNUC__ */
+
 #ifndef cairo_public
 # define cairo_public
 #endif
+#ifndef cairo_public_warn
+# define cairo_public_warn CAIRO_WARN_UNUSED_RESULT
+#endif
 
 #define CAIRO_VERSION_MAJOR $CAIRO_VERSION_MAJOR
 #define CAIRO_VERSION_MINOR $CAIRO_VERSION_MINOR
diff --git a/pixman/configure.in b/pixman/configure.in
index c9cdae8..4cbb5ba 100644
--- a/pixman/configure.in
+++ b/pixman/configure.in
@@ -45,7 +45,8 @@ WARN_CFLAGS=""
 if test "x$GCC" = "xyes"; then
 	WARN_CFLAGS="-Wall -Wpointer-arith -Wstrict-prototypes \
 	-Wmissing-prototypes -Wmissing-declarations \
-	-Wnested-externs -fno-strict-aliasing"
+	-Wnested-externs -fno-strict-aliasing \
+	-Wno-attributes"
 fi
 
 AC_SUBST(WARN_CFLAGS)
diff --git a/pixman/src/Makefile.am b/pixman/src/Makefile.am
index 7b828f5..f1808e3 100644
--- a/pixman/src/Makefile.am
+++ b/pixman/src/Makefile.am
@@ -29,6 +29,7 @@ libpixman_la_SOURCES = \
 	fbcompose.c \
 	renderedge.c \
 	renderedge.h
+libpixman_la_CFLAGS = $(PIXMAN_CFLAGS)
 
 if USE_MMX
 noinst_LTLIBRARIES += libpixman-mmx.la
diff --git a/pixman/src/pixman.h b/pixman/src/pixman.h
index 9120eb6..acf5327 100644
--- a/pixman/src/pixman.h
+++ b/pixman/src/pixman.h
@@ -100,7 +100,7 @@ SOFTWARE.
 #include "pixman-remap.h"
 
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun__)
-#define pixman_private		__attribute__((__visibility__("hidden")))
+#define pixman_private		__attribute__((__visibility__("hidden"),__warn_unused_result__))
 #elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
 #define pixman_private		__hidden
 #else /* not gcc >= 3.3 and not Sun Studio >= 8 */
diff --git a/src/cairo.h b/src/cairo.h
index a80efde..5fc05e3 100644
--- a/src/cairo.h
+++ b/src/cairo.h
@@ -313,7 +313,7 @@ cairo_public void *
 cairo_get_user_data (cairo_t			 *cr,
 		     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_set_user_data (cairo_t			 *cr,
 		     const cairo_user_data_key_t *key,
 		     void			 *user_data,
@@ -972,7 +972,7 @@ cairo_font_options_copy (const cairo_font_options_t *original);
 cairo_public void
 cairo_font_options_destroy (cairo_font_options_t *options);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_options_status (cairo_font_options_t *options);
 
 cairo_public void
@@ -1088,7 +1088,7 @@ cairo_font_face_destroy (cairo_font_face_t *font_face);
 cairo_public unsigned int
 cairo_font_face_get_reference_count (cairo_font_face_t *font_face);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_face_status (cairo_font_face_t *font_face);
 
 /**
@@ -1141,7 +1141,7 @@ cairo_public void *
 cairo_font_face_get_user_data (cairo_font_face_t	   *font_face,
 			       const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_face_set_user_data (cairo_font_face_t	   *font_face,
 			       const cairo_user_data_key_t *key,
 			       void			   *user_data,
@@ -1164,7 +1164,7 @@ cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font);
 cairo_public unsigned int
 cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_scaled_font_status (cairo_scaled_font_t *scaled_font);
 
 cairo_public cairo_font_type_t
@@ -1174,7 +1174,7 @@ cairo_public void *
 cairo_scaled_font_get_user_data (cairo_scaled_font_t         *scaled_font,
 				 const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_scaled_font_set_user_data (cairo_scaled_font_t         *scaled_font,
 				 const cairo_user_data_key_t *key,
 				 void                        *user_data,
@@ -1392,7 +1392,7 @@ cairo_path_destroy (cairo_path_t *path);
 
 /* Error status queries */
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_status (cairo_t *cr);
 
 cairo_public const char *
@@ -1418,7 +1418,7 @@ cairo_surface_destroy (cairo_surface_t *surface);
 cairo_public unsigned int
 cairo_surface_get_reference_count (cairo_surface_t *surface);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_status (cairo_surface_t *surface);
 
 /**
@@ -1482,11 +1482,11 @@ cairo_surface_get_content (cairo_surface_t *surface);
 
 #if CAIRO_HAS_PNG_FUNCTIONS
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_write_to_png (cairo_surface_t	*surface,
 			    const char		*filename);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_write_to_png_stream (cairo_surface_t	*surface,
 				   cairo_write_func_t	write_func,
 				   void			*closure);
@@ -1497,7 +1497,7 @@ cairo_public void *
 cairo_surface_get_user_data (cairo_surface_t		 *surface,
 			     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_set_user_data (cairo_surface_t		 *surface,
 			     const cairo_user_data_key_t *key,
 			     void			 *user_data,
@@ -1642,14 +1642,14 @@ cairo_pattern_destroy (cairo_pattern_t *pattern);
 cairo_public unsigned int
 cairo_pattern_get_reference_count (cairo_pattern_t *pattern);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_status (cairo_pattern_t *pattern);
 
 cairo_public void *
 cairo_pattern_get_user_data (cairo_pattern_t		 *pattern,
 			     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_set_user_data (cairo_pattern_t		 *pattern,
 			     const cairo_user_data_key_t *key,
 			     void			 *user_data,
@@ -1758,32 +1758,32 @@ cairo_pattern_set_filter (cairo_pattern_t *pattern, cairo_filter_t filter);
 cairo_public cairo_filter_t
 cairo_pattern_get_filter (cairo_pattern_t *pattern);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_rgba (cairo_pattern_t *pattern,
 			double *red, double *green,
 			double *blue, double *alpha);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_surface (cairo_pattern_t *pattern,
 			   cairo_surface_t **surface);
 
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_color_stop_rgba (cairo_pattern_t *pattern,
 				   int index, double *offset,
 				   double *red, double *green,
 				   double *blue, double *alpha);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_color_stop_count (cairo_pattern_t *pattern,
 				    int *count);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_linear_points (cairo_pattern_t *pattern,
 				 double *x0, double *y0,
 				 double *x1, double *y1);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_radial_circles (cairo_pattern_t *pattern,
 				  double *x0, double *y0, double *r0,
 				  double *x1, double *y1, double *r1);
@@ -1820,7 +1820,7 @@ cairo_matrix_scale (cairo_matrix_t *matrix, double sx, double sy);
 cairo_public void
 cairo_matrix_rotate (cairo_matrix_t *matrix, double radians);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_matrix_invert (cairo_matrix_t *matrix);
 
 cairo_public void
diff --git a/src/cairoint.h b/src/cairoint.h
index 1d2c3c7..ed685e6 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -103,13 +103,18 @@ CAIRO_BEGIN_DECLS
 
 /* slim_internal.h */
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
-#define cairo_private		__attribute__((__visibility__("hidden")))
+#define cairo_private			__attribute__((__visibility__("hidden"),__warn_unused_result__))
 #elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
-#define cairo_private		__hidden
+#define cairo_private			__hidden CAIRO_WARN_UNUSED_RESULT
 #else /* not gcc >= 3.3 and not Sun Studio >= 8 */
-#define cairo_private
+#define cairo_private			CAIRO_WARN_UNUSED_RESULT
 #endif
 
+/* This allows us to conditionally expose internals during debugging,
+   and forces propagation of return values.
+*/
+#define cairo_static static CAIRO_WARN_UNUSED_RESULT
+
 /* This macro allow us to deprecate a function by providing an alias
    for the old function name to the new function name. With this
    macro, binary compatibility is preserved. The macro only works on
diff --git a/src/check-headers.sh b/src/check-headers.sh
index 1d0ebf8..2ac74fd 100755
--- a/src/check-headers.sh
+++ b/src/check-headers.sh
@@ -12,7 +12,7 @@ xargs grep -B 1 '^cairo_.*[ 	]\+(' |
 awk '
 /^--$/ { context=""; public=0; next; }
 /:cairo_.*[ 	]+\(/ { if (!public) {print context; print; print "--";} next; }
-/-cairo_public[ 	]/ {public=1;}
+/-cairo_public.*[ 	]/ {public=1;}
 { context=$0; }
 ' |
 sed 's/[.]h-/.h:/' |
-- 
1.4.4.2

-------------- next part --------------
>From cfc8b86edd0660a5bcbf8b6b5c977287bc173f47 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 27 Mar 2007 21:52:37 +0100
Subject: [PATCH] Fix up the trivial warnings from warn-unused-result.

For the majority of cases of unchecked status returns the most appropiate
action is to simply propagate the status back up the chain, after
performing all apropiate cleanups.
---
 boilerplate/cairo-boilerplate.c |   10 ++++-
 src/cairo-clip.c                |   19 ++++++---
 src/cairo-ft-font.c             |   82 +++++++++++++++++++++++++-------------
 src/cairo-gstate.c              |   17 ++++++--
 src/cairo-image-surface.c       |    6 ++-
 src/cairo-meta-surface.c        |    4 +-
 src/cairo-paginated-surface.c   |   22 ++++++++---
 src/cairo-path-fill.c           |    2 +-
 src/cairo-path-stroke.c         |   54 +++++++++++++++++++------
 src/cairo-path.c                |   38 +++++++++--------
 src/cairo-pattern.c             |   10 ++++-
 src/cairo-pdf-surface.c         |   25 ++++++------
 src/cairo-pen.c                 |   24 ++++++++---
 src/cairo-polygon.c             |    8 +--
 src/cairo-ps-surface.c          |   54 +++++++++++++++-----------
 src/cairo-scaled-font.c         |   43 +++++++++++++-------
 src/cairo-surface-fallback.c    |   44 ++++++++++++--------
 src/cairo-svg-surface.c         |   34 +++++++++++-----
 src/cairo-type1-fallback.c      |    7 ++-
 src/cairo.c                     |   74 +++++++++++++++++++++++------------
 test/buffer-diff.c              |    5 +-
 21 files changed, 378 insertions(+), 204 deletions(-)

diff --git a/boilerplate/cairo-boilerplate.c b/boilerplate/cairo-boilerplate.c
index f726d42..858c5c0 100644
--- a/boilerplate/cairo-boilerplate.c
+++ b/boilerplate/cairo-boilerplate.c
@@ -1095,7 +1095,15 @@ create_ps_surface (const char			 *name,
 	ptc->target = NULL;
     }
 
-    cairo_surface_set_user_data (surface, &ps_closure_key, ptc, NULL);
+    if (cairo_surface_set_user_data (surface,
+	       	                     &ps_closure_key,
+				     ptc,
+				     NULL) != CAIRO_STATUS_SUCCESS) {
+	cairo_surface_destroy (surface);
+	free (ptc->filename);
+	free (ptc);
+	return NULL;
+    }
 
     return surface;
 }
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index efecd89..0ab036b 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -203,6 +203,8 @@ cairo_status_t
 _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 				 pixman_region16_t *region)
 {
+    pixman_region_status_t pixman_status;
+
     if (!clip)
 	return CAIRO_STATUS_SUCCESS;
 
@@ -210,12 +212,14 @@ _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 	/* Intersect clip path into region. */
     }
 
-    if (clip->region)
-	pixman_region_intersect (region, clip->region, region);
+    if (clip->region) {
+	pixman_status = pixman_region_intersect (region, clip->region, region);
+	if (pixman_status != PIXMAN_REGION_STATUS_SUCCESS)
+	    return CAIRO_STATUS_NO_MEMORY;
+    }
 
     if (clip->surface) {
 	pixman_region16_t *clip_rect;
-	pixman_region_status_t pixman_status;
 	cairo_status_t status = CAIRO_STATUS_SUCCESS;
 
 	clip_rect = _cairo_region_create_from_rectangle (&clip->surface_rect);
@@ -635,10 +639,11 @@ _cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate)
         }
     } else {
         cairo_rectangle_int16_t extents;
-        _cairo_surface_get_extents (_cairo_gstate_get_target (gstate), &extents);
-        if (!_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
-                                      extents.width, extents.height,
-                                      rectangles)) {
+        if (_cairo_surface_get_extents (_cairo_gstate_get_target (gstate),
+		                        &extents) != CAIRO_STATUS_SUCCESS ||
+		!_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
+                                          extents.width, extents.height,
+                                          rectangles)) {
             free (rectangles);
             return (cairo_rectangle_list_t*)
                 &_cairo_rectangles_not_representable;
diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index 7f10fd7..73a40f8 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -1154,24 +1154,33 @@ _transform_glyph_bitmap (cairo_matrix_t         * shape,
 
     /* Initialize it to empty
      */
-    _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
-				   CAIRO_COLOR_TRANSPARENT,
-				   0, 0,
-				   width, height);
+    status = _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
+				            CAIRO_COLOR_TRANSPARENT,
+					    0, 0,
+					    width, height);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     /* Draw the original bitmap transformed into the new bitmap
      */
     _cairo_pattern_init_for_surface (&pattern, &(*surface)->base);
     cairo_pattern_set_matrix (&pattern.base, &transformed_to_original);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_OVER,
-			      &pattern.base, NULL, image,
-			      0, 0, 0, 0, 0, 0,
-			      width,
-			      height);
+    status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+			               &pattern.base, NULL, image,
+				       0, 0, 0, 0, 0, 0,
+				       width,
+				       height);
 
     _cairo_pattern_fini (&pattern.base);
 
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
+
     /* Now update the cache entry for the new bitmap, recomputing
      * the origin based on the final transform.
      */
@@ -1421,6 +1430,7 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
     FT_Face face;
     FT_Size_Metrics *metrics;
     cairo_font_extents_t fs_metrics;
+    cairo_status_t status;
 
     face = _cairo_ft_unscaled_font_lock_face (unscaled);
     if (!face)
@@ -1441,10 +1451,15 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
     _cairo_font_options_init_copy (&scaled_font->ft_options.base, options);
     _cairo_ft_options_merge (&scaled_font->ft_options, &ft_options);
 
-    _cairo_scaled_font_init (&scaled_font->base,
-			     font_face,
-			     font_matrix, ctm, options,
-			     &cairo_ft_scaled_font_backend);
+    status = _cairo_scaled_font_init (&scaled_font->base,
+			              font_face,
+				      font_matrix, ctm, options,
+				      &cairo_ft_scaled_font_backend);
+    if (status) {
+	free (scaled_font);
+	_cairo_ft_unscaled_font_unlock_face (unscaled);
+	return NULL;
+    }
 
     _cairo_ft_unscaled_font_set_scale (unscaled,
 				       &scaled_font->base.scale);
@@ -1620,8 +1635,10 @@ _move_to (FT_Vector *to, void *closure)
     x = _cairo_fixed_from_26_6 (to->x);
     y = _cairo_fixed_from_26_6 (to->y);
 
-    _cairo_path_fixed_close_path (path);
-    _cairo_path_fixed_move_to (path, x, y);
+    if (_cairo_path_fixed_close_path (path) != CAIRO_STATUS_SUCCESS)
+	return 1;
+    if (_cairo_path_fixed_move_to (path, x, y) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1635,7 +1652,8 @@ _line_to (FT_Vector *to, void *closure)
     x = _cairo_fixed_from_26_6 (to->x);
     y = _cairo_fixed_from_26_6 (to->y);
 
-    _cairo_path_fixed_line_to (path, x, y);
+    if (_cairo_path_fixed_line_to (path, x, y) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1651,7 +1669,9 @@ _conic_to (FT_Vector *control, FT_Vector *to, void *closure)
     cairo_fixed_t x3, y3;
     cairo_point_t conic;
 
-    _cairo_path_fixed_get_current_point (path, &x0, &y0);
+    if (_cairo_path_fixed_get_current_point (path, &x0, &y0) !=
+	    CAIRO_STATUS_SUCCESS)
+	return 1;
 
     conic.x = _cairo_fixed_from_26_6 (control->x);
     conic.y = _cairo_fixed_from_26_6 (control->y);
@@ -1665,10 +1685,11 @@ _conic_to (FT_Vector *control, FT_Vector *to, void *closure)
     x2 = x3 + 2.0/3.0 * (conic.x - x3);
     y2 = y3 + 2.0/3.0 * (conic.y - y3);
 
-    _cairo_path_fixed_curve_to (path,
-				x1, y1,
-				x2, y2,
-				x3, y3);
+    if (_cairo_path_fixed_curve_to (path,
+				    x1, y1,
+				    x2, y2,
+				    x3, y3) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1691,10 +1712,11 @@ _cubic_to (FT_Vector *control1, FT_Vector *control2,
     x2 = _cairo_fixed_from_26_6 (to->x);
     y2 = _cairo_fixed_from_26_6 (to->y);
 
-    _cairo_path_fixed_curve_to (path,
-				x0, y0,
-				x1, y1,
-				x2, y2);
+    if (_cairo_path_fixed_curve_to (path,
+				    x0, y0,
+				    x1, y1,
+				    x2, y2) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1719,6 +1741,7 @@ _decompose_glyph_outline (FT_Face		  face,
 
     FT_GlyphSlot glyph;
     cairo_path_fixed_t *path;
+    cairo_status_t status;
 
     path = _cairo_path_fixed_create ();
     if (!path)
@@ -1726,15 +1749,18 @@ _decompose_glyph_outline (FT_Face		  face,
 
     glyph = face->glyph;
 
+    status = CAIRO_STATUS_SUCCESS;
     /* Font glyphs have an inverted Y axis compared to cairo. */
     FT_Outline_Transform (&glyph->outline, &invert_y);
-    FT_Outline_Decompose (&glyph->outline, &outline_funcs, path);
+    if (FT_Outline_Decompose (&glyph->outline, &outline_funcs, path))
+	status = CAIRO_STATUS_NO_MEMORY;
 
     _cairo_path_fixed_close_path (path);
 
-    *pathp = path;
+    if (status == CAIRO_STATUS_SUCCESS)
+	*pathp = path;
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 /*
diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index 377871e..5647f9c 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -64,6 +64,7 @@ cairo_status_t
 _cairo_gstate_init (cairo_gstate_t  *gstate,
 		    cairo_surface_t *target)
 {
+    cairo_status_t status;
     gstate->next = NULL;
 
     gstate->op = CAIRO_GSTATE_OPERATOR_DEFAULT;
@@ -90,7 +91,9 @@ _cairo_gstate_init (cairo_gstate_t  *gstate,
     gstate->parent_target = NULL;
     gstate->original_target = cairo_surface_reference (target);
 
-    _cairo_gstate_identity_matrix (gstate);
+    status = _cairo_gstate_identity_matrix (gstate);
+    if (status)
+	return status;
     gstate->source_ctm_inverse = gstate->ctm_inverse;
 
     gstate->source = _cairo_pattern_create_solid (CAIRO_COLOR_BLACK);
@@ -405,7 +408,7 @@ _cairo_gstate_set_source (cairo_gstate_t  *gstate,
     if (source->status)
 	return source->status;
 
-    cairo_pattern_reference (source);
+    source = cairo_pattern_reference (source);
     cairo_pattern_destroy (gstate->source);
     gstate->source = source;
     gstate->source_ctm_inverse = gstate->ctm_inverse;
@@ -650,13 +653,16 @@ _cairo_gstate_transform (cairo_gstate_t	      *gstate,
 			 const cairo_matrix_t *matrix)
 {
     cairo_matrix_t tmp;
+    cairo_status_t status;
 
     _cairo_gstate_unset_scaled_font (gstate);
 
     tmp = *matrix;
     cairo_matrix_multiply (&gstate->ctm, &tmp, &gstate->ctm);
 
-    cairo_matrix_invert (&tmp);
+    status = cairo_matrix_invert (&tmp);
+    if (status)
+	return status;
     cairo_matrix_multiply (&gstate->ctm_inverse, &gstate->ctm_inverse, &tmp);
 
     return CAIRO_STATUS_SUCCESS;
@@ -1257,12 +1263,15 @@ _cairo_gstate_select_font_face (cairo_gstate_t       *gstate,
 				cairo_font_weight_t   weight)
 {
     cairo_font_face_t *font_face;
+    cairo_status_t status;
 
     font_face = _cairo_toy_font_face_create (family, slant, weight);
     if (font_face->status)
 	return font_face->status;
 
-    _cairo_gstate_set_font_face (gstate, font_face);
+    status = _cairo_gstate_set_font_face (gstate, font_face);
+    if (status)
+	return status;
     cairo_font_face_destroy (font_face);
 
     return CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-image-surface.c b/src/cairo-image-surface.c
index 6279012..3062533 100644
--- a/src/cairo-image-surface.c
+++ b/src/cairo-image-surface.c
@@ -690,7 +690,8 @@ _cairo_image_surface_set_matrix (cairo_image_surface_t	*surface,
 
     _cairo_matrix_to_pixman_matrix (matrix, &pixman_transform);
 
-    pixman_image_set_transform (surface->pixman_image, &pixman_transform);
+    if (pixman_image_set_transform (surface->pixman_image, &pixman_transform))
+	return CAIRO_STATUS_NO_MEMORY;
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -1047,7 +1048,8 @@ _cairo_image_surface_set_clip_region (void *abstract_surface,
 {
     cairo_image_surface_t *surface = (cairo_image_surface_t *) abstract_surface;
 
-    pixman_image_set_clip_region (surface->pixman_image, region);
+    if (pixman_image_set_clip_region (surface->pixman_image, region))
+	return CAIRO_STATUS_NO_MEMORY;
 
     surface->has_clip = region != NULL;
 
diff --git a/src/cairo-meta-surface.c b/src/cairo-meta-surface.c
index e196df2..7bbdc39 100644
--- a/src/cairo-meta-surface.c
+++ b/src/cairo-meta-surface.c
@@ -668,7 +668,9 @@ _cairo_meta_surface_replay (cairo_surface_t *surface,
 
 	dev_path = _cairo_command_get_path (command);
 	if (dev_path && has_device_transform) {
-	    _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    status = _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    if (status)
+		break;
 	    _cairo_path_fixed_device_transform (&path_copy, device_transform);
 	    dev_path = &path_copy;
 	}
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index c8e4612..e6702b7 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -201,15 +201,22 @@ _cairo_paginated_surface_acquire_source_image (void	       *abstract_surface,
 {
     cairo_paginated_surface_t *surface = abstract_surface;
     cairo_surface_t *image;
+    cairo_status_t status;
     cairo_rectangle_int16_t extents;
 
-    _cairo_surface_get_extents (surface->target, &extents);
+    status = _cairo_surface_get_extents (surface->target, &extents);
+    if (status)
+	return status;
 
     image = _cairo_paginated_surface_create_image_surface (surface,
 							   extents.width,
 							   extents.height);
 
-    _cairo_meta_surface_replay (surface->meta, image);
+    status = _cairo_meta_surface_replay (surface->meta, image);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     *image_out = (cairo_image_surface_t*) image;
     *image_extra = NULL;
@@ -257,26 +264,29 @@ _paint_page (cairo_paginated_surface_t *surface)
 							       surface->height * y_scale);
 	_cairo_surface_set_device_scale (image, x_scale, y_scale);
 
-	_cairo_meta_surface_replay (surface->meta, image);
+	status = _cairo_meta_surface_replay (surface->meta, image);
+	if (status)
+	    goto CLEANUP_IMAGE;
 
 	pattern = cairo_pattern_create_for_surface (image);
 	cairo_matrix_init_scale (&matrix, x_scale, y_scale);
 	cairo_pattern_set_matrix (pattern, &matrix);
 
-	_cairo_surface_paint (surface->target, CAIRO_OPERATOR_SOURCE, pattern);
+	status = _cairo_surface_paint (surface->target, CAIRO_OPERATOR_SOURCE, pattern);
 
 	cairo_pattern_destroy (pattern);
 
+CLEANUP_IMAGE:
 	cairo_surface_destroy (image);
     }
     else
     {
-	_cairo_meta_surface_replay (surface->meta, surface->target);
+	status = _cairo_meta_surface_replay (surface->meta, surface->target);
     }
 
     cairo_surface_destroy (analysis);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
diff --git a/src/cairo-path-fill.c b/src/cairo-path-fill.c
index b1b7a12..d2a9118 100644
--- a/src/cairo-path-fill.c
+++ b/src/cairo-path-fill.c
@@ -138,7 +138,7 @@ _cairo_filler_curve_to (void *closure,
     if (status == CAIRO_INT_STATUS_DEGENERATE)
 	return CAIRO_STATUS_SUCCESS;
 
-    _cairo_spline_decompose (&spline, filler->tolerance);
+    status = _cairo_spline_decompose (&spline, filler->tolerance);
     if (status)
 	goto CLEANUP_SPLINE;
 
diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index 09bafbf..3aeb41f 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -205,6 +205,7 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 {
     int			clockwise = _cairo_stroker_face_clockwise (out, in);
     cairo_point_t	*inpt, *outpt;
+    cairo_status_t status;
 
     if (in->cw.x == out->cw.x
 	&& in->cw.y == out->cw.y
@@ -231,13 +232,21 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 
 	tri[0] = in->point;
 	if (clockwise) {
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = -1;
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	} else {
-	    _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = +1;
-	    _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	}
 
 	i = start;
@@ -245,7 +254,9 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 	while (i != stop) {
 	    tri[2] = in->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	    i += step;
 	    if (i < 0)
@@ -378,17 +389,23 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	cairo_pen_t *pen = &stroker->pen;
 
 	slope = f->dev_vector;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	if (status)
+	    return status;
 	slope.dx = -slope.dx;
 	slope.dy = -slope.dy;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	if (status)
+	    return status;
 
 	tri[0] = f->point;
 	tri[1] = f->cw;
 	for (i=start; i != stop; i = (i+1) % pen->num_vertices) {
 	    tri[2] = f->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	}
 	tri[2] = f->ccw;
@@ -414,13 +431,24 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	ocw.y = f->cw.y + fvector.dy;
 
 	_cairo_polygon_init (&polygon);
-	_cairo_polygon_move_to (&polygon, &f->cw);
-	_cairo_polygon_line_to (&polygon, &ocw);
-	_cairo_polygon_line_to (&polygon, &occw);
-	_cairo_polygon_line_to (&polygon, &f->ccw);
-	_cairo_polygon_close (&polygon);
+	status = _cairo_polygon_move_to (&polygon, &f->cw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &ocw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &occw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &f->ccw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_close (&polygon);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
 
 	status = _cairo_bentley_ottmann_tessellate_polygon (stroker->traps, &polygon, CAIRO_FILL_RULE_WINDING);
+CLEANUP_LINE_CAP_SQUARE:
 	_cairo_polygon_fini (&polygon);
 
 	return status;
diff --git a/src/cairo-path.c b/src/cairo-path.c
index d79454c..95fe99c 100644
--- a/src/cairo-path.c
+++ b/src/cairo-path.c
@@ -141,15 +141,16 @@ _cairo_path_count (cairo_path_t		*path,
     cpc.current_point.x = 0;
     cpc.current_point.y = 0;
 
-    _cairo_path_fixed_interpret (path_fixed,
-				 CAIRO_DIRECTION_FORWARD,
-				 _cpc_move_to,
-				 _cpc_line_to,
-				 flatten ?
-				 _cpc_curve_to_flatten :
-				 _cpc_curve_to,
-				 _cpc_close_path,
-				 &cpc);
+    if (_cairo_path_fixed_interpret (path_fixed,
+				     CAIRO_DIRECTION_FORWARD,
+				     _cpc_move_to,
+				     _cpc_line_to,
+				     flatten ?
+				     _cpc_curve_to_flatten :
+				     _cpc_curve_to,
+				     _cpc_close_path,
+				     &cpc) != CAIRO_STATUS_SUCCESS)
+	return 0;
 
     return cpc.count;
 }
@@ -318,15 +319,16 @@ _cairo_path_populate (cairo_path_t		*path,
     cpp.current_point.x = 0;
     cpp.current_point.y = 0;
 
-    _cairo_path_fixed_interpret (path_fixed,
-				 CAIRO_DIRECTION_FORWARD,
-				 _cpp_move_to,
-				 _cpp_line_to,
-				 flatten ?
-				 _cpp_curve_to_flatten :
-				 _cpp_curve_to,
-				 _cpp_close_path,
-				 &cpp);
+    if (_cairo_path_fixed_interpret (path_fixed,
+				     CAIRO_DIRECTION_FORWARD,
+				     _cpp_move_to,
+				     _cpp_line_to,
+				     flatten ?
+				     _cpp_curve_to_flatten :
+				     _cpp_curve_to,
+				     _cpp_close_path,
+				     &cpp) != CAIRO_STATUS_SUCCESS)
+	return; /* XXX propagate status */
 
     /* Sanity check the count */
     assert (cpp.data - path->data == path->num_data);
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index 2bc5580..3001e10 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -1191,7 +1191,11 @@ _cairo_pattern_acquire_surface_for_gradient (cairo_gradient_pattern_t *pattern,
     pixman_image_set_filter (pixman_image, PIXMAN_FILTER_BILINEAR);
 
     _cairo_matrix_to_pixman_matrix (&pattern->base.matrix, &pixman_transform);
-    pixman_image_set_transform (pixman_image, &pixman_transform);
+    if (pixman_image_set_transform (pixman_image, &pixman_transform)) {
+	cairo_surface_destroy (&image->base);
+	pixman_image_destroy (pixman_image);
+	return CAIRO_STATUS_NO_MEMORY;
+    }
 
     switch (pattern->base.extend) {
     case CAIRO_EXTEND_NONE:
@@ -1755,7 +1759,9 @@ _cairo_pattern_get_extents (cairo_pattern_t         *pattern,
 	    return status;
 
 	imatrix = pattern->matrix;
-	cairo_matrix_invert (&imatrix);
+	status = cairo_matrix_invert (&imatrix);
+	if (status)
+	    return status;
 
 	/* XXX Use _cairo_matrix_transform_bounding_box here */
 	for (sy = 0; sy <= 1; sy++) {
diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 3e8375f..67cfbc6 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -900,7 +900,9 @@ _cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	*surface,
     if (status)
 	goto BAIL;
 
-    _cairo_surface_get_extents (&surface->base, &surface_extents);
+    status = _cairo_surface_get_extents (&surface->base, &surface_extents);
+    if (status)
+	goto BAIL;
 
     switch (extend) {
     /* We implement EXTEND_PAD like EXTEND_NONE for now */
@@ -1253,6 +1255,7 @@ _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radi
     cairo_pdf_resource_t function, pattern_resource, alpha;
     double x0, y0, x1, y1, r0, r1;
     cairo_matrix_t p2u;
+    cairo_status_t status;
 
     _cairo_pdf_surface_pause_content_stream (surface);
 
@@ -1261,7 +1264,9 @@ _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radi
 	return CAIRO_STATUS_NO_MEMORY;
 
     p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     x0 = _cairo_fixed_to_double (pattern->gradient.c1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.c1.y);
@@ -1822,11 +1827,11 @@ _cairo_pdf_surface_emit_cff_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_cff_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
@@ -1931,9 +1936,7 @@ _cairo_pdf_surface_emit_type1_font (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 #if CAIRO_HAS_FT_FONT
@@ -2102,11 +2105,11 @@ _cairo_pdf_surface_emit_truetype_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_truetype_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_int_status_t
@@ -2387,9 +2390,7 @@ _cairo_pdf_surface_emit_type3_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 static void
diff --git a/src/cairo-pen.c b/src/cairo-pen.c
index 1af8c36..1bc096b 100644
--- a/src/cairo-pen.c
+++ b/src/cairo-pen.c
@@ -135,6 +135,7 @@ cairo_status_t
 _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
 {
     cairo_pen_vertex_t *vertices;
+    cairo_status_t status;
     int num_vertices;
     int i;
 
@@ -150,7 +151,9 @@ _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
     for (i=0; i < num_points; i++)
 	pen->vertices[pen->num_vertices-num_points+i].point = point[i];
 
-    _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    status = _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    if (status)
+	return status;
 
     _cairo_pen_compute_slopes (pen);
 
@@ -388,7 +391,11 @@ _cairo_pen_stroke_spline_half (cairo_pen_t *pen,
 	final_slope.dy = -final_slope.dy;
     }
 
-    _cairo_pen_find_active_cw_vertex_index (pen, &initial_slope, &active);
+    status = _cairo_pen_find_active_cw_vertex_index (pen,
+	                                             &initial_slope,
+						     &active);
+    if (status)
+	return status;
 
     i = start;
     while (i != stop) {
@@ -437,18 +444,21 @@ _cairo_pen_stroke_spline (cairo_pen_t		*pen,
 
     status = _cairo_spline_decompose (spline, tolerance);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_FORWARD, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_REVERSE, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
-    _cairo_polygon_close (&polygon);
-    _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
+    status = _cairo_polygon_close (&polygon);
+    if (status)
+	goto BAIL;
+    status = _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
+BAIL:
     _cairo_polygon_fini (&polygon);
 
     return CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-polygon.c b/src/cairo-polygon.c
index f36bc71..84be855 100644
--- a/src/cairo-polygon.c
+++ b/src/cairo-polygon.c
@@ -135,9 +135,7 @@ _cairo_polygon_add_edge (cairo_polygon_t *polygon, cairo_point_t *p1, cairo_poin
     polygon->num_edges++;
 
   DONE:
-    _cairo_polygon_move_to (polygon, p2);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_polygon_move_to (polygon, p2);
 }
 
 cairo_status_t
@@ -154,12 +152,12 @@ _cairo_polygon_move_to (cairo_polygon_t *polygon, cairo_point_t *point)
 cairo_status_t
 _cairo_polygon_line_to (cairo_polygon_t *polygon, cairo_point_t *point)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
 
     if (polygon->has_current_point) {
 	status = _cairo_polygon_add_edge (polygon, &polygon->current_point, point);
     } else {
-	_cairo_polygon_move_to (polygon, point);
+	status = _cairo_polygon_move_to (polygon, point);
     }
 
     return status;
diff --git a/src/cairo-ps-surface.c b/src/cairo-ps-surface.c
index 84427e5..ea0f0f4 100644
--- a/src/cairo-ps-surface.c
+++ b/src/cairo-ps-surface.c
@@ -297,7 +297,7 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 			     cairo_line_cap_t	    line_cap)
 {
     cairo_output_stream_t *word_wrap;
-    cairo_status_t status;
+    cairo_status_t status, status2;
     ps_path_info_t path_info;
 
     word_wrap = _word_wrap_stream_create (stream, 79);
@@ -315,7 +315,9 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 
     if (status == CAIRO_STATUS_SUCCESS)
 	status = _cairo_output_stream_get_status (word_wrap);
-    _cairo_output_stream_destroy (word_wrap);
+    status2 = _cairo_output_stream_destroy (word_wrap);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
@@ -1201,7 +1203,7 @@ cairo_ps_surface_dsc_begin_page_setup (cairo_surface_t *surface)
 static cairo_status_t
 _cairo_ps_surface_finish (void *abstract_surface)
 {
-    cairo_status_t status;
+    cairo_status_t status, status2;
     cairo_ps_surface_t *surface = abstract_surface;
     int i, num_comments;
     char **comments;
@@ -1214,16 +1216,13 @@ _cairo_ps_surface_finish (void *abstract_surface)
 
     _cairo_ps_surface_emit_footer (surface);
 
-    _cairo_output_stream_close (surface->stream);
-    status = _cairo_output_stream_get_status (surface->stream);
-    _cairo_output_stream_destroy (surface->stream);
+    status = _cairo_output_stream_destroy (surface->stream);
 
     fclose (surface->tmpfile);
 
-    _cairo_output_stream_close (surface->final_stream);
+    status2 = _cairo_output_stream_destroy (surface->final_stream);
     if (status == CAIRO_STATUS_SUCCESS)
-	status = _cairo_output_stream_get_status (surface->final_stream);
-    _cairo_output_stream_destroy (surface->final_stream);
+	status = status2;
 
     num_comments = _cairo_array_num_elements (&surface->dsc_header_comments);
     comments = _cairo_array_index (&surface->dsc_header_comments, 0);
@@ -1588,20 +1587,29 @@ _cairo_ps_surface_emit_image (cairo_ps_surface_t    *surface,
 
 	_cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-	_cairo_surface_fill_rectangle (opaque,
-				       CAIRO_OPERATOR_SOURCE,
-				       CAIRO_COLOR_WHITE,
-				       0, 0, image->width, image->height);
-
-	_cairo_surface_composite (CAIRO_OPERATOR_OVER,
-				  &pattern.base,
-				  NULL,
-				  opaque,
-				  0, 0,
-				  0, 0,
-				  0, 0,
-				  image->width,
-				  image->height);
+	status = _cairo_surface_fill_rectangle (opaque,
+				                CAIRO_OPERATOR_SOURCE,
+						CAIRO_COLOR_WHITE,
+						0, 0,
+					       	image->width, image->height);
+	if (status) {
+	    _cairo_pattern_fini (&pattern.base);
+	    goto bail0;
+	}
+
+	status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+				           &pattern.base,
+					   NULL,
+					   opaque,
+					   0, 0,
+					   0, 0,
+					   0, 0,
+					   image->width,
+					   image->height);
+	if (status) {
+	    _cairo_pattern_fini (&pattern.base);
+	    goto bail0;
+	}
 
 	_cairo_pattern_fini (&pattern.base);
 	opaque_image = (cairo_image_surface_t *) opaque;
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 963c060..2391457 100644
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -357,7 +357,7 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
     _cairo_scaled_font_init_key (scaled_font, font_face,
 				 font_matrix, ctm, options);
 
-    cairo_font_face_reference (font_face);
+    font_face = cairo_font_face_reference (font_face);
 
     cairo_matrix_multiply (&scaled_font->scale,
 			   &scaled_font->font_matrix,
@@ -1197,6 +1197,7 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
 		     cairo_path_fixed_t *path)
 {
     cairo_image_surface_t *a1_mask;
+    cairo_status_t status;
     unsigned char *row, *byte_ptr, byte;
     int rows, cols, bytes_per_row;
     int x, y, bit;
@@ -1212,34 +1213,46 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
 
     cairo_surface_get_device_offset (&mask->base, &xoff, &yoff);
 
+    status = CAIRO_STATUS_SUCCESS;
     bytes_per_row = (a1_mask->width + 7) / 8;
     for (y = 0, row = a1_mask->data, rows = a1_mask->height; rows; row += a1_mask->stride, rows--, y++) {
 	for (x = 0, byte_ptr = row, cols = (a1_mask->width + 7) / 8; cols; byte_ptr++, cols--) {
 	    byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte_ptr);
 	    for (bit = 7; bit >= 0 && x < a1_mask->width; bit--, x++) {
 		if (byte & (1 << bit)) {
-		    _cairo_path_fixed_move_to (path,
-					       _cairo_fixed_from_int (x + xoff),
-					       _cairo_fixed_from_int (y + yoff));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (1),
-						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (0),
-						   _cairo_fixed_from_int (1));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (-1),
-						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_close_path (path);
+		    status = _cairo_path_fixed_move_to (path,
+					      _cairo_fixed_from_int (x + xoff),
+					      _cairo_fixed_from_int (y + yoff));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (1),
+						     _cairo_fixed_from_int (0));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (0),
+						     _cairo_fixed_from_int (1));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (-1),
+						     _cairo_fixed_from_int (0));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_close_path (path);
+		    if (status)
+			goto BAIL;
 		}
 	    }
 	}
     }
 
+BAIL:
     if (a1_mask != mask)
 	cairo_surface_destroy (&a1_mask->base);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..9a1a844 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -452,8 +452,11 @@ _composite_trap_region (cairo_clip_t            *clip,
 				       extents->width, extents->height);
 
     /* Restore the original clip if we modified it temporarily. */
-    if (num_rects >1)
-	_cairo_surface_set_clip (dst, clip);
+    if (num_rects > 1) {
+	cairo_status_t status2 = _cairo_surface_set_clip (dst, clip);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = status2;
+    }
 
     if (clip_surface)
       _cairo_pattern_fini (&mask.base);
@@ -979,17 +982,21 @@ _cairo_surface_fallback_snapshot (cairo_surface_t *surface)
 
     _cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
-			      &pattern.base,
-			      NULL,
-			      snapshot,
-			      0, 0,
-			      0, 0,
-			      0, 0,
-			      image->width,
-			      image->height);
+    status = _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
+			               &pattern.base,
+				       NULL,
+				       snapshot,
+				       0, 0,
+				       0, 0,
+				       0, 0,
+				       image->width,
+				       image->height);
 
     _cairo_pattern_fini (&pattern.base);
+    if (status) {
+	cairo_surface_destroy (snapshot);
+	return (cairo_surface_t *) &_cairo_surface_nil;
+    }
 
     _cairo_surface_release_source_image (surface,
 					 image, &image_extra);
@@ -1158,13 +1165,14 @@ _cairo_surface_fallback_composite_trapezoids (cairo_operator_t		op,
 	traps = offset_traps;
     }
 
-    _cairo_surface_composite_trapezoids (op, pattern,
-					 &state.image->base,
-					 antialias,
-					 src_x, src_y,
-					 dst_x - state.image_rect.x,
-					 dst_y - state.image_rect.y,
-					 width, height, traps, num_traps);
+    status = _cairo_surface_composite_trapezoids (op, pattern,
+					          &state.image->base,
+						  antialias,
+						  src_x, src_y,
+						  dst_x - state.image_rect.x,
+						  dst_y - state.image_rect.y,
+						  width, height,
+						  traps, num_traps);
     if (offset_traps)
 	free (offset_traps);
 
diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index 703017a..1c885d1 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -447,7 +447,8 @@ _cairo_svg_surface_store_page (cairo_svg_surface_t *surface)
     for (i = 0; i < page.clip_level; i++)
 	_cairo_output_stream_printf (page.xml_node, "</g>\n");
 
-    _cairo_array_append (&surface->page_set, &page);
+    if (_cairo_array_append (&surface->page_set, &page) != CAIRO_STATUS_SUCCESS)
+	return NULL;
 
     return _cairo_array_index (&surface->page_set, surface->page_set.num_elements - 1);
 }
@@ -776,7 +777,7 @@ _cairo_svg_surface_create_similar (void			*abstract_src,
 static cairo_status_t
 _cairo_svg_surface_finish (void *abstract_surface)
 {
-    cairo_status_t status;
+    cairo_status_t status, status2;
     cairo_svg_surface_t *surface = abstract_surface;
     cairo_svg_document_t *document = surface->document;
     cairo_svg_page_t *page;
@@ -787,11 +788,15 @@ _cairo_svg_surface_finish (void *abstract_surface)
     else
 	status = CAIRO_STATUS_SUCCESS;
 
-    _cairo_output_stream_destroy (surface->xml_node);
+    status2 = _cairo_output_stream_destroy (surface->xml_node);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     for (i = 0; i < surface->page_set.num_elements; i++) {
 	page = _cairo_array_index (&surface->page_set, i);
-	_cairo_output_stream_destroy (page->xml_node);
+	status2 = _cairo_output_stream_destroy (page->xml_node);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = status2;
     }
     _cairo_array_fini (&surface->page_set);
 
@@ -941,7 +946,9 @@ _cairo_svg_surface_emit_composite_image_pattern (cairo_output_stream_t     *outp
 	return status;
 
     p2u = pattern->base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     if (pattern_id != invalid_pattern_id) {
 	_cairo_output_stream_printf (output,
@@ -1075,15 +1082,18 @@ _cairo_svg_surface_emit_composite_meta_pattern (cairo_output_stream_t	*output,
     cairo_svg_document_t *document = surface->document;
     cairo_meta_surface_t *meta_surface;
     cairo_matrix_t p2u;
+    cairo_status_t status;
     int id;
 
+    p2u = pattern->base.matrix;
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
+
     meta_surface = (cairo_meta_surface_t *) pattern->surface;
 
     id = _cairo_svg_surface_emit_meta_surface (document, meta_surface);
 
-    p2u = pattern->base.matrix;
-    cairo_matrix_invert (&p2u);
-
     if (pattern_id != invalid_pattern_id) {
 	_cairo_output_stream_printf (output,
 				     "<pattern id=\"pattern%d\" "
@@ -1375,6 +1385,12 @@ _cairo_svg_surface_emit_linear_pattern (cairo_svg_surface_t    *surface,
     cairo_svg_document_t *document = surface->document;
     double x0, y0, x1, y1;
     cairo_matrix_t p2u;
+    cairo_status_t status;
+
+    p2u = pattern->base.base.matrix;
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     x0 = _cairo_fixed_to_double (pattern->gradient.p1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.p1.y);
@@ -1389,8 +1405,6 @@ _cairo_svg_surface_emit_linear_pattern (cairo_svg_surface_t    *surface,
 				 x0, y0, x1, y1);
 
     _cairo_svg_surface_emit_pattern_extend (document->xml_node_defs, &pattern->base.base),
-    p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
     _cairo_svg_surface_emit_transform (document->xml_node_defs, "gradientTransform", ">\n", &p2u);
 
     _cairo_svg_surface_emit_pattern_stops (document->xml_node_defs ,&pattern->base, 0.0, FALSE, FALSE);
diff --git a/src/cairo-type1-fallback.c b/src/cairo-type1-fallback.c
index a183b28..eef0d73 100644
--- a/src/cairo-type1-fallback.c
+++ b/src/cairo-type1-fallback.c
@@ -558,6 +558,7 @@ cairo_type1_font_write_private_dict (cairo_type1_font_t *font,
                                      const char         *name)
 {
     cairo_int_status_t status;
+    cairo_status_t status2;
     cairo_output_stream_t *encrypted_output;
 
     font->eexec_key = CAIRO_TYPE1_PRIVATE_DICT_KEY;
@@ -597,10 +598,10 @@ cairo_type1_font_write_private_dict (cairo_type1_font_t *font,
                                  "dup /FontName get exch definefont pop\n"
                                  "mark currentfile closefile\n");
 
-    if (status == CAIRO_STATUS_SUCCESS)
-	status = _cairo_output_stream_get_status (encrypted_output);
   fail:
-    _cairo_output_stream_destroy (encrypted_output);
+    status2 = _cairo_output_stream_destroy (encrypted_output);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
diff --git a/src/cairo.c b/src/cairo.c
index 9a96dda..b8a0419 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -189,6 +189,7 @@ cairo_t *
 cairo_create (cairo_surface_t *target)
 {
     cairo_t *cr;
+    cairo_status_t status;
 
     cr = malloc (sizeof (cairo_t));
     if (cr == NULL)
@@ -201,14 +202,18 @@ cairo_create (cairo_surface_t *target)
     _cairo_user_data_array_init (&cr->user_data);
 
     cr->gstate = cr->gstate_tail;
-    _cairo_gstate_init (cr->gstate, target);
+    status = _cairo_gstate_init (cr->gstate, target);
 
     _cairo_path_fixed_init (cr->path);
 
     if (target == NULL) {
-	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
+	/* override status with user error */
+	status = CAIRO_STATUS_NULL_POINTER;
     }
 
+    if (status)
+	_cairo_set_error (cr, status);
+
     return cr;
 }
 slim_hidden_def (cairo_create);
@@ -483,9 +488,11 @@ cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
 
     parent_surface = _cairo_gstate_get_target (cr->gstate);
     /* Get the extents that we'll use in creating our new group surface */
-    _cairo_surface_get_extents (parent_surface, &extents);
+    status = _cairo_surface_get_extents (parent_surface, &extents);
+    if (status)
+	goto bail;
     status = _cairo_clip_intersect_to_rectangle (_cairo_gstate_get_clip (cr->gstate), &extents);
-    if (status != CAIRO_STATUS_SUCCESS)
+    if (status)
 	goto bail;
 
     group_surface = cairo_surface_create_similar (_cairo_gstate_get_target (cr->gstate),
@@ -563,7 +570,7 @@ cairo_pop_group (cairo_t *cr)
     /* We need to save group_surface before we restore; we don't need
      * to reference parent_target and original_target, since the
      * gstate will still hold refs to them once we restore. */
-    cairo_surface_reference (group_surface);
+    group_surface = cairo_surface_reference (group_surface);
 
     cairo_restore (cr);
 
@@ -1623,17 +1630,20 @@ void
 cairo_rel_move_to (cairo_t *cr, double dx, double dy)
 {
     cairo_fixed_t dx_fixed, dy_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 
 /**
@@ -1658,17 +1668,20 @@ void
 cairo_rel_line_to (cairo_t *cr, double dx, double dy)
 {
     cairo_fixed_t dx_fixed, dy_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 slim_hidden_def(cairo_rel_line_to);
 
@@ -1707,13 +1720,20 @@ cairo_rel_curve_to (cairo_t *cr,
     cairo_fixed_t dx1_fixed, dy1_fixed;
     cairo_fixed_t dx2_fixed, dy2_fixed;
     cairo_fixed_t dx3_fixed, dy3_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
+    if (status)
+	goto BAIL;
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
+    if (status)
+	goto BAIL;
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    if (status)
+	goto BAIL;
 
     dx1_fixed = _cairo_fixed_from_double (dx1);
     dy1_fixed = _cairo_fixed_from_double (dy1);
@@ -1724,12 +1744,14 @@ cairo_rel_curve_to (cairo_t *cr,
     dx3_fixed = _cairo_fixed_from_double (dx3);
     dy3_fixed = _cairo_fixed_from_double (dy3);
 
-    cr->status = _cairo_path_fixed_rel_curve_to (cr->path,
-						 dx1_fixed, dy1_fixed,
-						 dx2_fixed, dy2_fixed,
-						 dx3_fixed, dy3_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+    status = _cairo_path_fixed_rel_curve_to (cr->path,
+					     dx1_fixed, dy1_fixed,
+					     dx2_fixed, dy2_fixed,
+					     dx3_fixed, dy3_fixed);
+    if (status) {
+BAIL:
+	_cairo_set_error (cr, status);
+    }
 }
 
 /**
diff --git a/test/buffer-diff.c b/test/buffer-diff.c
index d111b23..abb7e33 100644
--- a/test/buffer-diff.c
+++ b/test/buffer-diff.c
@@ -339,6 +339,7 @@ image_diff_core (const char *filename_a,
 
     compare_surfaces (surface_a, surface_b, surface_diff, result);
 
+    status = CAIRO_STATUS_SUCCESS;
     if (result->pixels_changed) {
 	FILE *png_file;
 
@@ -347,7 +348,7 @@ image_diff_core (const char *filename_a,
 	else
 	    png_file = stdout;
 
-	cairo_surface_write_to_png_stream (surface_diff, stdio_write_func, png_file);
+	status = cairo_surface_write_to_png_stream (surface_diff, stdio_write_func, png_file);
 
 	if (png_file != stdout)
 	    fclose (png_file);
@@ -360,7 +361,7 @@ image_diff_core (const char *filename_a,
     cairo_surface_destroy (surface_b);
     cairo_surface_destroy (surface_diff);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Tue Mar 27 14:18:25 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Tue Mar 27 14:33:46 2007
Subject: [cairo] Add attribute(warn_unused_result)
Message-ID: <20070327211825.GA6801@inspired.chris-wilson.co.uk>

Behdad Esfahbod (behdad@behdad.org) said: 
> The only part I really displike is the "cairo_private_no_warn void".
> While cairo_private_no_warn is useful for other places too, can we have
> a cairo_private_void instead?

Fortunately for readability I found the -Wno-attributes flag.
Attached are the changes for the headers and the most trivial cleanups.
The plan is to attack the rest as a series of independent patches -
however any that are not blindingly obvious I'll defer to the intrepid
reader.

I'll leave introducing cairo_static prototypes for a future janitorial
crusade.
--
Chris Wilson
-------------- next part --------------
>From b2da8b40e9cfa16f156b5a482bcadfbf75d885f5 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 27 Mar 2007 19:15:42 +0100
Subject: [PATCH] Add attribute(warn_unused_result)

This adds a compiler check that the function result is used by the caller
and enables it by default for all cairo_private functions and for public
API that returns a cairo_status_t.

To extend the warnings to all functions, a new function type has been
introduced to cover static functions: cairo_static. The preference is
for all static code to be forward declared with a cairo_static prototype.

In order to reduce the warning spew generated by gcc for invalid use of
this attribute, -Wno-attributes is added to CFLAGS. This has the
unfortunate side-effect of masking future warnings for all attributes -
be warned!
---
 configure.in           |   13 ++++++++++++-
 pixman/configure.in    |    3 ++-
 pixman/src/Makefile.am |    1 +
 pixman/src/pixman.h    |    2 +-
 src/cairo.h            |   40 ++++++++++++++++++++--------------------
 src/cairoint.h         |   11 ++++++++---
 src/check-headers.sh   |    2 +-
 7 files changed, 45 insertions(+), 27 deletions(-)

diff --git a/configure.in b/configure.in
index 8acca66..e885b5c 100644
--- a/configure.in
+++ b/configure.in
@@ -621,7 +621,8 @@ MAYBE_WARN="-Wall -Wextra \
 -Wpacked -Wswitch-enum -Wmissing-format-attribute \
 -Wstrict-aliasing=2 -Winit-self -Wunsafe-loop-optimizations \
 -Wdeclaration-after-statement -Wold-style-definition \
--Wno-missing-field-initializers -Wno-unused-parameter"
+-Wno-missing-field-initializers -Wno-unused-parameter \
+-Wno-attributes"
 
 
 # invalidate cached value if MAYBE_WARN has changed
@@ -834,9 +835,19 @@ AC_CONFIG_COMMANDS([src/cairo-features.h],
 # define CAIRO_END_DECLS
 #endif
 
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#define CAIRO_WARN_UNUSED_RESULT 		\
+  __attribute__((__warn_unused_result__))
+#else
+#define CAIRO_WARN_UNUSED_RESULT
+#endif /* __GNUC__ */
+
 #ifndef cairo_public
 # define cairo_public
 #endif
+#ifndef cairo_public_warn
+# define cairo_public_warn CAIRO_WARN_UNUSED_RESULT
+#endif
 
 #define CAIRO_VERSION_MAJOR $CAIRO_VERSION_MAJOR
 #define CAIRO_VERSION_MINOR $CAIRO_VERSION_MINOR
diff --git a/pixman/configure.in b/pixman/configure.in
index c9cdae8..4cbb5ba 100644
--- a/pixman/configure.in
+++ b/pixman/configure.in
@@ -45,7 +45,8 @@ WARN_CFLAGS=""
 if test "x$GCC" = "xyes"; then
 	WARN_CFLAGS="-Wall -Wpointer-arith -Wstrict-prototypes \
 	-Wmissing-prototypes -Wmissing-declarations \
-	-Wnested-externs -fno-strict-aliasing"
+	-Wnested-externs -fno-strict-aliasing \
+	-Wno-attributes"
 fi
 
 AC_SUBST(WARN_CFLAGS)
diff --git a/pixman/src/Makefile.am b/pixman/src/Makefile.am
index 7b828f5..f1808e3 100644
--- a/pixman/src/Makefile.am
+++ b/pixman/src/Makefile.am
@@ -29,6 +29,7 @@ libpixman_la_SOURCES = \
 	fbcompose.c \
 	renderedge.c \
 	renderedge.h
+libpixman_la_CFLAGS = $(PIXMAN_CFLAGS)
 
 if USE_MMX
 noinst_LTLIBRARIES += libpixman-mmx.la
diff --git a/pixman/src/pixman.h b/pixman/src/pixman.h
index 9120eb6..acf5327 100644
--- a/pixman/src/pixman.h
+++ b/pixman/src/pixman.h
@@ -100,7 +100,7 @@ SOFTWARE.
 #include "pixman-remap.h"
 
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun__)
-#define pixman_private		__attribute__((__visibility__("hidden")))
+#define pixman_private		__attribute__((__visibility__("hidden"),__warn_unused_result__))
 #elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
 #define pixman_private		__hidden
 #else /* not gcc >= 3.3 and not Sun Studio >= 8 */
diff --git a/src/cairo.h b/src/cairo.h
index a80efde..5fc05e3 100644
--- a/src/cairo.h
+++ b/src/cairo.h
@@ -313,7 +313,7 @@ cairo_public void *
 cairo_get_user_data (cairo_t			 *cr,
 		     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_set_user_data (cairo_t			 *cr,
 		     const cairo_user_data_key_t *key,
 		     void			 *user_data,
@@ -972,7 +972,7 @@ cairo_font_options_copy (const cairo_font_options_t *original);
 cairo_public void
 cairo_font_options_destroy (cairo_font_options_t *options);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_options_status (cairo_font_options_t *options);
 
 cairo_public void
@@ -1088,7 +1088,7 @@ cairo_font_face_destroy (cairo_font_face_t *font_face);
 cairo_public unsigned int
 cairo_font_face_get_reference_count (cairo_font_face_t *font_face);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_face_status (cairo_font_face_t *font_face);
 
 /**
@@ -1141,7 +1141,7 @@ cairo_public void *
 cairo_font_face_get_user_data (cairo_font_face_t	   *font_face,
 			       const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_font_face_set_user_data (cairo_font_face_t	   *font_face,
 			       const cairo_user_data_key_t *key,
 			       void			   *user_data,
@@ -1164,7 +1164,7 @@ cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font);
 cairo_public unsigned int
 cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_scaled_font_status (cairo_scaled_font_t *scaled_font);
 
 cairo_public cairo_font_type_t
@@ -1174,7 +1174,7 @@ cairo_public void *
 cairo_scaled_font_get_user_data (cairo_scaled_font_t         *scaled_font,
 				 const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_scaled_font_set_user_data (cairo_scaled_font_t         *scaled_font,
 				 const cairo_user_data_key_t *key,
 				 void                        *user_data,
@@ -1392,7 +1392,7 @@ cairo_path_destroy (cairo_path_t *path);
 
 /* Error status queries */
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_status (cairo_t *cr);
 
 cairo_public const char *
@@ -1418,7 +1418,7 @@ cairo_surface_destroy (cairo_surface_t *surface);
 cairo_public unsigned int
 cairo_surface_get_reference_count (cairo_surface_t *surface);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_status (cairo_surface_t *surface);
 
 /**
@@ -1482,11 +1482,11 @@ cairo_surface_get_content (cairo_surface_t *surface);
 
 #if CAIRO_HAS_PNG_FUNCTIONS
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_write_to_png (cairo_surface_t	*surface,
 			    const char		*filename);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_write_to_png_stream (cairo_surface_t	*surface,
 				   cairo_write_func_t	write_func,
 				   void			*closure);
@@ -1497,7 +1497,7 @@ cairo_public void *
 cairo_surface_get_user_data (cairo_surface_t		 *surface,
 			     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_surface_set_user_data (cairo_surface_t		 *surface,
 			     const cairo_user_data_key_t *key,
 			     void			 *user_data,
@@ -1642,14 +1642,14 @@ cairo_pattern_destroy (cairo_pattern_t *pattern);
 cairo_public unsigned int
 cairo_pattern_get_reference_count (cairo_pattern_t *pattern);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_status (cairo_pattern_t *pattern);
 
 cairo_public void *
 cairo_pattern_get_user_data (cairo_pattern_t		 *pattern,
 			     const cairo_user_data_key_t *key);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_set_user_data (cairo_pattern_t		 *pattern,
 			     const cairo_user_data_key_t *key,
 			     void			 *user_data,
@@ -1758,32 +1758,32 @@ cairo_pattern_set_filter (cairo_pattern_t *pattern, cairo_filter_t filter);
 cairo_public cairo_filter_t
 cairo_pattern_get_filter (cairo_pattern_t *pattern);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_rgba (cairo_pattern_t *pattern,
 			double *red, double *green,
 			double *blue, double *alpha);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_surface (cairo_pattern_t *pattern,
 			   cairo_surface_t **surface);
 
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_color_stop_rgba (cairo_pattern_t *pattern,
 				   int index, double *offset,
 				   double *red, double *green,
 				   double *blue, double *alpha);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_color_stop_count (cairo_pattern_t *pattern,
 				    int *count);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_linear_points (cairo_pattern_t *pattern,
 				 double *x0, double *y0,
 				 double *x1, double *y1);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_pattern_get_radial_circles (cairo_pattern_t *pattern,
 				  double *x0, double *y0, double *r0,
 				  double *x1, double *y1, double *r1);
@@ -1820,7 +1820,7 @@ cairo_matrix_scale (cairo_matrix_t *matrix, double sx, double sy);
 cairo_public void
 cairo_matrix_rotate (cairo_matrix_t *matrix, double radians);
 
-cairo_public cairo_status_t
+cairo_public_warn cairo_status_t
 cairo_matrix_invert (cairo_matrix_t *matrix);
 
 cairo_public void
diff --git a/src/cairoint.h b/src/cairoint.h
index 1d2c3c7..ed685e6 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -103,13 +103,18 @@ CAIRO_BEGIN_DECLS
 
 /* slim_internal.h */
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
-#define cairo_private		__attribute__((__visibility__("hidden")))
+#define cairo_private			__attribute__((__visibility__("hidden"),__warn_unused_result__))
 #elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
-#define cairo_private		__hidden
+#define cairo_private			__hidden CAIRO_WARN_UNUSED_RESULT
 #else /* not gcc >= 3.3 and not Sun Studio >= 8 */
-#define cairo_private
+#define cairo_private			CAIRO_WARN_UNUSED_RESULT
 #endif
 
+/* This allows us to conditionally expose internals during debugging,
+   and forces propagation of return values.
+*/
+#define cairo_static static CAIRO_WARN_UNUSED_RESULT
+
 /* This macro allow us to deprecate a function by providing an alias
    for the old function name to the new function name. With this
    macro, binary compatibility is preserved. The macro only works on
diff --git a/src/check-headers.sh b/src/check-headers.sh
index 1d0ebf8..2ac74fd 100755
--- a/src/check-headers.sh
+++ b/src/check-headers.sh
@@ -12,7 +12,7 @@ xargs grep -B 1 '^cairo_.*[ 	]\+(' |
 awk '
 /^--$/ { context=""; public=0; next; }
 /:cairo_.*[ 	]+\(/ { if (!public) {print context; print; print "--";} next; }
-/-cairo_public[ 	]/ {public=1;}
+/-cairo_public.*[ 	]/ {public=1;}
 { context=$0; }
 ' |
 sed 's/[.]h-/.h:/' |
-- 
1.4.4.2

-------------- next part --------------
>From cfc8b86edd0660a5bcbf8b6b5c977287bc173f47 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 27 Mar 2007 21:52:37 +0100
Subject: [PATCH] Fix up the trivial warnings from warn-unused-result.

For the majority of cases of unchecked status returns the most appropiate
action is to simply propagate the status back up the chain, after
performing all apropiate cleanups.
---
 boilerplate/cairo-boilerplate.c |   10 ++++-
 src/cairo-clip.c                |   19 ++++++---
 src/cairo-ft-font.c             |   82 +++++++++++++++++++++++++-------------
 src/cairo-gstate.c              |   17 ++++++--
 src/cairo-image-surface.c       |    6 ++-
 src/cairo-meta-surface.c        |    4 +-
 src/cairo-paginated-surface.c   |   22 ++++++++---
 src/cairo-path-fill.c           |    2 +-
 src/cairo-path-stroke.c         |   54 +++++++++++++++++++------
 src/cairo-path.c                |   38 +++++++++--------
 src/cairo-pattern.c             |   10 ++++-
 src/cairo-pdf-surface.c         |   25 ++++++------
 src/cairo-pen.c                 |   24 ++++++++---
 src/cairo-polygon.c             |    8 +--
 src/cairo-ps-surface.c          |   54 +++++++++++++++-----------
 src/cairo-scaled-font.c         |   43 +++++++++++++-------
 src/cairo-surface-fallback.c    |   44 ++++++++++++--------
 src/cairo-svg-surface.c         |   34 +++++++++++-----
 src/cairo-type1-fallback.c      |    7 ++-
 src/cairo.c                     |   74 +++++++++++++++++++++++------------
 test/buffer-diff.c              |    5 +-
 21 files changed, 378 insertions(+), 204 deletions(-)

diff --git a/boilerplate/cairo-boilerplate.c b/boilerplate/cairo-boilerplate.c
index f726d42..858c5c0 100644
--- a/boilerplate/cairo-boilerplate.c
+++ b/boilerplate/cairo-boilerplate.c
@@ -1095,7 +1095,15 @@ create_ps_surface (const char			 *name,
 	ptc->target = NULL;
     }
 
-    cairo_surface_set_user_data (surface, &ps_closure_key, ptc, NULL);
+    if (cairo_surface_set_user_data (surface,
+	       	                     &ps_closure_key,
+				     ptc,
+				     NULL) != CAIRO_STATUS_SUCCESS) {
+	cairo_surface_destroy (surface);
+	free (ptc->filename);
+	free (ptc);
+	return NULL;
+    }
 
     return surface;
 }
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index efecd89..0ab036b 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -203,6 +203,8 @@ cairo_status_t
 _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 				 pixman_region16_t *region)
 {
+    pixman_region_status_t pixman_status;
+
     if (!clip)
 	return CAIRO_STATUS_SUCCESS;
 
@@ -210,12 +212,14 @@ _cairo_clip_intersect_to_region (cairo_clip_t      *clip,
 	/* Intersect clip path into region. */
     }
 
-    if (clip->region)
-	pixman_region_intersect (region, clip->region, region);
+    if (clip->region) {
+	pixman_status = pixman_region_intersect (region, clip->region, region);
+	if (pixman_status != PIXMAN_REGION_STATUS_SUCCESS)
+	    return CAIRO_STATUS_NO_MEMORY;
+    }
 
     if (clip->surface) {
 	pixman_region16_t *clip_rect;
-	pixman_region_status_t pixman_status;
 	cairo_status_t status = CAIRO_STATUS_SUCCESS;
 
 	clip_rect = _cairo_region_create_from_rectangle (&clip->surface_rect);
@@ -635,10 +639,11 @@ _cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate)
         }
     } else {
         cairo_rectangle_int16_t extents;
-        _cairo_surface_get_extents (_cairo_gstate_get_target (gstate), &extents);
-        if (!_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
-                                      extents.width, extents.height,
-                                      rectangles)) {
+        if (_cairo_surface_get_extents (_cairo_gstate_get_target (gstate),
+		                        &extents) != CAIRO_STATUS_SUCCESS ||
+		!_cairo_clip_rect_to_user(gstate, extents.x, extents.y,
+                                          extents.width, extents.height,
+                                          rectangles)) {
             free (rectangles);
             return (cairo_rectangle_list_t*)
                 &_cairo_rectangles_not_representable;
diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index 7f10fd7..73a40f8 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -1154,24 +1154,33 @@ _transform_glyph_bitmap (cairo_matrix_t         * shape,
 
     /* Initialize it to empty
      */
-    _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
-				   CAIRO_COLOR_TRANSPARENT,
-				   0, 0,
-				   width, height);
+    status = _cairo_surface_fill_rectangle (image, CAIRO_OPERATOR_CLEAR,
+				            CAIRO_COLOR_TRANSPARENT,
+					    0, 0,
+					    width, height);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     /* Draw the original bitmap transformed into the new bitmap
      */
     _cairo_pattern_init_for_surface (&pattern, &(*surface)->base);
     cairo_pattern_set_matrix (&pattern.base, &transformed_to_original);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_OVER,
-			      &pattern.base, NULL, image,
-			      0, 0, 0, 0, 0, 0,
-			      width,
-			      height);
+    status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+			               &pattern.base, NULL, image,
+				       0, 0, 0, 0, 0, 0,
+				       width,
+				       height);
 
     _cairo_pattern_fini (&pattern.base);
 
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
+
     /* Now update the cache entry for the new bitmap, recomputing
      * the origin based on the final transform.
      */
@@ -1421,6 +1430,7 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
     FT_Face face;
     FT_Size_Metrics *metrics;
     cairo_font_extents_t fs_metrics;
+    cairo_status_t status;
 
     face = _cairo_ft_unscaled_font_lock_face (unscaled);
     if (!face)
@@ -1441,10 +1451,15 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
     _cairo_font_options_init_copy (&scaled_font->ft_options.base, options);
     _cairo_ft_options_merge (&scaled_font->ft_options, &ft_options);
 
-    _cairo_scaled_font_init (&scaled_font->base,
-			     font_face,
-			     font_matrix, ctm, options,
-			     &cairo_ft_scaled_font_backend);
+    status = _cairo_scaled_font_init (&scaled_font->base,
+			              font_face,
+				      font_matrix, ctm, options,
+				      &cairo_ft_scaled_font_backend);
+    if (status) {
+	free (scaled_font);
+	_cairo_ft_unscaled_font_unlock_face (unscaled);
+	return NULL;
+    }
 
     _cairo_ft_unscaled_font_set_scale (unscaled,
 				       &scaled_font->base.scale);
@@ -1620,8 +1635,10 @@ _move_to (FT_Vector *to, void *closure)
     x = _cairo_fixed_from_26_6 (to->x);
     y = _cairo_fixed_from_26_6 (to->y);
 
-    _cairo_path_fixed_close_path (path);
-    _cairo_path_fixed_move_to (path, x, y);
+    if (_cairo_path_fixed_close_path (path) != CAIRO_STATUS_SUCCESS)
+	return 1;
+    if (_cairo_path_fixed_move_to (path, x, y) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1635,7 +1652,8 @@ _line_to (FT_Vector *to, void *closure)
     x = _cairo_fixed_from_26_6 (to->x);
     y = _cairo_fixed_from_26_6 (to->y);
 
-    _cairo_path_fixed_line_to (path, x, y);
+    if (_cairo_path_fixed_line_to (path, x, y) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1651,7 +1669,9 @@ _conic_to (FT_Vector *control, FT_Vector *to, void *closure)
     cairo_fixed_t x3, y3;
     cairo_point_t conic;
 
-    _cairo_path_fixed_get_current_point (path, &x0, &y0);
+    if (_cairo_path_fixed_get_current_point (path, &x0, &y0) !=
+	    CAIRO_STATUS_SUCCESS)
+	return 1;
 
     conic.x = _cairo_fixed_from_26_6 (control->x);
     conic.y = _cairo_fixed_from_26_6 (control->y);
@@ -1665,10 +1685,11 @@ _conic_to (FT_Vector *control, FT_Vector *to, void *closure)
     x2 = x3 + 2.0/3.0 * (conic.x - x3);
     y2 = y3 + 2.0/3.0 * (conic.y - y3);
 
-    _cairo_path_fixed_curve_to (path,
-				x1, y1,
-				x2, y2,
-				x3, y3);
+    if (_cairo_path_fixed_curve_to (path,
+				    x1, y1,
+				    x2, y2,
+				    x3, y3) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1691,10 +1712,11 @@ _cubic_to (FT_Vector *control1, FT_Vector *control2,
     x2 = _cairo_fixed_from_26_6 (to->x);
     y2 = _cairo_fixed_from_26_6 (to->y);
 
-    _cairo_path_fixed_curve_to (path,
-				x0, y0,
-				x1, y1,
-				x2, y2);
+    if (_cairo_path_fixed_curve_to (path,
+				    x0, y0,
+				    x1, y1,
+				    x2, y2) != CAIRO_STATUS_SUCCESS)
+	return 1;
 
     return 0;
 }
@@ -1719,6 +1741,7 @@ _decompose_glyph_outline (FT_Face		  face,
 
     FT_GlyphSlot glyph;
     cairo_path_fixed_t *path;
+    cairo_status_t status;
 
     path = _cairo_path_fixed_create ();
     if (!path)
@@ -1726,15 +1749,18 @@ _decompose_glyph_outline (FT_Face		  face,
 
     glyph = face->glyph;
 
+    status = CAIRO_STATUS_SUCCESS;
     /* Font glyphs have an inverted Y axis compared to cairo. */
     FT_Outline_Transform (&glyph->outline, &invert_y);
-    FT_Outline_Decompose (&glyph->outline, &outline_funcs, path);
+    if (FT_Outline_Decompose (&glyph->outline, &outline_funcs, path))
+	status = CAIRO_STATUS_NO_MEMORY;
 
     _cairo_path_fixed_close_path (path);
 
-    *pathp = path;
+    if (status == CAIRO_STATUS_SUCCESS)
+	*pathp = path;
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 /*
diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index 377871e..5647f9c 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -64,6 +64,7 @@ cairo_status_t
 _cairo_gstate_init (cairo_gstate_t  *gstate,
 		    cairo_surface_t *target)
 {
+    cairo_status_t status;
     gstate->next = NULL;
 
     gstate->op = CAIRO_GSTATE_OPERATOR_DEFAULT;
@@ -90,7 +91,9 @@ _cairo_gstate_init (cairo_gstate_t  *gstate,
     gstate->parent_target = NULL;
     gstate->original_target = cairo_surface_reference (target);
 
-    _cairo_gstate_identity_matrix (gstate);
+    status = _cairo_gstate_identity_matrix (gstate);
+    if (status)
+	return status;
     gstate->source_ctm_inverse = gstate->ctm_inverse;
 
     gstate->source = _cairo_pattern_create_solid (CAIRO_COLOR_BLACK);
@@ -405,7 +408,7 @@ _cairo_gstate_set_source (cairo_gstate_t  *gstate,
     if (source->status)
 	return source->status;
 
-    cairo_pattern_reference (source);
+    source = cairo_pattern_reference (source);
     cairo_pattern_destroy (gstate->source);
     gstate->source = source;
     gstate->source_ctm_inverse = gstate->ctm_inverse;
@@ -650,13 +653,16 @@ _cairo_gstate_transform (cairo_gstate_t	      *gstate,
 			 const cairo_matrix_t *matrix)
 {
     cairo_matrix_t tmp;
+    cairo_status_t status;
 
     _cairo_gstate_unset_scaled_font (gstate);
 
     tmp = *matrix;
     cairo_matrix_multiply (&gstate->ctm, &tmp, &gstate->ctm);
 
-    cairo_matrix_invert (&tmp);
+    status = cairo_matrix_invert (&tmp);
+    if (status)
+	return status;
     cairo_matrix_multiply (&gstate->ctm_inverse, &gstate->ctm_inverse, &tmp);
 
     return CAIRO_STATUS_SUCCESS;
@@ -1257,12 +1263,15 @@ _cairo_gstate_select_font_face (cairo_gstate_t       *gstate,
 				cairo_font_weight_t   weight)
 {
     cairo_font_face_t *font_face;
+    cairo_status_t status;
 
     font_face = _cairo_toy_font_face_create (family, slant, weight);
     if (font_face->status)
 	return font_face->status;
 
-    _cairo_gstate_set_font_face (gstate, font_face);
+    status = _cairo_gstate_set_font_face (gstate, font_face);
+    if (status)
+	return status;
     cairo_font_face_destroy (font_face);
 
     return CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-image-surface.c b/src/cairo-image-surface.c
index 6279012..3062533 100644
--- a/src/cairo-image-surface.c
+++ b/src/cairo-image-surface.c
@@ -690,7 +690,8 @@ _cairo_image_surface_set_matrix (cairo_image_surface_t	*surface,
 
     _cairo_matrix_to_pixman_matrix (matrix, &pixman_transform);
 
-    pixman_image_set_transform (surface->pixman_image, &pixman_transform);
+    if (pixman_image_set_transform (surface->pixman_image, &pixman_transform))
+	return CAIRO_STATUS_NO_MEMORY;
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -1047,7 +1048,8 @@ _cairo_image_surface_set_clip_region (void *abstract_surface,
 {
     cairo_image_surface_t *surface = (cairo_image_surface_t *) abstract_surface;
 
-    pixman_image_set_clip_region (surface->pixman_image, region);
+    if (pixman_image_set_clip_region (surface->pixman_image, region))
+	return CAIRO_STATUS_NO_MEMORY;
 
     surface->has_clip = region != NULL;
 
diff --git a/src/cairo-meta-surface.c b/src/cairo-meta-surface.c
index e196df2..7bbdc39 100644
--- a/src/cairo-meta-surface.c
+++ b/src/cairo-meta-surface.c
@@ -668,7 +668,9 @@ _cairo_meta_surface_replay (cairo_surface_t *surface,
 
 	dev_path = _cairo_command_get_path (command);
 	if (dev_path && has_device_transform) {
-	    _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    status = _cairo_path_fixed_init_copy (&path_copy, dev_path);
+	    if (status)
+		break;
 	    _cairo_path_fixed_device_transform (&path_copy, device_transform);
 	    dev_path = &path_copy;
 	}
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index c8e4612..e6702b7 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -201,15 +201,22 @@ _cairo_paginated_surface_acquire_source_image (void	       *abstract_surface,
 {
     cairo_paginated_surface_t *surface = abstract_surface;
     cairo_surface_t *image;
+    cairo_status_t status;
     cairo_rectangle_int16_t extents;
 
-    _cairo_surface_get_extents (surface->target, &extents);
+    status = _cairo_surface_get_extents (surface->target, &extents);
+    if (status)
+	return status;
 
     image = _cairo_paginated_surface_create_image_surface (surface,
 							   extents.width,
 							   extents.height);
 
-    _cairo_meta_surface_replay (surface->meta, image);
+    status = _cairo_meta_surface_replay (surface->meta, image);
+    if (status) {
+	cairo_surface_destroy (image);
+	return status;
+    }
 
     *image_out = (cairo_image_surface_t*) image;
     *image_extra = NULL;
@@ -257,26 +264,29 @@ _paint_page (cairo_paginated_surface_t *surface)
 							       surface->height * y_scale);
 	_cairo_surface_set_device_scale (image, x_scale, y_scale);
 
-	_cairo_meta_surface_replay (surface->meta, image);
+	status = _cairo_meta_surface_replay (surface->meta, image);
+	if (status)
+	    goto CLEANUP_IMAGE;
 
 	pattern = cairo_pattern_create_for_surface (image);
 	cairo_matrix_init_scale (&matrix, x_scale, y_scale);
 	cairo_pattern_set_matrix (pattern, &matrix);
 
-	_cairo_surface_paint (surface->target, CAIRO_OPERATOR_SOURCE, pattern);
+	status = _cairo_surface_paint (surface->target, CAIRO_OPERATOR_SOURCE, pattern);
 
 	cairo_pattern_destroy (pattern);
 
+CLEANUP_IMAGE:
 	cairo_surface_destroy (image);
     }
     else
     {
-	_cairo_meta_surface_replay (surface->meta, surface->target);
+	status = _cairo_meta_surface_replay (surface->meta, surface->target);
     }
 
     cairo_surface_destroy (analysis);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
diff --git a/src/cairo-path-fill.c b/src/cairo-path-fill.c
index b1b7a12..d2a9118 100644
--- a/src/cairo-path-fill.c
+++ b/src/cairo-path-fill.c
@@ -138,7 +138,7 @@ _cairo_filler_curve_to (void *closure,
     if (status == CAIRO_INT_STATUS_DEGENERATE)
 	return CAIRO_STATUS_SUCCESS;
 
-    _cairo_spline_decompose (&spline, filler->tolerance);
+    status = _cairo_spline_decompose (&spline, filler->tolerance);
     if (status)
 	goto CLEANUP_SPLINE;
 
diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index 09bafbf..3aeb41f 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -205,6 +205,7 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 {
     int			clockwise = _cairo_stroker_face_clockwise (out, in);
     cairo_point_t	*inpt, *outpt;
+    cairo_status_t status;
 
     if (in->cw.x == out->cw.x
 	&& in->cw.y == out->cw.y
@@ -231,13 +232,21 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 
 	tri[0] = in->point;
 	if (clockwise) {
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = -1;
-	    _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_ccw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	} else {
-	    _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &in->dev_vector, &start);
+	    if (status)
+		return status;
 	    step = +1;
-	    _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    status = _cairo_pen_find_active_cw_vertex_index (pen, &out->dev_vector, &stop);
+	    if (status)
+		return status;
 	}
 
 	i = start;
@@ -245,7 +254,9 @@ _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_st
 	while (i != stop) {
 	    tri[2] = in->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	    i += step;
 	    if (i < 0)
@@ -378,17 +389,23 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	cairo_pen_t *pen = &stroker->pen;
 
 	slope = f->dev_vector;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &start);
+	if (status)
+	    return status;
 	slope.dx = -slope.dx;
 	slope.dy = -slope.dy;
-	_cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	status = _cairo_pen_find_active_cw_vertex_index (pen, &slope, &stop);
+	if (status)
+	    return status;
 
 	tri[0] = f->point;
 	tri[1] = f->cw;
 	for (i=start; i != stop; i = (i+1) % pen->num_vertices) {
 	    tri[2] = f->point;
 	    _translate_point (&tri[2], &pen->vertices[i].point);
-	    _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    status = _cairo_traps_tessellate_triangle (stroker->traps, tri);
+	    if (status)
+		return status;
 	    tri[1] = tri[2];
 	}
 	tri[2] = f->ccw;
@@ -414,13 +431,24 @@ _cairo_stroker_add_cap (cairo_stroker_t *stroker, cairo_stroke_face_t *f)
 	ocw.y = f->cw.y + fvector.dy;
 
 	_cairo_polygon_init (&polygon);
-	_cairo_polygon_move_to (&polygon, &f->cw);
-	_cairo_polygon_line_to (&polygon, &ocw);
-	_cairo_polygon_line_to (&polygon, &occw);
-	_cairo_polygon_line_to (&polygon, &f->ccw);
-	_cairo_polygon_close (&polygon);
+	status = _cairo_polygon_move_to (&polygon, &f->cw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &ocw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &occw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_line_to (&polygon, &f->ccw);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
+	status = _cairo_polygon_close (&polygon);
+	if (status)
+	    goto CLEANUP_LINE_CAP_SQUARE;
 
 	status = _cairo_bentley_ottmann_tessellate_polygon (stroker->traps, &polygon, CAIRO_FILL_RULE_WINDING);
+CLEANUP_LINE_CAP_SQUARE:
 	_cairo_polygon_fini (&polygon);
 
 	return status;
diff --git a/src/cairo-path.c b/src/cairo-path.c
index d79454c..95fe99c 100644
--- a/src/cairo-path.c
+++ b/src/cairo-path.c
@@ -141,15 +141,16 @@ _cairo_path_count (cairo_path_t		*path,
     cpc.current_point.x = 0;
     cpc.current_point.y = 0;
 
-    _cairo_path_fixed_interpret (path_fixed,
-				 CAIRO_DIRECTION_FORWARD,
-				 _cpc_move_to,
-				 _cpc_line_to,
-				 flatten ?
-				 _cpc_curve_to_flatten :
-				 _cpc_curve_to,
-				 _cpc_close_path,
-				 &cpc);
+    if (_cairo_path_fixed_interpret (path_fixed,
+				     CAIRO_DIRECTION_FORWARD,
+				     _cpc_move_to,
+				     _cpc_line_to,
+				     flatten ?
+				     _cpc_curve_to_flatten :
+				     _cpc_curve_to,
+				     _cpc_close_path,
+				     &cpc) != CAIRO_STATUS_SUCCESS)
+	return 0;
 
     return cpc.count;
 }
@@ -318,15 +319,16 @@ _cairo_path_populate (cairo_path_t		*path,
     cpp.current_point.x = 0;
     cpp.current_point.y = 0;
 
-    _cairo_path_fixed_interpret (path_fixed,
-				 CAIRO_DIRECTION_FORWARD,
-				 _cpp_move_to,
-				 _cpp_line_to,
-				 flatten ?
-				 _cpp_curve_to_flatten :
-				 _cpp_curve_to,
-				 _cpp_close_path,
-				 &cpp);
+    if (_cairo_path_fixed_interpret (path_fixed,
+				     CAIRO_DIRECTION_FORWARD,
+				     _cpp_move_to,
+				     _cpp_line_to,
+				     flatten ?
+				     _cpp_curve_to_flatten :
+				     _cpp_curve_to,
+				     _cpp_close_path,
+				     &cpp) != CAIRO_STATUS_SUCCESS)
+	return; /* XXX propagate status */
 
     /* Sanity check the count */
     assert (cpp.data - path->data == path->num_data);
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index 2bc5580..3001e10 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -1191,7 +1191,11 @@ _cairo_pattern_acquire_surface_for_gradient (cairo_gradient_pattern_t *pattern,
     pixman_image_set_filter (pixman_image, PIXMAN_FILTER_BILINEAR);
 
     _cairo_matrix_to_pixman_matrix (&pattern->base.matrix, &pixman_transform);
-    pixman_image_set_transform (pixman_image, &pixman_transform);
+    if (pixman_image_set_transform (pixman_image, &pixman_transform)) {
+	cairo_surface_destroy (&image->base);
+	pixman_image_destroy (pixman_image);
+	return CAIRO_STATUS_NO_MEMORY;
+    }
 
     switch (pattern->base.extend) {
     case CAIRO_EXTEND_NONE:
@@ -1755,7 +1759,9 @@ _cairo_pattern_get_extents (cairo_pattern_t         *pattern,
 	    return status;
 
 	imatrix = pattern->matrix;
-	cairo_matrix_invert (&imatrix);
+	status = cairo_matrix_invert (&imatrix);
+	if (status)
+	    return status;
 
 	/* XXX Use _cairo_matrix_transform_bounding_box here */
 	for (sy = 0; sy <= 1; sy++) {
diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 3e8375f..67cfbc6 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -900,7 +900,9 @@ _cairo_pdf_surface_emit_surface_pattern (cairo_pdf_surface_t	*surface,
     if (status)
 	goto BAIL;
 
-    _cairo_surface_get_extents (&surface->base, &surface_extents);
+    status = _cairo_surface_get_extents (&surface->base, &surface_extents);
+    if (status)
+	goto BAIL;
 
     switch (extend) {
     /* We implement EXTEND_PAD like EXTEND_NONE for now */
@@ -1253,6 +1255,7 @@ _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radi
     cairo_pdf_resource_t function, pattern_resource, alpha;
     double x0, y0, x1, y1, r0, r1;
     cairo_matrix_t p2u;
+    cairo_status_t status;
 
     _cairo_pdf_surface_pause_content_stream (surface);
 
@@ -1261,7 +1264,9 @@ _cairo_pdf_surface_emit_radial_pattern (cairo_pdf_surface_t *surface, cairo_radi
 	return CAIRO_STATUS_NO_MEMORY;
 
     p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     x0 = _cairo_fixed_to_double (pattern->gradient.c1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.c1.y);
@@ -1822,11 +1827,11 @@ _cairo_pdf_surface_emit_cff_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_cff_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_status_t
@@ -1931,9 +1936,7 @@ _cairo_pdf_surface_emit_type1_font (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 #if CAIRO_HAS_FT_FONT
@@ -2102,11 +2105,11 @@ _cairo_pdf_surface_emit_truetype_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
+    status = _cairo_array_append (&surface->fonts, &font);
 
     _cairo_truetype_subset_fini (&subset);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 static cairo_int_status_t
@@ -2387,9 +2390,7 @@ _cairo_pdf_surface_emit_type3_font_subset (cairo_pdf_surface_t		*surface,
     font.font_id = font_subset->font_id;
     font.subset_id = font_subset->subset_id;
     font.subset_resource = subset_resource;
-    _cairo_array_append (&surface->fonts, &font);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_array_append (&surface->fonts, &font);
 }
 
 static void
diff --git a/src/cairo-pen.c b/src/cairo-pen.c
index 1af8c36..1bc096b 100644
--- a/src/cairo-pen.c
+++ b/src/cairo-pen.c
@@ -135,6 +135,7 @@ cairo_status_t
 _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
 {
     cairo_pen_vertex_t *vertices;
+    cairo_status_t status;
     int num_vertices;
     int i;
 
@@ -150,7 +151,9 @@ _cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points)
     for (i=0; i < num_points; i++)
 	pen->vertices[pen->num_vertices-num_points+i].point = point[i];
 
-    _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    status = _cairo_hull_compute (pen->vertices, &pen->num_vertices);
+    if (status)
+	return status;
 
     _cairo_pen_compute_slopes (pen);
 
@@ -388,7 +391,11 @@ _cairo_pen_stroke_spline_half (cairo_pen_t *pen,
 	final_slope.dy = -final_slope.dy;
     }
 
-    _cairo_pen_find_active_cw_vertex_index (pen, &initial_slope, &active);
+    status = _cairo_pen_find_active_cw_vertex_index (pen,
+	                                             &initial_slope,
+						     &active);
+    if (status)
+	return status;
 
     i = start;
     while (i != stop) {
@@ -437,18 +444,21 @@ _cairo_pen_stroke_spline (cairo_pen_t		*pen,
 
     status = _cairo_spline_decompose (spline, tolerance);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_FORWARD, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
     status = _cairo_pen_stroke_spline_half (pen, spline, CAIRO_DIRECTION_REVERSE, &polygon);
     if (status)
-	return status;
+	goto BAIL;
 
-    _cairo_polygon_close (&polygon);
-    _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
+    status = _cairo_polygon_close (&polygon);
+    if (status)
+	goto BAIL;
+    status = _cairo_bentley_ottmann_tessellate_polygon (traps, &polygon, CAIRO_FILL_RULE_WINDING);
+BAIL:
     _cairo_polygon_fini (&polygon);
 
     return CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-polygon.c b/src/cairo-polygon.c
index f36bc71..84be855 100644
--- a/src/cairo-polygon.c
+++ b/src/cairo-polygon.c
@@ -135,9 +135,7 @@ _cairo_polygon_add_edge (cairo_polygon_t *polygon, cairo_point_t *p1, cairo_poin
     polygon->num_edges++;
 
   DONE:
-    _cairo_polygon_move_to (polygon, p2);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_polygon_move_to (polygon, p2);
 }
 
 cairo_status_t
@@ -154,12 +152,12 @@ _cairo_polygon_move_to (cairo_polygon_t *polygon, cairo_point_t *point)
 cairo_status_t
 _cairo_polygon_line_to (cairo_polygon_t *polygon, cairo_point_t *point)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
 
     if (polygon->has_current_point) {
 	status = _cairo_polygon_add_edge (polygon, &polygon->current_point, point);
     } else {
-	_cairo_polygon_move_to (polygon, point);
+	status = _cairo_polygon_move_to (polygon, point);
     }
 
     return status;
diff --git a/src/cairo-ps-surface.c b/src/cairo-ps-surface.c
index 84427e5..ea0f0f4 100644
--- a/src/cairo-ps-surface.c
+++ b/src/cairo-ps-surface.c
@@ -297,7 +297,7 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 			     cairo_line_cap_t	    line_cap)
 {
     cairo_output_stream_t *word_wrap;
-    cairo_status_t status;
+    cairo_status_t status, status2;
     ps_path_info_t path_info;
 
     word_wrap = _word_wrap_stream_create (stream, 79);
@@ -315,7 +315,9 @@ _cairo_ps_surface_emit_path (cairo_ps_surface_t	   *surface,
 
     if (status == CAIRO_STATUS_SUCCESS)
 	status = _cairo_output_stream_get_status (word_wrap);
-    _cairo_output_stream_destroy (word_wrap);
+    status2 = _cairo_output_stream_destroy (word_wrap);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
@@ -1201,7 +1203,7 @@ cairo_ps_surface_dsc_begin_page_setup (cairo_surface_t *surface)
 static cairo_status_t
 _cairo_ps_surface_finish (void *abstract_surface)
 {
-    cairo_status_t status;
+    cairo_status_t status, status2;
     cairo_ps_surface_t *surface = abstract_surface;
     int i, num_comments;
     char **comments;
@@ -1214,16 +1216,13 @@ _cairo_ps_surface_finish (void *abstract_surface)
 
     _cairo_ps_surface_emit_footer (surface);
 
-    _cairo_output_stream_close (surface->stream);
-    status = _cairo_output_stream_get_status (surface->stream);
-    _cairo_output_stream_destroy (surface->stream);
+    status = _cairo_output_stream_destroy (surface->stream);
 
     fclose (surface->tmpfile);
 
-    _cairo_output_stream_close (surface->final_stream);
+    status2 = _cairo_output_stream_destroy (surface->final_stream);
     if (status == CAIRO_STATUS_SUCCESS)
-	status = _cairo_output_stream_get_status (surface->final_stream);
-    _cairo_output_stream_destroy (surface->final_stream);
+	status = status2;
 
     num_comments = _cairo_array_num_elements (&surface->dsc_header_comments);
     comments = _cairo_array_index (&surface->dsc_header_comments, 0);
@@ -1588,20 +1587,29 @@ _cairo_ps_surface_emit_image (cairo_ps_surface_t    *surface,
 
 	_cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-	_cairo_surface_fill_rectangle (opaque,
-				       CAIRO_OPERATOR_SOURCE,
-				       CAIRO_COLOR_WHITE,
-				       0, 0, image->width, image->height);
-
-	_cairo_surface_composite (CAIRO_OPERATOR_OVER,
-				  &pattern.base,
-				  NULL,
-				  opaque,
-				  0, 0,
-				  0, 0,
-				  0, 0,
-				  image->width,
-				  image->height);
+	status = _cairo_surface_fill_rectangle (opaque,
+				                CAIRO_OPERATOR_SOURCE,
+						CAIRO_COLOR_WHITE,
+						0, 0,
+					       	image->width, image->height);
+	if (status) {
+	    _cairo_pattern_fini (&pattern.base);
+	    goto bail0;
+	}
+
+	status = _cairo_surface_composite (CAIRO_OPERATOR_OVER,
+				           &pattern.base,
+					   NULL,
+					   opaque,
+					   0, 0,
+					   0, 0,
+					   0, 0,
+					   image->width,
+					   image->height);
+	if (status) {
+	    _cairo_pattern_fini (&pattern.base);
+	    goto bail0;
+	}
 
 	_cairo_pattern_fini (&pattern.base);
 	opaque_image = (cairo_image_surface_t *) opaque;
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 963c060..2391457 100644
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -357,7 +357,7 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
     _cairo_scaled_font_init_key (scaled_font, font_face,
 				 font_matrix, ctm, options);
 
-    cairo_font_face_reference (font_face);
+    font_face = cairo_font_face_reference (font_face);
 
     cairo_matrix_multiply (&scaled_font->scale,
 			   &scaled_font->font_matrix,
@@ -1197,6 +1197,7 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
 		     cairo_path_fixed_t *path)
 {
     cairo_image_surface_t *a1_mask;
+    cairo_status_t status;
     unsigned char *row, *byte_ptr, byte;
     int rows, cols, bytes_per_row;
     int x, y, bit;
@@ -1212,34 +1213,46 @@ _trace_mask_to_path (cairo_image_surface_t *mask,
 
     cairo_surface_get_device_offset (&mask->base, &xoff, &yoff);
 
+    status = CAIRO_STATUS_SUCCESS;
     bytes_per_row = (a1_mask->width + 7) / 8;
     for (y = 0, row = a1_mask->data, rows = a1_mask->height; rows; row += a1_mask->stride, rows--, y++) {
 	for (x = 0, byte_ptr = row, cols = (a1_mask->width + 7) / 8; cols; byte_ptr++, cols--) {
 	    byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (*byte_ptr);
 	    for (bit = 7; bit >= 0 && x < a1_mask->width; bit--, x++) {
 		if (byte & (1 << bit)) {
-		    _cairo_path_fixed_move_to (path,
-					       _cairo_fixed_from_int (x + xoff),
-					       _cairo_fixed_from_int (y + yoff));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (1),
-						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (0),
-						   _cairo_fixed_from_int (1));
-		    _cairo_path_fixed_rel_line_to (path,
-						   _cairo_fixed_from_int (-1),
-						   _cairo_fixed_from_int (0));
-		    _cairo_path_fixed_close_path (path);
+		    status = _cairo_path_fixed_move_to (path,
+					      _cairo_fixed_from_int (x + xoff),
+					      _cairo_fixed_from_int (y + yoff));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (1),
+						     _cairo_fixed_from_int (0));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (0),
+						     _cairo_fixed_from_int (1));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_rel_line_to (path,
+						     _cairo_fixed_from_int (-1),
+						     _cairo_fixed_from_int (0));
+		    if (status)
+			goto BAIL;
+		    status = _cairo_path_fixed_close_path (path);
+		    if (status)
+			goto BAIL;
 		}
 	    }
 	}
     }
 
+BAIL:
     if (a1_mask != mask)
 	cairo_surface_destroy (&a1_mask->base);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
diff --git a/src/cairo-surface-fallback.c b/src/cairo-surface-fallback.c
index 1a7d666..9a1a844 100644
--- a/src/cairo-surface-fallback.c
+++ b/src/cairo-surface-fallback.c
@@ -452,8 +452,11 @@ _composite_trap_region (cairo_clip_t            *clip,
 				       extents->width, extents->height);
 
     /* Restore the original clip if we modified it temporarily. */
-    if (num_rects >1)
-	_cairo_surface_set_clip (dst, clip);
+    if (num_rects > 1) {
+	cairo_status_t status2 = _cairo_surface_set_clip (dst, clip);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = status2;
+    }
 
     if (clip_surface)
       _cairo_pattern_fini (&mask.base);
@@ -979,17 +982,21 @@ _cairo_surface_fallback_snapshot (cairo_surface_t *surface)
 
     _cairo_pattern_init_for_surface (&pattern.surface, &image->base);
 
-    _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
-			      &pattern.base,
-			      NULL,
-			      snapshot,
-			      0, 0,
-			      0, 0,
-			      0, 0,
-			      image->width,
-			      image->height);
+    status = _cairo_surface_composite (CAIRO_OPERATOR_SOURCE,
+			               &pattern.base,
+				       NULL,
+				       snapshot,
+				       0, 0,
+				       0, 0,
+				       0, 0,
+				       image->width,
+				       image->height);
 
     _cairo_pattern_fini (&pattern.base);
+    if (status) {
+	cairo_surface_destroy (snapshot);
+	return (cairo_surface_t *) &_cairo_surface_nil;
+    }
 
     _cairo_surface_release_source_image (surface,
 					 image, &image_extra);
@@ -1158,13 +1165,14 @@ _cairo_surface_fallback_composite_trapezoids (cairo_operator_t		op,
 	traps = offset_traps;
     }
 
-    _cairo_surface_composite_trapezoids (op, pattern,
-					 &state.image->base,
-					 antialias,
-					 src_x, src_y,
-					 dst_x - state.image_rect.x,
-					 dst_y - state.image_rect.y,
-					 width, height, traps, num_traps);
+    status = _cairo_surface_composite_trapezoids (op, pattern,
+					          &state.image->base,
+						  antialias,
+						  src_x, src_y,
+						  dst_x - state.image_rect.x,
+						  dst_y - state.image_rect.y,
+						  width, height,
+						  traps, num_traps);
     if (offset_traps)
 	free (offset_traps);
 
diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index 703017a..1c885d1 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -447,7 +447,8 @@ _cairo_svg_surface_store_page (cairo_svg_surface_t *surface)
     for (i = 0; i < page.clip_level; i++)
 	_cairo_output_stream_printf (page.xml_node, "</g>\n");
 
-    _cairo_array_append (&surface->page_set, &page);
+    if (_cairo_array_append (&surface->page_set, &page) != CAIRO_STATUS_SUCCESS)
+	return NULL;
 
     return _cairo_array_index (&surface->page_set, surface->page_set.num_elements - 1);
 }
@@ -776,7 +777,7 @@ _cairo_svg_surface_create_similar (void			*abstract_src,
 static cairo_status_t
 _cairo_svg_surface_finish (void *abstract_surface)
 {
-    cairo_status_t status;
+    cairo_status_t status, status2;
     cairo_svg_surface_t *surface = abstract_surface;
     cairo_svg_document_t *document = surface->document;
     cairo_svg_page_t *page;
@@ -787,11 +788,15 @@ _cairo_svg_surface_finish (void *abstract_surface)
     else
 	status = CAIRO_STATUS_SUCCESS;
 
-    _cairo_output_stream_destroy (surface->xml_node);
+    status2 = _cairo_output_stream_destroy (surface->xml_node);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     for (i = 0; i < surface->page_set.num_elements; i++) {
 	page = _cairo_array_index (&surface->page_set, i);
-	_cairo_output_stream_destroy (page->xml_node);
+	status2 = _cairo_output_stream_destroy (page->xml_node);
+	if (status == CAIRO_STATUS_SUCCESS)
+	    status = status2;
     }
     _cairo_array_fini (&surface->page_set);
 
@@ -941,7 +946,9 @@ _cairo_svg_surface_emit_composite_image_pattern (cairo_output_stream_t     *outp
 	return status;
 
     p2u = pattern->base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     if (pattern_id != invalid_pattern_id) {
 	_cairo_output_stream_printf (output,
@@ -1075,15 +1082,18 @@ _cairo_svg_surface_emit_composite_meta_pattern (cairo_output_stream_t	*output,
     cairo_svg_document_t *document = surface->document;
     cairo_meta_surface_t *meta_surface;
     cairo_matrix_t p2u;
+    cairo_status_t status;
     int id;
 
+    p2u = pattern->base.matrix;
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
+
     meta_surface = (cairo_meta_surface_t *) pattern->surface;
 
     id = _cairo_svg_surface_emit_meta_surface (document, meta_surface);
 
-    p2u = pattern->base.matrix;
-    cairo_matrix_invert (&p2u);
-
     if (pattern_id != invalid_pattern_id) {
 	_cairo_output_stream_printf (output,
 				     "<pattern id=\"pattern%d\" "
@@ -1375,6 +1385,12 @@ _cairo_svg_surface_emit_linear_pattern (cairo_svg_surface_t    *surface,
     cairo_svg_document_t *document = surface->document;
     double x0, y0, x1, y1;
     cairo_matrix_t p2u;
+    cairo_status_t status;
+
+    p2u = pattern->base.base.matrix;
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     x0 = _cairo_fixed_to_double (pattern->gradient.p1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.p1.y);
@@ -1389,8 +1405,6 @@ _cairo_svg_surface_emit_linear_pattern (cairo_svg_surface_t    *surface,
 				 x0, y0, x1, y1);
 
     _cairo_svg_surface_emit_pattern_extend (document->xml_node_defs, &pattern->base.base),
-    p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
     _cairo_svg_surface_emit_transform (document->xml_node_defs, "gradientTransform", ">\n", &p2u);
 
     _cairo_svg_surface_emit_pattern_stops (document->xml_node_defs ,&pattern->base, 0.0, FALSE, FALSE);
diff --git a/src/cairo-type1-fallback.c b/src/cairo-type1-fallback.c
index a183b28..eef0d73 100644
--- a/src/cairo-type1-fallback.c
+++ b/src/cairo-type1-fallback.c
@@ -558,6 +558,7 @@ cairo_type1_font_write_private_dict (cairo_type1_font_t *font,
                                      const char         *name)
 {
     cairo_int_status_t status;
+    cairo_status_t status2;
     cairo_output_stream_t *encrypted_output;
 
     font->eexec_key = CAIRO_TYPE1_PRIVATE_DICT_KEY;
@@ -597,10 +598,10 @@ cairo_type1_font_write_private_dict (cairo_type1_font_t *font,
                                  "dup /FontName get exch definefont pop\n"
                                  "mark currentfile closefile\n");
 
-    if (status == CAIRO_STATUS_SUCCESS)
-	status = _cairo_output_stream_get_status (encrypted_output);
   fail:
-    _cairo_output_stream_destroy (encrypted_output);
+    status2 = _cairo_output_stream_destroy (encrypted_output);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
diff --git a/src/cairo.c b/src/cairo.c
index 9a96dda..b8a0419 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -189,6 +189,7 @@ cairo_t *
 cairo_create (cairo_surface_t *target)
 {
     cairo_t *cr;
+    cairo_status_t status;
 
     cr = malloc (sizeof (cairo_t));
     if (cr == NULL)
@@ -201,14 +202,18 @@ cairo_create (cairo_surface_t *target)
     _cairo_user_data_array_init (&cr->user_data);
 
     cr->gstate = cr->gstate_tail;
-    _cairo_gstate_init (cr->gstate, target);
+    status = _cairo_gstate_init (cr->gstate, target);
 
     _cairo_path_fixed_init (cr->path);
 
     if (target == NULL) {
-	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
+	/* override status with user error */
+	status = CAIRO_STATUS_NULL_POINTER;
     }
 
+    if (status)
+	_cairo_set_error (cr, status);
+
     return cr;
 }
 slim_hidden_def (cairo_create);
@@ -483,9 +488,11 @@ cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
 
     parent_surface = _cairo_gstate_get_target (cr->gstate);
     /* Get the extents that we'll use in creating our new group surface */
-    _cairo_surface_get_extents (parent_surface, &extents);
+    status = _cairo_surface_get_extents (parent_surface, &extents);
+    if (status)
+	goto bail;
     status = _cairo_clip_intersect_to_rectangle (_cairo_gstate_get_clip (cr->gstate), &extents);
-    if (status != CAIRO_STATUS_SUCCESS)
+    if (status)
 	goto bail;
 
     group_surface = cairo_surface_create_similar (_cairo_gstate_get_target (cr->gstate),
@@ -563,7 +570,7 @@ cairo_pop_group (cairo_t *cr)
     /* We need to save group_surface before we restore; we don't need
      * to reference parent_target and original_target, since the
      * gstate will still hold refs to them once we restore. */
-    cairo_surface_reference (group_surface);
+    group_surface = cairo_surface_reference (group_surface);
 
     cairo_restore (cr);
 
@@ -1623,17 +1630,20 @@ void
 cairo_rel_move_to (cairo_t *cr, double dx, double dy)
 {
     cairo_fixed_t dx_fixed, dy_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 
 /**
@@ -1658,17 +1668,20 @@ void
 cairo_rel_line_to (cairo_t *cr, double dx, double dy)
 {
     cairo_fixed_t dx_fixed, dy_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
+    if (status == CAIRO_STATUS_SUCCESS) {
+	dx_fixed = _cairo_fixed_from_double (dx);
+	dy_fixed = _cairo_fixed_from_double (dy);
 
-    cr->status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+	status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
+    }
+    if (status)
+	_cairo_set_error (cr, status);
 }
 slim_hidden_def(cairo_rel_line_to);
 
@@ -1707,13 +1720,20 @@ cairo_rel_curve_to (cairo_t *cr,
     cairo_fixed_t dx1_fixed, dy1_fixed;
     cairo_fixed_t dx2_fixed, dy2_fixed;
     cairo_fixed_t dx3_fixed, dy3_fixed;
+    cairo_status_t status;
 
     if (cr->status)
 	return;
 
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
-    _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
+    if (status)
+	goto BAIL;
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
+    if (status)
+	goto BAIL;
+    status = _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
+    if (status)
+	goto BAIL;
 
     dx1_fixed = _cairo_fixed_from_double (dx1);
     dy1_fixed = _cairo_fixed_from_double (dy1);
@@ -1724,12 +1744,14 @@ cairo_rel_curve_to (cairo_t *cr,
     dx3_fixed = _cairo_fixed_from_double (dx3);
     dy3_fixed = _cairo_fixed_from_double (dy3);
 
-    cr->status = _cairo_path_fixed_rel_curve_to (cr->path,
-						 dx1_fixed, dy1_fixed,
-						 dx2_fixed, dy2_fixed,
-						 dx3_fixed, dy3_fixed);
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+    status = _cairo_path_fixed_rel_curve_to (cr->path,
+					     dx1_fixed, dy1_fixed,
+					     dx2_fixed, dy2_fixed,
+					     dx3_fixed, dy3_fixed);
+    if (status) {
+BAIL:
+	_cairo_set_error (cr, status);
+    }
 }
 
 /**
diff --git a/test/buffer-diff.c b/test/buffer-diff.c
index d111b23..abb7e33 100644
--- a/test/buffer-diff.c
+++ b/test/buffer-diff.c
@@ -339,6 +339,7 @@ image_diff_core (const char *filename_a,
 
     compare_surfaces (surface_a, surface_b, surface_diff, result);
 
+    status = CAIRO_STATUS_SUCCESS;
     if (result->pixels_changed) {
 	FILE *png_file;
 
@@ -347,7 +348,7 @@ image_diff_core (const char *filename_a,
 	else
 	    png_file = stdout;
 
-	cairo_surface_write_to_png_stream (surface_diff, stdio_write_func, png_file);
+	status = cairo_surface_write_to_png_stream (surface_diff, stdio_write_func, png_file);
 
 	if (png_file != stdout)
 	    fclose (png_file);
@@ -360,7 +361,7 @@ image_diff_core (const char *filename_a,
     cairo_surface_destroy (surface_b);
     cairo_surface_destroy (surface_diff);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
 
 cairo_status_t
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Tue Mar 27 16:32:31 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Tue Mar 27 16:32:44 2007
Subject: [cairo] Propagate errors in pixman
In-Reply-To: <20070327210451.GB24027@inspired.chris-wilson.co.uk>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
	<1174502491.1028.20.camel@behdad>
	<20070327210451.GB24027@inspired.chris-wilson.co.uk>
Message-ID: <20070327233231.GA25830@inspired.chris-wilson.co.uk>

pixman is inconsistent in its return codes for error status often using
1 to flag an error, but sometimes using 0.  All I can say is that I've
reviewed it a couple of times and it passes make check[-valgrind]...
--
Chris Wilson
-------------- next part --------------
>From 6dbfc0e1949ac3736170b313933cc0ce30d1df86 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 00:26:24 +0100
Subject: [PATCH] Propagate errors throughout pixman_private functions.

A few paths were silently returning when an error occurred. This patch
propagates the error (usually a result of a malloc failure) back to the
caller.
---
 pixman/src/fbcompose.c |   19 ++-
 pixman/src/fbmmx.c     |   84 ++++++----
 pixman/src/fbmmx.h     |  428 ++++++++++++++++++++++++------------------------
 pixman/src/fbpict.c    |  125 ++++++++++-----
 pixman/src/fbpict.h    |    2 +-
 pixman/src/icimage.c   |   47 ++++--
 pixman/src/icimage.h   |    4 +-
 pixman/src/icrect.c    |   92 ++++++++---
 pixman/src/ictrap.c    |   37 +++--
 pixman/src/ictri.c     |   92 +++++++----
 pixman/src/pixman.h    |   14 +-
 11 files changed, 559 insertions(+), 385 deletions(-)

diff --git a/pixman/src/fbcompose.c b/pixman/src/fbcompose.c
index 233b90c..4086100 100644
--- a/pixman/src/fbcompose.c
+++ b/pixman/src/fbcompose.c
@@ -4182,7 +4182,7 @@ fbCompositeRect (const FbComposeData *data, CARD32 *scanline_buffer)
     }
 }
 
-void
+int
 pixman_compositeGeneral (pixman_operator_t	op,
 		    PicturePtr	pSrc,
 		    PicturePtr	pMask,
@@ -4218,7 +4218,15 @@ pixman_compositeGeneral (pixman_operator_t	op,
         op = PIXMAN_OPERATOR_SRC;
 
     region = pixman_region_create();
-    pixman_region_union_rect (region, region, xDst, yDst, width, height);
+    if (!region)
+	return 1;
+    if (pixman_region_union_rect (region, region,
+		                  xDst, yDst,
+				  width, height) !=
+	    PIXMAN_REGION_STATUS_SUCCESS) {
+	pixman_region_destroy (region);
+	return 1;
+    }
 
     if (!FbComputeCompositeRegion (region,
 				   pSrc,
@@ -4231,8 +4239,10 @@ pixman_compositeGeneral (pixman_operator_t	op,
 				   xDst,
 				   yDst,
 				   width,
-				   height))
-	    return;
+				   height)) {
+	pixman_region_destroy (region);
+	return 1;
+    }
 
     compose_data.op = op;
     compose_data.src = pSrc;
@@ -4300,6 +4310,7 @@ pixman_compositeGeneral (pixman_operator_t	op,
 
     if (scanline_buffer != _scanline_buffer)
         free(scanline_buffer);
+    return 0;
 }
 
 #endif
diff --git a/pixman/src/fbmmx.c b/pixman/src/fbmmx.c
index 387d4b4..4749361 100644
--- a/pixman/src/fbmmx.c
+++ b/pixman/src/fbmmx.c
@@ -915,7 +915,7 @@ void fbComposeSetupMMX(void)
 
 /* ------------------ MMX code paths called from fbpict.c ----------------------- */
 
-void
+int
 fbCompositeSolid_nx8888mmx (pixman_operator_t	op,
 			    PicturePtr pSrc,
 			    PicturePtr pMask,
@@ -940,7 +940,7 @@ fbCompositeSolid_nx8888mmx (pixman_operator_t	op,
     fbComposeGetSolid(pSrc, pDst, src);
 
     if (src >> 24 == 0)
-	return;
+	return 0;
 
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
 
@@ -991,9 +991,10 @@ fbCompositeSolid_nx8888mmx (pixman_operator_t	op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSolid_nx0565mmx (pixman_operator_t	op,
 			    PicturePtr pSrc,
 			    PicturePtr pMask,
@@ -1018,7 +1019,7 @@ fbCompositeSolid_nx0565mmx (pixman_operator_t	op,
     fbComposeGetSolid(pSrc, pDst, src);
 
     if (src >> 24 == 0)
-	return;
+	return 0;
 
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
 
@@ -1074,9 +1075,10 @@ fbCompositeSolid_nx0565mmx (pixman_operator_t	op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSolidMask_nx8888x8888Cmmx (pixman_operator_t	op,
 				      PicturePtr pSrc,
 				      PicturePtr pMask,
@@ -1102,7 +1104,7 @@ fbCompositeSolidMask_nx8888x8888Cmmx (pixman_operator_t	op,
 
     srca = src >> 24;
     if (srca == 0)
-	return;
+	return 0;
 
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);
@@ -1177,9 +1179,10 @@ fbCompositeSolidMask_nx8888x8888Cmmx (pixman_operator_t	op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSrc_8888x8x8888mmx (pixman_operator_t	op,
 			       PicturePtr pSrc,
 			       PicturePtr pMask,
@@ -1262,9 +1265,10 @@ fbCompositeSrc_8888x8x8888mmx (pixman_operator_t	op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSrc_x888x8x8888mmx (pixman_operator_t	op,
 			       PicturePtr pSrc,
 			       PicturePtr pMask,
@@ -1397,9 +1401,10 @@ fbCompositeSrc_x888x8x8888mmx (pixman_operator_t	op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSrc_8888x8888mmx (pixman_operator_t      op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
@@ -1446,9 +1451,10 @@ fbCompositeSrc_8888x8888mmx (pixman_operator_t      op,
 	}
     }
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSrc_8888x0565mmx (pixman_operator_t      op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
@@ -1540,9 +1546,10 @@ fbCompositeSrc_8888x0565mmx (pixman_operator_t      op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSolidMask_nx8x8888mmx (pixman_operator_t      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
@@ -1570,7 +1577,7 @@ fbCompositeSolidMask_nx8x8888mmx (pixman_operator_t      op,
 
     srca = src >> 24;
     if (srca == 0)
-	return;
+	return 0;
 
     srcsrc = (ullong)src << 32 | src;
 
@@ -1655,9 +1662,10 @@ fbCompositeSolidMask_nx8x8888mmx (pixman_operator_t      op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSolidMaskSrc_nx8x8888mmx (pixman_operator_t      op,
 				     PicturePtr pSrc,
 				     PicturePtr pMask,
@@ -1687,7 +1695,7 @@ fbCompositeSolidMaskSrc_nx8x8888mmx (pixman_operator_t      op,
     if (srca == 0)
     {
 	if (fbSolidFillmmx (pDst->pDrawable, xDst, yDst, width, height, 0))
-	    return;
+	    return 0;
     }
 
     srcsrc = (ullong)src << 32 | src;
@@ -1785,9 +1793,10 @@ fbCompositeSolidMaskSrc_nx8x8888mmx (pixman_operator_t      op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSolidMask_nx8x0565mmx (pixman_operator_t      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
@@ -1816,7 +1825,7 @@ fbCompositeSolidMask_nx8x0565mmx (pixman_operator_t      op,
 
     srca = src >> 24;
     if (srca == 0)
-	return;
+	return 0;
 
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
@@ -1914,9 +1923,10 @@ fbCompositeSolidMask_nx8x0565mmx (pixman_operator_t      op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSrc_8888RevNPx0565mmx (pixman_operator_t      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
@@ -2028,11 +2038,12 @@ fbCompositeSrc_8888RevNPx0565mmx (pixman_operator_t      op,
     }
 
     _mm_empty();
+    return 0;
 }
 
 /* "8888RevNP" is GdkPixbuf's format: ABGR, non premultiplied */
 
-void
+int
 fbCompositeSrc_8888RevNPx8888mmx (pixman_operator_t      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
@@ -2126,9 +2137,10 @@ fbCompositeSrc_8888RevNPx8888mmx (pixman_operator_t      op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSolidMask_nx8888x0565Cmmx (pixman_operator_t      op,
 				      PicturePtr pSrc,
 				      PicturePtr pMask,
@@ -2154,7 +2166,7 @@ fbCompositeSolidMask_nx8888x0565Cmmx (pixman_operator_t      op,
 
     srca = src >> 24;
     if (srca == 0)
-	return;
+	return 0;
 
     fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);
@@ -2231,9 +2243,10 @@ fbCompositeSolidMask_nx8888x0565Cmmx (pixman_operator_t      op,
     }
 
     _mm_empty ();
+    return 0;
 }
 
-void
+int
 fbCompositeIn_nx8x8mmx (pixman_operator_t	op,
 			PicturePtr pSrc,
 			PicturePtr pMask,
@@ -2262,7 +2275,7 @@ fbCompositeIn_nx8x8mmx (pixman_operator_t	op,
 
     sa = src >> 24;
     if (sa == 0)
-	return;
+	return 0;
 
     vsrc = load8888(src);
     vsrca = expand_alpha(vsrc);
@@ -2315,9 +2328,10 @@ fbCompositeIn_nx8x8mmx (pixman_operator_t	op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeIn_8x8mmx (pixman_operator_t	op,
 		      PicturePtr pSrc,
 		      PicturePtr pMask,
@@ -2379,9 +2393,10 @@ fbCompositeIn_8x8mmx (pixman_operator_t	op,
     }
 
     _mm_empty ();
+    return 0;
 }
 
-void
+int
 fbCompositeSrcAdd_8888x8x8mmx (pixman_operator_t   op,
 			       PicturePtr pSrc,
 			       PicturePtr pMask,
@@ -2410,7 +2425,7 @@ fbCompositeSrcAdd_8888x8x8mmx (pixman_operator_t   op,
 
     sa = src >> 24;
     if (sa == 0)
-	return;
+	return 0;
 
     vsrc = load8888(src);
     vsrca = expand_alpha(vsrc);
@@ -2457,9 +2472,10 @@ fbCompositeSrcAdd_8888x8x8mmx (pixman_operator_t   op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSrcAdd_8000x8000mmx (pixman_operator_t	op,
 				PicturePtr pSrc,
 				PicturePtr pMask,
@@ -2529,9 +2545,10 @@ fbCompositeSrcAdd_8000x8000mmx (pixman_operator_t	op,
     }
 
     _mm_empty();
+    return 0;
 }
 
-void
+int
 fbCompositeSrcAdd_8888x8888mmx (pixman_operator_t		op,
 				PicturePtr	pSrc,
 				PicturePtr	pMask,
@@ -2589,6 +2606,7 @@ fbCompositeSrcAdd_8888x8888mmx (pixman_operator_t		op,
     }
 
     _mm_empty();
+    return 0;
 }
 
 Bool
@@ -2813,7 +2831,7 @@ fbCopyAreammx (FbPixels	*pSrc,
     return TRUE;
 }
 
-void
+int
 fbCompositeCopyAreammx (pixman_operator_t		op,
 			PicturePtr	pSrc,
 			PicturePtr	pMask,
@@ -2827,11 +2845,11 @@ fbCompositeCopyAreammx (pixman_operator_t		op,
 			CARD16		width,
 			CARD16		height)
 {
-    fbCopyAreammx (pSrc->pDrawable,
-		   pDst->pDrawable,
-		   xSrc, ySrc,
-		   xDst, yDst,
-		   width, height);
+    return !fbCopyAreammx (pSrc->pDrawable,
+		          pDst->pDrawable,
+		          xSrc, ySrc,
+		          xDst, yDst,
+		          width, height);
 }
 
 #endif /* RENDER */
diff --git a/pixman/src/fbmmx.h b/pixman/src/fbmmx.h
index 054ac0b..54c9619 100644
--- a/pixman/src/fbmmx.h
+++ b/pixman/src/fbmmx.h
@@ -45,73 +45,21 @@ pixman_private
 void fbComposeSetupMMX(void);
 
 pixman_private
-void fbCompositeIn_nx8x8mmx (pixman_operator_t	op,
-			     PicturePtr pSrc,
-			     PicturePtr pMask,
-			     PicturePtr pDst,
-			     INT16      xSrc,
-			     INT16      ySrc,
-			     INT16      xMask,
-			     INT16      yMask,
-			     INT16      xDst,
-			     INT16      yDst,
-			     CARD16     width,
-			     CARD16     height);
+int fbCompositeIn_nx8x8mmx (pixman_operator_t	op,
+			    PicturePtr pSrc,
+			    PicturePtr pMask,
+			    PicturePtr pDst,
+			    INT16      xSrc,
+			    INT16      ySrc,
+			    INT16      xMask,
+			    INT16      yMask,
+			    INT16      xDst,
+			    INT16      yDst,
+			    CARD16     width,
+			    CARD16     height);
 
 pixman_private
-void fbCompositeSolidMask_nx8888x0565Cmmx (pixman_operator_t      op,
-					   PicturePtr pSrc,
-					   PicturePtr pMask,
-					   PicturePtr pDst,
-					   INT16      xSrc,
-					   INT16      ySrc,
-					   INT16      xMask,
-					   INT16      yMask,
-					   INT16      xDst,
-					   INT16      yDst,
-					   CARD16     width,
-					   CARD16     height);
-pixman_private
-void fbCompositeSrcAdd_8888x8888mmx (pixman_operator_t	op,
-				     PicturePtr	pSrc,
-				     PicturePtr	pMask,
-				     PicturePtr	pDst,
-				     INT16	xSrc,
-				     INT16      ySrc,
-				     INT16      xMask,
-				     INT16      yMask,
-				     INT16      xDst,
-				     INT16      yDst,
-				     CARD16     width,
-				     CARD16     height);
-pixman_private
-void fbCompositeSolidMask_nx8888x8888Cmmx (pixman_operator_t	op,
-					   PicturePtr	pSrc,
-					   PicturePtr	pMask,
-					   PicturePtr	pDst,
-					   INT16	xSrc,
-					   INT16	ySrc,
-					   INT16	xMask,
-					   INT16	yMask,
-					   INT16	xDst,
-					   INT16	yDst,
-					   CARD16	width,
-					   CARD16	height);
-pixman_private
-void fbCompositeSolidMask_nx8x8888mmx (pixman_operator_t      op,
-				       PicturePtr pSrc,
-				       PicturePtr pMask,
-				       PicturePtr pDst,
-				       INT16      xSrc,
-				       INT16      ySrc,
-				       INT16      xMask,
-				       INT16      yMask,
-				       INT16      xDst,
-				       INT16      yDst,
-				       CARD16     width,
-				       CARD16     height);
-pixman_private
-void fbCompositeSolidMaskSrc_nx8x8888mmx (pixman_operator_t      op,
+int fbCompositeSolidMask_nx8888x0565Cmmx (pixman_operator_t      op,
 					  PicturePtr pSrc,
 					  PicturePtr pMask,
 					  PicturePtr pDst,
@@ -123,9 +71,89 @@ void fbCompositeSolidMaskSrc_nx8x8888mmx (pixman_operator_t      op,
 					  INT16      yDst,
 					  CARD16     width,
 					  CARD16     height);
+pixman_private
+int fbCompositeSrcAdd_8888x8888mmx (pixman_operator_t	op,
+				    PicturePtr	pSrc,
+				    PicturePtr	pMask,
+				    PicturePtr	pDst,
+				    INT16	xSrc,
+				    INT16      ySrc,
+				    INT16      xMask,
+				    INT16      yMask,
+				    INT16      xDst,
+				    INT16      yDst,
+				    CARD16     width,
+				    CARD16     height);
+pixman_private
+int fbCompositeSolidMask_nx8888x8888Cmmx (pixman_operator_t	op,
+					  PicturePtr	pSrc,
+					  PicturePtr	pMask,
+					  PicturePtr	pDst,
+					  INT16	xSrc,
+					  INT16	ySrc,
+					  INT16	xMask,
+					  INT16	yMask,
+					  INT16	xDst,
+					  INT16	yDst,
+					  CARD16	width,
+					  CARD16	height);
+pixman_private
+int fbCompositeSolidMask_nx8x8888mmx (pixman_operator_t      op,
+				      PicturePtr pSrc,
+				      PicturePtr pMask,
+				      PicturePtr pDst,
+				      INT16      xSrc,
+				      INT16      ySrc,
+				      INT16      xMask,
+				      INT16      yMask,
+				      INT16      xDst,
+				      INT16      yDst,
+				      CARD16     width,
+				      CARD16     height);
+pixman_private
+int fbCompositeSolidMaskSrc_nx8x8888mmx (pixman_operator_t      op,
+					 PicturePtr pSrc,
+					 PicturePtr pMask,
+					 PicturePtr pDst,
+					 INT16      xSrc,
+					 INT16      ySrc,
+					 INT16      xMask,
+					 INT16      yMask,
+					 INT16      xDst,
+					 INT16      yDst,
+					 CARD16     width,
+					 CARD16     height);
+
+pixman_private
+int fbCompositeSrcAdd_8888x8x8mmx (pixman_operator_t   op,
+				   PicturePtr pSrc,
+				   PicturePtr pMask,
+				   PicturePtr pDst,
+				   INT16      xSrc,
+				   INT16      ySrc,
+				   INT16      xMask,
+				   INT16      yMask,
+				   INT16      xDst,
+				   INT16      yDst,
+				   CARD16     width,
+				   CARD16     height);
+
+pixman_private
+int fbCompositeIn_8x8mmx (pixman_operator_t	op,
+			  PicturePtr pSrc,
+			  PicturePtr pMask,
+			  PicturePtr pDst,
+			  INT16      xSrc,
+			  INT16      ySrc,
+			  INT16      xMask,
+			  INT16      yMask,
+			  INT16      xDst,
+			  INT16      yDst,
+			  CARD16     width,
+			  CARD16     height);
 
 pixman_private
-void fbCompositeSrcAdd_8888x8x8mmx (pixman_operator_t   op,
+int fbCompositeSrcAdd_8000x8000mmx (pixman_operator_t	op,
 				    PicturePtr pSrc,
 				    PicturePtr pMask,
 				    PicturePtr pDst,
@@ -137,151 +165,123 @@ void fbCompositeSrcAdd_8888x8x8mmx (pixman_operator_t   op,
 				    INT16      yDst,
 				    CARD16     width,
 				    CARD16     height);
-
-pixman_private
-void fbCompositeIn_8x8mmx (pixman_operator_t	op,
-			   PicturePtr pSrc,
-			   PicturePtr pMask,
-			   PicturePtr pDst,
-			   INT16      xSrc,
-			   INT16      ySrc,
-			   INT16      xMask,
-			   INT16      yMask,
-			   INT16      xDst,
-			   INT16      yDst,
-			   CARD16     width,
-			   CARD16     height);
-
 pixman_private
-void fbCompositeSrcAdd_8000x8000mmx (pixman_operator_t	op,
-				     PicturePtr pSrc,
-				     PicturePtr pMask,
-				     PicturePtr pDst,
-				     INT16      xSrc,
-				     INT16      ySrc,
-				     INT16      xMask,
-				     INT16      yMask,
-				     INT16      xDst,
-				     INT16      yDst,
-				     CARD16     width,
-				     CARD16     height);
+int fbCompositeSrc_8888RevNPx8888mmx (pixman_operator_t      op,
+				      PicturePtr pSrc,
+				      PicturePtr pMask,
+				      PicturePtr pDst,
+				      INT16      xSrc,
+				      INT16      ySrc,
+				      INT16      xMask,
+				      INT16      yMask,
+				      INT16      xDst,
+				      INT16      yDst,
+				      CARD16     width,
+				      CARD16     height);
 pixman_private
-void fbCompositeSrc_8888RevNPx8888mmx (pixman_operator_t      op,
-				       PicturePtr pSrc,
-				       PicturePtr pMask,
-				       PicturePtr pDst,
-				       INT16      xSrc,
-				       INT16      ySrc,
-				       INT16      xMask,
-				       INT16      yMask,
-				       INT16      xDst,
-				       INT16      yDst,
-				       CARD16     width,
-				       CARD16     height);
+int fbCompositeSrc_8888x0565mmx (pixman_operator_t      op,
+				 PicturePtr pSrc,
+				 PicturePtr pMask,
+				 PicturePtr pDst,
+				 INT16      xSrc,
+				 INT16      ySrc,
+				 INT16      xMask,
+				 INT16      yMask,
+				 INT16      xDst,
+				 INT16      yDst,
+				 CARD16     width,
+				 CARD16     height);
 pixman_private
-void fbCompositeSrc_8888x0565mmx (pixman_operator_t      op,
-				  PicturePtr pSrc,
-				  PicturePtr pMask,
-				  PicturePtr pDst,
-				  INT16      xSrc,
-				  INT16      ySrc,
-				  INT16      xMask,
-				  INT16      yMask,
-				  INT16      xDst,
-				  INT16      yDst,
-				  CARD16     width,
-				  CARD16     height);
+int fbCompositeSrc_8888RevNPx0565mmx (pixman_operator_t      op,
+				      PicturePtr pSrc,
+				      PicturePtr pMask,
+				      PicturePtr pDst,
+				      INT16      xSrc,
+				      INT16      ySrc,
+				      INT16      xMask,
+				      INT16      yMask,
+				      INT16      xDst,
+				      INT16      yDst,
+				      CARD16     width,
+				      CARD16     height);
 pixman_private
-void fbCompositeSrc_8888RevNPx0565mmx (pixman_operator_t      op,
-				       PicturePtr pSrc,
-				       PicturePtr pMask,
-				       PicturePtr pDst,
-				       INT16      xSrc,
-				       INT16      ySrc,
-				       INT16      xMask,
-				       INT16      yMask,
-				       INT16      xDst,
-				       INT16      yDst,
-				       CARD16     width,
-				       CARD16     height);
+int fbCompositeSolid_nx8888mmx (pixman_operator_t		op,
+				PicturePtr	pSrc,
+				PicturePtr	pMask,
+				PicturePtr	pDst,
+				INT16		xSrc,
+				INT16		ySrc,
+				INT16		xMask,
+				INT16		yMask,
+				INT16		xDst,
+				INT16		yDst,
+				CARD16		width,
+				CARD16		height);
 pixman_private
-void fbCompositeSolid_nx8888mmx (pixman_operator_t		op,
-				 PicturePtr	pSrc,
-				 PicturePtr	pMask,
-				 PicturePtr	pDst,
-				 INT16		xSrc,
-				 INT16		ySrc,
-				 INT16		xMask,
-				 INT16		yMask,
-				 INT16		xDst,
-				 INT16		yDst,
-				 CARD16		width,
-				 CARD16		height);
+int fbCompositeSolid_nx0565mmx (pixman_operator_t		op,
+				PicturePtr	pSrc,
+				PicturePtr	pMask,
+				PicturePtr	pDst,
+				INT16		xSrc,
+				INT16		ySrc,
+				INT16		xMask,
+				INT16		yMask,
+				INT16		xDst,
+				INT16		yDst,
+				CARD16		width,
+				CARD16		height);
 pixman_private
-void fbCompositeSolid_nx0565mmx (pixman_operator_t		op,
-				 PicturePtr	pSrc,
-				 PicturePtr	pMask,
-				 PicturePtr	pDst,
-				 INT16		xSrc,
-				 INT16		ySrc,
-				 INT16		xMask,
-				 INT16		yMask,
-				 INT16		xDst,
-				 INT16		yDst,
-				 CARD16		width,
-				 CARD16		height);
+int fbCompositeSolidMask_nx8x0565mmx (pixman_operator_t      op,
+				      PicturePtr pSrc,
+				      PicturePtr pMask,
+				      PicturePtr pDst,
+				      INT16      xSrc,
+				      INT16      ySrc,
+				      INT16      xMask,
+				      INT16      yMask,
+				      INT16      xDst,
+				      INT16      yDst,
+				      CARD16     width,
+				      CARD16     height);
 pixman_private
-void fbCompositeSolidMask_nx8x0565mmx (pixman_operator_t      op,
-				       PicturePtr pSrc,
-				       PicturePtr pMask,
-				       PicturePtr pDst,
-				       INT16      xSrc,
-				       INT16      ySrc,
-				       INT16      xMask,
-				       INT16      yMask,
-				       INT16      xDst,
-				       INT16      yDst,
-				       CARD16     width,
-				       CARD16     height);
+int fbCompositeSrc_x888x8x8888mmx (pixman_operator_t	op,
+				   PicturePtr  pSrc,
+				   PicturePtr  pMask,
+				   PicturePtr  pDst,
+				   INT16	xSrc,
+				   INT16	ySrc,
+				   INT16       xMask,
+				   INT16       yMask,
+				   INT16       xDst,
+				   INT16       yDst,
+				   CARD16      width,
+				   CARD16      height);
 pixman_private
-void fbCompositeSrc_x888x8x8888mmx (pixman_operator_t	op,
-				    PicturePtr  pSrc,
-				    PicturePtr  pMask,
-				    PicturePtr  pDst,
-				    INT16	xSrc,
-				    INT16	ySrc,
-				    INT16       xMask,
-				    INT16       yMask,
-				    INT16       xDst,
-				    INT16       yDst,
-				    CARD16      width,
-				    CARD16      height);
-pixman_private
-void fbCompositeSrc_8888x8x8888mmx (pixman_operator_t	op,
-				    PicturePtr  pSrc,
-				    PicturePtr  pMask,
-				    PicturePtr  pDst,
-				    INT16	xSrc,
-				    INT16	ySrc,
-				    INT16       xMask,
-				    INT16       yMask,
-				    INT16       xDst,
-				    INT16       yDst,
-				    CARD16      width,
-				    CARD16      height);
+int fbCompositeSrc_8888x8x8888mmx (pixman_operator_t	op,
+				   PicturePtr  pSrc,
+				   PicturePtr  pMask,
+				   PicturePtr  pDst,
+				   INT16	xSrc,
+				   INT16	ySrc,
+				   INT16       xMask,
+				   INT16       yMask,
+				   INT16       xDst,
+				   INT16       yDst,
+				   CARD16      width,
+				   CARD16      height);
 pixman_private
-void fbCompositeSrc_8888x8888mmx (pixman_operator_t      op,
-				  PicturePtr pSrc,
-				  PicturePtr pMask,
-				  PicturePtr pDst,
-				  INT16      xSrc,
-				  INT16      ySrc,
-				  INT16      xMask,
-				  INT16      yMask,
-				  INT16      xDst,
-				  INT16      yDst,
-				  CARD16     width,
-				  CARD16     height);
+int fbCompositeSrc_8888x8888mmx (pixman_operator_t      op,
+				 PicturePtr pSrc,
+				 PicturePtr pMask,
+				 PicturePtr pDst,
+				 INT16      xSrc,
+				 INT16      ySrc,
+				 INT16      xMask,
+				 INT16      yMask,
+				 INT16      xDst,
+				 INT16      yDst,
+				 CARD16     width,
+				 CARD16     height);
 pixman_private
 Bool fbCopyAreammx (FbPixels	*pSrc,
 		    FbPixels	*pDst,
@@ -293,18 +293,18 @@ Bool fbCopyAreammx (FbPixels	*pSrc,
 		    int		height);
 
 pixman_private
-void fbCompositeCopyAreammx (pixman_operator_t	op,
-			     PicturePtr	pSrc,
-			     PicturePtr	pMask,
-			     PicturePtr	pDst,
-			     INT16	xSrc,
-			     INT16      ySrc,
-			     INT16      xMask,
-			     INT16      yMask,
-			     INT16      xDst,
-			     INT16      yDst,
-			     CARD16     width,
-			     CARD16     height);
+int fbCompositeCopyAreammx (pixman_operator_t	op,
+			    PicturePtr	pSrc,
+			    PicturePtr	pMask,
+			    PicturePtr	pDst,
+			    INT16	xSrc,
+			    INT16      ySrc,
+			    INT16      xMask,
+			    INT16      yMask,
+			    INT16      xDst,
+			    INT16      yDst,
+			    CARD16     width,
+			    CARD16     height);
 
 pixman_private
 Bool fbSolidFillmmx (FbPixels	*pDraw,
diff --git a/pixman/src/fbpict.c b/pixman/src/fbpict.c
index 0bd989f..4d07699 100644
--- a/pixman/src/fbpict.c
+++ b/pixman/src/fbpict.c
@@ -133,7 +133,7 @@ fbIn (CARD32 x, CARD8 y)
  *  opSRCxMASKxDST
  */
 
-static void
+static int
 fbCompositeSolidMask_nx8x8888 (pixman_operator_t   op,
 			       PicturePtr pSrc,
 			       PicturePtr pMask,
@@ -158,7 +158,7 @@ fbCompositeSolidMask_nx8x8888 (pixman_operator_t   op,
     dstMask = FbFullMask (pDst->pDrawable->depth);
     srca = src >> 24;
     if (src == 0)
-	return;
+	return 0;
 
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
@@ -189,9 +189,10 @@ fbCompositeSolidMask_nx8x8888 (pixman_operator_t   op,
 	    dst++;
 	}
     }
+    return 0;
 }
 
-static void
+static int
 fbCompositeSolidMask_nx8888x8888C (pixman_operator_t   op,
 				   PicturePtr pSrc,
 				   PicturePtr pMask,
@@ -217,7 +218,7 @@ fbCompositeSolidMask_nx8888x8888C (pixman_operator_t   op,
     dstMask = FbFullMask (pDst->pDrawable->depth);
     srca = src >> 24;
     if (src == 0)
-	return;
+	return 0;
 
     fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
     fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);
@@ -262,10 +263,12 @@ fbCompositeSolidMask_nx8888x8888C (pixman_operator_t   op,
 	    dst++;
 	}
     }
+
+    return 0;
 }
 
 #define srcAlphaCombine24(a,b) genericCombine24(a,b,srca,srcia)
-static void
+static int
 fbCompositeSolidMask_nx8x0888 (pixman_operator_t   op,
 			       PicturePtr pSrc,
 			       PicturePtr pMask,
@@ -291,7 +294,7 @@ fbCompositeSolidMask_nx8x0888 (pixman_operator_t   op,
     srca = src >> 24;
     srcia = 255-srca;
     if (src == 0)
-	return;
+	return 0;
 
 	rs=src&0xff;
 	gs=(src>>8)&0xff;
@@ -358,9 +361,11 @@ fbCompositeSolidMask_nx8x0888 (pixman_operator_t   op,
 			}
 		}
 	}
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSolidMask_nx8x0565 (pixman_operator_t      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
@@ -385,7 +390,7 @@ fbCompositeSolidMask_nx8x0565 (pixman_operator_t      op,
     fbComposeGetSolid(pSrc, pDst, src);
 
     if (src == 0)
-	return;
+	return 0;
 
     srca8 = (src >> 24);
     srca5 = (srca8 >> 3);
@@ -435,9 +440,11 @@ fbCompositeSolidMask_nx8x0565 (pixman_operator_t      op,
 	    }
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSolidMask_nx8888x0565 (pixman_operator_t      op,
 				  PicturePtr pSrc,
 				  PicturePtr pMask,
@@ -463,7 +470,7 @@ fbCompositeSolidMask_nx8888x0565 (pixman_operator_t      op,
     fbComposeGetSolid(pSrc, pDst, src);
 
     if (src == 0)
-	return;
+	return 0;
 
     srca8 = src >> 24;
     srca5 = srca8 >> 3;
@@ -514,9 +521,11 @@ fbCompositeSolidMask_nx8888x0565 (pixman_operator_t      op,
 	    }
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSolidMask_nx8888x0565C (pixman_operator_t      op,
 				   PicturePtr pSrc,
 				   PicturePtr pMask,
@@ -543,7 +552,7 @@ fbCompositeSolidMask_nx8888x0565C (pixman_operator_t      op,
 
     srca = src >> 24;
     if (src == 0)
-	return;
+	return 0;
 
     src16 = cvt8888to0565(src);
 
@@ -587,9 +596,11 @@ fbCompositeSolidMask_nx8888x0565C (pixman_operator_t      op,
 	    dst++;
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSrc_8888x8888 (pixman_operator_t  op,
 			 PicturePtr pSrc,
 			 PicturePtr pMask,
@@ -633,9 +644,11 @@ fbCompositeSrc_8888x8888 (pixman_operator_t  op,
 	    dst++;
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSrc_8888x0888 (pixman_operator_t  op,
 			 PicturePtr pSrc,
 			 PicturePtr pMask,
@@ -682,9 +695,11 @@ fbCompositeSrc_8888x0888 (pixman_operator_t  op,
 	    dst += 3;
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSrc_8888x0565 (pixman_operator_t  op,
 			 PicturePtr pSrc,
 			 PicturePtr pMask,
@@ -734,9 +749,11 @@ fbCompositeSrc_8888x0565 (pixman_operator_t  op,
 	    dst++;
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSrcAdd_8000x8000 (pixman_operator_t	  op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
@@ -784,9 +801,11 @@ fbCompositeSrcAdd_8000x8000 (pixman_operator_t	  op,
 	    dst++;
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSrcAdd_8888x8888 (pixman_operator_t   op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
@@ -841,9 +860,11 @@ fbCompositeSrcAdd_8888x8888 (pixman_operator_t   op,
 	    dst++;
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSrcAdd_8888x8x8 (pixman_operator_t   op,
 			    PicturePtr pSrc,
 			    PicturePtr pMask,
@@ -893,9 +914,11 @@ fbCompositeSrcAdd_8888x8x8 (pixman_operator_t   op,
 	    *dst++ = r;
 	}
     }
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSrcAdd_1000x1000 (pixman_operator_t   op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
@@ -936,9 +959,11 @@ fbCompositeSrcAdd_1000x1000 (pixman_operator_t   op,
 
 	   FALSE,
 	   FALSE);
+
+    return 0;
 }
 
-static void
+static int
 fbCompositeSolidMask_nx1xn (pixman_operator_t   op,
 			    PicturePtr pSrc,
 			    PicturePtr pMask,
@@ -964,10 +989,9 @@ fbCompositeSolidMask_nx1xn (pixman_operator_t   op,
 
     if ((src & 0xff000000) != 0xff000000)
     {
-	pixman_compositeGeneral  (op, pSrc, pMask, pDst,
+	return pixman_compositeGeneral  (op, pSrc, pMask, pDst,
 			     xSrc, ySrc, xMask, yMask, xDst, yDst,
 			     width, height);
-	return;
     }
     FbGetStipPixels (pMask->pixels, maskBits, maskStride, maskBpp, maskXoff, maskYoff);
     fbGetDrawable (pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
@@ -1000,10 +1024,12 @@ fbCompositeSolidMask_nx1xn (pixman_operator_t   op,
 	      src,
 	      FB_ALLONES,
 	      0x0);
+
+    return 0;
 }
 
 /* prototype to help with merging */
-static void
+static int
 fbCompositeSrcSrc_nxn  (pixman_operator_t	op,
 			PicturePtr pSrc,
 			PicturePtr pMask,
@@ -1019,7 +1045,7 @@ fbCompositeSrcSrc_nxn  (pixman_operator_t	op,
 /*
  * Apply a constant alpha value in an over computation
  */
-static void
+static int
 fbCompositeTrans_0565xnx0565(pixman_operator_t      op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
@@ -1046,13 +1072,12 @@ fbCompositeTrans_0565xnx0565(pixman_operator_t      op,
     maskAlpha = mask >> 27;
 
     if (!maskAlpha)
-	return;
+	return 0;
     if (maskAlpha == 0xff)
     {
-	fbCompositeSrcSrc_nxn (PIXMAN_OPERATOR_SRC, pSrc, pMask, pDst,
-			       xSrc, ySrc, xMask, yMask, xDst, yDst,
-			       width, height);
-	return;
+	return fbCompositeSrcSrc_nxn (PIXMAN_OPERATOR_SRC, pSrc, pMask, pDst,
+			              xSrc, ySrc, xMask, yMask, xDst, yDst,
+				      width, height);
     }
 
     fbComposeGetStart (pSrc, xSrc, ySrc, CARD16, srcStride, srcLine, 1);
@@ -1117,11 +1142,13 @@ fbCompositeTrans_0565xnx0565(pixman_operator_t      op,
 			inOver0565(maskAlpha, s_16, d_16, *dst);
 		}
 	}
+
+    return 0;
 }
 
 /* macros for "i can't believe it's not fast" packed pixel handling */
 #define alphamaskCombine24(a,b) genericCombine24(a,b,maskAlpha,maskiAlpha)
-static void
+static int
 fbCompositeTrans_0888xnx0888(pixman_operator_t      op,
 			     PicturePtr pSrc,
 			     PicturePtr pMask,
@@ -1147,7 +1174,7 @@ fbCompositeTrans_0888xnx0888(pixman_operator_t      op,
 	maskiAlpha= 255-maskAlpha;
 
     if (!maskAlpha)
-	return;
+	return 0;
     /*
     if (maskAlpha == 0xff)
     {
@@ -1301,13 +1328,15 @@ fbCompositeTrans_0888xnx0888(pixman_operator_t      op,
 			}
 		}
 	}
+
+	return 0;
 }
 
 /*
  * Simple bitblt
  */
 
-static void
+static int
 fbCompositeSrcSrc_nxn  (pixman_operator_t	op,
 			PicturePtr pSrc,
 			PicturePtr pMask,
@@ -1351,6 +1380,7 @@ fbCompositeSrcSrc_nxn  (pixman_operator_t	op,
 
 	   reverse,
 	   upsidedown);
+    return 0;
 }
 
 /*
@@ -1375,7 +1405,7 @@ fbCompositeSolidSrc_nxn  (CARD8	op,
 
 # define mod(a,b)	((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))
 
-void
+int
 pixman_composite (pixman_operator_t	op,
 	     PicturePtr pSrc,
 	     PicturePtr pMask,
@@ -1402,6 +1432,7 @@ pixman_composite (pixman_operator_t	op,
     Bool	    dstAlphaMap = pDst->alphaMap != 0;
     int		    x_msk, y_msk, x_src, y_src, x_dst, y_dst;
     unsigned int    w, h, w_this, h_this;
+    int ret = 1;
 
 #ifdef USE_MMX
     static Bool mmx_setup = FALSE;
@@ -1922,8 +1953,7 @@ pixman_composite (pixman_operator_t	op,
 
     if (!func) {
         /* no fast path, use the general code */
-        pixman_compositeGeneral(op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
-        return;
+        return pixman_compositeGeneral(op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
     }
 
     /* if we are transforming, we handle repeats in IcFetch[a]_transform */
@@ -1933,7 +1963,13 @@ pixman_composite (pixman_operator_t	op,
 	maskRepeat = 0;
 
     region = pixman_region_create();
-    pixman_region_union_rect (region, region, xDst, yDst, width, height);
+    if (pixman_region_union_rect (region, region,
+	       	                  xDst, yDst,
+				  width, height) !=
+	    PIXMAN_REGION_STATUS_SUCCESS) {
+	pixman_region_destroy (region);
+	return 1;
+    }
 
     if (!FbComputeCompositeRegion (region,
 				   pSrc,
@@ -1946,8 +1982,10 @@ pixman_composite (pixman_operator_t	op,
 				   xDst,
 				   yDst,
 				   width,
-				   height))
-	return;
+				   height)) {
+	pixman_region_destroy (region);
+	return 1;
+    }
 
     n = pixman_region_num_rects (region);
     pbox = pixman_region_rects (region);
@@ -1991,9 +2029,10 @@ pixman_composite (pixman_operator_t	op,
 		    if (w_this > pSrc->pDrawable->width - x_src)
 			w_this = pSrc->pDrawable->width - x_src;
 		}
-		(*func) (op, pSrc, pMask, pDst,
-			 x_src, y_src, x_msk, y_msk, x_dst, y_dst,
-			 w_this, h_this);
+		if ((*func) (op, pSrc, pMask, pDst,
+			     x_src, y_src, x_msk, y_msk, x_dst, y_dst,
+			     w_this, h_this))
+		    goto bail;
 		w -= w_this;
 		x_src += w_this;
 		x_msk += w_this;
@@ -2006,7 +2045,11 @@ pixman_composite (pixman_operator_t	op,
 	}
 	pbox++;
     }
+    ret = 0;
+bail:
     pixman_region_destroy (region);
+
+    return ret;
 }
 
 /* The CPU detection code needs to be in a file not compiled with
diff --git a/pixman/src/fbpict.h b/pixman/src/fbpict.h
index 0ff0c11..196e5e2 100644
--- a/pixman/src/fbpict.h
+++ b/pixman/src/fbpict.h
@@ -93,7 +93,7 @@
 	(bits) = FbLeftStipBits((bits),1) ? 0xff000000 : 0x00000000;\
 	break; \
     default: \
-	return; \
+	return 1; \
     } \
     /* manage missing src alpha */ \
     if ((pict)->image_format.alphaMask == 0) \
diff --git a/pixman/src/icimage.c b/pixman/src/icimage.c
index 4d957a0..62ff209 100644
--- a/pixman/src/icimage.c
+++ b/pixman/src/icimage.c
@@ -521,7 +521,14 @@ pixman_image_set_clip_region (pixman_image_t	*image,
     pixman_image_destroyClip (image);
     if (region) {
 	image->clientClip = pixman_region_create ();
-	pixman_region_copy (image->clientClip, region);
+	if (image->clientClip == NULL)
+	    return 1;
+	if (pixman_region_copy (image->clientClip, region) !=
+		PIXMAN_REGION_STATUS_SUCCESS) {
+	    pixman_region_destroy (image->clientClip);
+	    image->clientClip = NULL;
+	    return 1;
+	}
 	image->clientClipType = CT_REGION;
     }
 
@@ -529,22 +536,36 @@ pixman_image_set_clip_region (pixman_image_t	*image,
     if (image->pSourcePict)
 	return 0;
 
-    if (image->freeCompClip)
+    if (image->freeCompClip) {
 	pixman_region_destroy (image->pCompositeClip);
+	image->freeCompClip = 0;
+    }
     image->pCompositeClip = pixman_region_create();
-    pixman_region_union_rect (image->pCompositeClip, image->pCompositeClip,
-			      0, 0, image->pixels->width, image->pixels->height);
+    if (image->pCompositeClip == NULL) {
+	return 1;
+    }
+    if (pixman_region_union_rect (image->pCompositeClip, image->pCompositeClip,
+			      0, 0,
+			      image->pixels->width, image->pixels->height) !=
+	    PIXMAN_REGION_STATUS_SUCCESS) {
+	pixman_region_destroy (image->pCompositeClip);
+	image->pCompositeClip = NULL;
+	return 1;
+    }
     image->freeCompClip = 1;
     if (region) {
+	pixman_region_status_t status;
 	pixman_region_translate (image->pCompositeClip,
 				 - image->clipOrigin.x,
 				 - image->clipOrigin.y);
-	pixman_region_intersect (image->pCompositeClip,
-				 image->pCompositeClip,
-				 region);
+	status = pixman_region_intersect (image->pCompositeClip,
+				          image->pCompositeClip,
+				          region);
 	pixman_region_translate (image->pCompositeClip,
 				 image->clipOrigin.x,
 				 image->clipOrigin.y);
+	if (status != PIXMAN_REGION_STATUS_SUCCESS)
+	    return 1;
     }
 
     return 0;
@@ -558,6 +579,7 @@ FbClipImageReg (pixman_region16_t	*region,
 		int		dx,
 		int		dy)
 {
+    int ret = 1;
     if (pixman_region_num_rects (region) == 1 &&
 	pixman_region_num_rects (clip) == 1)
     {
@@ -582,10 +604,11 @@ FbClipImageReg (pixman_region16_t	*region,
     else
     {
 	pixman_region_translate (region, dx, dy);
-	pixman_region_intersect (region, clip, region);
+	ret = pixman_region_intersect (region, clip, region) ==
+	    PIXMAN_REGION_STATUS_SUCCESS;
 	pixman_region_translate (region, -dx, -dy);
     }
-    return 1;
+    return ret;
 }
 
 static __inline int
@@ -600,6 +623,7 @@ FbClipImageSrc (pixman_region16_t	*region,
     /* XXX davidr hates this, wants to never use source-based clipping */
     if (image->repeat != PIXMAN_REPEAT_NONE || image->pSourcePict)
     {
+	int ret = 1;
 	/* XXX no source clipping */
 	if (image->compositeClipSource &&
 	    image->clientClipType != CT_NONE)
@@ -607,12 +631,13 @@ FbClipImageSrc (pixman_region16_t	*region,
 	    pixman_region_translate (region,
 			   dx - image->clipOrigin.x,
 			   dy - image->clipOrigin.y);
-	    pixman_region_intersect (region, image->clientClip, region);
+	    ret = pixman_region_intersect (region, image->clientClip, region) ==
+		PIXMAN_REGION_STATUS_SUCCESS;
 	    pixman_region_translate (region,
 			   - (dx - image->clipOrigin.x),
 			   - (dy - image->clipOrigin.y));
 	}
-	return 1;
+	return ret;
     }
     else
     {
diff --git a/pixman/src/icimage.h b/pixman/src/icimage.h
index bbf41b9..f5daa31 100644
--- a/pixman/src/icimage.h
+++ b/pixman/src/icimage.h
@@ -278,7 +278,7 @@ FbCreateAlphaPicture (pixman_image_t	*dst,
 		      uint16_t	width,
 		      uint16_t	height);
 
-typedef void	(*CompositeFunc) (pixman_operator_t   op,
+typedef int	(*CompositeFunc) (pixman_operator_t   op,
 				  pixman_image_t    *iSrc,
 				  pixman_image_t    *iMask,
 				  pixman_image_t    *iDst,
@@ -367,7 +367,7 @@ fbBuildCompositeOperand (pixman_image_t	    *image,
 			 int		    transform,
 			 int		    alpha);
 
-pixman_private void
+pixman_private int
 pixman_compositeGeneral (pixman_operator_t	op,
 			 pixman_image_t	*iSrc,
 			 pixman_image_t	*iMask,
diff --git a/pixman/src/icrect.c b/pixman/src/icrect.c
index e4d0c12..fbd2a2f 100644
--- a/pixman/src/icrect.c
+++ b/pixman/src/icrect.c
@@ -176,7 +176,7 @@ pixman_fill_rect_general (pixman_image_t *dst,
     }
 }
 
-static void
+static int
 pixman_color_rects (pixman_image_t	 *dst,
 	      pixman_image_t	 *clipPict,
 	      pixman_color_t	 *color,
@@ -201,17 +201,32 @@ pixman_color_rects (pixman_image_t	 *dst,
     yoff -= dst->pixels->y;
 
     clip = pixman_region_create();
-    pixman_region_union_rect (clip, clip,
+    if (!clip)
+	return 1;
+    if (pixman_region_union_rect (clip, clip,
 			      dst->pixels->x, dst->pixels->y,
-			      dst->pixels->width, dst->pixels->height);
+			      dst->pixels->width, dst->pixels->height) !=
+	    PIXMAN_REGION_STATUS_SUCCESS){
+	pixman_region_destroy (clip);
+	return 1;
+    }
 
-    pixman_region_intersect (clip, clip, clipPict->pCompositeClip);
+    if (pixman_region_intersect (clip, clip, clipPict->pCompositeClip) !=
+	    PIXMAN_REGION_STATUS_SUCCESS) {
+	pixman_region_destroy (clip);
+	return 1;
+    }
     if (clipPict->alphaMap)
     {
 	pixman_region_translate (clip,
 				 -clipPict->alphaOrigin.x,
 				 -clipPict->alphaOrigin.y);
-	pixman_region_intersect (clip, clip, clipPict->alphaMap->pCompositeClip);
+	if (pixman_region_intersect (clip, clip,
+		                     clipPict->alphaMap->pCompositeClip) !=
+		PIXMAN_REGION_STATUS_SUCCESS) {
+	    pixman_region_destroy (clip);
+	    return 1;
+	}
 	pixman_region_translate (clip,
 				 clipPict->alphaOrigin.x,
 				 clipPict->alphaOrigin.y);
@@ -227,14 +242,28 @@ pixman_color_rects (pixman_image_t	 *dst,
     }
 
     rects_as_region = pixman_region_create ();
+    if (!rects_as_region) {
+	pixman_region_destroy (clip);
+	return 1;
+    }
     for (i = 0; i < nRect; i++)
     {
-	pixman_region_union_rect (rects_as_region, rects_as_region,
+	if (pixman_region_union_rect (rects_as_region, rects_as_region,
 				  rects[i].x, rects[i].y,
-				  rects[i].width, rects[i].height);
+				  rects[i].width, rects[i].height) !=
+		PIXMAN_REGION_STATUS_SUCCESS) {
+	    pixman_region_destroy (rects_as_region);
+	    pixman_region_destroy (clip);
+	    return 1;
+	}
     }
 
-    pixman_region_intersect (rects_as_region, rects_as_region, clip);
+    if (pixman_region_intersect (rects_as_region, rects_as_region, clip) !=
+	    PIXMAN_REGION_STATUS_SUCCESS) {
+	pixman_region_destroy (rects_as_region);
+	pixman_region_destroy (clip);
+	return 1;
+    }
     pixman_region_destroy (clip);
 
     n_clipped_rects = pixman_region_num_rects (rects_as_region);
@@ -268,9 +297,10 @@ pixman_color_rects (pixman_image_t	 *dst,
 	    rects[i].y += yoff;
 	}
     }
+    return 0;
 }
 
-void pixman_fill_rectangle (pixman_operator_t	op,
+int pixman_fill_rectangle (pixman_operator_t	op,
 		      pixman_image_t		*dst,
 		      const pixman_color_t	*color,
 		      int		x,
@@ -285,10 +315,10 @@ void pixman_fill_rectangle (pixman_operator_t	op,
     rect.width = width;
     rect.height = height;
 
-    pixman_fill_rectangles (op, dst, color, &rect, 1);
+    return pixman_fill_rectangles (op, dst, color, &rect, 1);
 }
 
-void
+int
 pixman_fill_rectangles (pixman_operator_t		op,
 		  pixman_image_t		*dst,
 		  const pixman_color_t		*color,
@@ -296,6 +326,7 @@ pixman_fill_rectangles (pixman_operator_t		op,
 		  int			nRects)
 {
     pixman_color_t color_s = *color;
+    int ret = 1;
 
     if (color_s.alpha == 0xffff)
     {
@@ -309,12 +340,21 @@ pixman_fill_rectangles (pixman_operator_t		op,
     {
       /* We cast away the constness of rects here, because pixman_color_rects
 	 temporarily modifies it */
-	pixman_color_rects (dst, dst, &color_s, nRects, (pixman_rectangle_t *)rects, 0, 0);
-	if (dst->alphaMap)
-	    pixman_color_rects (dst->alphaMap, dst,
-			  &color_s, nRects, (pixman_rectangle_t *)rects,
-			  dst->alphaOrigin.x,
-			  dst->alphaOrigin.y);
+	if (pixman_color_rects (dst, dst,
+		                &color_s, nRects,
+				(pixman_rectangle_t *)rects, 0, 0)) {
+		goto bail1;
+	}
+	if (dst->alphaMap) {
+	    if (pixman_color_rects (dst->alphaMap, dst,
+			            &color_s, nRects,
+				    (pixman_rectangle_t *)rects,
+				    dst->alphaOrigin.x,
+				    dst->alphaOrigin.y))
+		goto bail1;
+	}
+
+	ret = 0;
     }
     else
     {
@@ -348,18 +388,22 @@ pixman_fill_rectangles (pixman_operator_t		op,
 
 	while (nRects--)
 	{
-	    pixman_composite (op, src, NULL, dst, 0, 0, 0, 0,
-			 rects->x,
-			 rects->y,
-			 rects->width,
-			 rects->height);
+	    if (pixman_composite (op, src, NULL, dst, 0, 0, 0, 0,
+			          rects->x,
+			          rects->y,
+			          rects->width,
+			          rects->height))
+		goto bail3;
 	    rects++;
 	}
 
+	ret = 0;
+bail3:
 	pixman_image_destroy (src);
 bail2:
 	FbPixelsDestroy (pixels);
-bail1:
-	;
     }
+
+bail1:
+    return ret;
 }
diff --git a/pixman/src/ictrap.c b/pixman/src/ictrap.c
index 5a33ab8..fc093f0 100644
--- a/pixman/src/ictrap.c
+++ b/pixman/src/ictrap.c
@@ -98,10 +98,7 @@ pixman_trapezoid_bounds (int ntrap, const pixman_trapezoid_t *traps, pixman_box1
     }
 }
 
-/* XXX: There are failure cases in this function. Don't we need to
- * propagate the errors out?
- */
-void
+int
 pixman_composite_trapezoids (pixman_operator_t	      op,
 			     pixman_image_t	      *src,
 			     pixman_image_t	      *dst,
@@ -116,9 +113,10 @@ pixman_composite_trapezoids (pixman_operator_t	      op,
     int16_t		xDst, yDst;
     int16_t		xRel, yRel;
     pixman_format_t	*format;
+    int ret = 0;
 
     if (ntraps == 0)
-	return;
+	return 0;
 
     /*
      * Check for solid alpha add
@@ -127,7 +125,7 @@ pixman_composite_trapezoids (pixman_operator_t	      op,
     {
 	for (; ntraps; ntraps--, traps++)
 	    fbRasterizeTrapezoid (dst, traps, 0, 0);
-	return;
+	return 0;
     }
 
     xDst = traps[0].left.p1.x >> 16;
@@ -146,8 +144,17 @@ pixman_composite_trapezoids (pixman_operator_t	      op,
     dst_bounds.y2 = pixman_image_get_height (dst);
 
     dst_region = pixman_region_create_simple (&dst_bounds);
+    if (!dst_region) {
+	pixman_region_destroy (traps_region);
+	return 1;
+    }
 
-    pixman_region_intersect (traps_region, traps_region, dst_region);
+    if (pixman_region_intersect (traps_region, traps_region, dst_region) !=
+	    PIXMAN_REGION_STATUS_SUCCESS) {
+	pixman_region_destroy (traps_region);
+	pixman_region_destroy (dst_region);
+	return 1;
+    }
 
     bounds = *(pixman_region_extents (traps_region));
 
@@ -155,11 +162,11 @@ pixman_composite_trapezoids (pixman_operator_t	      op,
     pixman_region_destroy (dst_region);
 
     if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
-	return;
+	return 0;
 
     format = pixman_format_create (PIXMAN_FORMAT_NAME_A8);
     if (!format)
-	return;
+	return 1;
 
     image = FbCreateAlphaPicture (dst, format,
 				  bounds.x2 - bounds.x1,
@@ -167,7 +174,7 @@ pixman_composite_trapezoids (pixman_operator_t	      op,
     if (!image)
     {
 	pixman_format_destroy (format);
-	return;
+	return 1;
     }
 
     for (; ntraps; ntraps--, traps++)
@@ -180,13 +187,15 @@ pixman_composite_trapezoids (pixman_operator_t	      op,
 
     xRel = bounds.x1 + xSrc - xDst;
     yRel = bounds.y1 + ySrc - yDst;
-    pixman_composite (op, src, image, dst,
-		      xRel, yRel, 0, 0, bounds.x1, bounds.y1,
-		      bounds.x2 - bounds.x1,
-		      bounds.y2 - bounds.y1);
+    ret = pixman_composite (op, src, image, dst,
+		            xRel, yRel, 0, 0, bounds.x1, bounds.y1,
+			    bounds.x2 - bounds.x1,
+			    bounds.y2 - bounds.y1);
     pixman_image_destroy (image);
 
     pixman_format_destroy (format);
+
+    return ret;
 }
 
 void
diff --git a/pixman/src/ictri.c b/pixman/src/ictri.c
index 4080239..35f983b 100644
--- a/pixman/src/ictri.c
+++ b/pixman/src/ictri.c
@@ -134,7 +134,7 @@ FbRasterizeTriangle (pixman_image_t		*image,
 	fbRasterizeTrapezoid (image, &trap[1], x_off, y_off);
 }
 
-void
+int
 pixman_composite_triangles (pixman_operator_t	op,
 		      pixman_image_t		*src,
 		      pixman_image_t		*dst,
@@ -148,6 +148,7 @@ pixman_composite_triangles (pixman_operator_t	op,
     int		xDst, yDst;
     int		xRel, yRel;
     pixman_format_t	*format;
+    int ret = 0;
 
     xDst = tris[0].p1.x >> 16;
     yDst = tris[0].p1.y >> 16;
@@ -158,13 +159,13 @@ pixman_composite_triangles (pixman_operator_t	op,
     {
 	pixman_triangle_bounds (ntris, tris, &bounds);
 	if (bounds.x2 <= bounds.x1 || bounds.y2 <= bounds.y1)
-	    return;
+	    return 0;
 	image = FbCreateAlphaPicture (dst,
 				      format,
 				      bounds.x2 - bounds.x1,
 				      bounds.y2 - bounds.y1);
 	if (!image)
-	    return;
+	    return 1;
     }
     for (; ntris; ntris--, tris++)
     {
@@ -177,18 +178,23 @@ pixman_composite_triangles (pixman_operator_t	op,
 					  format,
 					  bounds.x2 - bounds.x1,
 					  bounds.y2 - bounds.y1);
-	    if (!image)
+	    if (!image) {
+		ret = 1;
 		break;
+	    }
 	}
 	FbRasterizeTriangle (image, tris, -bounds.x1, -bounds.y1);
 	if (!format)
 	{
 	    xRel = bounds.x1 + xSrc - xDst;
 	    yRel = bounds.y1 + ySrc - yDst;
-	    pixman_composite (op, src, image, dst,
-			 xRel, yRel, 0, 0, bounds.x1, bounds.y1,
-			 bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
+	    ret = pixman_composite (op, src, image, dst,
+			            xRel, yRel, 0, 0, bounds.x1, bounds.y1,
+				    bounds.x2 - bounds.x1,
+				    bounds.y2 - bounds.y1);
 	    pixman_image_destroy (image);
+	    if (ret)
+		break;
 	}
 	/* XXX adjust xSrc and ySrc */
     }
@@ -196,16 +202,18 @@ pixman_composite_triangles (pixman_operator_t	op,
     {
 	xRel = bounds.x1 + xSrc - xDst;
 	yRel = bounds.y1 + ySrc - yDst;
-	pixman_composite (op, src, image, dst,
-		     xRel, yRel, 0, 0, bounds.x1, bounds.y1,
-		     bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
+	ret = pixman_composite (op, src, image, dst,
+		                xRel, yRel, 0, 0, bounds.x1, bounds.y1,
+				bounds.x2 - bounds.x1,
+				bounds.y2 - bounds.y1);
 	pixman_image_destroy (image);
     }
 
     pixman_format_destroy (format);
+    return ret;
 }
 
-void
+int
 pixman_composite_tri_strip (pixman_operator_t		op,
 		     pixman_image_t		*src,
 		     pixman_image_t		*dst,
@@ -220,9 +228,10 @@ pixman_composite_tri_strip (pixman_operator_t		op,
     int		xDst, yDst;
     int		xRel, yRel;
     pixman_format_t	*format;
+    int ret = 0;
 
     if (npoints < 3)
-	return;
+	return 0;
 
     xDst = points[0].x >> 16;
     yDst = points[0].y >> 16;
@@ -233,13 +242,13 @@ pixman_composite_tri_strip (pixman_operator_t		op,
     {
 	pixman_point_fixed_bounds (npoints, points, &bounds);
 	if (bounds.x2 <= bounds.x1 || bounds.y2 <= bounds.y1)
-	    return;
+	    return 0;
 	image = FbCreateAlphaPicture (dst,
 				      format,
 				      bounds.x2 - bounds.x1,
 				      bounds.y2 - bounds.y1);
 	if (!image)
-	    return;
+	    return 1;
     }
     for (; npoints >= 3; npoints--, points++)
     {
@@ -255,34 +264,41 @@ pixman_composite_tri_strip (pixman_operator_t		op,
 					  format,
 					  bounds.x2 - bounds.x1,
 					  bounds.y2 - bounds.y1);
-	    if (!image)
-		continue;
+	    if (!image) {
+		ret = 1;
+		break;
+	    }
 	}
 	FbRasterizeTriangle (image, &tri, -bounds.x1, -bounds.y1);
 	if (!format)
 	{
 	    xRel = bounds.x1 + xSrc - xDst;
 	    yRel = bounds.y1 + ySrc - yDst;
-	    pixman_composite (op, src, image, dst,
-			 xRel, yRel, 0, 0, bounds.x1, bounds.y1,
-			 bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
+	    ret = pixman_composite (op, src, image, dst,
+			            xRel, yRel, 0, 0, bounds.x1, bounds.y1,
+				    bounds.x2 - bounds.x1,
+				    bounds.y2 - bounds.y1);
 	    pixman_image_destroy (image);
+	    if (ret)
+		break;
 	}
     }
     if (format)
     {
 	xRel = bounds.x1 + xSrc - xDst;
 	yRel = bounds.y1 + ySrc - yDst;
-	pixman_composite (op, src, image, dst,
-		     xRel, yRel, 0, 0, bounds.x1, bounds.y1,
-		     bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
+	ret = pixman_composite (op, src, image, dst,
+		                xRel, yRel, 0, 0, bounds.x1, bounds.y1,
+				bounds.x2 - bounds.x1,
+				bounds.y2 - bounds.y1);
 	pixman_image_destroy (image);
     }
 
     pixman_format_destroy (format);
+    return ret;
 }
 
-void
+int
 pixman_composite_tri_fan (pixman_operator_t		op,
 		   pixman_image_t		*src,
 		   pixman_image_t		*dst,
@@ -298,9 +314,10 @@ pixman_composite_tri_fan (pixman_operator_t		op,
     int		xDst, yDst;
     int		xRel, yRel;
     pixman_format_t	*format;
+    int ret = 0;
 
     if (npoints < 3)
-	return;
+	return 0;
 
     xDst = points[0].x >> 16;
     yDst = points[0].y >> 16;
@@ -311,13 +328,13 @@ pixman_composite_tri_fan (pixman_operator_t		op,
     {
 	pixman_point_fixed_bounds (npoints, points, &bounds);
 	if (bounds.x2 <= bounds.x1 || bounds.y2 <= bounds.y1)
-	    return;
+	    return 0;
 	image = FbCreateAlphaPicture (dst,
 				      format,
 				      bounds.x2 - bounds.x1,
 				      bounds.y2 - bounds.y1);
 	if (!image)
-	    return;
+	    return 1;
     }
     first = points++;
     npoints--;
@@ -335,29 +352,36 @@ pixman_composite_tri_fan (pixman_operator_t		op,
 					  format,
 					  bounds.x2 - bounds.x1,
 					  bounds.y2 - bounds.y1);
-	    if (!image)
-		continue;
+	    if (!image) {
+		ret = 1;
+		break;
+	    }
 	}
 	FbRasterizeTriangle (image, &tri, -bounds.x1, -bounds.y1);
 	if (!format)
 	{
 	    xRel = bounds.x1 + xSrc - xDst;
 	    yRel = bounds.y1 + ySrc - yDst;
-	    pixman_composite (op, src, image, dst,
-			 xRel, yRel, 0, 0, bounds.x1, bounds.y1,
-			 bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
+	    ret = pixman_composite (op, src, image, dst,
+			            xRel, yRel, 0, 0, bounds.x1, bounds.y1,
+			            bounds.x2 - bounds.x1,
+				    bounds.y2 - bounds.y1);
 	    pixman_image_destroy (image);
+	    if (ret)
+		break;
 	}
     }
     if (format)
     {
 	xRel = bounds.x1 + xSrc - xDst;
 	yRel = bounds.y1 + ySrc - yDst;
-	pixman_composite (op, src, image, dst,
-		     xRel, yRel, 0, 0, bounds.x1, bounds.y1,
-		     bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
+	ret = pixman_composite (op, src, image, dst,
+		                xRel, yRel, 0, 0, bounds.x1, bounds.y1,
+		                bounds.x2 - bounds.x1,
+			       	bounds.y2 - bounds.y1);
 	pixman_image_destroy (image);
     }
 
     pixman_format_destroy (format);
+    return ret;
 }
diff --git a/pixman/src/pixman.h b/pixman/src/pixman.h
index acf5327..a4241c4 100644
--- a/pixman/src/pixman.h
+++ b/pixman/src/pixman.h
@@ -442,7 +442,7 @@ pixman_pixel_to_color (const pixman_format_t	*format,
 
 /* icrect.c */
 
-pixman_private void
+pixman_private int
 pixman_fill_rectangle (pixman_operator_t	op,
 		       pixman_image_t		*dst,
 		       const pixman_color_t	*color,
@@ -451,7 +451,7 @@ pixman_fill_rectangle (pixman_operator_t	op,
 		       unsigned int		width,
 		       unsigned int		height);
 
-pixman_private void
+pixman_private int
 pixman_fill_rectangles (pixman_operator_t		op,
 			pixman_image_t			*dst,
 			const pixman_color_t		*color,
@@ -460,7 +460,7 @@ pixman_fill_rectangles (pixman_operator_t		op,
 
 /* ictrap.c */
 
-pixman_private void
+pixman_private int
 pixman_composite_trapezoids (pixman_operator_t		op,
 			     pixman_image_t		*src,
 			     pixman_image_t		*dst,
@@ -478,7 +478,7 @@ pixman_add_trapezoids (pixman_image_t		*dst,
 
 /* ictri.c */
 
-pixman_private void
+pixman_private int
 pixman_composite_triangles (pixman_operator_t		op,
 			    pixman_image_t		*src,
 			    pixman_image_t		*dst,
@@ -487,7 +487,7 @@ pixman_composite_triangles (pixman_operator_t		op,
 			    const pixman_triangle_t	*tris,
 			    int				ntris);
 
-pixman_private void
+pixman_private int
 pixman_composite_tri_strip (pixman_operator_t		op,
 			    pixman_image_t		*src,
 			    pixman_image_t		*dst,
@@ -496,7 +496,7 @@ pixman_composite_tri_strip (pixman_operator_t		op,
 			    const pixman_point_fixed_t	*points,
 			    int				npoints);
 
-pixman_private void
+pixman_private int
 pixman_composite_tri_fan (pixman_operator_t		op,
 			  pixman_image_t		*src,
 			  pixman_image_t		*dst,
@@ -507,7 +507,7 @@ pixman_composite_tri_fan (pixman_operator_t		op,
 
 /* ic.c */
 
-pixman_private void
+pixman_private int
 pixman_composite (pixman_operator_t	op,
 		  pixman_image_t	*iSrc,
 		  pixman_image_t	*iMask,
-- 
1.4.4.2

From hugo.vincent at gmail.com  Wed Mar 28 02:08:14 2007
From: hugo.vincent at gmail.com (Hugo Vincent)
Date: Wed Mar 28 02:08:35 2007
Subject: [cairo] Re: 1.4.2 release planned for today, 1.4.4 in a few weeks
In-Reply-To: <46095087.3080507@pobox.com>
References: <20070316222928.1FDEE9E817@gabe.freedesktop.org>
	<ABFD8AA6-ACAA-4DAE-9DA7-0CA61B8F366C@gmail.com>
	<2faad3050703261522s47300908k8e8381db9761ad0@mail.gmail.com>
	<11B4E846-7B75-467C-9D33-4F5B35D8A463@gmail.com>
	<46095087.3080507@pobox.com>
Message-ID: <1CACC7B5-1BD5-4ACC-92A6-B55EE8291743@gmail.com>

Thanks Vlad, that fixed the problem. Sorry for the noise on the list  
- it seemed like a genuine Cairo bug.

Hugo

On 28/03/2007, at 5:12 AM, Vladimir Vukicevic wrote:

>
> Ah, that crash.  So what's happening here is that cairo doesn't  
> gracefully deal with a backend's acquire_*_image returning  
> CAIRO_INT_STATUS_UNSUPPORTED -- it ends up propagating that error  
> all the way up to the user level, at which point the generic "make  
> sure it's a public error" assert in cairo_error triggers.
>
> The reason why you're seeing CAIRO_INT_STATUS_UNSUPPORTED is  
> because Cairo (that is, the Quartz surface) didn't create the CG  
> context itself; when it does, it creates it as an image context and  
> can then do fallback rendering as necessary.  Assuming we don't  
> manage to implement everything natively using Quartz (I think there  
> are a few operators that simply have no equivalents in Quartz, as  
> well as some operations), an easy way to get around this is to wrap  
> your rendering in between cairo_push_group() and  
> cairo_pop_group_to_source()/cairo_paint(); this will give you a  
> temporary Quartz surface that was created by the Quartz backend, so  
> fallback rendering would be possible.
>
>     - Vlad
>
> Hugo Vincent wrote:
>> Hi Baz,
>> The code below seems to replicate the crash; that is to say, even  
>> the simplest use of a radial gradient on Quartz crashes.
>> verbatim error: cairo.c:91: failed assertion `status >  
>> CAIRO_STATUS_SUCCESS && status <= CAIRO_STATUS_LAST_STATUS'
>> System Info:
>> Mac OS X 10.4.9 (on Intel Core 2 Duo), Xcode 2.4.1, Cairo 1.4.2  
>> [release]
>> Note, this code isn't exactly what I've been testing with, but I  
>> am 100% confident the other stuff I have in my code, but not in  
>> the included code here, is not what is causing this crash. Like I  
>> said before, Rsvg renders correctly, assuming the SVG file has no  
>> radial gradients. Also, because both Rsvg (which uses the Cairo C  
>> api) and this code, which is using Cairomm, both crash in the same  
>> way, we can assume the problem isn't with Cairomm. Finally, if you  
>> render this code into a PNG file it works fine.
>> Cheers,
>> Hugo
>> -----------------------------------------------------------
>> testview.h:
>> -----------------------------------------------------------
>> #import <Cocoa/Cocoa.h>
>> @interface TestView : NSView
>> {
>>     // nothing needed here
>> }
>> @end
>> -----------------------------------------------------------
>> testview.m
>> -----------------------------------------------------------
>> #include <cairomm/cairomm.h>
>> #include <cairomm/quartz_surface.h>
>> #ifndef CAIRO_HAS_QUARTZ_SURFACE
>> #error Need to build Cairo and Cairomm with Quartz support  
>> (version 1.4.0 or higher)
>> #endif
>> @implementation TestView
>> - (id)initWithFrame:(NSRect)frameRect
>> {
>>     if ((self = [super initWithFrame:frameRect]) != nil)
>>     {
>>         // nothing needed here
>>     }
>>     return self;
>> }
>> - (void)drawRect:(NSRect)rect
>> {
>>     // Get the size of this NSView
>>     NSRect bounds = [self bounds];
>>     int width = bounds.size.width;
>>     int height = bounds.size.height;
>>         // Get CoreGraphcis context reference
>>     CGContextRef ctx = (CGContextRef)[[NSGraphicsContext  
>> currentContext] graphicsPort];
>>         // Make the CGContext coordinate system sane, as expected  
>> by Cairo
>>     CGContextTranslateCTM (ctx, 0.0, height);
>>     CGContextScaleCTM (ctx, 1.0, -1.0);
>>     // Create the Cairo surface and context
>>     Cairo::RefPtr<Cairo::QuartzSurface> surface =  
>> Cairo::QuartzSurface::create(ctx, width, height);
>>     Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create 
>> (surface);
>>     // Draw a radial gradient (copied and pasted, more or less,  
>> from http://cairographics.org/samples/gradient.html)
>>     cr->scale(width,height);
>>     Cairo::RefPtr<Cairo::RadialGradient> grad2 =  
>> Cairo::RadialGradient::create(0.45, 0.4, 0.1, 0.4, 0.4, 0.5);
>>     grad2->add_color_stop_rgba(0, 1,0,0, 1);
>>     grad2->add_color_stop_rgba(1, 0,1,0, 1);
>>     cr->set_source(grad2);
>>     cairo_arc (cr, 0.5, 0.5, 0.3, 0, 2 * M_PI);
>>     cr->fill(); //  CRASHES!
>> }
>> @end
>> On 27/03/2007, at 10:22 AM, Baz wrote:
>>> On 17/03/07, Hugo Vincent <hugo.vincent@gmail.com> wrote:
>>>> Can the patch for bug 10036 (Cairo-Quartz Line-width-scaling  
>>>> problem)
>>>> be accepted for into 1.4.2 (or even 1.4.4)? Please!?
>>>> https://bugs.freedesktop.org/show_bug.cgi?id=10036
>>>>
>>>> Also, I have been playing round with Rsvg on Mac OS X, rendering  
>>>> into
>>>> a Cairo-Quartz context. It mostly works (except for the above
>>>> mentioned bug), however in certain cases it crashes rather
>>>> ungracefully when trying to do fallback operations for things that
>>>> aren't supported natively by Cairo-Quartz (certain radial gradients
>>>> seem to be the culprit). I'll prepare a proper test case and  
>>>> submit a
>>>> bug soon after I've tried it with 1.4.2.
>>>>
>>>> Cheers,
>>>> Hugo Vincent
>>>
>>> Hugo, did you ever track down that crasher?
>>>
>>> Cheers,
>>> Baz
>> _______________________________________________
>> cairo mailing list
>> cairo@cairographics.org
>> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
>

From setton at adacore.com  Wed Mar 28 03:12:05 2007
From: setton at adacore.com (Nicolas Setton)
Date: Wed Mar 28 03:30:25 2007
Subject: [cairo] Re: Speeding up stroking of dashed rectangles (was: ideas
	on improving the performance of gtk_tree_view)
In-Reply-To: <878xdizg8p.wl%cworth@cworth.org>
References: <63246EC1-97E3-4530-A38D-02E8248E6991@adacore.com>
	<1174679869.3677.87.camel@cacharro.xalalinux.org>
	<1174857487.4606e70fc3602@webmail.welho.com>
	<1174957585.3677.190.camel@cacharro.xalalinux.org>
	<41E18DEB-6C44-4C89-8E2C-EA45E8674710@adacore.com>
	<177e83dd0703270757k267d3681i6107a0e039d0aee2@mail.gmail.com>
	<6266FC70-3B62-4080-8D4E-0ACAA6CF8275@adacore.com>
	<878xdizg8p.wl%cworth@cworth.org>
Message-ID: <2A0319A7-B1B9-4A4E-8EBF-B7E0D05EB5FF@adacore.com>

> What hadn't ever been made clear is if real-world applications were
> seeing performance problems caused by the dashed stroking. It sounds
> like maybe you're on to one of those now.

To be fair, even though it's a "justifiable" use, that's an extreme  
case - with the font I'm using, one tree row is more than one hundred  
thousand pixels long.

> 	if (stroke_style->dash)
> 	    return CAIRO_INT_STATUS_UNSUPPORTED;
>
> After you do that, the results won't be correct, (the focus rectangle
> will come out solid instead of dashed), but it should give you a
> feeling of the upper-bound of the performance benefit you could expect
> from adding dash support to this function, (and also confirm if the
> dashed stroking is the cause of the problems you're seeing).

I commented out the line, and, as expected, the performance becomes  
good. The response time was divided by about 100!

> And if so, then yes, the cairo list might be the best place to
> continue the discussion. In fact, I just decided to pull that list in
> with this reply. Please feel free to drop gtk-devel-list from future
> replies if we just keep talking about cairo's dashed stroking code.

I've kept gtk-devel-list to inform everyone of the results, since  
that's one more argument in favor of integrating Markku's patch.

I'll also take the opportunity to thank again everyone involved in  
these productive discussions. This is one healthy community!

Carl, see you in the cairo list for the continuation of this :) I'll  
try submitting a pertinent test for integration in the perf/ suite,  
and then a tentative implementation of dash support in  
_cairo_path_fixed_stroke_rectilinear.

Nico
From thekenny123 at gmail.com  Wed Mar 28 05:30:38 2007
From: thekenny123 at gmail.com (The-Kenny)
Date: Wed Mar 28 05:30:42 2007
Subject: [cairo] [cairomm] inline Images
Message-ID: <9712644.post@talk.nabble.com>


Hello,
Is there a way to store images (Png) in the sourcecode?
 
A (small) example:
 
test.cpp loads blubb.png
 
But I want blubb.png in test.cpp
 
So that my program does not have to load blubb.png
 
Best regards
Moritz Ulrich
-- 
View this message in context: http://www.nabble.com/-cairomm--inline-Images-tf3480012.html#a9712644
Sent from the Free Desktop - Cairo - General mailing list archive at Nabble.com.

From koen at dominion.kabel.utwente.nl  Wed Mar 28 06:03:21 2007
From: koen at dominion.kabel.utwente.nl (Koen Kooi)
Date: Wed Mar 28 06:03:37 2007
Subject: [cairo] Re: [cairomm] inline Images
In-Reply-To: <9712644.post@talk.nabble.com>
References: <9712644.post@talk.nabble.com>
Message-ID: <eudp2r$ads$1@sea.gmane.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

The-Kenny schreef:
> Hello,
> Is there a way to store images (Png) in the sourcecode?
>  
> A (small) example:
>  
> test.cpp loads blubb.png
>  
> But I want blubb.png in test.cpp
>  
> So that my program does not have to load blubb.png

IIRC the abiword people have a perl script called 'cdump.pl' to do such a thing for their
splash screen.

regards,

Koen
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (Darwin)

iD8DBQFGCmeZMkyGM64RGpERAr7AAJ9PinI6hiMMuLJErqtIg186fiZlTgCgp94U
xTdT/MyGhkZe4cD1fxKIk68=
=Yj2M
-----END PGP SIGNATURE-----

From alexl at redhat.com  Wed Mar 28 07:34:05 2007
From: alexl at redhat.com (Alexander Larsson)
Date: Wed Mar 28 07:34:11 2007
Subject: [cairo] [cairomm] inline Images
In-Reply-To: <9712644.post@talk.nabble.com>
References: <9712644.post@talk.nabble.com>
Message-ID: <1175092445.31394.46.camel@greebo>

On Wed, 2007-03-28 at 05:30 -0700, The-Kenny wrote:
> Hello,
> Is there a way to store images (Png) in the sourcecode?
>  
> A (small) example:
>  
> test.cpp loads blubb.png
>  
> But I want blubb.png in test.cpp
>  
> So that my program does not have to load blubb.png

You could use gdk-pixbuf-csource (from gtk+).

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 Alexander Larsson                                            Red Hat, Inc 
                   alexl@redhat.com    alla@lysator.liu.se 
He's a Nobel prize-winning sweet-toothed boxer looking for a cure to the 
poison coursing through his veins. She's a cynical out-of-work bodyguard with 
a birthmark shaped like Liberty's torch. They fight crime! 

From chris at chris-wilson.co.uk  Wed Mar 28 08:07:35 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar 28 08:07:48 2007
Subject: [cairo] Add attribute(warn_unused_result)
In-Reply-To: <20070327210451.GB24027@inspired.chris-wilson.co.uk>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
	<1174502491.1028.20.camel@behdad>
	<20070327210451.GB24027@inspired.chris-wilson.co.uk>
Message-ID: <20070328150735.GB30115@inspired.chris-wilson.co.uk>

A series of patches to propagate statuses which required changing
function types.
--
Chris Wilson
-------------- next part --------------
>From aeac341611e18208baa9f90296c8ebf8798e84ed Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 14:09:57 +0100
Subject: [PATCH] Catch and propagate out-of-memory status returns.

The skip list inserts could return NULL indicating an out-of-memory error.
In order to handle this, the error needs to propagate up the call stack.
---
 src/cairo-bentley-ottmann.c |   61 ++++++++++++++++++++++++++++++++----------
 1 files changed, 46 insertions(+), 15 deletions(-)

diff --git a/src/cairo-bentley-ottmann.c b/src/cairo-bentley-ottmann.c
index 873bfd6..14308f8 100644
--- a/src/cairo-bentley-ottmann.c
+++ b/src/cairo-bentley-ottmann.c
@@ -137,6 +137,18 @@ typedef struct _cairo_bo_sweep_line {
     int32_t current_y;
 } cairo_bo_sweep_line_t;
 
+
+cairo_static cairo_status_t
+_cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
+			     cairo_bo_edge_t		*edge);
+cairo_static cairo_status_t
+_cairo_bo_event_queue_insert (cairo_bo_event_queue_t *queue,
+			      cairo_bo_event_t	     *event);
+cairo_static cairo_status_t
+_cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t	*event_queue,
+							   cairo_bo_edge_t	*left,
+							   cairo_bo_edge_t	*right);
+
 static inline int
 _cairo_bo_point32_compare (cairo_bo_point32_t const *a,
 			   cairo_bo_point32_t const *b)
@@ -692,13 +704,16 @@ _cairo_bo_event_init (cairo_bo_event_t		*event,
     event->point = point;
 }
 
-static void
+static cairo_status_t
 _cairo_bo_event_queue_insert (cairo_bo_event_queue_t *queue,
 			      cairo_bo_event_t	     *event)
 {
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
     /* Don't insert if there's already an equivalent intersection event in the queue. */
-    _cairo_skip_list_insert (&queue->intersection_queue, event,
-		      event->type == CAIRO_BO_EVENT_TYPE_INTERSECTION);
+    if (_cairo_skip_list_insert (&queue->intersection_queue, event,
+		      event->type == CAIRO_BO_EVENT_TYPE_INTERSECTION) == NULL)
+	status = CAIRO_STATUS_NO_MEMORY;
+    return status;
 }
 
 static void
@@ -796,7 +811,7 @@ _cairo_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue)
 	free (event_queue->sorted_startstop_event_ptrs);
 }
 
-static void
+static cairo_status_t
 _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t	*event_queue,
 							   cairo_bo_edge_t	*left,
 							   cairo_bo_edge_t	*right)
@@ -806,7 +821,7 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
     cairo_bo_event_t event;
 
     if (left == NULL || right == NULL)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     /* The names "left" and "right" here are correct descriptions of
      * the order of the two edges within the active edge list. So if a
@@ -814,13 +829,13 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
      * that the intersection of these two segments has oalready
      * occurred before the current sweep line position. */
     if (_slope_compare (left, right) < 0)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     status = _cairo_bo_edge_intersect (left, right, &intersection);
     if (status == CAIRO_BO_STATUS_PARALLEL ||
 	status == CAIRO_BO_STATUS_NO_INTERSECTION)
     {
-	return;
+	return CAIRO_STATUS_SUCCESS;
     }
 
     _cairo_bo_event_init (&event,
@@ -828,7 +843,7 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
 			  left, right,
 			  intersection);
 
-    _cairo_bo_event_queue_insert (event_queue, &event);
+    return _cairo_bo_event_queue_insert (event_queue, &event);
 }
 
 static void
@@ -848,7 +863,7 @@ _cairo_bo_sweep_line_fini (cairo_bo_sweep_line_t *sweep_line)
     _cairo_skip_list_fini (&sweep_line->active_edges);
 }
 
-static void
+static cairo_status_t
 _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
 			     cairo_bo_edge_t		*edge)
 {
@@ -858,6 +873,8 @@ _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
 
     sweep_line_elt = _cairo_skip_list_insert (&sweep_line->active_edges, &edge,
 				       1 /* unique inserts*/);
+    if (sweep_line_elt == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
 
     next_elt = sweep_line_elt->elt.next[0];
     if (next_elt)
@@ -876,6 +893,8 @@ _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
     *next_of_prev = edge;
 
     edge->sweep_line_elt = sweep_line_elt;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static void
@@ -1296,7 +1315,9 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 	case CAIRO_BO_EVENT_TYPE_START:
 	    edge = event->e1;
 
-	    _cairo_bo_sweep_line_insert (&sweep_line, edge);
+	    status = _cairo_bo_sweep_line_insert (&sweep_line, edge);
+	    if (status)
+		goto unwind;
 	    /* Cache the insert position for use in pass 2.
 	    event->e2 = Sortlist::prev (sweep_line, edge);
 	    */
@@ -1304,9 +1325,13 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 	    left = edge->prev;
 	    right = edge->next;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, edge);
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, edge);
+	    if (status)
+		goto unwind;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, edge, right);
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, edge, right);
+	    if (status)
+		goto unwind;
 
 #if DEBUG_PRINT_STATE
 	    print_state ("After processing start", &event_queue, &sweep_line);
@@ -1326,7 +1351,9 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 	    if (status)
 		goto unwind;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, right);
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, right);
+	    if (status)
+		goto unwind;
 
 #if DEBUG_PRINT_STATE
 	    print_state ("After processing stop", &event_queue, &sweep_line);
@@ -1354,11 +1381,15 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 
 	    /* after the swap e2 is left of e1 */
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
 								       left, edge2);
+	    if (status)
+		goto unwind;
 
-	    _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
+	    status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue,
 								       edge1, right);
+	    if (status)
+		goto unwind;
 
 #if DEBUG_PRINT_STATE
 	    print_state ("After processing intersection", &event_queue, &sweep_line);
-- 
1.4.4.2

-------------- next part --------------
>From 0d8d5639b5379490bfdcf84bf1b627a1118960d7 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 14:37:18 +0100
Subject: [PATCH] pixman region operations can fail, propagate the error.

Copying the clip region could fail, add error returns and propagate up
the call stack.
---
 src/cairo-clip-private.h |    4 ++--
 src/cairo-clip.c         |   39 +++++++++++++++++++++++++++++++++------
 src/cairo-gstate.c       |   14 +++++++++++---
 src/cairo.c              |    2 +-
 src/cairoint.h           |    2 +-
 5 files changed, 48 insertions(+), 13 deletions(-)

diff --git a/src/cairo-clip-private.h b/src/cairo-clip-private.h
index 3c4ff0d..81482ff 100644
--- a/src/cairo-clip-private.h
+++ b/src/cairo-clip-private.h
@@ -86,10 +86,10 @@ _cairo_clip_init (cairo_clip_t *clip, cairo_surface_t *target);
 cairo_private void
 _cairo_clip_fini (cairo_clip_t *clip);
 
-cairo_private void
+cairo_private cairo_status_t
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other);
 
-cairo_private void
+cairo_private cairo_status_t
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target);
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index 0ab036b..de4bd23 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -82,7 +82,7 @@ _cairo_clip_fini (cairo_clip_t *clip)
     clip->path = NULL;
 }
 
-void
+cairo_status_t
 _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 {
     clip->mode = other->mode;
@@ -96,10 +96,21 @@ _cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other)
 	clip->region = other->region;
     } else {
 	clip->region = pixman_region_create ();
-	pixman_region_copy (clip->region, other->region);
+	if (clip->region == NULL) {
+	    cairo_surface_destroy (clip->surface);
+	    return CAIRO_STATUS_NO_MEMORY;
+	}
+	if (pixman_region_copy (clip->region, other->region) !=
+		PIXMAN_REGION_STATUS_SUCCESS) {
+	    pixman_region_destroy (clip->region);
+	    cairo_surface_destroy (clip->surface);
+	    return CAIRO_STATUS_NO_MEMORY;
+	}
     }
 
     clip->path = _cairo_clip_path_reference (other->path);
+    
+    return CAIRO_STATUS_SUCCESS;
 }
 
 cairo_status_t
@@ -553,7 +564,7 @@ _cairo_clip_path_reapply_clip_path (cairo_clip_t      *clip,
                                 clip_path->antialias);
 }
 
-void
+cairo_status_t
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target)
@@ -566,16 +577,22 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
     } else {
         if (other->region) {
             clip->region = pixman_region_create ();
-            pixman_region_copy (clip->region, other->region);
+	    if (clip->region == NULL)
+		goto BAIL;
+            if (pixman_region_copy (clip->region, other->region) !=
+		    PIXMAN_REGION_STATUS_SUCCESS)
+		goto BAIL;
         }
 
         if (other->surface) {
-            _cairo_surface_clone_similar (target, other->surface,
+            if (_cairo_surface_clone_similar (target, other->surface,
 					  other->surface_rect.x,
 					  other->surface_rect.y,
 					  other->surface_rect.width,
 					  other->surface_rect.height,
-					  &clip->surface);
+					  &clip->surface) !=
+		    CAIRO_STATUS_SUCCESS)
+		goto BAIL;
             clip->surface_rect = other->surface_rect;
         }
 
@@ -583,6 +600,16 @@ _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
             _cairo_clip_path_reapply_clip_path (clip, other->path);
         }
     }
+
+    return CAIRO_STATUS_SUCCESS;
+
+BAIL:
+    if (clip->region)
+	pixman_region_destroy (clip->region);
+    if (clip->surface)
+	cairo_surface_destroy (clip->surface);
+
+    return CAIRO_STATUS_NO_MEMORY;
 }
 
 const cairo_rectangle_list_t _cairo_rectangles_nil =
diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index 5647f9c..82f5402 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -134,7 +134,9 @@ _cairo_gstate_init_copy (cairo_gstate_t *gstate, cairo_gstate_t *other)
 
     _cairo_font_options_init_copy (&gstate->font_options , &other->font_options);
 
-    _cairo_clip_init_copy (&gstate->clip, &other->clip);
+    status = _cairo_clip_init_copy (&gstate->clip, &other->clip);
+    if (status)
+	return status;
 
     gstate->target = cairo_surface_reference (other->target);
     /* parent_target is always set to NULL; it's only ever set by redirect_target */
@@ -304,9 +306,11 @@ _cairo_gstate_recursive_apply_clip_path (cairo_gstate_t *gstate,
  * original #cairo_t target, the clip will be INVALID after this call,
  * and the caller should either recreate or reset the clip.
  **/
-void
+cairo_status_t
 _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child)
 {
+    cairo_status_t status;
+
     /* If this gstate is already redirected, this is an error; we need a
      * new gstate to be able to redirect */
     assert (gstate->parent_target == NULL);
@@ -322,13 +326,17 @@ _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child)
     gstate->target = cairo_surface_reference (child);
 
     _cairo_clip_fini (&gstate->clip);
-    _cairo_clip_init_deep_copy (&gstate->clip, &gstate->next->clip, child);
+    status = _cairo_clip_init_deep_copy (&gstate->clip, &gstate->next->clip, child);
+    if (status)
+	return status;
 
     /* The clip is in surface backend coordinates for the previous target;
      * translate it into the child's backend coordinates. */
     _cairo_clip_translate (&gstate->clip,
                            _cairo_fixed_from_double (child->device_transform.x0 - gstate->parent_target->device_transform.x0),
                            _cairo_fixed_from_double (child->device_transform.y0 - gstate->parent_target->device_transform.y0));
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /**
diff --git a/src/cairo.c b/src/cairo.c
index b8a0419..64b2b0b 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -517,7 +517,7 @@ cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
     if (cr->status)
 	goto bail;
 
-    _cairo_gstate_redirect_target (cr->gstate, group_surface);
+    status = _cairo_gstate_redirect_target (cr->gstate, group_surface);
 
 bail:
     cairo_surface_destroy (group_surface);
diff --git a/src/cairoint.h b/src/cairoint.h
index ed685e6..9aa50ff 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -1259,7 +1259,7 @@ _cairo_gstate_restore (cairo_gstate_t **gstate);
 cairo_private cairo_bool_t
 _cairo_gstate_is_redirected (cairo_gstate_t *gstate);
 
-cairo_private void
+cairo_private cairo_status_t
 _cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child);
 
 cairo_private cairo_surface_t *
-- 
1.4.4.2

-------------- next part --------------
>From 9873c2a418789dba375f74fe19dcbb182ee2f8ac Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 14:50:59 +0100
Subject: [PATCH] pixman_composite can fail, propagate the error status.

---
 src/cairo-image-surface.c |   42 +++++++++++++++++++++++++++---------------
 src/cairo-pattern.c       |   20 ++++++++++++--------
 2 files changed, 39 insertions(+), 23 deletions(-)

diff --git a/src/cairo-image-surface.c b/src/cairo-image-surface.c
index 3062533..a122fa3 100644
--- a/src/cairo-image-surface.c
+++ b/src/cairo-image-surface.c
@@ -848,7 +848,7 @@ _cairo_image_surface_composite (cairo_operator_t	op,
 	if (status)
 	    goto CLEANUP_SURFACES;
 
-	pixman_composite (_pixman_operator (op),
+	if (pixman_composite (_pixman_operator (op),
 			  src->pixman_image,
 			  mask->pixman_image,
 			  dst->pixman_image,
@@ -857,11 +857,14 @@ _cairo_image_surface_composite (cairo_operator_t	op,
 			  mask_x + mask_attr.x_offset,
 			  mask_y + mask_attr.y_offset,
 			  dst_x, dst_y,
-			  width, height);
+			  width, height)) {
+	    status = CAIRO_STATUS_NO_MEMORY;
+	    goto CLEANUP_SURFACES;
+	}
     }
     else
     {
-	pixman_composite (_pixman_operator (op),
+	if (pixman_composite (_pixman_operator (op),
 			  src->pixman_image,
 			  NULL,
 			  dst->pixman_image,
@@ -869,7 +872,10 @@ _cairo_image_surface_composite (cairo_operator_t	op,
 			  src_y + src_attr.y_offset,
 			  0, 0,
 			  dst_x, dst_y,
-			  width, height);
+			  width, height)) {
+	    status = CAIRO_STATUS_NO_MEMORY;
+	    goto CLEANUP_SURFACES;
+	}
     }
 
     if (!_cairo_operator_bounded_by_source (op))
@@ -908,8 +914,11 @@ _cairo_image_surface_fill_rectangles (void		      *abstract_surface,
     pixman_color.alpha = color->alpha_short;
 
     /* XXX: The pixman_rectangle_t cast is evil... it needs to go away somehow. */
-    pixman_fill_rectangles (_pixman_operator(op), surface->pixman_image,
-			    &pixman_color, (pixman_rectangle_t *) rects, num_rects);
+    if (pixman_fill_rectangles (_pixman_operator(op), surface->pixman_image,
+			        &pixman_color,
+			        (pixman_rectangle_t *) rects, num_rects)) {
+	return CAIRO_STATUS_NO_MEMORY;
+    }
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -1014,15 +1023,18 @@ _cairo_image_surface_composite_trapezoids (cairo_operator_t	op,
     pixman_add_trapezoids (mask, - dst_x, - dst_y,
 			   (pixman_trapezoid_t *) traps, num_traps);
 
-    pixman_composite (_pixman_operator (op),
-		      src->pixman_image,
-		      mask,
-		      dst->pixman_image,
-		      src_x + attributes.x_offset,
-		      src_y + attributes.y_offset,
-		      0, 0,
-		      dst_x, dst_y,
-		      width, height);
+    if (pixman_composite (_pixman_operator (op),
+		          src->pixman_image,
+			  mask,
+			  dst->pixman_image,
+			  src_x + attributes.x_offset,
+			  src_y + attributes.y_offset,
+			  0, 0,
+			  dst_x, dst_y,
+			  width, height)) {
+	status = CAIRO_STATUS_NO_MEMORY;
+	goto CLEANUP_IMAGE_DATA;
+    }
 
     if (!_cairo_operator_bounded_by_mask (op))
 	status = _cairo_surface_composite_shape_fixup_unbounded (&dst->base,
diff --git a/src/cairo-pattern.c b/src/cairo-pattern.c
index 3001e10..570527d 100644
--- a/src/cairo-pattern.c
+++ b/src/cairo-pattern.c
@@ -1212,14 +1212,18 @@ _cairo_pattern_acquire_surface_for_gradient (cairo_gradient_pattern_t *pattern,
 	break;
     }
 
-    pixman_composite (PIXMAN_OPERATOR_SRC,
-		      pixman_image,
-		      NULL,
-		      image->pixman_image,
-		      x, y,
-		      0, 0,
-		      0, 0,
-		      width, height);
+    if (pixman_composite (PIXMAN_OPERATOR_SRC,
+		          pixman_image,
+			  NULL,
+			  image->pixman_image,
+			  x, y,
+			  0, 0,
+			  0, 0,
+			  width, height)) {
+	cairo_surface_destroy (&image->base);
+	pixman_image_destroy (pixman_image);
+	return CAIRO_STATUS_NO_MEMORY;
+    }
 
     pixman_image_destroy (pixman_image);
 
-- 
1.4.4.2

-------------- next part --------------
>From 2b9f65d2860f3bbfa81c49179ffef031657ead81 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 14:57:44 +0100
Subject: [PATCH] cairo_pen_init() can fail propagate its error.

---
 src/cairo-path-stroke.c |   43 +++++++++++++++++++++++++------------------
 1 files changed, 25 insertions(+), 18 deletions(-)

diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index 3aeb41f..4dd96b0 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -67,7 +67,7 @@ typedef struct cairo_stroker {
 } cairo_stroker_t;
 
 /* private functions */
-static void
+cairo_static cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -75,40 +75,40 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     double			 tolerance,
 		     cairo_traps_t		*traps);
 
-static void
+cairo_static void
 _cairo_stroker_fini (cairo_stroker_t *stroker);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_move_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_line_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_line_to_dashed (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_curve_to (void *closure,
 			 cairo_point_t *b,
 			 cairo_point_t *c,
 			 cairo_point_t *d);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_curve_to_dashed (void *closure,
 				cairo_point_t *b,
 				cairo_point_t *c,
 				cairo_point_t *d);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_close_path (void *closure);
 
-static void
+cairo_static void
 _translate_point (cairo_point_t *point, cairo_point_t *offset);
 
-static int
+cairo_static int
 _cairo_stroker_face_clockwise (cairo_stroke_face_t *in, cairo_stroke_face_t *out);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_stroker_join (cairo_stroker_t *stroker, cairo_stroke_face_t *in, cairo_stroke_face_t *out);
 
 static void
@@ -148,7 +148,7 @@ _cairo_stroker_step_dash (cairo_stroker_t *stroker, double step)
     }
 }
 
-static void
+static cairo_status_t
 _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     cairo_stroke_style_t	*stroke_style,
 		     cairo_matrix_t		*ctm,
@@ -156,15 +156,18 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     double			 tolerance,
 		     cairo_traps_t		*traps)
 {
+    cairo_status_t status;
     stroker->style = stroke_style;
     stroker->ctm = ctm;
     stroker->ctm_inverse = ctm_inverse;
     stroker->tolerance = tolerance;
     stroker->traps = traps;
 
-    _cairo_pen_init (&stroker->pen,
-		     stroke_style->line_width / 2.0,
-		     tolerance, ctm);
+    status = _cairo_pen_init (&stroker->pen,
+		              stroke_style->line_width / 2.0,
+			      tolerance, ctm);
+    if (status)
+	return status;
 
     stroker->has_current_face = FALSE;
     stroker->has_first_face = FALSE;
@@ -174,6 +177,8 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 	_cairo_stroker_start_dash (stroker);
     else
 	stroker->dashed = FALSE;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static void
@@ -995,9 +1000,11 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
     if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 	return status;
 
-    _cairo_stroker_init (&stroker, stroke_style,
-			 ctm, ctm_inverse, tolerance,
-			 traps);
+    status = _cairo_stroker_init (&stroker, stroke_style,
+			          ctm, ctm_inverse, tolerance,
+				  traps);
+    if (status)
+	return status;
 
     if (stroker.style->dash)
 	status = _cairo_path_fixed_interpret (path,
-- 
1.4.4.2

-------------- next part --------------
>From 096461a0a558a7e37d1bac3151e2d2323fb4ee75 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 15:05:39 +0100
Subject: [PATCH] pen finalization can fail, propagate its status.

---
 src/cairo-path-stroke.c |   18 +++++++++++-------
 src/cairo-pen.c         |    4 ++--
 src/cairoint.h          |    2 +-
 3 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/src/cairo-path-stroke.c b/src/cairo-path-stroke.c
index 4dd96b0..aa8ce38 100644
--- a/src/cairo-path-stroke.c
+++ b/src/cairo-path-stroke.c
@@ -75,7 +75,7 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
 		     double			 tolerance,
 		     cairo_traps_t		*traps);
 
-cairo_static void
+cairo_static cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker);
 
 cairo_static cairo_status_t
@@ -181,10 +181,10 @@ _cairo_stroker_init (cairo_stroker_t		*stroker,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+static cairo_status_t
 _cairo_stroker_fini (cairo_stroker_t *stroker)
 {
-    _cairo_pen_fini (&stroker->pen);
+    return _cairo_pen_fini (&stroker->pen);
 }
 
 static void
@@ -811,7 +811,7 @@ _cairo_stroker_curve_to (void *closure,
 			 cairo_point_t *c,
 			 cairo_point_t *d)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS, status2;
     cairo_stroker_t *stroker = closure;
     cairo_spline_t spline;
     cairo_pen_t pen;
@@ -863,7 +863,9 @@ _cairo_stroker_curve_to (void *closure,
 	goto CLEANUP_PEN;
 
   CLEANUP_PEN:
-    _cairo_pen_fini (&pen);
+    status2 = _cairo_pen_fini (&pen);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
   CLEANUP_SPLINE:
     _cairo_spline_fini (&spline);
 
@@ -985,7 +987,7 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
 				   double		 tolerance,
 				   cairo_traps_t	*traps)
 {
-    cairo_status_t status;
+    cairo_status_t status, status2;
     cairo_stroker_t stroker;
 
     /* Before we do anything else, we attempt the rectilinear
@@ -1029,7 +1031,9 @@ _cairo_path_fixed_stroke_to_traps (cairo_path_fixed_t	*path,
     status = _cairo_stroker_add_caps (&stroker);
 
 BAIL:
-    _cairo_stroker_fini (&stroker);
+    status2 = _cairo_stroker_fini (&stroker);
+    if (status == CAIRO_STATUS_SUCCESS)
+	status = status2;
 
     return status;
 }
diff --git a/src/cairo-pen.c b/src/cairo-pen.c
index 1bc096b..74d2996 100644
--- a/src/cairo-pen.c
+++ b/src/cairo-pen.c
@@ -106,13 +106,13 @@ _cairo_pen_init (cairo_pen_t	*pen,
     return CAIRO_STATUS_SUCCESS;
 }
 
-void
+cairo_status_t
 _cairo_pen_fini (cairo_pen_t *pen)
 {
     free (pen->vertices);
     pen->vertices = NULL;
 
-    _cairo_pen_init_empty (pen);
+    return _cairo_pen_init_empty (pen);
 }
 
 cairo_status_t
diff --git a/src/cairoint.h b/src/cairoint.h
index 9aa50ff..cef52fc 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -2186,7 +2186,7 @@ _cairo_pen_init_empty (cairo_pen_t *pen);
 cairo_private cairo_status_t
 _cairo_pen_init_copy (cairo_pen_t *pen, cairo_pen_t *other);
 
-cairo_private void
+cairo_private cairo_status_t
 _cairo_pen_fini (cairo_pen_t *pen);
 
 cairo_private cairo_status_t
-- 
1.4.4.2

-------------- next part --------------
>From 2ab24f2827cd29c3d3b05cba8097b3b018105152 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 15:27:04 +0100
Subject: [PATCH] Matrix transformation could fail, so propagate its error status.

---
 src/cairo-ft-font.c     |   90 ++++++++++++++++++++++++++++++++++------------
 src/cairo-scaled-font.c |   13 +++++--
 src/cairoint.h          |    2 +-
 3 files changed, 76 insertions(+), 29 deletions(-)

diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index 73a40f8..d30628a 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -106,13 +106,20 @@ struct _cairo_ft_unscaled_font {
     cairo_ft_font_face_t *faces;	/* Linked list of faces for this font */
 };
 
-static int
+cairo_static cairo_status_t
+_compute_transform (cairo_ft_font_transform_t *sf,
+		    cairo_matrix_t      *scale);
+
+cairo_static int
 _cairo_ft_unscaled_font_keys_equal (const void *key_a,
 				    const void *key_b);
-
-static void
+cairo_static void
 _cairo_ft_unscaled_font_fini (cairo_ft_unscaled_font_t *unscaled);
 
+cairo_static cairo_status_t
+_cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
+				   cairo_matrix_t	      *scale);
+
 typedef enum _cairo_ft_extra_flags {
     CAIRO_FT_OPTIONS_HINT_METRICS = (1 << 0),
     CAIRO_FT_OPTIONS_EMBOLDEN = (1 << 1)
@@ -572,12 +579,13 @@ _cairo_ft_unscaled_font_unlock_face (cairo_ft_unscaled_font_t *unscaled)
 }
 slim_hidden_def (cairo_ft_scaled_font_unlock_face);
 
-static void
+static cairo_status_t
 _compute_transform (cairo_ft_font_transform_t *sf,
 		    cairo_matrix_t      *scale)
 {
     cairo_matrix_t normalized = *scale;
     double tx, ty;
+    cairo_status_t status;
 
     /* The font matrix has x and y "scale" components which we extract and
      * use as character scale values. These influence the way freetype
@@ -586,9 +594,11 @@ _compute_transform (cairo_ft_font_transform_t *sf,
      * freetype's transformation.
      */
 
-    _cairo_matrix_compute_scale_factors (&normalized,
-					 &sf->x_scale, &sf->y_scale,
-					 /* XXX */ 1);
+    status = _cairo_matrix_compute_scale_factors (&normalized,
+					          &sf->x_scale, &sf->y_scale,
+					          /* XXX */ 1);
+    if (status)
+	return status;
 
     if (sf->x_scale != 0 && sf->y_scale != 0) {
 	cairo_matrix_scale (&normalized, 1.0 / sf->x_scale, 1.0 / sf->y_scale);
@@ -601,16 +611,19 @@ _compute_transform (cairo_ft_font_transform_t *sf,
 	sf->shape[0][0] = sf->shape[1][1] = 1.0;
 	sf->shape[0][1] = sf->shape[1][0] = 0.0;
     }
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /* Temporarily scales an unscaled font to the give scale. We catch
  * scaling to the same size, since changing a FT_Face is expensive.
  */
-static void
+static cairo_status_t
 _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 				   cairo_matrix_t	      *scale)
 {
     cairo_ft_font_transform_t sf;
+    cairo_status_t status;
     FT_Matrix mat;
     FT_Error error;
 
@@ -621,12 +634,14 @@ _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 	scale->yx == unscaled->current_scale.yx &&
 	scale->xy == unscaled->current_scale.xy &&
 	scale->yy == unscaled->current_scale.yy)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     unscaled->have_scale = TRUE;
     unscaled->current_scale = *scale;
 
-    _compute_transform (&sf, scale);
+    status = _compute_transform (&sf, scale);
+    if (status)
+	return status;
 
     unscaled->x_scale = sf.x_scale;
     unscaled->y_scale = sf.y_scale;
@@ -654,6 +669,8 @@ _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 				  sf.x_scale * 64.0,
 				  sf.y_scale * 64.0,
 				  0, 0);
+	if (error)
+	    status = CAIRO_STATUS_NO_MEMORY;
 	assert (error == 0);
     } else {
 	double min_distance = DBL_MAX;
@@ -683,8 +700,12 @@ _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
 	    error = FT_Set_Pixel_Sizes (unscaled->face,
 					unscaled->face->available_sizes[best_i].width,
 					unscaled->face->available_sizes[best_i].height);
+	if (error)
+	    status = CAIRO_STATUS_NO_MEMORY;
 	assert (error == 0);
     }
+
+    return status;
 }
 
 /* Empirically-derived subpixel filtering values thanks to Keith
@@ -1461,8 +1482,13 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
 	return NULL;
     }
 
-    _cairo_ft_unscaled_font_set_scale (unscaled,
-				       &scaled_font->base.scale);
+    status = _cairo_ft_unscaled_font_set_scale (unscaled,
+				                &scaled_font->base.scale);
+    if (status) {
+	free (scaled_font);
+	_cairo_ft_unscaled_font_unlock_face (unscaled);
+	return NULL;
+    }
 
     metrics = &face->size->metrics;
 
@@ -1508,7 +1534,12 @@ _cairo_ft_scaled_font_create (cairo_ft_unscaled_font_t	 *unscaled,
 	}
     }
 
-    _cairo_scaled_font_set_metrics (&scaled_font->base, &fs_metrics);
+    status = _cairo_scaled_font_set_metrics (&scaled_font->base, &fs_metrics);
+    if (status) {
+	free (scaled_font);
+	_cairo_ft_unscaled_font_unlock_face (unscaled);
+	return NULL;
+    }
 
     _cairo_ft_unscaled_font_unlock_face (unscaled);
 
@@ -1536,6 +1567,7 @@ _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
     int fcweight;
     cairo_matrix_t scale;
     cairo_ft_font_transform_t sf;
+    cairo_status_t status;
     cairo_ft_options_t ft_options;
     unsigned char *family = (unsigned char*) toy_face->family;
 
@@ -1576,7 +1608,9 @@ _cairo_ft_scaled_font_create_toy (cairo_toy_font_face_t	      *toy_face,
 	goto FREE_PATTERN;
 
     cairo_matrix_multiply (&scale, font_matrix, ctm);
-    _compute_transform (&sf, &scale);
+    status = _compute_transform (&sf, &scale);
+    if (status)
+	goto FREE_PATTERN;
 
     FcPatternAddInteger (pattern, FC_PIXEL_SIZE, sf.y_scale);
 
@@ -1749,18 +1783,18 @@ _decompose_glyph_outline (FT_Face		  face,
 
     glyph = face->glyph;
 
-    status = CAIRO_STATUS_SUCCESS;
     /* Font glyphs have an inverted Y axis compared to cairo. */
     FT_Outline_Transform (&glyph->outline, &invert_y);
     if (FT_Outline_Decompose (&glyph->outline, &outline_funcs, path))
-	status = CAIRO_STATUS_NO_MEMORY;
+	return CAIRO_STATUS_NO_MEMORY;
 
-    _cairo_path_fixed_close_path (path);
+    status = _cairo_path_fixed_close_path (path);
+    if (status)
+	return status;
 
-    if (status == CAIRO_STATUS_SUCCESS)
-	*pathp = path;
+    *pathp = path;
 
-    return status;
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /*
@@ -1806,8 +1840,10 @@ _cairo_ft_scaled_glyph_init (void			*abstract_font,
     if (!face)
 	return CAIRO_STATUS_NO_MEMORY;
 
-    _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
-				       &scaled_font->base.scale);
+    status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
+				                &scaled_font->base.scale);
+    if (status)
+	goto FAIL;
 
     /* Ignore global advance unconditionally */
     load_flags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
@@ -2474,6 +2510,7 @@ cairo_ft_scaled_font_lock_face (cairo_scaled_font_t *abstract_font)
 {
     cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
     FT_Face face;
+    cairo_status_t status;
 
     if (scaled_font->base.status)
 	return NULL;
@@ -2484,8 +2521,13 @@ cairo_ft_scaled_font_lock_face (cairo_scaled_font_t *abstract_font)
 	return NULL;
     }
 
-    _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
-				       &scaled_font->base.scale);
+    status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
+				                &scaled_font->base.scale);
+    if (status) {
+	_cairo_ft_unscaled_font_unlock_face (scaled_font->unscaled);
+	_cairo_scaled_font_set_error (&scaled_font->base, status);
+	return NULL;
+    }
 
     /* NOTE: We deliberately release the unscaled font's mutex here,
      * so that we are not holding a lock across two separate calls to
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 2391457..0b19c8b 100644
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -397,15 +397,18 @@ _cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font)
 					       max_glyphs_cached_per_font);
 }
 
-void
+cairo_status_t
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics)
 {
     double  font_scale_x, font_scale_y;
+    cairo_status_t status;
 
-    _cairo_matrix_compute_scale_factors (&scaled_font->font_matrix,
-					 &font_scale_x, &font_scale_y,
-					 /* XXX */ 1);
+    status = _cairo_matrix_compute_scale_factors (&scaled_font->font_matrix,
+					          &font_scale_x, &font_scale_y,
+					          /* XXX */ 1);
+    if (status)
+	return status;
 
     /*
      * The font responded in unscaled units, scale by the font
@@ -417,6 +420,8 @@ _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
     scaled_font->extents.height = fs_metrics->height * font_scale_y;
     scaled_font->extents.max_x_advance = fs_metrics->max_x_advance * font_scale_x;
     scaled_font->extents.max_y_advance = fs_metrics->max_y_advance * font_scale_y;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 void
diff --git a/src/cairoint.h b/src/cairoint.h
index cef52fc..cbb0b74 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -1744,7 +1744,7 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			 const cairo_font_options_t	   *options,
 			 const cairo_scaled_font_backend_t *backend);
 
-cairo_private void
+cairo_private cairo_status_t
 _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
 				cairo_font_extents_t	    *fs_metrics);
 
-- 
1.4.4.2

-------------- next part --------------
>From 1f7156528afd9545b42b05742b684817fe786c37 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 15:43:37 +0100
Subject: [PATCH] Propagate some error returns up through the svg call stack.

---
 src/cairo-svg-surface.c |   56 +++++++++++++++++++++++++++++++----------------
 1 files changed, 37 insertions(+), 19 deletions(-)

diff --git a/src/cairo-svg-surface.c b/src/cairo-svg-surface.c
index 1c885d1..7d217a9 100644
--- a/src/cairo-svg-surface.c
+++ b/src/cairo-svg-surface.c
@@ -707,14 +707,21 @@ _cairo_svg_document_emit_font_subset (cairo_scaled_font_subset_t	*font_subset,
     }
 }
 
-static void
+static cairo_status_t
 _cairo_svg_document_emit_font_subsets (cairo_svg_document_t *document)
 {
-    _cairo_scaled_font_subsets_foreach_scaled (document->font_subsets,
-                                               _cairo_svg_document_emit_font_subset,
-                                               document);
+    cairo_status_t status;
+
+    status = _cairo_scaled_font_subsets_foreach_scaled (document->font_subsets,
+                                                        _cairo_svg_document_emit_font_subset,
+                                                        document);
+    if (status)
+	return status;
+
     _cairo_scaled_font_subsets_destroy (document->font_subsets);
     document->font_subsets = NULL;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_bool_t cairo_svg_force_fallbacks = FALSE;
@@ -1162,7 +1169,7 @@ _cairo_svg_surface_emit_operator (cairo_output_stream_t *output,
 	_cairo_output_stream_printf (output, "comp-op: %s; ", op_str[op]);
 }
 
-static void
+static cairo_status_t
 _cairo_svg_surface_emit_solid_pattern (cairo_svg_surface_t	    *surface,
 		    cairo_solid_pattern_t   *pattern,
 		    cairo_output_stream_t   *style,
@@ -1176,9 +1183,11 @@ _cairo_svg_surface_emit_solid_pattern (cairo_svg_surface_t	    *surface,
 				 pattern->color.green * 100.0,
 				 pattern->color.blue * 100.0,
 				 pattern->color.alpha);
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+static cairo_status_t
 _cairo_svg_surface_emit_surface_pattern (cairo_svg_surface_t	*surface,
 		      cairo_surface_pattern_t	*pattern,
 		      cairo_output_stream_t     *style,
@@ -1195,6 +1204,8 @@ _cairo_svg_surface_emit_surface_pattern (cairo_svg_surface_t	*surface,
 				 "%s: url(#pattern%d);",
 				 is_stroke ? "color" : "fill",
 				 pattern_id);
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static void
@@ -1376,7 +1387,7 @@ _cairo_svg_surface_emit_pattern_extend (cairo_output_stream_t *output,
     }
 }
 
-static void
+static cairo_status_t
 _cairo_svg_surface_emit_linear_pattern (cairo_svg_surface_t    *surface,
 		     cairo_linear_pattern_t *pattern,
 		     cairo_output_stream_t  *style,
@@ -1418,9 +1429,11 @@ _cairo_svg_surface_emit_linear_pattern (cairo_svg_surface_t    *surface,
 				 document->linear_pattern_id);
 
     document->linear_pattern_id++;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+static cairo_status_t
 _cairo_svg_surface_emit_radial_pattern (cairo_svg_surface_t    *surface,
 		     cairo_radial_pattern_t *pattern,
 		     cairo_output_stream_t  *style,
@@ -1432,6 +1445,7 @@ _cairo_svg_surface_emit_radial_pattern (cairo_svg_surface_t    *surface,
     double x0, y0, x1, y1, r0, r1;
     double fx, fy;
     cairo_bool_t reverse_stops;
+    cairo_status_t status;
     pixman_circle_t *c0, *c1;
 
     extend = pattern->base.base.extend;
@@ -1454,7 +1468,9 @@ _cairo_svg_surface_emit_radial_pattern (cairo_svg_surface_t    *surface,
     r1 = _cairo_fixed_to_double (c1->radius);
 
     p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     if (pattern->gradient.c1.radius == pattern->gradient.c2.radius) {
 	_cairo_output_stream_printf (document->xml_node_defs,
@@ -1585,29 +1601,28 @@ _cairo_svg_surface_emit_radial_pattern (cairo_svg_surface_t    *surface,
 				 document->radial_pattern_id);
 
     document->radial_pattern_id++;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+static cairo_status_t
 _cairo_svg_surface_emit_pattern (cairo_svg_surface_t *surface, cairo_pattern_t *pattern,
 	      cairo_output_stream_t *output, cairo_bool_t is_stroke)
 {
     switch (pattern->type) {
     case CAIRO_PATTERN_TYPE_SOLID:
-	_cairo_svg_surface_emit_solid_pattern (surface, (cairo_solid_pattern_t *) pattern, output, is_stroke);
-	break;
+	return _cairo_svg_surface_emit_solid_pattern (surface, (cairo_solid_pattern_t *) pattern, output, is_stroke);
 
     case CAIRO_PATTERN_TYPE_SURFACE:
-	_cairo_svg_surface_emit_surface_pattern (surface, (cairo_surface_pattern_t *) pattern, output, is_stroke);
-	break;
+	return _cairo_svg_surface_emit_surface_pattern (surface, (cairo_surface_pattern_t *) pattern, output, is_stroke);
 
     case CAIRO_PATTERN_TYPE_LINEAR:
-	_cairo_svg_surface_emit_linear_pattern (surface, (cairo_linear_pattern_t *) pattern, output, is_stroke);
-	break;
+	return _cairo_svg_surface_emit_linear_pattern (surface, (cairo_linear_pattern_t *) pattern, output, is_stroke);
 
     case CAIRO_PATTERN_TYPE_RADIAL:
-	_cairo_svg_surface_emit_radial_pattern (surface, (cairo_radial_pattern_t *) pattern, output, is_stroke);
-	break;
+	return _cairo_svg_surface_emit_radial_pattern (surface, (cairo_radial_pattern_t *) pattern, output, is_stroke);
     }
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_int_status_t
@@ -2127,7 +2142,10 @@ _cairo_svg_document_finish (cairo_svg_document_t *document)
 				 document->width, document->height,
 				 _cairo_svg_internal_version_strings [document->svg_version]);
 
-    _cairo_svg_document_emit_font_subsets (document);
+    status = _cairo_svg_document_emit_font_subsets (document);
+    if (status)
+	return status;
+
     if (_cairo_memory_stream_length (document->xml_node_glyphs) > 0 ||
 	_cairo_memory_stream_length (document->xml_node_defs) > 0) {
 	_cairo_output_stream_printf (output, "<defs>\n");
-- 
1.4.4.2

-------------- next part --------------
>From df63ea77e3d80f550b6a461dc2401816240f5b8f Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 15:50:12 +0100
Subject: [PATCH] Propagate one error return through pdf.

---
 src/cairo-pdf-surface.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/src/cairo-pdf-surface.c b/src/cairo-pdf-surface.c
index 67cfbc6..2118973 100644
--- a/src/cairo-pdf-surface.c
+++ b/src/cairo-pdf-surface.c
@@ -1192,6 +1192,7 @@ _cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_line
     cairo_pdf_resource_t function, pattern_resource, alpha;
     double x0, y0, x1, y1;
     cairo_matrix_t p2u;
+    cairo_status_t status;
 
     _cairo_pdf_surface_pause_content_stream (surface);
 
@@ -1200,7 +1201,9 @@ _cairo_pdf_surface_emit_linear_pattern (cairo_pdf_surface_t *surface, cairo_line
 	return CAIRO_STATUS_NO_MEMORY;
 
     p2u = pattern->base.base.matrix;
-    cairo_matrix_invert (&p2u);
+    status = cairo_matrix_invert (&p2u);
+    if (status)
+	return status;
 
     x0 = _cairo_fixed_to_double (pattern->gradient.p1.x);
     y0 = _cairo_fixed_to_double (pattern->gradient.p1.y);
-- 
1.4.4.2

-------------- next part --------------
>From 003eefe74656083d2641e3edf5fdad877ca5a560 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 15:55:06 +0100
Subject: [PATCH] Propagate status returns through type1.

---
 src/cairo-type1-fallback.c |   31 ++++++++++++++++++++++++-------
 1 files changed, 24 insertions(+), 7 deletions(-)

diff --git a/src/cairo-type1-fallback.c b/src/cairo-type1-fallback.c
index eef0d73..b88930a 100644
--- a/src/cairo-type1-fallback.c
+++ b/src/cairo-type1-fallback.c
@@ -63,6 +63,12 @@ typedef struct _cairo_type1_font {
     int hex_column;
 } cairo_type1_font_t;
 
+cairo_static cairo_status_t
+cairo_type1_font_write_header (cairo_type1_font_t *font,
+                               const char         *name);
+cairo_static cairo_status_t
+cairo_type1_font_destroy (cairo_type1_font_t *font);
+
 static cairo_status_t
 cairo_type1_font_create (cairo_scaled_font_subset_t  *scaled_font_subset,
                          cairo_type1_font_t         **subset_return,
@@ -464,18 +470,21 @@ fail:
     return status;
 }
 
-static void
+static cairo_status_t
 cairo_type1_font_write_header (cairo_type1_font_t *font,
                                const char         *name)
 {
     cairo_matrix_t matrix;
+    cairo_status_t status;
     unsigned int i;
     const char spaces[50] = "                                                  ";
 
     matrix = font->type1_scaled_font->scale;
     matrix.xy = -matrix.xy;
     matrix.yy = -matrix.yy;
-    cairo_matrix_invert (&matrix);
+    status = cairo_matrix_invert (&matrix);
+    if (status)
+	return status;
 
     _cairo_output_stream_printf (font->output,
                                  "%%!FontType1-1.1 %s 1.0\n"
@@ -512,6 +521,8 @@ cairo_type1_font_write_header (cairo_type1_font_t *font,
                                  "readonly def\n"
                                  "currentdict end\n"
                                  "currentfile eexec\n");
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
@@ -635,7 +646,9 @@ cairo_type1_font_write (cairo_type1_font_t *font,
 {
     cairo_int_status_t status;
 
-    cairo_type1_font_write_header (font, name);
+    status = cairo_type1_font_write_header (font, name);
+    if (status)
+	return status;
     font->header_size = _cairo_output_stream_get_position (font->output);
 
     status = cairo_type1_font_write_private_dict (font, name);
@@ -673,14 +686,18 @@ cairo_type1_font_generate (cairo_type1_font_t *font, const char *name)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+static cairo_status_t
 cairo_type1_font_destroy (cairo_type1_font_t *font)
 {
+    cairo_status_t status;
+
     free (font->widths);
     cairo_scaled_font_destroy (font->type1_scaled_font);
     _cairo_array_fini (&font->contents);
-    _cairo_output_stream_destroy (font->output);
+    status = _cairo_output_stream_destroy (font->output);
     free (font);
+
+    return status;
 }
 
 static cairo_status_t
@@ -746,14 +763,14 @@ _cairo_type1_fallback_init_internal (cairo_type1_subset_t	*type1_subset,
     type1_subset->data_length = font->data_size;
     type1_subset->trailer_length = font->trailer_size;
 
-    cairo_type1_font_destroy (font);
-    return CAIRO_STATUS_SUCCESS;
+    return cairo_type1_font_destroy (font);
 
  fail3:
     free (type1_subset->widths);
  fail2:
     free (type1_subset->base_font);
  fail1:
+    /* status is already set, ignore further errors */
     cairo_type1_font_destroy (font);
 
     return status;
-- 
1.4.4.2

From jeff at infidigm.net  Wed Mar 28 09:44:46 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Wed Mar 28 09:42:48 2007
Subject: [cairo] rewriting libpixman
Message-ID: <20070328164446.GA24453@infidigm.net>

I have put up a copy of cairo that has a partially rewritten libpixman
in the pixman-new branch of my cairo tree.

The main change is that all of the hand written special cases have been
replaced with machine generated special cases. The impact of this is
that now all regular compositing operations will not use the
compositeGeneral case. In addition, the python script allows handwritten
substitutions to be made. In this case, I've added substitutions using
liboil for the operations that it supports. These substitutions cover
alot of the common cases and cause a lot of the speed up seen below.
I've also included a patch against liboil that adds another useful
operation for cairo.

Implementation
--------------
The code currently uses a very large table of function pointers to look
up the compositing kernel needed. I'm a little uncomfortable with this
approach, however the alternatives aren't great either. In the worst
case it should make it possible to determine the best case performance
of some of the less often used compositing operators.

The basic premise behind the python script/compiler is to take a tree
like the following and create the corresponding c code.

          ast = op_loop(
                    op_pack(
                        op_over(            
                            op_unpack(source_in),       
                            op_unpack(dest_in)          
                        ),                      
                        dest_out                
                    ),
                    dest_out,           
                    inputs              
                )

likewise here is the corresponding tree when a mask is being used.

          ast = op_loop(
                    op_pack(
                        op_over(            
                            op_in(                      
                                op_unpack(source_in),           
                                op_unpack(mask_in)
                            ),
                            op_unpack(dest_in)    
                        ),
                        dest_out
                    ),
                    dest_out,
                    inputs
                )

This is done for all the permutations of (operator, src_format,
dest_format, mask_format, solid_src) with an entry in the dispatch table
for each.

Currently, the generated code is messy as are the details of the
generator but the basic idea is there. A snapshot of the
generator/compiler is at
http://people.freedesktop.org/~jrmuizel/libcomposite-preview.tar.bz2

Results
-------
Some tests have sped up signficantly (4.5x). glitz-test with software
rendering goes from approx 20fps to 25fps. However, there are some
regressions as well.  The most notible one that shows up with cairo-perf
is long-lines-uncropped.  This test is doing the operation
ARGB32_over_ARGB32_in_A8 which does have a liboil substitute. This
substitute is usually much faster. However, the cairo equivalent has a
special case when both the SRC and and MASK pixels are opaque.  This
special case allows the current cairo code to outpreform the liboil code
when it can take advantage of the special case about 85% or more of the
time.

Currently my feelings are that this should be dealt with at a level
above libpixman. It seems bad to ask the compositor to do OVER IN when
for > 85% of the time it could just be doing SRC. However, I have no
idea how practical it is to actually do this.

cairo-perf-diff with the smaller changes removed:

Speedups
========
image-rgba      paint_solid_rgba_over-256    1.16 0.55% ->   0.25 2.07%:  4.54x speedup
????
image-rgb       paint_solid_rgba_over-256    1.15 0.79% ->   0.26 0.53%:  4.45x speedup
????
image-rgba      paint_solid_rgba_over-512    4.67 0.86% ->   1.19 1.41%:  3.94x speedup
???
image-rgb       paint_solid_rgba_over-512    4.67 0.83% ->   1.20 1.19%:  3.91x speedup
???
image-rgba      paint_image_rgba_over-256    0.81 1.18% ->   0.29 2.69%:  2.83x speedup
??
image-rgba    paint_similar_rgba_over-256    0.81 0.92% ->   0.29 1.93%:  2.82x speedup
??
image-rgb     paint_similar_rgba_over-256    0.80 1.35% ->   0.30 1.68%:  2.67x speedup
??
image-rgb       paint_image_rgba_over-256    0.81 1.80% ->   0.32 1.12%:  2.55x speedup
??
image-rgba      paint_image_rgba_over-512    3.29 0.18% ->   1.38 2.49%:  2.40x speedup
??
image-rgba    paint_similar_rgba_over-512    3.28 1.23% ->   1.40 1.89%:  2.35x speedup
??
image-rgb     paint_similar_rgba_over-512    3.29 1.23% ->   1.43 1.46%:  2.30x speedup
??
image-rgb       paint_image_rgba_over-512    3.29 0.23% ->   1.47 0.32%:  2.25x speedup
??
image-rgb        fill_solid_rgba_over-256    1.48 0.26% ->   0.76 0.49%:  1.94x speedup
?
image-rgba       fill_solid_rgba_over-256    1.44 1.37% ->   0.76 0.74%:  1.89x speedup
?
image-rgba       paint_solid_rgb_over-256    0.09 0.19% ->   0.05 0.20%:  1.62x speedup
?
image-rgba     paint_solid_rgb_source-256    0.09 0.49% ->   0.05 0.02%:  1.62x speedup
?
image-rgba    paint_solid_rgba_source-256    0.09 1.14% ->   0.05 0.10%:  1.60x speedup
?
image-rgb        paint_solid_rgb_over-256    0.08 0.45% ->   0.05 1.81%:  1.51x speedup
?
image-rgb     paint_solid_rgba_source-256    0.08 0.15% ->   0.06 1.87%:  1.51x speedup
?
image-rgba       fill_solid_rgba_over-128    0.47 0.91% ->   0.31 0.19%:  1.51x speedup
?
image-rgb        fill_solid_rgba_over-128    0.47 0.23% ->   0.32 0.15%:  1.50x speedup
?
image-rgb      paint_solid_rgb_source-256    0.08 0.98% ->   0.05 0.34%:  1.49x speedup
?
image-rgba    text_radial_rgba_source-128    3.07 0.14% ->   2.19 1.30%:  1.40x speedup
?
image-rgba     text_radial_rgb_source-128    3.00 0.13% ->   2.17 0.28%:  1.38x speedup
?
image-rgba     text_radial_rgb_source-256   12.06 0.11% ->   8.78 0.66%:  1.37x speedup
?
image-rgb      stroke_solid_rgba_over-256    2.93 1.10% ->   2.15 0.82%:  1.36x speedup
?
image-rgba   paint_similar_rgb_source-256    0.26 0.70% ->   0.19 5.21%:  1.36x speedup
?
image-rgba     stroke_solid_rgba_over-256    2.92 1.34% ->   2.17 1.69%:  1.35x speedup
?
image-rgba    text_radial_rgba_source-256   12.12 0.28% ->   9.05 0.48%:  1.34x speedup
?
image-rgba     paint_similar_rgb_over-256    0.25 2.48% ->   0.20 4.01%:  1.30x speedup
?
image-rgba    text_linear_rgba_source-256   10.37 0.48% ->   8.20 0.71%:  1.26x speedup
?
image-rgba       paint_image_rgb_over-256    0.26 1.26% ->   0.20 4.81%:  1.26x speedup
?
image-rgba     paint_image_rgb_source-256    0.25 0.85% ->   0.20 5.25%:  1.26x speedup
?
image-rgba     text_linear_rgb_source-256   10.39 0.57% ->   8.29 0.22%:  1.25x speedup
?
image-rgba    text_linear_rgba_source-128    2.62 1.99% ->   2.09 1.18%:  1.25x speedup
?
image-rgba     text_linear_rgb_source-128    2.62 0.38% ->   2.10 0.39%:  1.25x speedup
?
image-rgb     text_radial_rgba_source-128    3.05 0.79% ->   2.47 0.08%:  1.24x speedup
?
image-rgb      stroke_solid_rgba_over-128    1.27 1.00% ->   1.03 0.45%:  1.23x speedup
?
image-rgb      text_radial_rgb_source-128    3.00 0.28% ->   2.46 1.23%:  1.22x speedup
?
image-rgb      text_radial_rgb_source-256   12.05 0.53% ->   9.89 0.26%:  1.22x speedup
?
image-rgba     fill_solid_rgba_source-256    1.99 1.65% ->   1.64 0.32%:  1.21x speedup
?
image-rgba    fill_linear_rgba_source-256    3.04 1.45% ->   2.52 2.55%:  1.21x speedup
?
image-rgba     stroke_solid_rgba_over-128    1.25 0.35% ->   1.04 0.93%:  1.21x speedup
?
image-rgba      fill_solid_rgb_source-256    1.98 1.39% ->   1.65 1.51%:  1.20x speedup
?
image-rgb        fill_solid_rgba_over-64     0.24 0.37% ->   0.20 0.25%:  1.20x speedup

Slowdowns
=========
image-rgba              subimage_copy-64     0.00 1.78% ->   0.00 0.31%:  1.46x slowdown
?
image-rgb     paint_image_rgba_source-256    0.19 5.22% ->   0.26 2.14%:  1.35x slowdown
?
image-rgb   paint_similar_rgba_source-256    0.19 0.63% ->   0.25 2.53%:  1.35x slowdown
?
image-rgba       long-lines-uncropped-100    4.61 0.85% ->   6.06 0.44%:  1.32x slowdown
?
image-rgb        long-lines-uncropped-100    4.61 0.80% ->   6.06 0.47%:  1.31x slowdown
?
image-rgba        fill_solid_rgb_over-256    0.58 0.74% ->   0.76 1.23%:  1.30x slowdown
?
image-rgb         fill_solid_rgb_over-256    0.59 2.15% ->   0.76 1.13%:  1.29x slowdown
?
image-rgb         fill_image_rgb_over-256    0.69 1.17% ->   0.87 0.59%:  1.26x slowdown
?
image-rgb       fill_similar_rgb_over-256    0.69 0.67% ->   0.87 1.47%:  1.26x slowdown
?
image-rgba              subimage_copy-128    0.00 1.97% ->   0.00 1.20%:  1.25x slowdown
?
image-rgb        paint_image_rgb_over-256    0.22 1.76% ->   0.27 2.77%:  1.24x slowdown
?
image-rgba      fill_similar_rgb_over-256    0.69 2.05% ->   0.85 1.61%:  1.23x slowdown
?
image-rgba        fill_image_rgb_over-256    0.70 1.28% ->   0.86 0.88%:  1.23x slowdown
?
image-rgb         fill_solid_rgb_over-128    0.26 0.44% ->   0.32 0.20%:  1.22x slowdown
?
image-rgb          long-lines-cropped-100    4.06 0.65% ->   4.93 0.66%:  1.22x slowdown
?
image-rgb      paint_image_rgb_source-256    0.22 2.63% ->   0.26 3.32%:  1.21x slowdown
?
image-rgba         long-lines-cropped-100    4.07 0.43% ->   4.94 0.75%:  1.21x slowdown
?
image-rgba        fill_solid_rgb_over-128    0.26 0.76% ->   0.31 0.22%:  1.21x slowdown
?
image-rgb               subimage_copy-64     0.00 1.58% ->   0.01 0.45%:  1.20x slowdown
?
image-rgba              subimage_copy-512    0.00 0.93% ->   0.00 1.86%:  1.20x slowdown
?
image-rgba          mosaic_fill_lines-800   97.33 0.07% -> 115.13 0.03%:  1.18x slowdown
?
image-rgb           mosaic_fill_lines-800   97.38 0.06% -> 114.97 0.04%:  1.18x slowdown
?
image-rgb      paint_similar_rgb_over-256    0.22 1.28% ->   0.25 3.59%:  1.18x slowdown
?
image-rgb    paint_similar_rgb_source-256    0.21 0.69% ->   0.25 4.23%:  1.18x slowdown
?
image-rgba             unaligned_clip-100    0.05 0.57% ->   0.07 0.82%:  1.16x slowdown
?
image-rgb              unaligned_clip-100    0.06 1.49% ->   0.06 0.77%:  1.16x slowdown
?
image-rgb    fill_similar_rgba_source-256    1.89 0.46% ->   2.17 0.45%:  1.15x slowdown
?
image-rgb       stroke_solid_rgb_over-256    1.89 3.32% ->   2.16 0.38%:  1.15x slowdown
?
image-rgb      fill_image_rgba_source-256    1.90 1.05% ->   2.17 0.35%:  1.14x slowdown
?
image-rgba              subimage_copy-256    0.00 2.47% ->   0.00 2.15%:  1.14x slowdown
?
image-rgb     fill_similar_rgb_source-256    1.91 1.52% ->   2.17 0.71%:  1.14x slowdown
?
image-rgba              subimage_copy-32     0.00 2.92% ->   0.00 8.91%:  1.13x slowdown
?
image-rgb          box-outline-stroke-100    0.01 1.69% ->   0.01 0.83%:  1.12x slowdown
?
image-rgb       fill_image_rgb_source-256    1.90 2.40% ->   2.13 1.87%:  1.12x slowdown
?
image-rgba      stroke_image_rgb_over-256    2.07 2.52% ->   2.31 0.49%:  1.11x slowdown
?
image-rgba         mosaic_fill_curves-800  169.25 0.06% -> 187.61 0.04%:  1.11x slowdown
?
image-rgba    stroke_similar_rgb_over-256    2.09 1.34% ->   2.32 0.36%:  1.11x slowdown
?
image-rgb          mosaic_fill_curves-800  169.35 0.23% -> 187.45 0.04%:  1.11x slowdown
?
image-rgb     stroke_similar_rgb_over-256    2.09 0.88% ->   2.31 0.24%:  1.11x slowdown


Index: liboil/liboilclasses.h
===================================================================
RCS file: /cvs/liboil/liboil/liboil/liboilclasses.h,v
retrieving revision 1.24
diff -u -r1.24 liboilclasses.h
--- liboil/liboilclasses.h	23 Mar 2007 00:54:49 -0000	1.24
+++ liboil/liboilclasses.h	27 Mar 2007 20:16:24 -0000
@@ -128,6 +128,7 @@
 OIL_DECLARE_CLASS(composite_in_over_argb);
 OIL_DECLARE_CLASS(composite_in_over_argb_const_mask);
 OIL_DECLARE_CLASS(composite_in_over_argb_const_src);
+OIL_DECLARE_CLASS(composite_in_over_rgb);
 OIL_DECLARE_CLASS(composite_over_argb);
 OIL_DECLARE_CLASS(composite_over_argb_const_src);
 OIL_DECLARE_CLASS(composite_over_u8);
@@ -274,15 +275,15 @@
 OIL_DECLARE_CLASS(mas4_add_s16);
 OIL_DECLARE_CLASS(mas8_across_add_s16);
 OIL_DECLARE_CLASS(mas8_add_s16);
-OIL_DECLARE_CLASS(max_f32);
-OIL_DECLARE_CLASS(max_f64);
 OIL_DECLARE_CLASS(maximum_f32);
+OIL_DECLARE_CLASS(maximum_f64);
 OIL_DECLARE_CLASS(md5);
 OIL_DECLARE_CLASS(mdct12_f64);
 OIL_DECLARE_CLASS(mdct36_f64);
 OIL_DECLARE_CLASS(merge_linear_argb);
 OIL_DECLARE_CLASS(merge_linear_u8);
 OIL_DECLARE_CLASS(minimum_f32);
+OIL_DECLARE_CLASS(minimum_f64);
 OIL_DECLARE_CLASS(mix_u8);
 OIL_DECLARE_CLASS(mt19937);
 OIL_DECLARE_CLASS(mult8x8_s16);
Index: liboil/liboilfuncs-04.h
===================================================================
RCS file: /cvs/liboil/liboil/liboil/liboilfuncs-04.h,v
retrieving revision 1.16
diff -u -r1.16 liboilfuncs-04.h
--- liboil/liboilfuncs-04.h	23 Mar 2007 00:54:49 -0000	1.16
+++ liboil/liboilfuncs-04.h	27 Mar 2007 20:16:24 -0000
@@ -128,6 +128,7 @@
 void oil_composite_in_over_argb (uint32_t * i_n, const uint32_t * s1_n, const uint8_t * s2_n, int n);
 void oil_composite_in_over_argb_const_mask (uint32_t * i_n, const uint32_t * s1_n, const uint8_t * s2_1, int n);
 void oil_composite_in_over_argb_const_src (uint32_t * i_n, const uint32_t * s1_1, const uint8_t * s2_n, int n);
+void oil_composite_in_over_rgb (uint32_t * i_n, const uint32_t * s1_n, const uint8_t * s2_n, int n);
 void oil_composite_over_argb (uint32_t * i_n, const uint32_t * s1_n, int n);
 void oil_composite_over_argb_const_src (uint32_t * i_n, const uint32_t * s1_1, int n);
 void oil_composite_over_u8 (uint8_t * i_n, const uint8_t * s1_n, int n);
@@ -274,15 +275,15 @@
 void oil_mas4_add_s16 (int16_t * d, const int16_t * s1, const int16_t * s2_np3, const int16_t * s3_4, const int16_t * s4_2, int n);
 void oil_mas8_across_add_s16 (int16_t * d, const int16_t * s1, const int16_t * s2_nx8, int sstr2, const int16_t * s3_8, const int16_t * s4_2, int n);
 void oil_mas8_add_s16 (int16_t * d, const int16_t * s1, const int16_t * s2_np7, const int16_t * s3_8, const int16_t * s4_2, int n);
-void oil_max_f32 (float * d, const float * s1, int n);
-void oil_max_f64 (double * d, const double * s1, int n);
 void oil_maximum_f32 (float * d, const float * s1, const float * s2, int n);
+void oil_maximum_f64 (float * d, const float * s1, const float * s2, int n);
 void oil_md5 (uint32_t * i_4, const uint32_t * s_16);
 void oil_mdct12_f64 (double * d_6, const double * s_12);
 void oil_mdct36_f64 (double * d_18, const double * s_36);
 void oil_merge_linear_argb (uint32_t * d_n, const uint32_t * s_n, const uint32_t * s2_n, const uint32_t * s3_1, int n);
 void oil_merge_linear_u8 (uint8_t * d_n, const uint8_t * s_n, const uint8_t * s2_n, const uint32_t * s3_1, int n);
 void oil_minimum_f32 (float * d, const float * s1, const float * s2, int n);
+void oil_minimum_f64 (float * d, const float * s1, const float * s2, int n);
 void oil_mix_u8 (uint8_t * dest, const uint8_t * src1, const uint8_t * src2, const uint8_t * src3, int n);
 void oil_mt19937 (uint32_t * d_624, uint32_t * i_624);
 void oil_mult8x8_s16 (int16_t * d_8x8, const int16_t * s1_8x8, const int16_t * s2_8x8, int ds, int ss1, int ss2);
Index: liboil/liboilfuncs.h
===================================================================
RCS file: /cvs/liboil/liboil/liboil/liboilfuncs.h,v
retrieving revision 1.49
diff -u -r1.49 liboilfuncs.h
--- liboil/liboilfuncs.h	23 Mar 2007 00:54:49 -0000	1.49
+++ liboil/liboilfuncs.h	27 Mar 2007 20:16:24 -0000
@@ -312,6 +312,9 @@
 extern OilFunctionClass *oil_function_class_ptr_composite_in_over_argb_const_src;
 typedef void (*_oil_type_composite_in_over_argb_const_src)(uint32_t * i_n, const uint32_t * s1_1, const uint8_t * s2_n, int n);
 #define oil_composite_in_over_argb_const_src ((_oil_type_composite_in_over_argb_const_src)(*(void **)oil_function_class_ptr_composite_in_over_argb_const_src))
+extern OilFunctionClass *oil_function_class_ptr_composite_in_over_rgb;
+typedef void (*_oil_type_composite_in_over_rgb)(uint32_t * i_n, const uint32_t * s1_n, const uint8_t * s2_n, int n);
+#define oil_composite_in_over_rgb ((_oil_type_composite_in_over_rgb)(*(void **)oil_function_class_ptr_composite_in_over_rgb))
 extern OilFunctionClass *oil_function_class_ptr_composite_over_argb;
 typedef void (*_oil_type_composite_over_argb)(uint32_t * i_n, const uint32_t * s1_n, int n);
 #define oil_composite_over_argb ((_oil_type_composite_over_argb)(*(void **)oil_function_class_ptr_composite_over_argb))
@@ -750,15 +753,12 @@
 extern OilFunctionClass *oil_function_class_ptr_mas8_add_s16;
 typedef void (*_oil_type_mas8_add_s16)(int16_t * d, const int16_t * s1, const int16_t * s2_np7, const int16_t * s3_8, const int16_t * s4_2, int n);
 #define oil_mas8_add_s16 ((_oil_type_mas8_add_s16)(*(void **)oil_function_class_ptr_mas8_add_s16))
-extern OilFunctionClass *oil_function_class_ptr_max_f32;
-typedef void (*_oil_type_max_f32)(float * d, const float * s1, int n);
-#define oil_max_f32 ((_oil_type_max_f32)(*(void **)oil_function_class_ptr_max_f32))
-extern OilFunctionClass *oil_function_class_ptr_max_f64;
-typedef void (*_oil_type_max_f64)(double * d, const double * s1, int n);
-#define oil_max_f64 ((_oil_type_max_f64)(*(void **)oil_function_class_ptr_max_f64))
 extern OilFunctionClass *oil_function_class_ptr_maximum_f32;
 typedef void (*_oil_type_maximum_f32)(float * d, const float * s1, const float * s2, int n);
 #define oil_maximum_f32 ((_oil_type_maximum_f32)(*(void **)oil_function_class_ptr_maximum_f32))
+extern OilFunctionClass *oil_function_class_ptr_maximum_f64;
+typedef void (*_oil_type_maximum_f64)(float * d, const float * s1, const float * s2, int n);
+#define oil_maximum_f64 ((_oil_type_maximum_f64)(*(void **)oil_function_class_ptr_maximum_f64))
 extern OilFunctionClass *oil_function_class_ptr_md5;
 typedef void (*_oil_type_md5)(uint32_t * i_4, const uint32_t * s_16);
 #define oil_md5 ((_oil_type_md5)(*(void **)oil_function_class_ptr_md5))
@@ -777,6 +777,9 @@
 extern OilFunctionClass *oil_function_class_ptr_minimum_f32;
 typedef void (*_oil_type_minimum_f32)(float * d, const float * s1, const float * s2, int n);
 #define oil_minimum_f32 ((_oil_type_minimum_f32)(*(void **)oil_function_class_ptr_minimum_f32))
+extern OilFunctionClass *oil_function_class_ptr_minimum_f64;
+typedef void (*_oil_type_minimum_f64)(float * d, const float * s1, const float * s2, int n);
+#define oil_minimum_f64 ((_oil_type_minimum_f64)(*(void **)oil_function_class_ptr_minimum_f64))
 extern OilFunctionClass *oil_function_class_ptr_mix_u8;
 typedef void (*_oil_type_mix_u8)(uint8_t * dest, const uint8_t * src1, const uint8_t * src2, const uint8_t * src3, int n);
 #define oil_mix_u8 ((_oil_type_mix_u8)(*(void **)oil_function_class_ptr_mix_u8))
Index: liboil/liboiltrampolines.c
===================================================================
RCS file: /cvs/liboil/liboil/liboil/liboiltrampolines.c,v
retrieving revision 1.22
diff -u -r1.22 liboiltrampolines.c
--- liboil/liboiltrampolines.c	23 Mar 2007 00:54:49 -0000	1.22
+++ liboil/liboiltrampolines.c	27 Mar 2007 20:16:24 -0000
@@ -951,6 +951,16 @@
   ((void (*)(uint32_t * i_n, const uint32_t * s1_1, const uint8_t * s2_n, int n))(_oil_function_class_composite_in_over_argb_const_src.func))(i_n, s1_1, s2_n, n);
 }
 
+#undef oil_composite_in_over_rgb
+void
+oil_composite_in_over_rgb (uint32_t * i_n, const uint32_t * s1_n, const uint8_t * s2_n, int n)
+{
+  if (_oil_function_class_composite_in_over_rgb.func == NULL) {
+    oil_class_optimize (&_oil_function_class_composite_in_over_rgb);
+  }
+  ((void (*)(uint32_t * i_n, const uint32_t * s1_n, const uint8_t * s2_n, int n))(_oil_function_class_composite_in_over_rgb.func))(i_n, s1_n, s2_n, n);
+}
+
 #undef oil_composite_over_argb
 void
 oil_composite_over_argb (uint32_t * i_n, const uint32_t * s1_n, int n)
@@ -2411,26 +2421,6 @@
   ((void (*)(int16_t * d, const int16_t * s1, const int16_t * s2_np7, const int16_t * s3_8, const int16_t * s4_2, int n))(_oil_function_class_mas8_add_s16.func))(d, s1, s2_np7, s3_8, s4_2, n);
 }
 
-#undef oil_max_f32
-void
-oil_max_f32 (float * d, const float * s1, int n)
-{
-  if (_oil_function_class_max_f32.func == NULL) {
-    oil_class_optimize (&_oil_function_class_max_f32);
-  }
-  ((void (*)(float * d, const float * s1, int n))(_oil_function_class_max_f32.func))(d, s1, n);
-}
-
-#undef oil_max_f64
-void
-oil_max_f64 (double * d, const double * s1, int n)
-{
-  if (_oil_function_class_max_f64.func == NULL) {
-    oil_class_optimize (&_oil_function_class_max_f64);
-  }
-  ((void (*)(double * d, const double * s1, int n))(_oil_function_class_max_f64.func))(d, s1, n);
-}
-
 #undef oil_maximum_f32
 void
 oil_maximum_f32 (float * d, const float * s1, const float * s2, int n)
@@ -2441,6 +2431,16 @@
   ((void (*)(float * d, const float * s1, const float * s2, int n))(_oil_function_class_maximum_f32.func))(d, s1, s2, n);
 }
 
+#undef oil_maximum_f64
+void
+oil_maximum_f64 (float * d, const float * s1, const float * s2, int n)
+{
+  if (_oil_function_class_maximum_f64.func == NULL) {
+    oil_class_optimize (&_oil_function_class_maximum_f64);
+  }
+  ((void (*)(float * d, const float * s1, const float * s2, int n))(_oil_function_class_maximum_f64.func))(d, s1, s2, n);
+}
+
 #undef oil_md5
 void
 oil_md5 (uint32_t * i_4, const uint32_t * s_16)
@@ -2501,6 +2501,16 @@
   ((void (*)(float * d, const float * s1, const float * s2, int n))(_oil_function_class_minimum_f32.func))(d, s1, s2, n);
 }
 
+#undef oil_minimum_f64
+void
+oil_minimum_f64 (float * d, const float * s1, const float * s2, int n)
+{
+  if (_oil_function_class_minimum_f64.func == NULL) {
+    oil_class_optimize (&_oil_function_class_minimum_f64);
+  }
+  ((void (*)(float * d, const float * s1, const float * s2, int n))(_oil_function_class_minimum_f64.func))(d, s1, s2, n);
+}
+
 #undef oil_mix_u8
 void
 oil_mix_u8 (uint8_t * dest, const uint8_t * src1, const uint8_t * src2, const uint8_t * src3, int n)
Index: liboil/c/composite.c
===================================================================
RCS file: /cvs/liboil/liboil/liboil/c/composite.c,v
retrieving revision 1.2
diff -u -r1.2 composite.c
--- liboil/c/composite.c	22 May 2006 22:31:47 -0000	1.2
+++ liboil/c/composite.c	27 Mar 2007 20:16:24 -0000
@@ -313,6 +313,61 @@
 OIL_DEFINE_IMPL (composite_in_over_argb_fast, composite_in_over_argb);
 
 static void
+composite_in_over_rgb_fast (uint32_t *dest, const uint32_t *src,
+    const uint8_t *mask, int n)
+{
+  for (; n > 0; n--) {
+    uint32_t d = *dest, s = *src++;
+    uint32_t s1, s2, d1, d2, sa;
+    uint8_t m = *mask++;
+
+    s1 = s & 0x00ff00ff;
+    /* fill the missing alpha byte */
+    s2 = (((s | (0xff<<24)) >> 8) & 0x00ff00ff);
+
+    /* in */
+    s1 *= m;
+    s1 += 0x00800080;
+    s1 += (s1 >> 8) & 0x00ff00ff;
+    s1 >>= 8;
+    s1 &= 0x00ff00ff;
+
+    s2 *= m;
+    s2 += 0x00800080;
+    s2 += (s2 >> 8) & 0x00ff00ff;
+    s2 >>= 8;
+    s2 &= 0x00ff00ff;
+
+    /* over */
+    sa = (~s2 >> 16) & 0xff;
+
+    d1 = d & 0x00ff00ff;
+    d1 *= sa;
+    d1 += 0x00800080;
+    d1 += (d1 >> 8) & 0x00ff00ff;
+    d1 >>= 8;
+    d1 &= 0x00ff00ff;
+    d1 += s1;
+    d1 |= 0x01000100 - ((d1 >> 8) & 0x00ff00ff);
+    d1 &= 0x00ff00ff;
+
+    d2 = (d >> 8) & 0x00ff00ff;
+    d2 *= sa;
+    d2 += 0x00800080;
+    d2 += (d2 >> 8) & 0x00ff00ff;
+    d2 >>= 8;
+    d2 &= 0x00ff00ff;
+    d2 += s2;
+    d2 |= 0x01000100 - ((d2 >> 8) & 0x00ff00ff);
+    d2 &= 0x00ff00ff;
+
+    *dest++ = d1 | (d2 << 8);
+  }
+}
+OIL_DEFINE_IMPL (composite_in_over_rgb_fast, composite_in_over_rgb);
+
+
+static void
 composite_in_over_argb_const_src_fast (uint32_t *dest, const uint32_t *src,
     const uint8_t *mask, int n)
 {
Index: liboil/i386/composite_i386.c
===================================================================
RCS file: /cvs/liboil/liboil/liboil/i386/composite_i386.c,v
retrieving revision 1.4
diff -u -r1.4 composite_i386.c
--- liboil/i386/composite_i386.c	29 Jan 2006 02:55:37 -0000	1.4
+++ liboil/i386/composite_i386.c	27 Mar 2007 20:16:24 -0000
@@ -36,10 +36,12 @@
 OIL_DECLARE_CLASS (composite_in_argb_const_src);
 OIL_DECLARE_CLASS (composite_in_argb_const_mask);
 OIL_DECLARE_CLASS (composite_over_argb);
+OIL_DECLARE_CLASS (composite_over_rgb);
 OIL_DECLARE_CLASS (composite_over_argb_const_src);
 OIL_DECLARE_CLASS (composite_add_argb);
 OIL_DECLARE_CLASS (composite_add_argb_const_src);
 OIL_DECLARE_CLASS (composite_in_over_argb);
+OIL_DECLARE_CLASS (composite_in_over_rgb);
 OIL_DECLARE_CLASS (composite_in_over_argb_const_src);
 OIL_DECLARE_CLASS (composite_in_over_argb_const_mask);
 
@@ -911,6 +913,49 @@
 OIL_DEFINE_IMPL_FULL (composite_in_over_argb_mmx, composite_in_over_argb, OIL_IMPL_FLAG_MMX | OIL_IMPL_FLAG_MMXEXT);
 
 static void
+composite_in_over_rgb_mmx (uint32_t *dest, uint32_t *src, uint8_t *mask, int n)
+{
+  __asm__ __volatile__ (
+      MMX_LOAD_CONSTANTS
+      "1:\n"
+      "  movd (%2), %%mm0\n"
+      "  punpcklbw %%mm7, %%mm0\n"
+      "  pshufw $0x00, %%mm0, %%mm1\n"
+
+      "  movl (%1), %%eax\n"
+      "  or $0xff000000, %%eax\n"
+      "  movd %%eax, %%mm2\n"
+      "  punpcklbw %%mm7, %%mm2\n"
+
+      MMX_MULDIV255(mm2, mm1)
+
+      "  movd (%0), %%mm0\n"
+      "  punpcklbw %%mm7, %%mm0\n"
+
+      "  pshufw $0xff, %%mm2, %%mm1\n"
+      "  pxor %%mm5, %%mm1\n"
+
+      MMX_MULDIV255(mm0, mm1)
+
+      "  paddw %%mm0, %%mm2\n"
+      "  packuswb %%mm2, %%mm2\n"
+
+      "  movd %%mm2, (%0)\n"
+      "  addl $4, %0\n"
+      "  addl $4, %1\n"
+      "  addl $1, %2\n"
+      "  decl %3\n"
+      "  jnz 1b\n"
+      "  emms\n"
+      :"+r" (dest), "+r" (src), "+r" (mask), "+r" (n)
+      :
+      :"eax");
+
+}
+OIL_DEFINE_IMPL_FULL (composite_in_over_rgb_mmx, composite_in_over_rgb, OIL_IMPL_FLAG_MMX | OIL_IMPL_FLAG_MMXEXT);
+
+
+static void
 composite_in_over_argb_const_src_mmx (uint32_t *dest, uint32_t *src, uint8_t *mask, int n)
 {
   __asm__ __volatile__ (
Index: liboil/ref/composite.c
===================================================================
RCS file: /cvs/liboil/liboil/liboil/ref/composite.c,v
retrieving revision 1.7
diff -u -r1.7 composite.c
--- liboil/ref/composite.c	20 Dec 2005 01:28:18 -0000	1.7
+++ liboil/ref/composite.c	27 Mar 2007 20:16:24 -0000
@@ -180,6 +180,20 @@
 OIL_DEFINE_CLASS_FULL (composite_in_over_argb,
     "uint32_t *i_n, uint32_t *s1_n, uint8_t *s2_n, int n",
     composite_test);
+
+/**
+ * oil_composite_in_over_rgb:
+ * @i_n: DEST
+ * @s1_n: SRC
+ * @s2_n: MASK
+ * @n: number of elements
+ *
+ * Performs the compositing operation DEST = (SRC IN MASK) OVER DEST.
+ */
+OIL_DEFINE_CLASS_FULL (composite_in_over_rgb,
+    "uint32_t *i_n, uint32_t *s1_n, uint8_t *s2_n, int n",
+    composite_test);
+
 /**
  * oil_composite_in_over_argb_const_src:
  * @i_n: DEST
@@ -378,6 +392,31 @@
 OIL_DEFINE_IMPL_REF (composite_in_over_argb_ref, composite_in_over_argb);
 
 static void
+composite_in_over_rgb_ref (uint32_t *dest, const uint32_t *src, const uint8_t *mask, int n)
+{
+  int i;
+  uint8_t a;
+  uint32_t color;
+
+  for(i=0;i<n;i++){
+    color = oil_argb(
+        COMPOSITE_IN(0xff, mask[i]),
+        COMPOSITE_IN(oil_argb_R(src[i]), mask[i]),
+        COMPOSITE_IN(oil_argb_G(src[i]), mask[i]),
+        COMPOSITE_IN(oil_argb_B(src[i]), mask[i]));
+    a = oil_argb_A(color);
+    dest[i] = oil_argb(
+        COMPOSITE_OVER(oil_argb_A(dest[i]),oil_argb_A(color),a),
+        COMPOSITE_OVER(oil_argb_R(dest[i]),oil_argb_R(color),a),
+        COMPOSITE_OVER(oil_argb_G(dest[i]),oil_argb_G(color),a),
+        COMPOSITE_OVER(oil_argb_B(dest[i]),oil_argb_B(color),a));
+  }
+
+}
+OIL_DEFINE_IMPL_REF (composite_in_over_rgb_ref, composite_in_over_rgb);
+
+
+static void
 composite_in_over_argb_const_src_ref (uint32_t *dest, const uint32_t *src, const uint8_t *mask, int n)
 {
   int i;
From chris at chris-wilson.co.uk  Wed Mar 28 10:20:42 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar 28 10:20:54 2007
Subject: [cairo] Add attribute(warn_unused_result)
In-Reply-To: <20070327210451.GB24027@inspired.chris-wilson.co.uk>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
	<1174502491.1028.20.camel@behdad>
	<20070327210451.GB24027@inspired.chris-wilson.co.uk>
Message-ID: <20070328172042.GA12094@inspired.chris-wilson.co.uk>

Another batch of missing error checks and similar mistakes.
--
Chris Wilson
-------------- next part --------------
>From a4726471c905b73f065520e6fb4892f86e72264a Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 16:54:03 +0100
Subject: [PATCH] Populate cairo-bentley-ottmann.c with cairo_static forward declarations.

This caught an instance where an error status was not checked.
---
 src/cairo-bentley-ottmann.c |  161 ++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 152 insertions(+), 9 deletions(-)

diff --git a/src/cairo-bentley-ottmann.c b/src/cairo-bentley-ottmann.c
index 14308f8..6459166 100644
--- a/src/cairo-bentley-ottmann.c
+++ b/src/cairo-bentley-ottmann.c
@@ -138,17 +138,158 @@ typedef struct _cairo_bo_sweep_line {
 } cairo_bo_sweep_line_t;
 
 
-cairo_static cairo_status_t
-_cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
-			     cairo_bo_edge_t		*edge);
+cairo_static cairo_quorem64_t
+edge_x_for_y (cairo_bo_edge_t *edge,
+	      int32_t y);
+
+cairo_static int
+_cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t	*sweep_line,
+				    cairo_bo_edge_t		*a,
+				    cairo_bo_edge_t		*b);
+
+cairo_static int
+_sweep_line_elt_compare (void	*list,
+			 void	*a,
+			 void	*b);
+
+cairo_static inline int
+cairo_bo_event_compare (cairo_bo_event_t const *a,
+			cairo_bo_event_t const *b);
+
+cairo_static int
+cairo_bo_event_compare_abstract (void		*list,
+				 void	*a,
+				 void	*b);
+
+cairo_static int
+cairo_bo_event_compare_pointers (void const *voida,
+				 void const *voidb);
+
+cairo_static inline cairo_int64_t
+det32_64 (int32_t a,
+	  int32_t b,
+	  int32_t c,
+	  int32_t d);
+
+cairo_static inline cairo_int128_t
+det64_128 (cairo_int64_t a,
+	   cairo_int64_t b,
+	   cairo_int64_t c,
+	   cairo_int64_t d);
+
+cairo_static cairo_bo_status_t
+intersect_lines (cairo_bo_edge_t		*a,
+		 cairo_bo_edge_t		*b,
+		 cairo_bo_intersect_point_t	*intersection);
+
+cairo_static int
+_cairo_bo_intersect_ordinate_32_compare (cairo_bo_intersect_ordinate_t	a,
+					 int32_t			b);
+
+cairo_static cairo_bool_t
+_cairo_bo_edge_contains_intersect_point (cairo_bo_edge_t		*edge,
+					 cairo_bo_intersect_point_t	*point);
+
+cairo_static cairo_bo_status_t
+_cairo_bo_edge_intersect (cairo_bo_edge_t	*a,
+			  cairo_bo_edge_t	*b,
+			  cairo_bo_point32_t	*intersection);
+
+cairo_static void
+_cairo_bo_event_init (cairo_bo_event_t		*event,
+		      cairo_bo_event_type_t	 type,
+		      cairo_bo_edge_t	*e1,
+		      cairo_bo_edge_t	*e2,
+		      cairo_bo_point32_t	 point);
+
 cairo_static cairo_status_t
 _cairo_bo_event_queue_insert (cairo_bo_event_queue_t *queue,
 			      cairo_bo_event_t	     *event);
+
+cairo_static void
+_cairo_bo_event_queue_delete (cairo_bo_event_queue_t *queue,
+			      cairo_bo_event_t	     *event);
+
+cairo_static cairo_bo_event_t *
+_cairo_bo_event_dequeue (cairo_bo_event_queue_t *event_queue);
+
+cairo_static cairo_status_t
+_cairo_bo_event_queue_init (cairo_bo_event_queue_t	*event_queue,
+			    cairo_bo_edge_t	        *edges,
+			    int				 num_edges);
+
+cairo_static void
+_cairo_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue);
+
 cairo_static cairo_status_t
 _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t	*event_queue,
 							   cairo_bo_edge_t	*left,
 							   cairo_bo_edge_t	*right);
 
+cairo_static void
+_cairo_bo_sweep_line_init (cairo_bo_sweep_line_t *sweep_line);
+
+cairo_static void
+_cairo_bo_sweep_line_fini (cairo_bo_sweep_line_t *sweep_line);
+
+cairo_static cairo_status_t
+_cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
+			     cairo_bo_edge_t		*edge);
+
+cairo_static void
+_cairo_bo_sweep_line_delete (cairo_bo_sweep_line_t	*sweep_line,
+			     cairo_bo_edge_t	        *edge);
+
+cairo_static void
+_cairo_bo_sweep_line_swap (cairo_bo_sweep_line_t	*sweep_line,
+			   cairo_bo_edge_t		*left,
+			   cairo_bo_edge_t		*right);
+cairo_static cairo_status_t
+_cairo_bo_edge_end_trap (cairo_bo_edge_t	*left,
+			 int32_t		 bot,
+			 cairo_bo_traps_t	*bo_traps);
+
+cairo_static cairo_status_t
+_cairo_bo_edge_start_or_continue_trap (cairo_bo_edge_t	*edge,
+				       int32_t		 top,
+				       cairo_bo_traps_t	*bo_traps);
+
+cairo_static void
+_cairo_bo_traps_init (cairo_bo_traps_t	*bo_traps,
+		      cairo_traps_t	*traps,
+		      cairo_fixed_t	 xmin,
+		      cairo_fixed_t	 ymin,
+		      cairo_fixed_t	 xmax,
+		      cairo_fixed_t	 ymax);
+
+cairo_static void
+_cairo_bo_traps_fini (cairo_bo_traps_t *bo_traps);
+
+cairo_static void
+_cairo_bo_sweep_line_validate (cairo_bo_sweep_line_t *sweep_line);
+
+cairo_static cairo_status_t
+_active_edges_to_traps (cairo_bo_edge_t		*head,
+			int32_t			 top,
+			cairo_fill_rule_t	 fill_rule,
+			cairo_bo_traps_t	*bo_traps);
+
+cairo_static cairo_status_t
+_cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
+					    int			 num_edges,
+					    cairo_fill_rule_t	 fill_rule,
+					    cairo_traps_t	*traps,
+					    cairo_fixed_t	xmin,
+					    cairo_fixed_t	ymin,
+					    cairo_fixed_t	xmax,
+					    cairo_fixed_t	ymax,
+					    int			*num_intersections);
+
+cairo_static void
+update_minmax(cairo_fixed_t *inout_min,
+	      cairo_fixed_t *inout_max,
+	      cairo_fixed_t v);
+
 static inline int
 _cairo_bo_point32_compare (cairo_bo_point32_t const *a,
 			   cairo_bo_point32_t const *b)
@@ -746,7 +887,7 @@ _cairo_bo_event_dequeue (cairo_bo_event_queue_t *event_queue)
 
 static cairo_status_t
 _cairo_bo_event_queue_init (cairo_bo_event_queue_t	*event_queue,
-			    cairo_bo_edge_t	*edges,
+			    cairo_bo_edge_t	        *edges,
 			    int				 num_edges)
 {
     int i;
@@ -899,7 +1040,7 @@ _cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t	*sweep_line,
 
 static void
 _cairo_bo_sweep_line_delete (cairo_bo_sweep_line_t	*sweep_line,
-			     cairo_bo_edge_t	*edge)
+			     cairo_bo_edge_t	        *edge)
 {
     cairo_bo_edge_t **left_next, **right_prev;
 
@@ -1072,7 +1213,7 @@ print_state (const char			*msg,
  * of bo_traps. */
 static cairo_status_t
 _cairo_bo_edge_end_trap (cairo_bo_edge_t	*left,
-			 int32_t		bot,
+			 int32_t		 bot,
 			 cairo_bo_traps_t	*bo_traps)
 {
     cairo_fixed_t fixed_top, fixed_bot;
@@ -1146,7 +1287,7 @@ _cairo_bo_edge_end_trap (cairo_bo_edge_t	*left,
  * trapezoid would be a continuation of the existing one. */
 static cairo_status_t
 _cairo_bo_edge_start_or_continue_trap (cairo_bo_edge_t	*edge,
-				       int32_t		top,
+				       int32_t		 top,
 				       cairo_bo_traps_t	*bo_traps)
 {
     cairo_status_t status;
@@ -1273,7 +1414,7 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
 					    cairo_fixed_t	ymax,
 					    int			*num_intersections)
 {
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_status_t status;
     int intersection_count = 0;
     cairo_bo_event_queue_t event_queue;
     cairo_bo_sweep_line_t sweep_line;
@@ -1283,7 +1424,9 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_edge_t	*edges,
     cairo_bo_edge_t *left, *right;
     cairo_bo_edge_t *edge1, *edge2;
 
-    _cairo_bo_event_queue_init (&event_queue, edges, num_edges);
+    status = _cairo_bo_event_queue_init (&event_queue, edges, num_edges);
+    if (status)
+	return status;
     _cairo_bo_sweep_line_init (&sweep_line);
     _cairo_bo_traps_init (&bo_traps, traps, xmin, ymin, xmax, ymax);
 
-- 
1.4.4.2

-------------- next part --------------
>From 3a87e368ecd8186cd7cb75cf7abddba8906a226c Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 17:00:27 +0100
Subject: [PATCH] cairo_skip_list_insert - missing check after malloc.

Return NULL when out of memory and propagate the error status back up
the call chain.
---
 src/cairo-skiplist.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/src/cairo-skiplist.c b/src/cairo-skiplist.c
index 451ecb0..2374b37 100644
--- a/src/cairo-skiplist.c
+++ b/src/cairo-skiplist.c
@@ -349,6 +349,8 @@ _cairo_skip_list_insert (cairo_skip_list_t *list, void *data, int unique)
     }
 
     data_and_elt = alloc_node_for_level (list, level);
+    if (data_and_elt == NULL)
+	return NULL;
     memcpy (data_and_elt, data, list->data_size);
     elt = (skip_elt_t *) (data_and_elt + list->data_size);
 
-- 
1.4.4.2

-------------- next part --------------
>From b354b03ef697093b40c1679c94a8f7f012cc4b29 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 17:02:35 +0100
Subject: [PATCH] pixman_create_source_image - missing check after malloc

Call chain already checked for a failure that was never reported.
---
 pixman/src/icimage.c    |    2 ++
 src/cairo-scaled-font.c |    1 +
 2 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/pixman/src/icimage.c b/pixman/src/icimage.c
index 62ff209..cd03251 100644
--- a/pixman/src/icimage.c
+++ b/pixman/src/icimage.c
@@ -187,6 +187,8 @@ _pixman_create_source_image (void)
     pixman_image_t *image;
 
     image = (pixman_image_t *) malloc (sizeof (pixman_image_t));
+    if (!image)
+	return NULL;
     image->pDrawable   = NULL;
     image->pixels      = NULL;
     image->format_code = PICT_a8r8g8b8;
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 0b19c8b..35fb692 100644
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -211,6 +211,7 @@ _cairo_scaled_font_map_lock (void)
 
  CLEANUP_SCALED_FONT_MAP:
     free (cairo_scaled_font_map);
+    cairo_scaled_font_map = NULL;
  CLEANUP_MUTEX_LOCK:
     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
     return NULL;
-- 
1.4.4.2

-------------- next part --------------
>From 5dd01e059e26da222419a90f1eab9c3a8c28f67e Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 19:35:02 +0000
Subject: [PATCH] Handle failure to allocate a GC.

---
 src/cairo-xlib-surface.c |   51 ++++++++++++++++++++++++++++++---------------
 1 files changed, 34 insertions(+), 17 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 7f1392d..ff5cdfe 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -51,7 +51,7 @@ typedef int (*cairo_xlib_error_func_t) (Display     *display,
 
 typedef struct _cairo_xlib_surface cairo_xlib_surface_t;
 
-static void
+static cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface);
 
 static void
@@ -587,22 +587,27 @@ _get_image_surface (cairo_xlib_surface_t    *surface,
 	 * retry, but to keep things simple, we just create a
 	 * temporary pixmap
 	 */
-	Pixmap pixmap = XCreatePixmap (surface->dpy,
+	Pixmap pixmap;
+	cairo_status_t status = _cairo_xlib_surface_ensure_gc (surface);
+	if (status)
+	    return status;
+
+	pixmap = XCreatePixmap (surface->dpy,
 				       surface->drawable,
 				       x2 - x1, y2 - y1,
 				       surface->depth);
-	_cairo_xlib_surface_ensure_gc (surface);
-
-	XCopyArea (surface->dpy, surface->drawable, pixmap, surface->gc,
-		   x1, y1, x2 - x1, y2 - y1, 0, 0);
+	if (pixmap) {
+	    XCopyArea (surface->dpy, surface->drawable, pixmap, surface->gc,
+		       x1, y1, x2 - x1, y2 - y1, 0, 0);
 
-	ximage = XGetImage (surface->dpy,
-			    pixmap,
-			    0, 0,
-			    x2 - x1, y2 - y1,
-			    AllPlanes, ZPixmap);
+	    ximage = XGetImage (surface->dpy,
+				pixmap,
+				0, 0,
+				x2 - x1, y2 - y1,
+				AllPlanes, ZPixmap);
 
-	XFreePixmap (surface->dpy, pixmap);
+	    XFreePixmap (surface->dpy, pixmap);
+	}
     }
     if (!ximage)
 	return CAIRO_STATUS_NO_MEMORY;
@@ -731,18 +736,23 @@ _cairo_xlib_surface_ensure_dst_picture (cairo_xlib_surface_t    *surface)
 
 }
 
-static void
+static cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface)
 {
     XGCValues gcv;
 
     if (surface->gc)
-	return;
+	return CAIRO_STATUS_SUCCESS;
 
     gcv.graphics_exposures = False;
     surface->gc = XCreateGC (surface->dpy, surface->drawable,
 			     GCGraphicsExposures, &gcv);
+    if (!surface->gc)
+	return CAIRO_STATUS_NO_MEMORY;
+
     _cairo_xlib_surface_set_gc_clip_rects (surface);
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_status_t
@@ -758,6 +768,7 @@ _draw_image_surface (cairo_xlib_surface_t   *surface,
     XImage ximage;
     unsigned int bpp, alpha, red, green, blue;
     int native_byte_order = _native_byte_order_lsb () ? LSBFirst : MSBFirst;
+    cairo_status_t status;
 
     pixman_format_get_masks (pixman_image_get_format (image->pixman_image),
 			     &bpp, &alpha, &red, &green, &blue);
@@ -780,7 +791,9 @@ _draw_image_surface (cairo_xlib_surface_t   *surface,
 
     XInitImage (&ximage);
 
-    _cairo_xlib_surface_ensure_gc (surface);
+    status = _cairo_xlib_surface_ensure_gc (surface);
+    if (status)
+	return status;
     XPutImage(surface->dpy, surface->drawable, surface->gc,
 	      &ximage, src_x, src_y, dst_x, dst_y,
 	      width, height);
@@ -1364,7 +1377,9 @@ _cairo_xlib_surface_composite (cairo_operator_t		op,
 	break;
 
     case DO_XCOPYAREA:
-	_cairo_xlib_surface_ensure_gc (dst);
+	status = _cairo_xlib_surface_ensure_gc (dst);
+	if (status)
+	    goto BAIL;
 	XCopyArea (dst->dpy,
 		   src->drawable,
 		   dst->drawable,
@@ -1384,7 +1399,9 @@ _cairo_xlib_surface_composite (cairo_operator_t		op,
 	 * _recategorize_composite_operation.
 	 */
 
-	_cairo_xlib_surface_ensure_gc (dst);
+	status = _cairo_xlib_surface_ensure_gc (dst);
+	if (status)
+	    goto BAIL;
 	_cairo_matrix_is_integer_translation (&src_attr.matrix, &itx, &ity);
 
 	XSetTSOrigin (dst->dpy, dst->gc,
-- 
1.4.4.2

-------------- next part --------------
>From c78d6358eef6c5a9f9cd385ff6328c5e7aa200a5 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 16 Mar 2007 20:04:26 +0000
Subject: [PATCH] Avoid using substituted surfaces for xlib operations.

Detect when a substitute image surface is returned for a solid pattern,
and avoid mixed image/xlib composite operations. This can happen for example
if there is a resource allocation failure during creating a similar surface.
---
 src/cairo-xlib-surface.c |    7 ++++++-
 1 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index ff5cdfe..5914c37 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -1217,7 +1217,12 @@ _recategorize_composite_operation (cairo_xlib_surface_t	      *dst,
 {
     cairo_bool_t is_integer_translation =
 	_cairo_matrix_is_integer_translation (&src_attr->matrix, NULL, NULL);
-    cairo_bool_t needs_alpha_composite =
+    cairo_bool_t needs_alpha_composite;
+
+    if (!_cairo_surface_is_xlib (&src->base))
+	return DO_UNSUPPORTED;
+
+    needs_alpha_composite =
 	_operator_needs_alpha_composite (op, _surface_has_alpha (src));
 
     if (!have_mask &&
-- 
1.4.4.2

-------------- next part --------------
>From b419aa16d10ec913cba0e036191dcbcfab207e45 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 17:58:31 +0100
Subject: [PATCH] Protect boilerplate_xlib_synchronize from alloc failure.

Don't call XDestroyImage on a NULL image.
---
 boilerplate/cairo-boilerplate.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/boilerplate/cairo-boilerplate.c b/boilerplate/cairo-boilerplate.c
index 858c5c0..cbfb2d4 100644
--- a/boilerplate/cairo-boilerplate.c
+++ b/boilerplate/cairo-boilerplate.c
@@ -877,7 +877,8 @@ boilerplate_xlib_synchronize (void *closure)
 
     ximage = XGetImage (xtc->dpy, xtc->drawable,
 			0, 0, 1, 1, AllPlanes, ZPixmap);
-    XDestroyImage (ximage);
+    if (ximage != NULL)
+	XDestroyImage (ximage);
 }
 
 /* For the xlib backend we distinguish between TEST and PERF mode in a
-- 
1.4.4.2

From chris at chris-wilson.co.uk  Wed Mar 28 16:16:28 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Wed Mar 28 16:16:40 2007
Subject: [cairo] Returning cached erroneous patterns
In-Reply-To: <1174666327.18229.23.camel@behdad>
References: <20070322172140.GF10524@inspired.chris-wilson.co.uk>
	<2faad3050703221112g4559d01bj1ea0c3f4cbed349a@mail.gmail.com>
	<1174666327.18229.23.camel@behdad>
Message-ID: <20070328231627.GB12094@inspired.chris-wilson.co.uk>

Behdad Esfahbod (behdad@behdad.org) said: 
> On Thu, 2007-03-22 at 14:12 -0400, Baz wrote:
> > All of this comes from patterns being mutable, for adding color stops,
> > and setting user data. Should those operations should even be possible
> > on patterns with more than one reference?
> 
> Ok, thanks for raising the issue.  The problem is that solid patterns
> are not immutable as we expected.  Giving away the same mutable object
> multiple times is definitely wrong.

Hmm, solid-patterns were not the only objects to be subjectable to this
unrecoverable error condition. A similar happenstance also occurs with
scaled fonts. :-(

Maaybe we need a proxy object to hold the user modifiable structures
struct _cairo_user_object {
    cairo_status_t status;
    unsigned int ref_count;
    cairo_user_data_array_t user_data;

    void *proxy; /* in this case the real _cairo_scaled_font */
}?

For the time being I'm using this patch to continue testing malloc
failures.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bad-scaled-font.patch
Type: text/x-diff
Size: 1858 bytes
Desc: not available
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070329/e816969f/bad-scaled-font.bin
From daniel.amelang at gmail.com  Wed Mar 28 21:44:54 2007
From: daniel.amelang at gmail.com (Daniel Amelang)
Date: Wed Mar 28 21:45:08 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <20070328164446.GA24453@infidigm.net>
References: <20070328164446.GA24453@infidigm.net>
Message-ID: <a65ae5c90703282144w2cf4a926ve317477d651de10b@mail.gmail.com>

On 3/28/07, Jeff Muizelaar <jeff@infidigm.net> wrote:
> I have put up a copy of cairo that has a partially rewritten libpixman
> in the pixman-new branch of my cairo tree.
>
> The main change is that all of the hand written special cases have been
> replaced with machine generated special cases. The impact of this is
> that now all regular compositing operations will not use the
> compositeGeneral case. In addition, the python script allows handwritten
> substitutions to be made. In this case, I've added substitutions using
> liboil for the operations that it supports. These substitutions cover
> alot of the common cases and cause a lot of the speed up seen below.
> I've also included a patch against liboil that adds another useful
> operation for cairo.

Nice. So how much bigger does cairo get with all the statically
generated code compiled in? I remember suggesting this approach once,
but Soren scared me away. Hmmm...I see 54k lines of C code in
composite.c.ref. I would have thought it would be worse, actually.

Also, I noticed that when you convert from 16-bit to 32-bit color, you
don't replicate the upper bits of the 5 (or 6)-bit color component in
the lower half of the resulting 8-bit color channel. Pixman does that
currently, and as I understand it, it's the Right Thing To Do to
prevent fading.

Great stuff! I'll be keeping a close eye on this.

Dan
From chris at chris-wilson.co.uk  Thu Mar 29 08:09:16 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Thu Mar 29 08:09:34 2007
Subject: [cairo] Add attribute(warn_unused_result)
In-Reply-To: <20070327210451.GB24027@inspired.chris-wilson.co.uk>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
	<1174502491.1028.20.camel@behdad>
	<20070327210451.GB24027@inspired.chris-wilson.co.uk>
Message-ID: <20070329150916.GA10132@inspired.chris-wilson.co.uk>

Continuing the series of feeding Cairo NULLs and picking up the
pieces...
-------------- next part --------------
>From 24bcfb2b8308705ea5aaee78bc902edca0be82dc Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 19:23:15 +0100
Subject: [PATCH] Cause pixman_region_create() to return NULL

Since PIXMAN_REGION_NAR is not exported this is a simple method of
detecting allocation failure.
---
 perf/cairo-perf.c      |    2 +-
 perf/text.c            |    4 +-
 pixman/src/fbpict.c    |    2 +
 pixman/src/icimage.c   |   49 ++++++++++++++++++++++++++++-------------------
 pixman/src/ictrap.c    |    2 +
 pixman/src/pixregion.c |    2 +-
 src/cairo-clip.c       |    5 +++-
 src/cairo-region.c     |    2 +
 src/cairo-traps.c      |    2 +
 9 files changed, 45 insertions(+), 25 deletions(-)

diff --git a/perf/cairo-perf.c b/perf/cairo-perf.c
index 44e842b..5657a38 100644
--- a/perf/cairo-perf.c
+++ b/perf/cairo-perf.c
@@ -355,7 +355,7 @@ main (int argc, char *argv[])
 		if (cairo_status (perf.cr)) {
 		    fprintf (stderr, "Error: Test left cairo in an error state: %s\n",
 			     cairo_status_to_string (cairo_status (perf.cr)));
-		    exit (1);
+		    //exit (1);
 		}
 
 		cairo_destroy (perf.cr);
diff --git a/perf/text.c b/perf/text.c
index de5e0cd..efe7d91 100644
--- a/perf/text.c
+++ b/perf/text.c
@@ -40,14 +40,14 @@ do_text (cairo_t *cr, int width, int height)
 	cairo_move_to (cr, 0, i * 10);
 	cairo_show_text (cr, text + i);
 	cairo_get_current_point (cr, &x, &y);
-	while (x < width) {
+	while (x < width && cairo_status (cr) == CAIRO_STATUS_SUCCESS) {
 	    cairo_show_text (cr, text);
 	    cairo_get_current_point (cr, &x, &y);
 	}
 	i++;
 	if (i >= len)
 	    i = 0;
-    } while (y < height);
+    } while (y < height && cairo_status (cr) == CAIRO_STATUS_SUCCESS);
 
     cairo_perf_timer_stop ();
 
diff --git a/pixman/src/fbpict.c b/pixman/src/fbpict.c
index 4d07699..6a41071 100644
--- a/pixman/src/fbpict.c
+++ b/pixman/src/fbpict.c
@@ -1963,6 +1963,8 @@ pixman_composite (pixman_operator_t	op,
 	maskRepeat = 0;
 
     region = pixman_region_create();
+    if (!region)
+	return 1;
     if (pixman_region_union_rect (region, region,
 	       	                  xDst, yDst,
 				  width, height) !=
diff --git a/pixman/src/icimage.c b/pixman/src/icimage.c
index cd03251..06a4a0f 100644
--- a/pixman/src/icimage.c
+++ b/pixman/src/icimage.c
@@ -326,26 +326,6 @@ pixman_image_init (pixman_image_t *image)
     image->serialNumber = GC_CHANGE_SERIAL_BIT;
 */
 
-    if (image->pixels)
-    {
-	image->pCompositeClip = pixman_region_create();
-	pixman_region_union_rect (image->pCompositeClip, image->pCompositeClip,
-				  0, 0, image->pixels->width,
-				  image->pixels->height);
-	image->freeCompClip = 1;
-
-	image->pSourceClip = pixman_region_create ();
-	pixman_region_union_rect (image->pSourceClip, image->pSourceClip,
-				  0, 0, image->pixels->width,
-				  image->pixels->height);
-	image->freeSourceClip = 1;
-    }
-    else
-    {
-	image->pCompositeClip = NULL;
-	image->pSourceClip    = NULL;
-    }
-
     image->transform = NULL;
 
     image->filter = PIXMAN_FILTER_NEAREST;
@@ -355,6 +335,35 @@ pixman_image_init (pixman_image_t *image)
     image->owns_pixels = 0;
 
     image->pSourcePict = NULL;
+    image->pCompositeClip = NULL;
+    image->pSourceClip    = NULL;
+
+    if (image->pixels)
+    {
+	image->pCompositeClip = pixman_region_create();
+	if (!image->pCompositeClip)
+	    return;
+	image->freeCompClip = 1;
+	if (pixman_region_union_rect (image->pCompositeClip,
+		                      image->pCompositeClip,
+				      0, 0,
+				      image->pixels->width,
+				      image->pixels->height) !=
+	       	PIXMAN_REGION_STATUS_SUCCESS)
+	    return;
+
+	image->pSourceClip = pixman_region_create ();
+	if (!image->pSourceClip)
+	    return;
+	image->freeSourceClip = 1;
+	if (pixman_region_union_rect (image->pSourceClip,
+		                      image->pSourceClip,
+				      0, 0,
+				      image->pixels->width,
+				      image->pixels->height) !=
+		PIXMAN_REGION_STATUS_SUCCESS)
+	    return;
+    }
 }
 
 void
diff --git a/pixman/src/ictrap.c b/pixman/src/ictrap.c
index fc093f0..261f961 100644
--- a/pixman/src/ictrap.c
+++ b/pixman/src/ictrap.c
@@ -134,6 +134,8 @@ pixman_composite_trapezoids (pixman_operator_t	      op,
     pixman_trapezoid_bounds (ntraps, traps, &traps_bounds);
 
     traps_region = pixman_region_create_simple (&traps_bounds);
+    if (!traps_region)
+	return 1;
 
     /* XXX: If the image has a clip region set, we should really be
      * fetching it here instead, but it looks like we don't yet expose
diff --git a/pixman/src/pixregion.c b/pixman/src/pixregion.c
index 0404dff..a3c83ad 100644
--- a/pixman/src/pixregion.c
+++ b/pixman/src/pixregion.c
@@ -316,7 +316,7 @@ pixman_region_create_simple (pixman_box16_t *extents)
 
     region = malloc (sizeof (pixman_region16_t));
     if (region == NULL)
-	return &pixman_brokenregion;
+	return NULL;
 
     pixman_init (region, extents);
 
diff --git a/src/cairo-clip.c b/src/cairo-clip.c
index de4bd23..f425e2b 100644
--- a/src/cairo-clip.c
+++ b/src/cairo-clip.c
@@ -368,12 +368,15 @@ _cairo_clip_intersect_region (cairo_clip_t    *clip,
     } else {
 	pixman_region16_t *intersection = pixman_region_create();
 
-	if (pixman_region_intersect (intersection,
+	if (intersection != NULL &&
+		pixman_region_intersect (intersection,
 				     clip->region, region)
 	    == PIXMAN_REGION_STATUS_SUCCESS) {
 	    pixman_region_destroy (clip->region);
 	    clip->region = intersection;
 	} else {
+	    if (intersection)
+		pixman_region_destroy (intersection);
 	    status = CAIRO_STATUS_NO_MEMORY;
 	}
 	pixman_region_destroy (region);
diff --git a/src/cairo-region.c b/src/cairo-region.c
index 057f9fe..f55008c 100644
--- a/src/cairo-region.c
+++ b/src/cairo-region.c
@@ -52,6 +52,8 @@ _cairo_region_create_from_rectangle (cairo_rectangle_int16_t *rect)
      * have an error return
      */
     pixman_region16_t *region = pixman_region_create ();
+    if (region == NULL)
+	return NULL;
     if (pixman_region_union_rect (region, region,
 				  rect->x, rect->y,
 				  rect->width, rect->height) != PIXMAN_REGION_STATUS_SUCCESS) {
diff --git a/src/cairo-traps.c b/src/cairo-traps.c
index 65075c2..00d1b8c 100644
--- a/src/cairo-traps.c
+++ b/src/cairo-traps.c
@@ -554,6 +554,8 @@ _cairo_traps_extract_region (cairo_traps_t      *traps,
 	}
 
     *region = pixman_region_create ();
+    if (*region == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
 
     for (i = 0; i < traps->num_traps; i++) {
 	int x = _cairo_fixed_integer_part(traps->traps[i].left.p1.x);
-- 
1.4.4.2

-------------- next part --------------
>From 83ffc06b14e8fe37b1690a01c4c1e739f66825f3 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 19:32:25 +0100
Subject: [PATCH] Detect failure to allocate glyphs during _cairo_scaled_font_init()

If _cairo_cache_create fails, return CAIRO_STATUS_NO_MEMORY.
---
 src/cairo-scaled-font.c |    9 ++++++---
 1 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index 35fb692..ab7007e 100644
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -351,6 +351,12 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			 const cairo_font_options_t	   *options,
 			 const cairo_scaled_font_backend_t *backend)
 {
+    scaled_font->glyphs = _cairo_cache_create (_cairo_scaled_glyph_keys_equal,
+					       _cairo_scaled_glyph_destroy,
+					       max_glyphs_cached_per_font);
+    if (scaled_font->glyphs == NULL)
+	return CAIRO_STATUS_NO_MEMORY;
+
     scaled_font->ref_count = 1;
 
     _cairo_user_data_array_init (&scaled_font->user_data);
@@ -365,9 +371,6 @@ _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
 			   &scaled_font->ctm);
 
     CAIRO_MUTEX_INIT (&scaled_font->mutex);
-    scaled_font->glyphs = _cairo_cache_create (_cairo_scaled_glyph_keys_equal,
-					       _cairo_scaled_glyph_destroy,
-					       max_glyphs_cached_per_font);
 
     scaled_font->surface_backend = NULL;
     scaled_font->surface_private = NULL;
-- 
1.4.4.2

-------------- next part --------------
>From 760711a5e4a5a9df6f14a65bca63b456ec18a46b Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 28 Mar 2007 20:27:29 +0100
Subject: [PATCH] _get_bitmap_surface - check for calloc failure

---
 src/cairo-ft-font.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index d30628a..9c6ed0b 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -838,6 +838,8 @@ _get_bitmap_surface (FT_Bitmap		     *bitmap,
 	    stride = bitmap->pitch;
 	    stride_rgba = (width_rgba * 4 + 3) & ~3;
 	    data_rgba = calloc (1, stride_rgba * height);
+	    if (data_rgba == NULL)
+		return CAIRO_STATUS_NO_MEMORY;
 
 	    os = 1;
 	    switch (font_options->subpixel_order) {
-- 
1.4.4.2

-------------- next part --------------
>From fe3026db386a70bfd532815be0f54db0d36079c1 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 09:11:21 +0100
Subject: [PATCH] Reorder cleanup cairo_xlib_surface_show_glyphs()

_cairo_pattern_release_surface() asserts that it is passed a pattern
surface. This itself is bad as breaks the symmetry with
_cairo_pattern_acquire_surface under() error conditions, however reorder
the cleanup to avoid this assertion.
---
 src/cairo-xlib-surface.c |   22 ++++++++++++----------
 1 files changed, 12 insertions(+), 10 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 5914c37..5c25c06 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -2920,6 +2920,8 @@ _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
                                                  0, 0, 1, 1,
                                                  (cairo_surface_t **) &src,
                                                  &attributes);
+    if (status)
+        goto BAIL0;
     } else {
         cairo_rectangle_int16_t glyph_extents;
 
@@ -2928,38 +2930,38 @@ _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
                                                           num_glyphs,
                                                           &glyph_extents);
         if (status)
-	    goto BAIL;
+	    goto BAIL0;
 
         status = _cairo_pattern_acquire_surface (src_pattern, &dst->base,
                                                  glyph_extents.x, glyph_extents.y,
                                                  glyph_extents.width, glyph_extents.height,
                                                  (cairo_surface_t **) &src,
                                                  &attributes);
+        if (status)
+	    goto BAIL0;
     }
 
-    if (status)
-        goto BAIL;
-
     operation = _recategorize_composite_operation (dst, op, src, &attributes, TRUE);
     if (operation == DO_UNSUPPORTED) {
 	status = CAIRO_INT_STATUS_UNSUPPORTED;
-	goto BAIL;
+	goto BAIL1;
     }
 
     status = _cairo_xlib_surface_set_attributes (src, &attributes);
     if (status)
-        goto BAIL;
+        goto BAIL1;
 
-    _cairo_xlib_surface_emit_glyphs (dst, (cairo_xlib_glyph_t *) glyphs, num_glyphs,
+    _cairo_xlib_surface_emit_glyphs (dst,
+	                             (cairo_xlib_glyph_t *) glyphs, num_glyphs,
 				     scaled_font, op, src, &attributes);
 
-  BAIL:
-    _cairo_scaled_font_thaw_cache (scaled_font);
-
+  BAIL1:
     if (src)
         _cairo_pattern_release_surface (src_pattern, &src->base, &attributes);
     if (src_pattern == &solid_pattern.base)
 	_cairo_pattern_fini (&solid_pattern.base);
+  BAIL0:
+    _cairo_scaled_font_thaw_cache (scaled_font);
 
     return status;
 }
-- 
1.4.4.2

-------------- next part --------------
>From b448992d70b2b4166185e196aa177d3fae163236 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 12:16:43 +0100
Subject: [PATCH] Mark function tables with attribute(warn_unused_result)

---
 src/cairo-paginated-surface-private.h |    2 +-
 src/cairoint.h                        |   53 +++++++++++++++++----------------
 2 files changed, 28 insertions(+), 27 deletions(-)

diff --git a/src/cairo-paginated-surface-private.h b/src/cairo-paginated-surface-private.h
index b5e4d5c..1e07f59 100644
--- a/src/cairo-paginated-surface-private.h
+++ b/src/cairo-paginated-surface-private.h
@@ -53,7 +53,7 @@ typedef struct _cairo_paginated_surface_backend {
      * any drawing operations for the page, (that is, it will occur
      * during the user's call to cairo_show_page or cairo_copy_page).
      */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*start_page)		(void			*surface);
 
     /* Required. Will be called twice for each page, once with an
diff --git a/src/cairoint.h b/src/cairoint.h
index cbb0b74..26a3145 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -114,6 +114,7 @@ CAIRO_BEGIN_DECLS
    and forces propagation of return values.
 */
 #define cairo_static static CAIRO_WARN_UNUSED_RESULT
+#define cairo_warn CAIRO_WARN_UNUSED_RESULT
 
 /* This macro allow us to deprecate a function by providing an alias
    for the old function name to the new function name. With this
@@ -636,7 +637,7 @@ typedef struct _cairo_scaled_font_subset {
 struct _cairo_scaled_font_backend {
     cairo_font_type_t type;
 
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*create_toy)  (cairo_toy_font_face_t	*toy_face,
 		    const cairo_matrix_t	*font_matrix,
 		    const cairo_matrix_t	*ctm,
@@ -646,7 +647,7 @@ struct _cairo_scaled_font_backend {
     void
     (*fini)		(void			*scaled_font);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*scaled_glyph_init)	(void			     *scaled_font,
 				 cairo_scaled_glyph_t	     *scaled_glyph,
 				 cairo_scaled_glyph_info_t    info);
@@ -655,7 +656,7 @@ struct _cairo_scaled_font_backend {
      * both. This allows the backend to do something more sophisticated
      * then just converting characters one by one.
      */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*text_to_glyphs) (void                *scaled_font,
 		       double		    x,
 		       double		    y,
@@ -666,7 +667,7 @@ struct _cairo_scaled_font_backend {
     unsigned long
     (*ucs4_to_index)		(void			     *scaled_font,
 				 uint32_t		      ucs4);
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*show_glyphs)	(void			*scaled_font,
 			 cairo_operator_t	 op,
 			 cairo_pattern_t	*pattern,
@@ -680,7 +681,7 @@ struct _cairo_scaled_font_backend {
 			 cairo_glyph_t		*glyphs,
 			 int			 num_glyphs);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*load_truetype_table)(void		        *scaled_font,
                            unsigned long         tag,
                            long                  offset,
@@ -702,7 +703,7 @@ struct _cairo_font_face_backend {
     void
     (*destroy)     (void			*font_face);
 
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*scaled_font_create) (void				*font_face,
 			   const cairo_matrix_t		*font_matrix,
 			   const cairo_matrix_t		*ctm,
@@ -748,10 +749,10 @@ struct _cairo_surface_backend {
 				 int			 width,
 				 int			 height);
 
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*finish)			(void			*surface);
 
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*acquire_source_image)	(void                    *abstract_surface,
 				 cairo_image_surface_t  **image_out,
 				 void                   **image_extra);
@@ -761,7 +762,7 @@ struct _cairo_surface_backend {
 				 cairo_image_surface_t  *image,
 				 void                   *image_extra);
 
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*acquire_dest_image)       (void                    *abstract_surface,
 				 cairo_rectangle_int16_t *interest_rect,
 				 cairo_image_surface_t  **image_out,
@@ -785,7 +786,7 @@ struct _cairo_surface_backend {
      *
      * 3. It has the same contents as @src within the given rectangle.
      */
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*clone_similar)            (void                   *surface,
 				 cairo_surface_t        *src,
 				 int                     src_x,
@@ -795,7 +796,7 @@ struct _cairo_surface_backend {
 				 cairo_surface_t       **clone_out);
 
     /* XXX: dst should be the first argument for consistency */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*composite)		(cairo_operator_t	 op,
 				 cairo_pattern_t       	*src,
 				 cairo_pattern_t	*mask,
@@ -809,7 +810,7 @@ struct _cairo_surface_backend {
 				 unsigned int		 width,
 				 unsigned int		 height);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*fill_rectangles)		(void			 *surface,
 				 cairo_operator_t	  op,
 				 const cairo_color_t     *color,
@@ -817,7 +818,7 @@ struct _cairo_surface_backend {
 				 int			  num_rects);
 
     /* XXX: dst should be the first argument for consistency */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*composite_trapezoids)	(cairo_operator_t	 op,
 				 cairo_pattern_t	*pattern,
 				 void			*dst,
@@ -831,10 +832,10 @@ struct _cairo_surface_backend {
 				 cairo_trapezoid_t	*traps,
 				 int			 num_traps);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*copy_page)		(void			*surface);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*show_page)		(void			*surface);
 
     /* Set given region as the clip region for the surface, replacing
@@ -850,7 +851,7 @@ struct _cairo_surface_backend {
      * this is not possible, cairo will use mask surfaces for
      * clipping.
      */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*set_clip_region)		(void			*surface,
 				 pixman_region16_t	*region);
 
@@ -868,7 +869,7 @@ struct _cairo_surface_backend {
      * function is not implemented cairo will use set_clip_region()
      * (if available) and mask surfaces for clipping.
      */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*intersect_clip_path)	(void			*dst,
 				 cairo_path_fixed_t	*path,
 				 cairo_fill_rule_t	fill_rule,
@@ -885,7 +886,7 @@ struct _cairo_surface_backend {
      * into the specific surface->get_extents if there is no current
      * clip.
      */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*get_extents)		(void			 *surface,
 				 cairo_rectangle_int16_t *rectangle);
 
@@ -894,7 +895,7 @@ struct _cairo_surface_backend {
      * resources. If null, render against this surface, using image
      * surfaces as glyphs.
      */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*old_show_glyphs)		(cairo_scaled_font_t	        *font,
 				 cairo_operator_t		 op,
 				 cairo_pattern_t		*pattern,
@@ -912,10 +913,10 @@ struct _cairo_surface_backend {
     (*get_font_options)         (void                  *surface,
 				 cairo_font_options_t  *options);
 
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*flush)                    (void                  *surface);
 
-    cairo_status_t
+    cairo_warn cairo_status_t
     (*mark_dirty_rectangle)     (void                  *surface,
 				 int                    x,
 				 int                    y,
@@ -932,18 +933,18 @@ struct _cairo_surface_backend {
     /* OK, I'm starting over somewhat by defining the 5 top-level
      * drawing operators for the surface backend here with consistent
      * naming and argument-order conventions. */
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*paint)			(void			*surface,
 				 cairo_operator_t	 op,
 				 cairo_pattern_t	*source);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*mask)			(void			*surface,
 				 cairo_operator_t	 op,
 				 cairo_pattern_t	*source,
 				 cairo_pattern_t	*mask);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*stroke)			(void			*surface,
 				 cairo_operator_t	 op,
 				 cairo_pattern_t	*source,
@@ -954,7 +955,7 @@ struct _cairo_surface_backend {
 				 double			 tolerance,
 				 cairo_antialias_t	 antialias);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*fill)			(void			*surface,
 				 cairo_operator_t	 op,
 				 cairo_pattern_t	*source,
@@ -963,7 +964,7 @@ struct _cairo_surface_backend {
 				 double			 tolerance,
 				 cairo_antialias_t	 antialias);
 
-    cairo_int_status_t
+    cairo_warn cairo_int_status_t
     (*show_glyphs)		(void			*surface,
 				 cairo_operator_t	 op,
 				 cairo_pattern_t	*source,
-- 
1.4.4.2

-------------- next part --------------
>From 2581f6296988c145ebe452717ea553422dc0dad3 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 13:36:07 +0100
Subject: [PATCH] Remove the entry if we return an error code during _cair_hash_table_insert.

Previously if we detected an error during resize we would report a
failure to insert the entry into the hash table having already done so.
---
 src/cairo-hash.c |   25 +++++++++++++++++++++----
 1 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/src/cairo-hash.c b/src/cairo-hash.c
index 31de811..87eb4da 100644
--- a/src/cairo-hash.c
+++ b/src/cairo-hash.c
@@ -52,6 +52,14 @@
  *       Appears in the table as any non-NULL, non-DEAD_ENTRY pointer.
  */
 
+cairo_static cairo_status_t
+_cairo_hash_table_resize  (cairo_hash_table_t *hash_table);
+
+cairo_static cairo_hash_entry_t **
+_cairo_hash_table_lookup_internal (cairo_hash_table_t *hash_table,
+				   cairo_hash_entry_t *key,
+				   cairo_bool_t	       key_is_unique);
+
 static cairo_hash_entry_t dead_entry = { 0 };
 #define DEAD_ENTRY (&dead_entry)
 
@@ -481,8 +489,12 @@ _cairo_hash_table_insert (cairo_hash_table_t *hash_table,
     hash_table->live_entries++;
 
     status = _cairo_hash_table_resize (hash_table);
-    if (status)
+    if (status) {
+	/* abort the insert... */
+	*entry = DEAD_ENTRY;
+	hash_table->live_entries--;
 	return status;
+    }
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -516,11 +528,12 @@ _cairo_hash_table_remove (cairo_hash_table_t *hash_table,
      * reorder elements of the table and cause the iteration to potentially
      * skip some elements. */
     if (hash_table->iterating == 0) {
+	cairo_status_t ignore;
 	/* This call _can_ fail, but only in failing to allocate new
 	 * memory to shrink the hash table. It does leave the table in a
 	 * consistent state, and we've already succeeded in removing the
 	 * entry, so we don't examine the failure status of this call. */
-	_cairo_hash_table_resize (hash_table);
+	 ignore = _cairo_hash_table_resize (hash_table);
     }
 }
 
@@ -561,6 +574,10 @@ _cairo_hash_table_foreach (cairo_hash_table_t	      *hash_table,
      * the table may need resizing. Just do this every time
      * as the check is inexpensive.
      */
-    if (--hash_table->iterating == 0)
-	_cairo_hash_table_resize (hash_table);
+    if (--hash_table->iterating == 0) {
+	cairo_status_t ignore;
+	/* Should we fail to shrink the hash table, it is left unaltered,
+	 * and we don't need to propagate the error status. */
+	ignore = _cairo_hash_table_resize (hash_table);
+    }
 }
-- 
1.4.4.2

-------------- next part --------------
>From 88d0e6daaf206d84c41e830dd253435438c6abeb Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 16:02:21 +0100
Subject: [PATCH] Handler failure in _cairo_xlib_surface_add_glyph.

Start by s/static/cairo_static/ to detect errors and fixup the warnings.
The main one in question is setting the have added glyph flag to TRUE even
if _cairo_xlib_surface_add_glyph() fails. This can cause an application
crash due to a RenderBadGlyph error later when the scaled font is cleaned
and we attempt to remove the glyph.
---
 src/cairo-xlib-surface.c |  172 +++++++++++++++++++++++++---------------------
 1 files changed, 94 insertions(+), 78 deletions(-)

diff --git a/src/cairo-xlib-surface.c b/src/cairo-xlib-surface.c
index 5c25c06..40fe7a5 100644
--- a/src/cairo-xlib-surface.c
+++ b/src/cairo-xlib-surface.c
@@ -51,22 +51,22 @@ typedef int (*cairo_xlib_error_func_t) (Display     *display,
 
 typedef struct _cairo_xlib_surface cairo_xlib_surface_t;
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface);
 
-static void
+cairo_static void
 _cairo_xlib_surface_ensure_src_picture (cairo_xlib_surface_t *surface);
 
-static void
+cairo_static void
 _cairo_xlib_surface_ensure_dst_picture (cairo_xlib_surface_t *surface);
 
-static cairo_bool_t
+cairo_static cairo_bool_t
 _cairo_surface_is_xlib (cairo_surface_t *surface);
 
-static cairo_bool_t
+cairo_static cairo_bool_t
 _native_byte_order_lsb (void);
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
 				 cairo_operator_t     op,
 				 cairo_pattern_t     *src_pattern,
@@ -151,7 +151,7 @@ struct _cairo_xlib_surface {
 #define CAIRO_SURFACE_RENDER_HAS_PICTURE_TRANSFORM(surface)	CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 6)
 #define CAIRO_SURFACE_RENDER_HAS_FILTERS(surface)	CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 6)
 
-static cairo_bool_t cairo_xlib_render_disabled = FALSE;
+cairo_static cairo_bool_t cairo_xlib_render_disabled = FALSE;
 
 /**
  * _cairo_xlib_test_disable_render:
@@ -170,7 +170,7 @@ _cairo_xlib_test_disable_render (void)
     cairo_xlib_render_disabled = TRUE;
 }
 
-static int
+cairo_static int
 _CAIRO_FORMAT_DEPTH (cairo_format_t format)
 {
     switch (format) {
@@ -186,7 +186,7 @@ _CAIRO_FORMAT_DEPTH (cairo_format_t format)
     }
 }
 
-static XRenderPictFormat *
+cairo_static XRenderPictFormat *
 _CAIRO_FORMAT_TO_XRENDER_FORMAT(Display *dpy, cairo_format_t format)
 {
     int	pict_format;
@@ -204,7 +204,7 @@ _CAIRO_FORMAT_TO_XRENDER_FORMAT(Display *dpy, cairo_format_t format)
     return XRenderFindStandardFormat (dpy, pict_format);
 }
 
-static cairo_surface_t *
+cairo_static cairo_surface_t *
 _cairo_xlib_surface_create_similar_with_format (void	       *abstract_src,
 						cairo_format_t	format,
 						int		width,
@@ -245,7 +245,7 @@ _cairo_xlib_surface_create_similar_with_format (void	       *abstract_src,
     return &surface->base;
 }
 
-static cairo_content_t
+cairo_static cairo_content_t
 _xrender_format_to_content (XRenderPictFormat *xrender_format)
 {
     cairo_bool_t xrender_format_has_alpha;
@@ -270,7 +270,7 @@ _xrender_format_to_content (XRenderPictFormat *xrender_format)
 	return CAIRO_CONTENT_COLOR;
 }
 
-static cairo_surface_t *
+cairo_static cairo_surface_t *
 _cairo_xlib_surface_create_similar (void	       *abstract_src,
 				    cairo_content_t	content,
 				    int			width,
@@ -322,7 +322,7 @@ _cairo_xlib_surface_create_similar (void	       *abstract_src,
     return &surface->base;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_finish (void *abstract_surface)
 {
     cairo_xlib_surface_t *surface = abstract_surface;
@@ -346,14 +346,14 @@ _cairo_xlib_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static int
+cairo_static int
 _noop_error_handler (Display     *display,
 		     XErrorEvent *event)
 {
     return False;		/* return value is ignored */
 }
 
-static cairo_bool_t
+cairo_static cairo_bool_t
 _CAIRO_MASK_FORMAT (cairo_format_masks_t *masks, cairo_format_t *format)
 {
     switch (masks->bpp) {
@@ -393,7 +393,7 @@ _CAIRO_MASK_FORMAT (cairo_format_masks_t *masks, cairo_format_t *format)
     return False;
 }
 
-static void
+cairo_static void
 _swap_ximage_2bytes (XImage *ximage)
 {
     int i, j;
@@ -411,7 +411,7 @@ _swap_ximage_2bytes (XImage *ximage)
     }
 }
 
-static void
+cairo_static void
 _swap_ximage_4bytes (XImage *ximage)
 {
     int i, j;
@@ -431,7 +431,7 @@ _swap_ximage_4bytes (XImage *ximage)
     }
 }
 
-static void
+cairo_static void
 _swap_ximage_bits (XImage *ximage)
 {
     int i, j;
@@ -456,7 +456,7 @@ _swap_ximage_bits (XImage *ximage)
     }
 }
 
-static void
+cairo_static void
 _swap_ximage_to_native (XImage *ximage)
 {
     int unit_bytes = 0;
@@ -503,7 +503,7 @@ _swap_ximage_to_native (XImage *ximage)
     }
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _get_image_surface (cairo_xlib_surface_t    *surface,
 		    cairo_rectangle_int16_t *interest_rect,
 		    cairo_image_surface_t  **image_out,
@@ -693,7 +693,7 @@ _get_image_surface (cairo_xlib_surface_t    *surface,
     return CAIRO_STATUS_NO_MEMORY;
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_ensure_src_picture (cairo_xlib_surface_t    *surface)
 {
     if (!surface->src_picture)
@@ -703,7 +703,7 @@ _cairo_xlib_surface_ensure_src_picture (cairo_xlib_surface_t    *surface)
 						     0, NULL);
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_set_picture_clip_rects (cairo_xlib_surface_t *surface)
 {
     if (surface->have_clip_rects)
@@ -713,7 +713,7 @@ _cairo_xlib_surface_set_picture_clip_rects (cairo_xlib_surface_t *surface)
 					 surface->num_clip_rects);
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_set_gc_clip_rects (cairo_xlib_surface_t *surface)
 {
     if (surface->have_clip_rects)
@@ -723,7 +723,7 @@ _cairo_xlib_surface_set_gc_clip_rects (cairo_xlib_surface_t *surface)
 			   surface->num_clip_rects, YXSorted);
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_ensure_dst_picture (cairo_xlib_surface_t    *surface)
 {
     if (!surface->dst_picture) {
@@ -736,7 +736,7 @@ _cairo_xlib_surface_ensure_dst_picture (cairo_xlib_surface_t    *surface)
 
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface)
 {
     XGCValues gcv;
@@ -755,7 +755,7 @@ _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _draw_image_surface (cairo_xlib_surface_t   *surface,
 		     cairo_image_surface_t  *image,
 		     int                    src_x,
@@ -802,7 +802,7 @@ _draw_image_surface (cairo_xlib_surface_t   *surface,
 
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_acquire_source_image (void                    *abstract_surface,
 					  cairo_image_surface_t  **image_out,
 					  void                   **image_extra)
@@ -821,7 +821,7 @@ _cairo_xlib_surface_acquire_source_image (void                    *abstract_surf
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_release_source_image (void                   *abstract_surface,
 					  cairo_image_surface_t  *image,
 					  void                   *image_extra)
@@ -829,7 +829,7 @@ _cairo_xlib_surface_release_source_image (void                   *abstract_surfa
     cairo_surface_destroy (&image->base);
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_acquire_dest_image (void                    *abstract_surface,
 					cairo_rectangle_int16_t *interest_rect,
 					cairo_image_surface_t  **image_out,
@@ -850,7 +850,7 @@ _cairo_xlib_surface_acquire_dest_image (void                    *abstract_surfac
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_release_dest_image (void                    *abstract_surface,
 					cairo_rectangle_int16_t *interest_rect,
 					cairo_image_surface_t   *image,
@@ -858,10 +858,13 @@ _cairo_xlib_surface_release_dest_image (void                    *abstract_surfac
 					void                    *image_extra)
 {
     cairo_xlib_surface_t *surface = abstract_surface;
+    cairo_status_t ignore;
 
     /* ignore errors */
-    _draw_image_surface (surface, image, 0, 0, image->width, image->height,
-			 image_rect->x, image_rect->y);
+    ignore = _draw_image_surface (surface, image,
+	                          0, 0,
+				  image->width, image->height,
+				  image_rect->x, image_rect->y);
 
     cairo_surface_destroy (&image->base);
 }
@@ -871,14 +874,14 @@ _cairo_xlib_surface_release_dest_image (void                    *abstract_surfac
  * screen.  Both core and Render drawing require this
  * when using multiple drawables in an operation.
  */
-static cairo_bool_t
+cairo_static cairo_bool_t
 _cairo_xlib_surface_same_screen (cairo_xlib_surface_t *dst,
 				 cairo_xlib_surface_t *src)
 {
     return dst->dpy == src->dpy && dst->screen == src->screen;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_clone_similar (void			*abstract_surface,
 				   cairo_surface_t	*src,
 				   int                   src_x,
@@ -889,6 +892,7 @@ _cairo_xlib_surface_clone_similar (void			*abstract_surface,
 {
     cairo_xlib_surface_t *surface = abstract_surface;
     cairo_xlib_surface_t *clone;
+    cairo_status_t status;
 
     if (src->backend == surface->base.backend ) {
 	cairo_xlib_surface_t *xlib_src = (cairo_xlib_surface_t *)src;
@@ -910,8 +914,12 @@ _cairo_xlib_surface_clone_similar (void			*abstract_surface,
 	if (clone->base.status)
 	    return CAIRO_STATUS_NO_MEMORY;
 
-	_draw_image_surface (clone, image_src, src_x, src_y,
+	status = _draw_image_surface (clone, image_src, src_x, src_y,
 			     width, height, src_x, src_y);
+	if (status) {
+	    cairo_surface_destroy (&clone->base);
+	    return status;
+	}
 
 	*clone_out = &clone->base;
 
@@ -921,7 +929,7 @@ _cairo_xlib_surface_clone_similar (void			*abstract_surface,
     return CAIRO_INT_STATUS_UNSUPPORTED;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_set_matrix (cairo_xlib_surface_t *surface,
 				cairo_matrix_t	     *matrix)
 {
@@ -944,7 +952,7 @@ _cairo_xlib_surface_set_matrix (cairo_xlib_surface_t *surface,
 
     if (!CAIRO_SURFACE_RENDER_HAS_PICTURE_TRANSFORM (surface))
     {
-	static const XTransform identity = { {
+	cairo_static const XTransform identity = { {
 	    { 1 << 16, 0x00000, 0x00000 },
 	    { 0x00000, 1 << 16, 0x00000 },
 	    { 0x00000, 0x00000, 1 << 16 },
@@ -961,7 +969,7 @@ _cairo_xlib_surface_set_matrix (cairo_xlib_surface_t *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_set_filter (cairo_xlib_surface_t *surface,
 				cairo_filter_t	     filter)
 {
@@ -1011,7 +1019,7 @@ _cairo_xlib_surface_set_filter (cairo_xlib_surface_t *surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_set_repeat (cairo_xlib_surface_t *surface, int repeat)
 {
     XRenderPictureAttributes pa;
@@ -1028,7 +1036,7 @@ _cairo_xlib_surface_set_repeat (cairo_xlib_surface_t *surface, int repeat)
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_set_attributes (cairo_xlib_surface_t	  *surface,
 				       cairo_surface_attributes_t *attributes)
 {
@@ -1042,15 +1050,17 @@ _cairo_xlib_surface_set_attributes (cairo_xlib_surface_t	  *surface,
 
     switch (attributes->extend) {
     case CAIRO_EXTEND_NONE:
-	_cairo_xlib_surface_set_repeat (surface, 0);
+	status = _cairo_xlib_surface_set_repeat (surface, 0);
 	break;
     case CAIRO_EXTEND_REPEAT:
-	_cairo_xlib_surface_set_repeat (surface, 1);
+	status = _cairo_xlib_surface_set_repeat (surface, 1);
 	break;
     case CAIRO_EXTEND_REFLECT:
     case CAIRO_EXTEND_PAD:
 	return CAIRO_INT_STATUS_UNSUPPORTED;
     }
+    if (status)
+	return status;
 
     status = _cairo_xlib_surface_set_filter (surface, attributes->filter);
     if (status)
@@ -1063,7 +1073,7 @@ _cairo_xlib_surface_set_attributes (cairo_xlib_surface_t	  *surface,
  * the core protocol: either with CopyArea or using src as a
  * a tile in a GC.
  */
-static cairo_bool_t
+cairo_static cairo_bool_t
 _surfaces_compatible (cairo_xlib_surface_t *dst,
 		      cairo_xlib_surface_t *src)
 {
@@ -1086,7 +1096,7 @@ _surfaces_compatible (cairo_xlib_surface_t *dst,
     return FALSE;
 }
 
-static cairo_bool_t
+cairo_static cairo_bool_t
 _surface_has_alpha (cairo_xlib_surface_t *surface)
 {
     if (surface->xrender_format) {
@@ -1105,7 +1115,7 @@ _surface_has_alpha (cairo_xlib_surface_t *surface)
 /* Returns true if the given operator and source-alpha combination
  * requires alpha compositing to complete.
  */
-static cairo_bool_t
+cairo_static cairo_bool_t
 _operator_needs_alpha_composite (cairo_operator_t op,
 				 cairo_bool_t     surface_has_alpha)
 {
@@ -1148,7 +1158,7 @@ typedef enum {
  * All we do here is reject cases where we *know* are going to
  * hit the bug and won't be able to use a core protocol fallback.
  */
-static composite_operation_t
+cairo_static composite_operation_t
 _categorize_composite_operation (cairo_xlib_surface_t *dst,
 				 cairo_operator_t      op,
 				 cairo_pattern_t      *src_pattern,
@@ -1208,7 +1218,7 @@ _categorize_composite_operation (cairo_xlib_surface_t *dst,
  * Also check here if we can just use XCopyArea, instead of going through
  * Render.
  */
-static composite_operation_t
+cairo_static composite_operation_t
 _recategorize_composite_operation (cairo_xlib_surface_t	      *dst,
 				   cairo_operator_t	       op,
 				   cairo_xlib_surface_t	      *src,
@@ -1254,7 +1264,7 @@ _recategorize_composite_operation (cairo_xlib_surface_t	      *dst,
     return DO_RENDER;
 }
 
-static int
+cairo_static int
 _render_operator (cairo_operator_t op)
 {
     switch (op) {
@@ -1294,7 +1304,7 @@ _render_operator (cairo_operator_t op)
     }
 }
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_composite (cairo_operator_t		op,
 			       cairo_pattern_t		*src_pattern,
 			       cairo_pattern_t		*mask_pattern,
@@ -1442,7 +1452,7 @@ _cairo_xlib_surface_composite (cairo_operator_t		op,
     return status;
 }
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_fill_rectangles (void		     *abstract_surface,
 				     cairo_operator_t	      op,
 				     const cairo_color_t     *color,
@@ -1472,7 +1482,7 @@ _cairo_xlib_surface_fill_rectangles (void		     *abstract_surface,
 
 /* Creates an A8 picture of size @width x @height, initialized with @color
  */
-static Picture
+cairo_static Picture
 _create_a8_picture (cairo_xlib_surface_t *surface,
 		    XRenderColor         *color,
 		    int                   width,
@@ -1506,7 +1516,7 @@ _create_a8_picture (cairo_xlib_surface_t *surface,
 /* Creates a temporary mask for the trapezoids covering the area
  * [@dst_x, @dst_y, @width, @height] of the destination surface.
  */
-static Picture
+cairo_static Picture
 _create_trapezoid_mask (cairo_xlib_surface_t *dst,
 			cairo_trapezoid_t    *traps,
 			int                   num_traps,
@@ -1561,7 +1571,7 @@ _create_trapezoid_mask (cairo_xlib_surface_t *dst,
     return mask_picture;
 }
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_composite_trapezoids (cairo_operator_t	op,
 					  cairo_pattern_t	*pattern,
 					  void			*abstract_dst,
@@ -1687,7 +1697,7 @@ _cairo_xlib_surface_composite_trapezoids (cairo_operator_t	op,
     return status;
 }
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_set_clip_region (void              *abstract_surface,
 				     pixman_region16_t *region)
 {
@@ -1748,7 +1758,7 @@ _cairo_xlib_surface_set_clip_region (void              *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_get_extents (void		         *abstract_surface,
 				 cairo_rectangle_int16_t *rectangle)
 {
@@ -1763,7 +1773,7 @@ _cairo_xlib_surface_get_extents (void		         *abstract_surface,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_get_font_options (void                  *abstract_surface,
 				      cairo_font_options_t  *options)
 {
@@ -1772,14 +1782,14 @@ _cairo_xlib_surface_get_font_options (void                  *abstract_surface,
     *options = surface->screen_info->font_options;
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_scaled_font_fini (cairo_scaled_font_t *scaled_font);
 
-static void
+cairo_static void
 _cairo_xlib_surface_scaled_glyph_fini (cairo_scaled_glyph_t *scaled_glyph,
 				       cairo_scaled_font_t  *scaled_font);
 
-static const cairo_surface_backend_t cairo_xlib_surface_backend = {
+cairo_static const cairo_surface_backend_t cairo_xlib_surface_backend = {
     CAIRO_SURFACE_TYPE_XLIB,
     _cairo_xlib_surface_create_similar,
     _cairo_xlib_surface_finish,
@@ -1819,13 +1829,13 @@ static const cairo_surface_backend_t cairo_xlib_surface_backend = {
  *
  * Return value: True if the surface is an xlib surface
  **/
-static cairo_bool_t
+cairo_static cairo_bool_t
 _cairo_surface_is_xlib (cairo_surface_t *surface)
 {
     return surface->backend == &cairo_xlib_surface_backend;
 }
 
-static cairo_surface_t *
+cairo_static cairo_surface_t *
 _cairo_xlib_surface_create_internal (Display		       *dpy,
 				     Drawable		        drawable,
 				     Screen		       *screen,
@@ -1928,7 +1938,7 @@ _cairo_xlib_surface_create_internal (Display		       *dpy,
     return (cairo_surface_t *) surface;
 }
 
-static Screen *
+cairo_static Screen *
 _cairo_xlib_screen_from_visual (Display *dpy, Visual *visual)
 {
     int	    s;
@@ -2293,7 +2303,7 @@ typedef struct _cairo_xlib_surface_font_private {
     XRenderPictFormat	*xrender_format;
 } cairo_xlib_surface_font_private_t;
 
-static void
+cairo_static void
 _cairo_xlib_surface_remove_scaled_font (Display *dpy,
 	                               void    *data)
 {
@@ -2311,22 +2321,24 @@ _cairo_xlib_surface_remove_scaled_font (Display *dpy,
     }
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_font_init (Display		    *dpy,
 			       cairo_scaled_font_t  *scaled_font,
 			       cairo_format_t	     format)
 {
     cairo_xlib_surface_font_private_t	*font_private;
 
-    if (!_cairo_xlib_add_close_display_hook (dpy,
-		_cairo_xlib_surface_remove_scaled_font,
-		scaled_font, scaled_font))
-	return CAIRO_STATUS_NO_MEMORY;
-
     font_private = malloc (sizeof (cairo_xlib_surface_font_private_t));
     if (!font_private)
 	return CAIRO_STATUS_NO_MEMORY;
 
+    if (!_cairo_xlib_add_close_display_hook (dpy,
+		_cairo_xlib_surface_remove_scaled_font,
+		scaled_font, scaled_font)) {
+	free (font_private);
+	return CAIRO_STATUS_NO_MEMORY;
+    }
+
     font_private->dpy = dpy;
     font_private->format = format;
     font_private->xrender_format = _CAIRO_FORMAT_TO_XRENDER_FORMAT(dpy, format);
@@ -2337,7 +2349,7 @@ _cairo_xlib_surface_font_init (Display		    *dpy,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_scaled_font_fini (cairo_scaled_font_t *scaled_font)
 {
     cairo_xlib_surface_font_private_t	*font_private = scaled_font->surface_private;
@@ -2349,7 +2361,7 @@ _cairo_xlib_surface_scaled_font_fini (cairo_scaled_font_t *scaled_font)
     }
 }
 
-static void
+cairo_static void
 _cairo_xlib_surface_scaled_glyph_fini (cairo_scaled_glyph_t *scaled_glyph,
 				       cairo_scaled_font_t  *scaled_font)
 {
@@ -2363,7 +2375,7 @@ _cairo_xlib_surface_scaled_glyph_fini (cairo_scaled_glyph_t *scaled_glyph,
     }
 }
 
-static cairo_bool_t
+cairo_static cairo_bool_t
 _native_byte_order_lsb (void)
 {
     int	x = 1;
@@ -2371,7 +2383,7 @@ _native_byte_order_lsb (void)
     return *((char *) &x) == 1;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_add_glyph (Display *dpy,
 			       cairo_scaled_font_t  *scaled_font,
 			       cairo_scaled_glyph_t *scaled_glyph)
@@ -2580,7 +2592,7 @@ typedef struct {
 #define GLYPH_INDEX_SKIP ((unsigned long) -1)
 #define STACK_ELTS_LEN ((int) (CAIRO_STACK_BUFFER_SIZE / sizeof (XGlyphElt8)))
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_emit_glyphs_chunk (cairo_xlib_surface_t *dst,
 				       cairo_xlib_glyph_t *glyphs,
 				       int num_glyphs,
@@ -2695,7 +2707,7 @@ _cairo_xlib_surface_emit_glyphs_chunk (cairo_xlib_surface_t *dst,
 
 #undef STACK_ELTS_LEN
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_xlib_surface_emit_glyphs (cairo_xlib_surface_t *dst,
 				 cairo_xlib_glyph_t *glyphs,
 				 int num_glyphs,
@@ -2815,7 +2827,11 @@ _cairo_xlib_surface_emit_glyphs (cairo_xlib_surface_t *dst,
 
 	/* Send unsent glyphs to the server */
 	if (scaled_glyph->surface_private == NULL) {
-	    _cairo_xlib_surface_add_glyph (dst->dpy, scaled_font, scaled_glyph);
+	    status = _cairo_xlib_surface_add_glyph (dst->dpy,
+		                                    scaled_font,
+						    scaled_glyph);
+	    if (status)
+		return status;
 	    scaled_glyph->surface_private = (void *) 1;
 	}
 
@@ -2837,7 +2853,7 @@ _cairo_xlib_surface_emit_glyphs (cairo_xlib_surface_t *dst,
 
 #undef GLYPH_INDEX_SKIP
 
-static cairo_int_status_t
+cairo_static cairo_int_status_t
 _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
 				 cairo_operator_t     op,
 				 cairo_pattern_t     *src_pattern,
@@ -2951,7 +2967,7 @@ _cairo_xlib_surface_show_glyphs (void                *abstract_dst,
     if (status)
         goto BAIL1;
 
-    _cairo_xlib_surface_emit_glyphs (dst,
+    status = _cairo_xlib_surface_emit_glyphs (dst,
 	                             (cairo_xlib_glyph_t *) glyphs, num_glyphs,
 				     scaled_font, op, src, &attributes);
 
-- 
1.4.4.2

From behdad at behdad.org  Thu Mar 29 09:30:30 2007
From: behdad at behdad.org (Behdad Esfahbod)
Date: Thu Mar 29 09:30:33 2007
Subject: [cairo] Returning cached erroneous patterns
In-Reply-To: <20070328231627.GB12094@inspired.chris-wilson.co.uk>
References: <20070322172140.GF10524@inspired.chris-wilson.co.uk>
	<2faad3050703221112g4559d01bj1ea0c3f4cbed349a@mail.gmail.com>
	<1174666327.18229.23.camel@behdad>
	<20070328231627.GB12094@inspired.chris-wilson.co.uk>
Message-ID: <1175185831.14707.12.camel@behdad>

On Thu, 2007-03-29 at 00:16 +0100, Chris Wilson wrote:
> Behdad Esfahbod (behdad@behdad.org) said: 
> > On Thu, 2007-03-22 at 14:12 -0400, Baz wrote:
> > > All of this comes from patterns being mutable, for adding color stops,
> > > and setting user data. Should those operations should even be possible
> > > on patterns with more than one reference?
> > 
> > Ok, thanks for raising the issue.  The problem is that solid patterns
> > are not immutable as we expected.  Giving away the same mutable object
> > multiple times is definitely wrong.
> 
> Hmm, solid-patterns were not the only objects to be subjectable to this
> unrecoverable error condition. A similar happenstance also occurs with
> scaled fonts. :-(

Except that the user cannot put a scaled-font into an error state.  It
just happens on real errors like out-of-memory.  That's not a problem
IMO.

> For the time being I'm using this patch to continue testing malloc
> failures.

The patch looks like the right approach to me.

-- 
behdad
http://behdad.org/

"Those who would give up Essential Liberty to purchase a little
 Temporary Safety, deserve neither Liberty nor Safety."
        -- Benjamin Franklin, 1759



From jeff at infidigm.net  Thu Mar 29 10:02:05 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Thu Mar 29 10:00:40 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <a65ae5c90703282144w2cf4a926ve317477d651de10b@mail.gmail.com>
References: <20070328164446.GA24453@infidigm.net>
	<a65ae5c90703282144w2cf4a926ve317477d651de10b@mail.gmail.com>
Message-ID: <20070329170205.GA29219@infidigm.net>

On Wed, Mar 28, 2007 at 09:44:54PM -0700, Daniel Amelang wrote:
> On 3/28/07, Jeff Muizelaar <jeff@infidigm.net> wrote:
> >I have put up a copy of cairo that has a partially rewritten libpixman
> >in the pixman-new branch of my cairo tree.
> >
> >The main change is that all of the hand written special cases have been
> >replaced with machine generated special cases. The impact of this is
> >that now all regular compositing operations will not use the
> >compositeGeneral case. In addition, the python script allows handwritten
> >substitutions to be made. In this case, I've added substitutions using
> >liboil for the operations that it supports. These substitutions cover
> >alot of the common cases and cause a lot of the speed up seen below.
> >I've also included a patch against liboil that adds another useful
> >operation for cairo.
> 
> Nice. So how much bigger does cairo get with all the statically
> generated code compiled in? I remember suggesting this approach once,
> but Soren scared me away. Hmmm...I see 54k lines of C code in
> composite.c.ref. I would have thought it would be worse, actually.

old:
   text    data     bss     dec     hex filename
 459857    4500     236  464593   716d1 src/.libs/libcairo.so

new:
   text    data     bss     dec     hex filename
 887388   17360     268  905016   dcf38 src/.libs/libcairo.so

So, it doesn't look very good. The text size increase isn't that big a
deal because we can emit the kernels in the order of most commonly used
and the unused kernels won't even need to be paged in. However, the more
concerning part is the increase in data (.data.rel.ro) that presumeably
comes from the dispatch table. Anyone have any thoughts on how bad this
is and whether it can be fixed?

> 
> Also, I noticed that when you convert from 16-bit to 32-bit color, you
> don't replicate the upper bits of the 5 (or 6)-bit color component in
> the lower half of the resulting 8-bit color channel. Pixman does that
> currently, and as I understand it, it's the Right Thing To Do to
> prevent fading.

Yeah, the precision conversion code was pretty broken. I haven't
actually done any 565 testing yet, so I didn't need it to actually work.
Anyways, I've fixed it to do the proper multiply by 255 and divide by 31
or 63, but I plan to add support for the bit copying approximation as
well.

> Great stuff! I'll be keeping a close eye on this.

Thanks,

-Jeff
From mental at rydia.net  Thu Mar 29 10:17:03 2007
From: mental at rydia.net (MenTaLguY)
Date: Thu Mar 29 10:17:07 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <20070329170205.GA29219@infidigm.net>
References: <20070329170205.GA29219@infidigm.net>
Message-ID: <2d30085fb027b6516519b4ffda7448c6@localhost>

On Thu, 29 Mar 2007 13:02:05 -0400, Jeff Muizelaar <jeff@infidigm.net> wrote:
> Yeah, the precision conversion code was pretty broken. I haven't
> actually done any 565 testing yet, so I didn't need it to actually work.
> Anyways, I've fixed it to do the proper multiply by 255 and divide by 31
> or 63, but I plan to add support for the bit copying approximation as
> well.

The bit-copying "approximation" is exactly equivalent to multiplying by 255 and dividing by 31.  There's no point in implementing both -- stick with the bit copy, since it's more efficient.

-mental

From jeff at infidigm.net  Thu Mar 29 10:33:42 2007
From: jeff at infidigm.net (Jeff Muizelaar)
Date: Thu Mar 29 10:31:42 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <2d30085fb027b6516519b4ffda7448c6@localhost>
References: <20070329170205.GA29219@infidigm.net>
	<2d30085fb027b6516519b4ffda7448c6@localhost>
Message-ID: <20070329173342.GA29877@infidigm.net>

On Thu, Mar 29, 2007 at 10:17:03AM -0700, MenTaLguY wrote:
> On Thu, 29 Mar 2007 13:02:05 -0400, Jeff Muizelaar <jeff@infidigm.net> wrote:
> > Yeah, the precision conversion code was pretty broken. I haven't
> > actually done any 565 testing yet, so I didn't need it to actually work.
> > Anyways, I've fixed it to do the proper multiply by 255 and divide by 31
> > or 63, but I plan to add support for the bit copying approximation as
> > well.
> 
> The bit-copying "approximation" is exactly equivalent to multiplying by 255 and dividing by 31.  There's no point in implementing both -- stick with the bit copy, since it's more efficient.

(x << 3) | (x >> 2) is not equivalent to (255*x + 15)/31 for x = {3, 7, 24, 28}

-Jeff
From chris at chris-wilson.co.uk  Thu Mar 29 13:26:20 2007
From: chris at chris-wilson.co.uk (Chris Wilson)
Date: Thu Mar 29 13:26:39 2007
Subject: [cairo] Add attribute(warn_unused_result)
In-Reply-To: <20070327210451.GB24027@inspired.chris-wilson.co.uk>
References: <20070321165133.GA10524@inspired.chris-wilson.co.uk>
	<1174502491.1028.20.camel@behdad>
	<20070327210451.GB24027@inspired.chris-wilson.co.uk>
Message-ID: <20070329202620.GB10132@inspired.chris-wilson.co.uk>

And with this patch, all malloc call sites triggered by cairo-perf for
xlib and image have been tested and do not cause cairo to fallover.
[Ok, that's not the same as all code paths but it's a good first step
with a finite runtime ;]

-------------- next part --------------
>From 8e87f5d1b36469e8c15e6b8a65ef73bdf1e81d6d Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 19:27:09 +0100
Subject: [PATCH] Return the correct status from _cairo_pen_stroke_spline

Don't blindly return CAIRO_STATUS_SUCCESS when the normal return path
also handle the error returns.
---
 src/cairo-pen.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/cairo-pen.c b/src/cairo-pen.c
index 74d2996..8bbc199 100644
--- a/src/cairo-pen.c
+++ b/src/cairo-pen.c
@@ -36,13 +36,13 @@
 
 #include "cairoint.h"
 
-static int
+cairo_static int
 _cairo_pen_vertices_needed (double tolerance, double radius, cairo_matrix_t *matrix);
 
-static void
+cairo_static void
 _cairo_pen_compute_slopes (cairo_pen_t *pen);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_pen_stroke_spline_half (cairo_pen_t *pen, cairo_spline_t *spline, cairo_direction_t dir, cairo_polygon_t *polygon);
 
 cairo_status_t
@@ -245,7 +245,7 @@ Note that this also equation works for M == m (a circle) as it
 doesn't matter where on the circle the error is computed.
 */
 
-static int
+cairo_static int
 _cairo_pen_vertices_needed (double	    tolerance,
 			    double	    radius,
 			    cairo_matrix_t  *matrix)
@@ -282,7 +282,7 @@ _cairo_pen_vertices_needed (double	    tolerance,
     return num_vertices;
 }
 
-static void
+cairo_static void
 _cairo_pen_compute_slopes (cairo_pen_t *pen)
 {
     int i, i_prev;
@@ -358,7 +358,7 @@ _cairo_pen_find_active_ccw_vertex_index (cairo_pen_t *pen,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_pen_stroke_spline_half (cairo_pen_t *pen,
 			       cairo_spline_t *spline,
 			       cairo_direction_t dir,
@@ -461,5 +461,5 @@ _cairo_pen_stroke_spline (cairo_pen_t		*pen,
 BAIL:
     _cairo_polygon_fini (&polygon);
 
-    return CAIRO_STATUS_SUCCESS;
+    return status;
 }
-- 
1.4.4.2

-------------- next part --------------
>From f44b5107e1ca34e8aa33037eef95bcd4414c0de4 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 19:50:06 +0100
Subject: [PATCH] Convert to cairo_static and fixup.

Nothing of consequence, but future-proofing.
---
 src/cairo-path-bounds.c |   49 ++++++++++++++++++++++++----------------------
 1 files changed, 26 insertions(+), 23 deletions(-)

diff --git a/src/cairo-path-bounds.c b/src/cairo-path-bounds.c
index 48b4393..f4be744 100644
--- a/src/cairo-path-bounds.c
+++ b/src/cairo-path-bounds.c
@@ -45,43 +45,43 @@ typedef struct cairo_path_bounder {
     cairo_fixed_t max_y;
 } cairo_path_bounder_t;
 
-static void
+cairo_static void
 _cairo_path_bounder_init (cairo_path_bounder_t *bounder);
 
-static void
+cairo_static void
 _cairo_path_bounder_fini (cairo_path_bounder_t *bounder);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_add_point (cairo_path_bounder_t *bounder, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_move_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_line_to (void *closure, cairo_point_t *point);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_curve_to (void *closure,
 			      cairo_point_t *b,
 			      cairo_point_t *c,
 			      cairo_point_t *d);
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_close_path (void *closure);
 
-static void
+cairo_static void
 _cairo_path_bounder_init (cairo_path_bounder_t *bounder)
 {
     bounder->has_point = 0;
 }
 
-static void
+cairo_static void
 _cairo_path_bounder_fini (cairo_path_bounder_t *bounder)
 {
     bounder->has_point = 0;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_add_point (cairo_path_bounder_t *bounder, cairo_point_t *point)
 {
     if (bounder->has_point) {
@@ -108,42 +108,45 @@ _cairo_path_bounder_add_point (cairo_path_bounder_t *bounder, cairo_point_t *poi
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_move_to (void *closure, cairo_point_t *point)
 {
     cairo_path_bounder_t *bounder = closure;
 
-    _cairo_path_bounder_add_point (bounder, point);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_path_bounder_add_point (bounder, point);
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_line_to (void *closure, cairo_point_t *point)
 {
     cairo_path_bounder_t *bounder = closure;
 
-    _cairo_path_bounder_add_point (bounder, point);
-
-    return CAIRO_STATUS_SUCCESS;
+    return _cairo_path_bounder_add_point (bounder, point);
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_curve_to (void *closure,
 			      cairo_point_t *b,
 			      cairo_point_t *c,
 			      cairo_point_t *d)
 {
     cairo_path_bounder_t *bounder = closure;
+    cairo_status_t status;
 
-    _cairo_path_bounder_add_point (bounder, b);
-    _cairo_path_bounder_add_point (bounder, c);
-    _cairo_path_bounder_add_point (bounder, d);
+    status = _cairo_path_bounder_add_point (bounder, b);
+    if (status)
+	return status;
+    status = _cairo_path_bounder_add_point (bounder, c);
+    if (status)
+	return status;
+    status = _cairo_path_bounder_add_point (bounder, d);
+    if (status)
+	return status;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_status_t
+cairo_static cairo_status_t
 _cairo_path_bounder_close_path (void *closure)
 {
     return CAIRO_STATUS_SUCCESS;
-- 
1.4.4.2

-------------- next part --------------
>From 47ee2c33f4f970fe6dd8aa6fc284260c41989e88 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 20:44:19 +0100
Subject: [PATCH] Don't return scaled fonts in the error state from the cache.

It is possible for a scaled_font to be flagged as in error, though only
through a "true error" e.g. a malloc failure. However, when returning a font
from the cache it should not be in error. So if we find a error font in the
cache we remove it and return a new font.
---
 src/cairo-gstate.c      |    2 +-
 src/cairo-scaled-font.c |   13 ++++++++-----
 src/cairo.c             |   25 +++++++++++++------------
 3 files changed, 22 insertions(+), 18 deletions(-)

diff --git a/src/cairo-gstate.c b/src/cairo-gstate.c
index 82f5402..364fd09 100644
--- a/src/cairo-gstate.c
+++ b/src/cairo-gstate.c
@@ -1513,7 +1513,7 @@ _cairo_gstate_text_to_glyphs (cairo_gstate_t *gstate,
     status = _cairo_scaled_font_text_to_glyphs (gstate->scaled_font, x, y,
 						utf8, glyphs, num_glyphs);
 
-    if (status || !glyphs || !num_glyphs || !(*glyphs) || !(num_glyphs))
+    if (status || !glyphs || !num_glyphs || !(*glyphs))
 	return status;
 
     return CAIRO_STATUS_SUCCESS;
diff --git a/src/cairo-scaled-font.c b/src/cairo-scaled-font.c
index ab7007e..b904b85 100644
--- a/src/cairo-scaled-font.c
+++ b/src/cairo-scaled-font.c
@@ -508,6 +508,12 @@ cairo_scaled_font_create (cairo_font_face_t          *font_face,
 	    memmove (&font_map->holdovers[i],
 		     &font_map->holdovers[i+1],
 		     (font_map->num_holdovers - i) * sizeof (cairo_scaled_font_t*));
+
+	    scaled_font->status = CAIRO_STATUS_SUCCESS;
+	} else if (scaled_font->status != CAIRO_STATUS_SUCCESS) {
+	    /* the font has been put into an error state - abandon the cache */
+	    _cairo_hash_table_remove (font_map->hash_table, &key.hash_entry);
+	    goto create_font;
 	}
 
 	/* We increment the reference count manually here, (rather
@@ -517,6 +523,7 @@ cairo_scaled_font_create (cairo_font_face_t          *font_face,
 	scaled_font->ref_count++;
 	_cairo_scaled_font_map_unlock ();
     } else {
+create_font:
 	/* Otherwise create it and insert it into the hash table. */
 	status = font_face->backend->scaled_font_create (font_face, font_matrix,
 							 ctm, options, &scaled_font);
@@ -969,10 +976,8 @@ _cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t	 *scaled_font,
 					     glyphs[i].index,
 					     CAIRO_SCALED_GLYPH_INFO_METRICS,
 					     &scaled_glyph);
-	if (status) {
-	    _cairo_scaled_font_set_error (scaled_font, status);
+	if (status)
 	    return status;
-	}
 
 	/* glyph images are snapped to pixel locations */
 	x = _cairo_lround (glyphs[i].x);
@@ -1531,8 +1536,6 @@ _cairo_scaled_glyph_lookup (cairo_scaled_font_t *scaled_font,
   CLEANUP:
     if (status) {
 	/* It's not an error for the backend to not support the info we want. */
-	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
-	    _cairo_scaled_font_set_error (scaled_font, status);
 	*scaled_glyph_ret = NULL;
     } else {
 	*scaled_glyph_ret = scaled_glyph;
diff --git a/src/cairo.c b/src/cairo.c
index 64b2b0b..56b799e 100644
--- a/src/cairo.c
+++ b/src/cairo.c
@@ -2810,6 +2810,7 @@ cairo_glyph_extents (cairo_t                *cr,
 void
 cairo_show_text (cairo_t *cr, const char *utf8)
 {
+    cairo_status_t status;
     cairo_text_extents_t extents;
     cairo_glyph_t *glyphs = NULL, *last_glyph;
     int num_glyphs;
@@ -2823,24 +2824,24 @@ cairo_show_text (cairo_t *cr, const char *utf8)
 
     cairo_get_current_point (cr, &x, &y);
 
-    cr->status = _cairo_gstate_text_to_glyphs (cr->gstate, utf8,
-					       x, y,
-					       &glyphs, &num_glyphs);
-    if (cr->status)
+    status = _cairo_gstate_text_to_glyphs (cr->gstate, utf8,
+					   x, y,
+					   &glyphs, &num_glyphs);
+    if (status)
 	goto BAIL;
 
     if (num_glyphs == 0)
 	return;
 
-    cr->status = _cairo_gstate_show_glyphs (cr->gstate, glyphs, num_glyphs);
-    if (cr->status)
+    status = _cairo_gstate_show_glyphs (cr->gstate, glyphs, num_glyphs);
+    if (status)
 	goto BAIL;
 
     last_glyph = &glyphs[num_glyphs - 1];
-    cr->status = _cairo_gstate_glyph_extents (cr->gstate,
-					      last_glyph, 1,
-					      &extents);
-    if (cr->status)
+    status = _cairo_gstate_glyph_extents (cr->gstate,
+					  last_glyph, 1,
+					  &extents);
+    if (status)
 	goto BAIL;
 
     x = last_glyph->x + extents.x_advance;
@@ -2851,8 +2852,8 @@ cairo_show_text (cairo_t *cr, const char *utf8)
     if (glyphs)
 	free (glyphs);
 
-    if (cr->status)
-	_cairo_set_error (cr, cr->status);
+    if (status)
+	_cairo_set_error (cr, status);
 }
 
 /**
-- 
1.4.4.2

-------------- next part --------------
>From 664905cc03e61039d9d06ee6c27201a6d61151e0 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 29 Mar 2007 21:20:50 +0100
Subject: [PATCH] Use cairo-perf for malloc failure testing

By changing cairo-perf to repeat a perf-case if it returns
CAIRO_STATUS_NO_MEMORY we can use cairo-perf, in conjuction with a fault
injector, to test a large swathe of failure handling throughout the entire
library.
---
 boilerplate/cairo-boilerplate.c |   27 ++++++++++++++++
 perf/Makefile.am                |    7 ++--
 perf/box-outline.c              |    8 +++-
 perf/cairo-perf-cover.c         |   26 ++++++++++-----
 perf/cairo-perf.c               |   65 +++++++++++++++++++++++++++------------
 perf/cairo-perf.h               |   17 ++++++++--
 perf/long-lines.c               |    8 +++-
 perf/mosaic.c                   |   12 +++++--
 perf/pattern_create_radial.c    |    4 +-
 perf/rectangles.c               |    2 +-
 perf/subimage_copy.c            |    2 +-
 perf/tessellate.c               |   10 ++++--
 perf/unaligned-clip.c           |    2 +-
 perf/world-map.c                |    2 +-
 perf/zrusin.c                   |    8 +++-
 15 files changed, 146 insertions(+), 54 deletions(-)

diff --git a/boilerplate/cairo-boilerplate.c b/boilerplate/cairo-boilerplate.c
index cbfb2d4..dbca77c 100644
--- a/boilerplate/cairo-boilerplate.c
+++ b/boilerplate/cairo-boilerplate.c
@@ -985,6 +985,28 @@ create_xlib_perf_surface (Display		*dpy,
 							  width, height);
 }
 
+static int xlib_error_handler (Display *dpy, XErrorEvent *ev)
+{
+    char buf[1024];
+    char msg[1024];
+
+    XGetErrorText (dpy, ev->error_code, buf, sizeof (buf));
+    XGetErrorDatabaseText (dpy, "XlibMessage",
+	    "XError", "X Error", msg, sizeof (msg));
+    fprintf(stderr, "%s:  %s\n  ", msg, buf);
+
+    XGetErrorDatabaseText (dpy, "XlibMessage",
+	    "MajorCode", "Request Major code %d", 
+	    msg, sizeof (msg));
+    fprintf (stderr, msg, ev->request_code);
+    fprintf (stderr, "\n");
+
+    if (!getenv ("CAIRO_TEST_XLIB_NO_ERRORS"))
+	abort();
+
+    return 0;
+}
+
 static cairo_surface_t *
 create_xlib_surface (const char			 *name,
 		     cairo_content_t		  content,
@@ -1009,6 +1031,11 @@ create_xlib_surface (const char			 *name,
 	return NULL;
     }
 
+    /* install an eror handler that aborts rather than simply exits... */
+    XSetErrorHandler (xlib_error_handler);
+    if (getenv ("CAIRO_TEST_XLIB_SYNC"))
+	XSynchronize (dpy, TRUE);
+
     if (mode == CAIRO_BOILERPLATE_MODE_TEST)
 	return create_xlib_test_surface (dpy, content, width, height, xtc);
     else /* mode == CAIRO_BOILERPLATE_MODE_PERF */
diff --git a/perf/Makefile.am b/perf/Makefile.am
index 8fd6e64..c8585ce 100644
--- a/perf/Makefile.am
+++ b/perf/Makefile.am
@@ -42,14 +42,15 @@ cairo_perf_SOURCES += cairo-perf-win32.c
 else
 cairo_perf_SOURCES += cairo-perf-posix.c
 endif
+cairo_perf_LDADD = $(top_builddir)/boilerplate/libcairoboilerplate.la \
+	$(top_builddir)/src/libcairo.la
+
 
 cairo_perf_diff_files_SOURCES =	\
 	cairo-perf-diff-files.c \
 	cairo-stats.c		\
 	cairo-stats.h
-
-LDADD = $(top_builddir)/boilerplate/libcairoboilerplate.la \
-	$(top_builddir)/src/libcairo.la
+cairo_perf_diff_files_LDADD = $(top_builddir)/boilerplate/libcairoboilerplate.la
 
 $(top_builddir)/boilerplate/libcairoboilerplate.la:
 	cd $(top_builddir)/boilerplate && $(MAKE) $(AM_MAKEFLAGS) libcairoboilerplate.la
diff --git a/perf/box-outline.c b/perf/box-outline.c
index 74dd19a..ccba0aa 100644
--- a/perf/box-outline.c
+++ b/perf/box-outline.c
@@ -88,6 +88,10 @@ box_outline_fill (cairo_t *cr, int width, int height)
 void
 box_outline (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "box-outline-stroke", box_outline_stroke);
-    cairo_perf_run (perf, "box-outline-fill", box_outline_fill);
+    static const cairo_perf_functions_t funcs[] = {
+	{ "box-outline-stroke", box_outline_stroke },
+	{ "box-outline-fill", box_outline_fill },
+	{ NULL, NULL }
+    };
+    cairo_perf_run (funcs, perf);
 }
diff --git a/perf/cairo-perf-cover.c b/perf/cairo-perf-cover.c
index 53dc7b7..5251a51 100644
--- a/perf/cairo-perf-cover.c
+++ b/perf/cairo-perf-cover.c
@@ -200,10 +200,8 @@ cairo_perf_cover_sources_and_operators (cairo_perf_t		*perf,
 					const char		*name,
 					cairo_perf_func_t	 perf_func)
 {
-    unsigned int i, j;
-    char *expanded_name;
-
-    struct { set_source_func_t set_source; const char *name; } sources[] = {
+    static unsigned int i, j;
+    const struct { set_source_func_t set_source; const char *name; } sources[] = {
 	{ set_source_solid_rgb, "solid_rgb" },
 	{ set_source_solid_rgba, "solid_rgba" },
 	{ set_source_image_surface_rgb, "image_rgb" },
@@ -215,22 +213,32 @@ cairo_perf_cover_sources_and_operators (cairo_perf_t		*perf,
 	{ set_source_radial_rgb, "radial_rgb" },
 	{ set_source_radial_rgba, "radial_rgba" }
     };
-
-    struct { cairo_operator_t op; const char *name; } operators[] = {
+    const struct { cairo_operator_t op; const char *name; } operators[] = {
 	{ CAIRO_OPERATOR_OVER, "over" },
 	{ CAIRO_OPERATOR_SOURCE, "source" }
     };
 
-    for (i = 0; i < ARRAY_SIZE (sources); i++) {
+    /* We assume we will be called in a tight loop, for example when we are
+     * performing malloc failure testing and we don't want to have to repeat
+     * tests already completed. */
+
+    for (; i < ARRAY_SIZE (sources); i++) {
 	(sources[i].set_source) (perf->cr, perf->size, perf->size);
 
-	for (j = 0; j < ARRAY_SIZE (operators); j++) {
+	for (; j < ARRAY_SIZE (operators); j++) {
+	    cairo_status_t status;
+	    char *expanded_name;
 	    cairo_set_operator (perf->cr, operators[j].op);
 
 	    xasprintf (&expanded_name, "%s_%s_%s",
 		       name, sources[i].name, operators[j].name);
-	    cairo_perf_run (perf, expanded_name, perf_func);
+	    status = cairo_perf_run_one (perf, expanded_name, perf_func);
 	    free (expanded_name);
+
+	    if (status)
+		return;
 	}
+	j = 0;
     }
+    i = 0;
 }
diff --git a/perf/cairo-perf.c b/perf/cairo-perf.c
index 5657a38..b904bdd 100644
--- a/perf/cairo-perf.c
+++ b/perf/cairo-perf.c
@@ -103,10 +103,10 @@ _content_to_string (cairo_content_t content)
     }
 }
 
-void
-cairo_perf_run (cairo_perf_t		*perf,
-		const char		*name,
-		cairo_perf_func_t	 perf_func)
+cairo_status_t
+cairo_perf_run_one (cairo_perf_t		*perf,
+		    const char			*name,
+		    cairo_perf_func_t		 perf_func)
 {
     static cairo_bool_t first_run = TRUE;
     unsigned int i;
@@ -118,13 +118,13 @@ cairo_perf_run (cairo_perf_t		*perf,
 	for (i = 0; i < perf->num_names; i++)
 	    if (strstr (name, perf->names[i]))
 		goto NAME_FOUND;
-	return;
+	return CAIRO_STATUS_SUCCESS;
     }
   NAME_FOUND:
 
     if (perf->list_only) {
 	printf ("%s\n", name);
-	return;
+	return CAIRO_STATUS_SUCCESS;
     }
 
     if (first_run) {
@@ -148,6 +148,8 @@ cairo_perf_run (cairo_perf_t		*perf,
     for (i =0; i < perf->iterations; i++) {
 	cairo_perf_yield ();
 	times[i] = (perf_func) (perf->cr, perf->size, perf->size);
+	if (cairo_status (perf->cr))
+	    goto bail;
 
 	if (perf->raw) {
 	    if (i == 0)
@@ -190,7 +192,21 @@ cairo_perf_run (cairo_perf_t		*perf,
     }
 
     perf->test_number++;
+bail:
     free (times);
+    return cairo_status (perf->cr);
+}
+
+void
+cairo_perf_run (const cairo_perf_functions_t *funcs, cairo_perf_t *perf)
+{
+    static unsigned int n;
+    while (funcs[n].name != NULL) {
+	if (cairo_perf_run_one (perf, funcs[n].name, funcs[n].func))
+	    return;
+	n++;
+    }
+    n = 0;
 }
 
 static void
@@ -301,15 +317,16 @@ check_cpu_affinity(void)
 int
 main (int argc, char *argv[])
 {
-    int i, j;
-    cairo_perf_case_t *perf_case;
-    cairo_perf_t perf;
+    cairo_bool_t testing_malloc_failures = FALSE;
     const char *cairo_test_target = getenv ("CAIRO_TEST_TARGET");
-    cairo_boilerplate_target_t *target;
-    cairo_surface_t *surface;
+    cairo_perf_t perf;
+    int i, j;
 
     parse_options (&perf, argc, argv);
 
+    if (getenv ("CAIRO_TEST_MALLOC_FAILURE") != NULL)
+	testing_malloc_failures = TRUE;
+
     if (check_cpu_affinity()) {
         fputs(
             "NOTICE: cairo-perf and the X server should be bound to CPUs (either the same\n"
@@ -324,7 +341,8 @@ main (int argc, char *argv[])
     }
 
     for (i = 0; targets[i].name; i++) {
-	perf.target = target = &targets[i];
+	cairo_boilerplate_target_t *target = &targets[i];
+	perf.target = target;
 	perf.test_number = 0;
 
 	if (! target_is_measurable (target))
@@ -333,13 +351,15 @@ main (int argc, char *argv[])
 	    continue;
 
 	for (j = 0; perf_cases[j].run; j++) {
-
-	    perf_case = &perf_cases[j];
+	    cairo_perf_case_t *perf_case = &perf_cases[j];
 
 	    for (perf.size = perf_case->min_size;
 		 perf.size <= perf_case->max_size;
 		 perf.size *= 2)
 	    {
+		cairo_status_t status;
+		cairo_surface_t *surface;
+retest:
 		surface = (target->create_surface) (NULL,
 						    target->content,
 						    perf.size, perf.size,
@@ -351,18 +371,23 @@ main (int argc, char *argv[])
 		perf.cr = cairo_create (surface);
 
 		perf_case->run (&perf, perf.cr, perf.size, perf.size);
-
-		if (cairo_status (perf.cr)) {
-		    fprintf (stderr, "Error: Test left cairo in an error state: %s\n",
-			     cairo_status_to_string (cairo_status (perf.cr)));
-		    //exit (1);
-		}
+		status = cairo_status (perf.cr);
 
 		cairo_destroy (perf.cr);
 		cairo_surface_destroy (surface);
 
 		if (target->cleanup)
 		    target->cleanup (target->closure);
+
+		if (testing_malloc_failures &&
+			status == CAIRO_STATUS_NO_MEMORY)
+		    goto retest;
+
+		if (status) {
+		    fprintf (stderr, "Error: Test left cairo in an error state: %s\n",
+			    cairo_status_to_string (status));
+		    exit (1);
+		}
 	    }
 	}
     }
diff --git a/perf/cairo-perf.h b/perf/cairo-perf.h
index 1fef997..cf6f884 100644
--- a/perf/cairo-perf.h
+++ b/perf/cairo-perf.h
@@ -80,10 +80,21 @@ typedef struct _cairo_perf {
 typedef cairo_perf_ticks_t
 (*cairo_perf_func_t) (cairo_t *cr, int width, int height);
 
+typedef struct _cairo_perf_functions {
+    const char        *name;
+    cairo_perf_func_t  func;
+} cairo_perf_functions_t;
+
 void
-cairo_perf_run (cairo_perf_t		*perf,
-		const char		*name,
-		cairo_perf_func_t	 perf_func);
+cairo_perf_run (const cairo_perf_functions_t		*funcs,
+       	        cairo_perf_t				*perf);
+
+cairo_status_t
+cairo_perf_run_one (cairo_perf_t			*perf,
+		    const char				*name,
+		    cairo_perf_func_t			 perf_func);
+
+
 
 void
 cairo_perf_cover_sources_and_operators (cairo_perf_t		*perf,
diff --git a/perf/long-lines.c b/perf/long-lines.c
index 62e8e16..06df09a 100644
--- a/perf/long-lines.c
+++ b/perf/long-lines.c
@@ -112,6 +112,10 @@ long_lines_cropped (cairo_t *cr, int width, int height)
 void
 long_lines (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "long-lines-uncropped", long_lines_uncropped);
-    cairo_perf_run (perf, "long-lines-cropped", long_lines_cropped);
+    static const cairo_perf_functions_t funcs[] = {
+	{ "long-lines-uncropped", long_lines_uncropped },
+	{ "long-lines-cropped", long_lines_cropped },
+	{ NULL, NULL }
+    };
+    cairo_perf_run (funcs, perf);
 }
diff --git a/perf/mosaic.c b/perf/mosaic.c
index 7172a9d..1c781b0 100644
--- a/perf/mosaic.c
+++ b/perf/mosaic.c
@@ -161,8 +161,12 @@ mosaic_tessellate_curves (cairo_t *cr, int width, int height)
 void
 mosaic (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "mosaic_fill_curves", mosaic_fill_curves);
-    cairo_perf_run (perf, "mosaic_fill_lines", mosaic_fill_lines);
-    cairo_perf_run (perf, "mosaic_tessellate_curves", mosaic_tessellate_curves);
-    cairo_perf_run (perf, "mosaic_tessellate_lines", mosaic_tessellate_lines);
+    static cairo_perf_functions_t funcs[] = {
+	{ "mosaic_fill_curves", mosaic_fill_curves },
+	{ "mosaic_fill_lines", mosaic_fill_lines },
+	{ "mosaic_tessellate_curves", mosaic_tessellate_curves },
+	{ "mosaic_tessellate_lines", mosaic_tessellate_lines },
+	{ NULL, NULL }
+    };
+    cairo_perf_run (funcs, perf);
 }
diff --git a/perf/pattern_create_radial.c b/perf/pattern_create_radial.c
index 09f15a8..9de43a9 100644
--- a/perf/pattern_create_radial.c
+++ b/perf/pattern_create_radial.c
@@ -93,6 +93,6 @@ pattern_create_radial (cairo_perf_t *perf, cairo_t *cr, int width, int height)
         radials[i].radius1 = generate_double_in_range (0.0, 1000.0);
     }
 
-    cairo_perf_run (perf, "pattern_create_radial",
-                          do_pattern_create_radial);
+    cairo_perf_run_one (perf, "pattern_create_radial",
+                              do_pattern_create_radial);
 }
diff --git a/perf/rectangles.c b/perf/rectangles.c
index 9fa89f5..c7ae881 100644
--- a/perf/rectangles.c
+++ b/perf/rectangles.c
@@ -67,5 +67,5 @@ rectangles (cairo_perf_t *perf, cairo_t *cr, int width, int height)
         rects[i].height = (rand () % (height / 10)) + 1;
     }
 
-    cairo_perf_run (perf, "rectangles", do_rectangles);
+    cairo_perf_run_one (perf, "rectangles", do_rectangles);
 }
diff --git a/perf/subimage_copy.c b/perf/subimage_copy.c
index 54f596f..896f8d8 100644
--- a/perf/subimage_copy.c
+++ b/perf/subimage_copy.c
@@ -67,5 +67,5 @@ subimage_copy (cairo_perf_t *perf, cairo_t *cr, int width, int height)
     cairo_set_source_surface (cr, image, 0, 0);
     cairo_surface_destroy (image);
 
-    cairo_perf_run (perf, "subimage_copy", do_subimage_copy);
+    cairo_perf_run_one (perf, "subimage_copy", do_subimage_copy);
 }
diff --git a/perf/tessellate.c b/perf/tessellate.c
index fc97db7..c81e53a 100644
--- a/perf/tessellate.c
+++ b/perf/tessellate.c
@@ -143,9 +143,13 @@ tessellate_256 (cairo_t *cr, int width, int height)
 void
 tessellate (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "tessellate-16", tessellate_16);
-    cairo_perf_run (perf, "tessellate-64", tessellate_64);
-    cairo_perf_run (perf, "tessellate-256", tessellate_256);
+    static const cairo_perf_functions_t funcs[] = {
+	{ "tessellate-16", tessellate_16 },
+	{ "tessellate-64", tessellate_64 },
+	{ "tessellate-256", tessellate_256 },
+	{ NULL, NULL }
+    };
+    cairo_perf_run (funcs, perf);
 }
 
 #if 0
diff --git a/perf/unaligned-clip.c b/perf/unaligned-clip.c
index c7b9d21..60ea01a 100644
--- a/perf/unaligned-clip.c
+++ b/perf/unaligned-clip.c
@@ -62,5 +62,5 @@ do_unaligned_clip (cairo_t *cr, int width, int height)
 void
 unaligned_clip (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "unaligned_clip", do_unaligned_clip);
+    cairo_perf_run_one (perf, "unaligned_clip", do_unaligned_clip);
 }
diff --git a/perf/world-map.c b/perf/world-map.c
index eef3619..f52dc6e 100644
--- a/perf/world-map.c
+++ b/perf/world-map.c
@@ -103,5 +103,5 @@ do_world_map (cairo_t *cr, int width, int height)
 void
 world_map (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "world_map", do_world_map);
+    cairo_perf_run_one (perf, "world_map", do_world_map);
 }
diff --git a/perf/zrusin.c b/perf/zrusin.c
index 6840775..8171b16 100644
--- a/perf/zrusin.c
+++ b/perf/zrusin.c
@@ -85,6 +85,10 @@ zrusin_another_fill (cairo_t *cr, int width, int height)
 void
 zrusin (cairo_perf_t *perf, cairo_t *cr, int width, int height)
 {
-    cairo_perf_run (perf, "zrusin_another_tessellate", zrusin_another_tessellate);
-    cairo_perf_run (perf, "zrusin_another_fill", zrusin_another_fill);
+    static const cairo_perf_functions_t funcs[] = {
+	{ "zrusin_another_tessellate", zrusin_another_tessellate },
+	{ "zrusin_another_fill", zrusin_another_fill },
+	{ NULL, NULL }
+    };
+    cairo_perf_run (funcs, perf);
 }
-- 
1.4.4.2

From mental at rydia.net  Thu Mar 29 17:44:14 2007
From: mental at rydia.net (MenTaLguY)
Date: Thu Mar 29 17:44:22 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <20070329173342.GA29877@infidigm.net>
References: <20070329170205.GA29219@infidigm.net>
	<2d30085fb027b6516519b4ffda7448c6@localhost>
	<20070329173342.GA29877@infidigm.net>
Message-ID: <1175215454.10123.45.camel@localhost.localdomain>

On Thu, 2007-03-29 at 13:33 -0400, Jeff Muizelaar wrote:
> (x << 3) | (x >> 2) is not equivalent to (255*x + 15)/31 for x = {3,
> 7, 24, 28}

Ah, wow, you're right.  I need to go back and fix some code... O_o

-mental
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070329/f4f50639/attachment-0001.pgp
From david at freetype.org  Thu Mar 29 23:49:32 2007
From: david at freetype.org (David Turner)
Date: Thu Mar 29 23:49:35 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <20070329173342.GA29877@infidigm.net>
References: <20070329170205.GA29219@infidigm.net>
	<2d30085fb027b6516519b4ffda7448c6@localhost>
	<20070329173342.GA29877@infidigm.net>
Message-ID: <1175237372.15671.1182168427@webmail.messagingengine.com>

Hello Guys,

On Thu, 29 Mar 2007 13:33:42 -0400, "Jeff Muizelaar" <jeff@infidigm.net> said:
> > 
> > The bit-copying "approximation" is exactly equivalent to multiplying by 255 and dividing by 31.  There's no point in implementing both -- stick with the bit copy, since it's more efficient.
> 
> (x << 3) | (x >> 2) is not equivalent to (255*x + 15)/31 for x = {3, 7,
> 24, 28}
> 

May I remind everyone that what we call "alpha" is a mere *approximation*, and that maybe this kind of
numerical accuracy isn't so important as it may seem ?

another common example is the "fast" implementation of y = x*alpha/255.0

Cairo uses (t = x*alpha+128, y = (t + (t >> 8)) >> 8)

while many other graphics libraries do something like:

  alpha2 = alpha + (alpha >> 7)   // convert from 0..255 to 0..256 range
  y      = x*alpha2 >> 8

which turns out to be noticeably faster, especially when you're performing several multiplications
with the same alpha in parallel. And I'm pretty certain that this doesn't amount to any perceptual
difference in an 8-bit/channel world, unless you do a ton of alpha composition work on the same
pixels (in which case things are likely to break *anyway* due to accumulated rounding errors)

Frankly, I'd like to see alternative implementations of the "libpixman2" to compare their
performance; that could be very interesting.

Just my ?.02

- David





- David Turner

> -Jeff
> _______________________________________________
> cairo mailing list
> cairo@cairographics.org
> http://cairographics.org/cgi-bin/mailman/listinfo/cairo
From spitzak at d2.com  Fri Mar 30 03:22:41 2007
From: spitzak at d2.com (Bill Spitzak)
Date: Fri Mar 30 03:22:57 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <1175237372.15671.1182168427@webmail.messagingengine.com>
References: <20070329170205.GA29219@infidigm.net>	<2d30085fb027b6516519b4ffda7448c6@localhost>	<20070329173342.GA29877@infidigm.net>
	<1175237372.15671.1182168427@webmail.messagingengine.com>
Message-ID: <460CE4F1.9@d2.com>

David Turner wrote:
> Hello Guys,
> 
> On Thu, 29 Mar 2007 13:33:42 -0400, "Jeff Muizelaar" <jeff@infidigm.net> said:
>>> The bit-copying "approximation" is exactly equivalent to multiplying by 255 and dividing by 31.  There's no point in implementing both -- stick with the bit copy, since it's more efficient.
>> (x << 3) | (x >> 2) is not equivalent to (255*x + 15)/31 for x = {3, 7,
>> 24, 28}
>>
> 
> May I remind everyone that what we call "alpha" is a mere *approximation*, and that maybe this kind of
> numerical accuracy isn't so important as it may seem ?
> 
> another common example is the "fast" implementation of y = x*alpha/255.0
> 
> Cairo uses (t = x*alpha+128, y = (t + (t >> 8)) >> 8)
> 
> while many other graphics libraries do something like:
> 
>   alpha2 = alpha + (alpha >> 7)   // convert from 0..255 to 0..256 range
>   y      = x*alpha2 >> 8
> 
> which turns out to be noticeably faster, especially when you're performing several multiplications
> with the same alpha in parallel. And I'm pretty certain that this doesn't amount to any perceptual
> difference in an 8-bit/channel world, unless you do a ton of alpha composition work on the same
> pixels (in which case things are likely to break *anyway* due to accumulated rounding errors)
> 
> Frankly, I'd like to see alternative implementations of the "libpixman2" to compare their
> performance; that could be very interesting.
> 
> Just my ?.02
> 
> - David

Indeed. I think in all cases where the fast and slow methods come out 
different, the actual floating point value is within the range n+.25 and 
n+.75. This means that the inaccuracy of either answer exceeds the 
additional inaccuracy of picking the further-away answer. This is 
pointless, the only way to get a more accurate result is to use error 
diffusion, and Cairo is not going to attempt that.

Also people *rely* on the simple math. They do not expect edges of their 
carefully photoshopped overlays to become visible when put atop the 
background they painted it atop. This pretty much means that it has to 
use the common simple implementations of these since that is what 
Photoshop did. This also means that Cairo must have a "specify the color 
as 8 bits" api, because otherwise people are going to guess or do 
experiments and then rely on preciesly how Cairo turns floating point 
into 8 bits, which means that algorithim can never be fixed or changed 
after the first version.

From olivier.jolet at skynet.be  Fri Mar 30 03:49:59 2007
From: olivier.jolet at skynet.be (Olivier Jolet)
Date: Fri Mar 30 03:50:10 2007
Subject: [cairo] Vertical text
Message-ID: <001a01c772b9$29d2de30$4f3210ac@Pcoj>

Hi,
I'm trying to draw a text vertically, but I always get a 90 degree
rotation of the whole text and not of each character. 
The method I tried to use is font matrix transformation to a PI/2
rotation.
What is incorrect in my sequence? How can I do to rotate each character?
 
 - cairo_matrix_init
 - cairo_matrix_rotate
 - cairo_matrix_scale                                        
 - cairo_set_font_matrix
 - cairo_move_to
 - cairo_show_text
 
 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070330/6d9ba3a0/attachment.html
From cloos at jhcloos.com  Fri Mar 30 16:26:59 2007
From: cloos at jhcloos.com (James Cloos)
Date: Fri Mar 30 16:28:21 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <20070329173342.GA29877@infidigm.net> (Jeff Muizelaar's message
	of "Thu\, 29 Mar 2007 13\:33\:42 -0400")
References: <20070329170205.GA29219@infidigm.net>
	<2d30085fb027b6516519b4ffda7448c6@localhost>
	<20070329173342.GA29877@infidigm.net>
Message-ID: <m3r6r6nwh1.fsf@lugabout.jhcloos.org>

>> The bit-copying "approximation" is exactly equivalent to
>> multiplying by 255 and dividing by 31.  There's no point in
>> implementing both -- stick with the bit copy, since it's more
>> efficient.

Jeff> (x << 3) | (x >> 2) is not equivalent to (255*x + 15)/31
Jeff> for x = {3, 7, 24, 28}

As I recall from doing some analysis during the float thread, that
should be multiplying by 256 and dividing by 31.  Ie, always multiply
by 2^${num_bits} and divide by ${Int_max} to get reversable conversions
well centered w/in the sample resolution(s).

-JimC
-- 
James Cloos <cloos@jhcloos.com>         OpenPGP: 1024D/ED7DAEA6
From keithp at keithp.com  Fri Mar 30 16:51:45 2007
From: keithp at keithp.com (Keith Packard)
Date: Fri Mar 30 16:52:02 2007
Subject: [cairo] rewriting libpixman
In-Reply-To: <m3r6r6nwh1.fsf@lugabout.jhcloos.org>
References: <20070329170205.GA29219@infidigm.net>
	<2d30085fb027b6516519b4ffda7448c6@localhost>
	<20070329173342.GA29877@infidigm.net>
	<m3r6r6nwh1.fsf@lugabout.jhcloos.org>
Message-ID: <1175298705.26106.298.camel@neko.keithp.com>

On Fri, 2007-03-30 at 19:26 -0400, James Cloos wrote:

> As I recall from doing some analysis during the float thread, that
> should be multiplying by 256 and dividing by 31.  Ie, always multiply
> by 2^${num_bits} and divide by ${Int_max} to get reversable conversions
> well centered w/in the sample resolution(s).

31. ick.

-- 
keith.packard@intel.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: This is a digitally signed message part
Url : http://lists.freedesktop.org/archives/cairo/attachments/20070330/ce544d65/attachment.pgp
From jordan2.j at gmail.com  Sat Mar 31 09:08:50 2007
From: jordan2.j at gmail.com (Akex J.)
Date: Sat Mar 31 09:08:54 2007
Subject: [cairo] Draw outline text
Message-ID: <dd489ffb0703310908y38a9be4et2fb5a6b4f832d245@mail.gmail.com>

Hello,

I'm trying to draw outline text fast.
I'm using code like on this page http://cairographics.org/samples/text.html
But it's too slow, cairo_show_text() is fast, but the other sample that draw
outline text ("void") is very slow.
Is there any other way to draw (outline) text fast ?
As I see cairo_show_text and cairo_text_path are "toy" API and documentation
say I should use cairo_glyph_path(), but I have no idea how. Is there any
sample or can someone show me how can be done with cairo_glyph_path() ?

Regards,

AleX
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.freedesktop.org/archives/cairo/attachments/20070331/e0b11ec3/attachment.html
